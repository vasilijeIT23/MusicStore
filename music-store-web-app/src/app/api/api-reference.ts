//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface ICartClient {
    find(): Observable<Cart[]>;
    getAll(): Observable<Cart[]>;
    getById(id: string): Observable<Cart>;
    create(cart: Cart): Observable<Cart>;
    update(cart: Cart): Observable<Cart>;
    delete(request: DeleteCartCommand): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class CartClient implements ICartClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:52720";
    }

    find(): Observable<Cart[]> {
        let url_ = this.baseUrl + "/api/carts/filtered";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFind(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFind(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Cart[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Cart[]>;
        }));
    }

    protected processFind(response: HttpResponseBase): Observable<Cart[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Cart.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAll(): Observable<Cart[]> {
        let url_ = this.baseUrl + "/api/carts/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Cart[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Cart[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<Cart[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Cart.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getById(id: string): Observable<Cart> {
        let url_ = this.baseUrl + "/api/carts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Cart>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Cart>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<Cart> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Cart.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(cart: Cart): Observable<Cart> {
        let url_ = this.baseUrl + "/api/carts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(cart);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Cart>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Cart>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Cart> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Cart.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(cart: Cart): Observable<Cart> {
        let url_ = this.baseUrl + "/api/carts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(cart);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Cart>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Cart>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<Cart> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Cart.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(request: DeleteCartCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/carts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICustomerClient {
    find(): Observable<Customer[]>;
    getAll(): Observable<Customer[]>;
    getById(id: string): Observable<Customer>;
    create(request: CreateCustomerCommand): Observable<Customer>;
    update(request: UpdateCustomerCommand): Observable<Customer>;
    delete(request: DeleteCustomerCommand): Observable<void>;
    addToCart(request: AddToCartCommand): Observable<void>;
    emptyCart(request: EmptyCartCommand): Observable<void>;
    removeFromCart(request: RemoveCartItemCommand): Observable<void>;
    purchaseProduct(request: PurchaseFromCartCommand): Observable<Order>;
    promote(request: PromoteCustomerCommand): Observable<Customer>;
    reviewProduct(customerId: string, productId: string): Observable<void>;
    authenticate(request: AuthenticateCustomerCommand): Observable<Customer>;
    generateJwtToken(request: GenerateJwtTokenCommand): Observable<string>;
    changeCredentials(request: ChangeCredentialsCommand): Observable<Customer>;
}

@Injectable({
    providedIn: 'root'
})
export class CustomerClient implements ICustomerClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:52720";
    }

    find(): Observable<Customer[]> {
        let url_ = this.baseUrl + "/api/customers/filtered";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFind(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFind(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Customer[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Customer[]>;
        }));
    }

    protected processFind(response: HttpResponseBase): Observable<Customer[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Customer.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAll(): Observable<Customer[]> {
        let url_ = this.baseUrl + "/api/customers/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Customer[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Customer[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<Customer[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Customer.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getById(id: string): Observable<Customer> {
        let url_ = this.baseUrl + "/api/customers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Customer>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Customer>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<Customer> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Customer.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(request: CreateCustomerCommand): Observable<Customer> {
        let url_ = this.baseUrl + "/api/customers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Customer>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Customer>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Customer> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Customer.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(request: UpdateCustomerCommand): Observable<Customer> {
        let url_ = this.baseUrl + "/api/customers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Customer>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Customer>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<Customer> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Customer.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(request: DeleteCustomerCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/customers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addToCart(request: AddToCartCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/customers/addToCart";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddToCart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddToCart(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddToCart(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    emptyCart(request: EmptyCartCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/customers/emptyCart";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmptyCart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmptyCart(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEmptyCart(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    removeFromCart(request: RemoveCartItemCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/customers/removeCartItem";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveFromCart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveFromCart(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemoveFromCart(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    purchaseProduct(request: PurchaseFromCartCommand): Observable<Order> {
        let url_ = this.baseUrl + "/api/customers/purchase";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPurchaseProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPurchaseProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Order>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Order>;
        }));
    }

    protected processPurchaseProduct(response: HttpResponseBase): Observable<Order> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Order.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    promote(request: PromoteCustomerCommand): Observable<Customer> {
        let url_ = this.baseUrl + "/api/customers/promote";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPromote(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPromote(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Customer>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Customer>;
        }));
    }

    protected processPromote(response: HttpResponseBase): Observable<Customer> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Customer.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    reviewProduct(customerId: string, productId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/customers/{customerId}/review/{productId}";
        if (customerId === undefined || customerId === null)
            throw new Error("The parameter 'customerId' must be defined.");
        url_ = url_.replace("{customerId}", encodeURIComponent("" + customerId));
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReviewProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReviewProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processReviewProduct(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    authenticate(request: AuthenticateCustomerCommand): Observable<Customer> {
        let url_ = this.baseUrl + "/api/customers/auth";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Customer>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Customer>;
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<Customer> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Customer.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    generateJwtToken(request: GenerateJwtTokenCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/customers/jwtToken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateJwtToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateJwtToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGenerateJwtToken(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    changeCredentials(request: ChangeCredentialsCommand): Observable<Customer> {
        let url_ = this.baseUrl + "/api/customers/credentials";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeCredentials(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeCredentials(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Customer>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Customer>;
        }));
    }

    protected processChangeCredentials(response: HttpResponseBase): Observable<Customer> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Customer.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IImageClient {
    upload(): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class ImageClient implements IImageClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:52720";
    }

    upload(): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/upload";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpload(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpload(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IOrderClient {
    find(): Observable<Order[]>;
    getAll(): Observable<Order[]>;
    getById(id: string): Observable<Order>;
    create(order: Order): Observable<Order>;
    update(order: Order): Observable<Order>;
    delete(request: DeleteOrderCommand): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class OrderClient implements IOrderClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:52720";
    }

    find(): Observable<Order[]> {
        let url_ = this.baseUrl + "/api/orders/filtered";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFind(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFind(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Order[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Order[]>;
        }));
    }

    protected processFind(response: HttpResponseBase): Observable<Order[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Order.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAll(): Observable<Order[]> {
        let url_ = this.baseUrl + "/api/orders/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Order[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Order[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<Order[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Order.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getById(id: string): Observable<Order> {
        let url_ = this.baseUrl + "/api/orders/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Order>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Order>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<Order> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Order.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(order: Order): Observable<Order> {
        let url_ = this.baseUrl + "/api/orders";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(order);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Order>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Order>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Order> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Order.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(order: Order): Observable<Order> {
        let url_ = this.baseUrl + "/api/orders";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(order);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Order>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Order>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<Order> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Order.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(request: DeleteOrderCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/orders";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IPaymentClient {
    find(): Observable<Payment[]>;
    getAll(): Observable<Payment[]>;
    getById(id: string): Observable<Payment>;
}

@Injectable({
    providedIn: 'root'
})
export class PaymentClient implements IPaymentClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:52720";
    }

    find(): Observable<Payment[]> {
        let url_ = this.baseUrl + "/api/payments/filtered";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFind(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFind(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Payment[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Payment[]>;
        }));
    }

    protected processFind(response: HttpResponseBase): Observable<Payment[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Payment.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAll(): Observable<Payment[]> {
        let url_ = this.baseUrl + "/api/payments/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Payment[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Payment[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<Payment[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Payment.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getById(id: string): Observable<Payment> {
        let url_ = this.baseUrl + "/api/payments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Payment>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Payment>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<Payment> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Payment.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IProductClient {
    find(): Observable<Product[]>;
    getAll(): Observable<Product[]>;
    getById(id: string): Observable<Product>;
    create(request: CreateProductCommand): Observable<Product>;
    update(request: UpdateProductCommand): Observable<Product>;
    delete(request: DeleteProductCommand): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class ProductClient implements IProductClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:52720";
    }

    find(): Observable<Product[]> {
        let url_ = this.baseUrl + "/api/products/filtered";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFind(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFind(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Product[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Product[]>;
        }));
    }

    protected processFind(response: HttpResponseBase): Observable<Product[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Product.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAll(): Observable<Product[]> {
        let url_ = this.baseUrl + "/api/products/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Product[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Product[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<Product[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Product.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getById(id: string): Observable<Product> {
        let url_ = this.baseUrl + "/api/products/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Product>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Product>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<Product> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Product.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(request: CreateProductCommand): Observable<Product> {
        let url_ = this.baseUrl + "/api/products";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Product>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Product>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Product> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Product.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(request: UpdateProductCommand): Observable<Product> {
        let url_ = this.baseUrl + "/api/products";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Product>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Product>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<Product> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Product.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(request: DeleteProductCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/products";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IProductTypeClient {
    find(): Observable<ProductType[]>;
    getAll(): Observable<ProductType[]>;
    getById(id: string): Observable<ProductType>;
    create(request: CreateProductTypeCommand): Observable<ProductType>;
    update(request: UpdateProductTypeCommand): Observable<ProductType>;
    delete(request: DeleteProductTypeCommand): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class ProductTypeClient implements IProductTypeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:52720";
    }

    find(): Observable<ProductType[]> {
        let url_ = this.baseUrl + "/api/productTypes/filtered";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFind(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFind(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductType[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductType[]>;
        }));
    }

    protected processFind(response: HttpResponseBase): Observable<ProductType[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductType.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAll(): Observable<ProductType[]> {
        let url_ = this.baseUrl + "/api/productTypes/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductType[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductType[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ProductType[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductType.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getById(id: string): Observable<ProductType> {
        let url_ = this.baseUrl + "/api/productTypes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductType>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ProductType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductType.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(request: CreateProductTypeCommand): Observable<ProductType> {
        let url_ = this.baseUrl + "/api/productTypes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductType>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ProductType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductType.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(request: UpdateProductTypeCommand): Observable<ProductType> {
        let url_ = this.baseUrl + "/api/productTypes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductType>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ProductType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductType.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(request: DeleteProductTypeCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/productTypes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IStockClient {
    find(): Observable<Stock[]>;
    getAll(): Observable<Stock[]>;
    getById(id: string): Observable<Stock>;
    create(request: CreateStockCommand): Observable<Stock>;
    update(request: UpdateStockCommand): Observable<Stock>;
    delete(request: DeleteStockCommand): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class StockClient implements IStockClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:52720";
    }

    find(): Observable<Stock[]> {
        let url_ = this.baseUrl + "/api/stock/filtered";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFind(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFind(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Stock[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Stock[]>;
        }));
    }

    protected processFind(response: HttpResponseBase): Observable<Stock[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Stock.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAll(): Observable<Stock[]> {
        let url_ = this.baseUrl + "/api/stock/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Stock[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Stock[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<Stock[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Stock.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getById(id: string): Observable<Stock> {
        let url_ = this.baseUrl + "/api/stock/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Stock>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Stock>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<Stock> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Stock.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(request: CreateStockCommand): Observable<Stock> {
        let url_ = this.baseUrl + "/api/stock";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Stock>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Stock>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Stock> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Stock.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(request: UpdateStockCommand): Observable<Stock> {
        let url_ = this.baseUrl + "/api/stock";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Stock>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Stock>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<Stock> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Stock.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(request: DeleteStockCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/stock";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IStripeApiClient {
    processPayment(request: ProcessPaymentCommand): Observable<boolean>;
    createStripeCustomer(request: CreateStripeCustomerCommand): Observable<Customer2>;
    createPaymentIntent(request: CreatePaymentIntentCommand): Observable<PaymentIntent>;
    confirmPaymentIntent(request: ConfirmPaymentIntentCommand): Observable<PaymentIntent>;
}

@Injectable({
    providedIn: 'root'
})
export class StripeApiClient implements IStripeApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:52720";
    }

    processPayment(request: ProcessPaymentCommand): Observable<boolean> {
        let url_ = this.baseUrl + "/api/payment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProcessPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProcessPayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processProcessPayment(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createStripeCustomer(request: CreateStripeCustomerCommand): Observable<Customer2> {
        let url_ = this.baseUrl + "/api/payment/createCustomer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateStripeCustomer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateStripeCustomer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Customer2>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Customer2>;
        }));
    }

    protected processCreateStripeCustomer(response: HttpResponseBase): Observable<Customer2> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Customer2.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createPaymentIntent(request: CreatePaymentIntentCommand): Observable<PaymentIntent> {
        let url_ = this.baseUrl + "/api/payment/createIntent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePaymentIntent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePaymentIntent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentIntent>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentIntent>;
        }));
    }

    protected processCreatePaymentIntent(response: HttpResponseBase): Observable<PaymentIntent> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentIntent.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    confirmPaymentIntent(request: ConfirmPaymentIntentCommand): Observable<PaymentIntent> {
        let url_ = this.baseUrl + "/api/payment/confirmIntent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmPaymentIntent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmPaymentIntent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentIntent>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentIntent>;
        }));
    }

    protected processConfirmPaymentIntent(response: HttpResponseBase): Observable<PaymentIntent> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentIntent.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IStripeWebHookClient {
    index(): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class StripeWebHookClient implements IStripeWebHookClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:52720";
    }

    index(): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/webhook/email";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIndex(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIndex(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processIndex(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IWarehouseClient {
    find(): Observable<Warehouse[]>;
    getAll(): Observable<Warehouse[]>;
    getById(id: string): Observable<Warehouse>;
    create(request: CreateWarehouseCommand): Observable<Warehouse>;
    update(request: UpdateWarehouseCommand): Observable<Warehouse>;
    delete(request: DeleteWarehouseCommand): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class WarehouseClient implements IWarehouseClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:52720";
    }

    find(): Observable<Warehouse[]> {
        let url_ = this.baseUrl + "/api/warehouses/filtered";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFind(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFind(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Warehouse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Warehouse[]>;
        }));
    }

    protected processFind(response: HttpResponseBase): Observable<Warehouse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Warehouse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAll(): Observable<Warehouse[]> {
        let url_ = this.baseUrl + "/api/warehouses/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Warehouse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Warehouse[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<Warehouse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Warehouse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getById(id: string): Observable<Warehouse> {
        let url_ = this.baseUrl + "/api/warehouses/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Warehouse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Warehouse>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<Warehouse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Warehouse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(request: CreateWarehouseCommand): Observable<Warehouse> {
        let url_ = this.baseUrl + "/api/warehouses";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Warehouse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Warehouse>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Warehouse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Warehouse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(request: UpdateWarehouseCommand): Observable<Warehouse> {
        let url_ = this.baseUrl + "/api/warehouses";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Warehouse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Warehouse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<Warehouse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Warehouse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(request: DeleteWarehouseCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/warehouses";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class Cart implements ICart {
    id?: string;
    customer?: Customer;
    cartValue?: number;
    cartItems?: CartItem[];

    constructor(data?: ICart) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.customer = _data["customer"] ? Customer.fromJS(_data["customer"]) : <any>undefined;
            this.cartValue = _data["cartValue"];
            if (Object(_data["cartItems"])) {
                this.cartItems = [] as any;
                for (let item of _data["cartItems"].$values)
                    this.cartItems!.push(item);
            }
        }
    }

    static fromJS(data: any): Cart {
        data = typeof data === 'object' ? data : {};
        let result = new Cart();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["cartValue"] = this.cartValue;
        if (Array.isArray(this.cartItems)) {
            data["cartItems"] = [];
            for (let item of this.cartItems)
                data["cartItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICart {
    id?: string;
    customer?: Customer;
    cartValue?: number;
    cartItems?: CartItem[];
}

export class Customer implements ICustomer {
    id?: string;
    firstName?: string;
    lastName?: string;
    email?: string;
    role?: Role;
    status?: Status;
    statusExpirationDate?: Date | undefined;
    moneySpent?: number;
    username?: string;
    password?: string;
    salt?: string;
    orders?: Order[];
    reviews?: Review[];

    constructor(data?: ICustomer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.role = _data["role"];
            this.status = _data["status"];
            this.statusExpirationDate = _data["statusExpirationDate"] ? new Date(_data["statusExpirationDate"].toString()) : <any>undefined;
            this.moneySpent = _data["moneySpent"];
            this.username = _data["username"];
            this.password = _data["password"];
            this.salt = _data["salt"];
            if (Array.isArray(_data["orders"])) {
                this.orders = [] as any;
                for (let item of _data["orders"])
                    this.orders!.push(Order.fromJS(item));
            }
            if (Array.isArray(_data["reviews"])) {
                this.reviews = [] as any;
                for (let item of _data["reviews"])
                    this.reviews!.push(Review.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Customer {
        data = typeof data === 'object' ? data : {};
        let result = new Customer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["role"] = this.role;
        data["status"] = this.status;
        data["statusExpirationDate"] = this.statusExpirationDate ? this.statusExpirationDate.toISOString() : <any>undefined;
        data["moneySpent"] = this.moneySpent;
        data["username"] = this.username;
        data["password"] = this.password;
        data["salt"] = this.salt;
        if (Array.isArray(this.orders)) {
            data["orders"] = [];
            for (let item of this.orders)
                data["orders"].push(item.toJSON());
        }
        if (Array.isArray(this.reviews)) {
            data["reviews"] = [];
            for (let item of this.reviews)
                data["reviews"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICustomer {
    id?: string;
    firstName?: string;
    lastName?: string;
    email?: string;
    role?: Role;
    status?: Status;
    statusExpirationDate?: Date | undefined;
    moneySpent?: number;
    username?: string;
    password?: string;
    salt?: string;
    orders?: Order[];
    reviews?: Review[];
}

export enum Role {
    Regular = 1,
    Admin = 2,
}

export enum Status {
    Regular = 1,
    Advanced = 2,
}

export class Order implements IOrder {
    id?: string;
    customer?: Customer;
    orderDate?: Date;
    price?: number;
    paymentCompleted?: boolean;
    payment?: Payment;
    orderItems?: OrderItem[];

    constructor(data?: IOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.customer = _data["customer"] ? Customer.fromJS(_data["customer"]) : <any>undefined;
            this.orderDate = _data["orderDate"] ? new Date(_data["orderDate"].toString()) : <any>undefined;
            this.price = _data["price"];
            this.paymentCompleted = _data["paymentCompleted"];
            this.payment = _data["payment"] ? Payment.fromJS(_data["payment"]) : <any>undefined;
            if (Object(_data["orderItems"])) {
                this.orderItems = [] as any;
                for (let item of _data["orderItems"].$values)
                    this.orderItems!.push(item);
            }
        }
    }

    static fromJS(data: any): Order {
        data = typeof data === 'object' ? data : {};
        let result = new Order();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["orderDate"] = this.orderDate ? this.orderDate.toISOString() : <any>undefined;
        data["price"] = this.price;
        data["paymentCompleted"] = this.paymentCompleted;
        data["payment"] = this.payment ? this.payment.toJSON() : <any>undefined;
        if (Array.isArray(this.orderItems)) {
            data["orderItems"] = [];
            for (let item of this.orderItems)
                data["orderItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface IOrder {
    id?: string;
    customer?: Customer;
    orderDate?: Date;
    price?: number;
    paymentCompleted?: boolean;
    payment?: Payment;
    orderItems?: OrderItem[];
}

export class Payment implements IPayment {
    id?: string;
    paymentId?: string;
    customerId?: string;
    price?: number;

    constructor(data?: IPayment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.paymentId = _data["paymentId"];
            this.customerId = _data["customerId"];
            this.price = _data["price"];
        }
    }

    static fromJS(data: any): Payment {
        data = typeof data === 'object' ? data : {};
        let result = new Payment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["paymentId"] = this.paymentId;
        data["customerId"] = this.customerId;
        data["price"] = this.price;
        return data;
    }
}

export interface IPayment {
    id?: string;
    paymentId?: string;
    customerId?: string;
    price?: number;
}

export class OrderItem implements IOrderItem {
    id?: string;
    product?: Product;
    order?: Order;
    quantity?: number;

    constructor(data?: IOrderItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : <any>undefined;
            this.order = _data["order"] ? Order.fromJS(_data["order"]) : <any>undefined;
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): OrderItem {
        data = typeof data === 'object' ? data : {};
        let result = new OrderItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["order"] = this.order ? this.order.toJSON() : <any>undefined;
        data["quantity"] = this.quantity;
        return data;
    }
}

export interface IOrderItem {
    id?: string;
    product?: Product;
    order?: Order;
    quantity?: number;
}

export class Product implements IProduct {
    id?: string;
    name?: string;
    inStock?: boolean;
    price?: number;
    imagePath?: string;
    productType?: ProductType;
    reviews?: Review[];

    constructor(data?: IProduct) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.inStock = _data["inStock"];
            this.price = _data["price"];
            this.imagePath = _data["imagePath"];
            this.productType = _data["productType"] ? ProductType.fromJS(_data["productType"]) : <any>undefined;
            if (Array.isArray(_data["reviews"])) {
                this.reviews = [] as any;
                for (let item of _data["reviews"])
                    this.reviews!.push(Review.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Product {
        data = typeof data === 'object' ? data : {};
        let result = new Product();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["inStock"] = this.inStock;
        data["price"] = this.price;
        data["imagePath"] = this.imagePath;
        data["productType"] = this.productType ? this.productType.toJSON() : <any>undefined;
        if (Array.isArray(this.reviews)) {
            data["reviews"] = [];
            for (let item of this.reviews)
                data["reviews"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProduct {
    id?: string;
    name?: string;
    inStock?: boolean;
    price?: number;
    imagePath?: string;
    productType?: ProductType;
    reviews?: Review[];
}

export class ProductType implements IProductType {
    id?: string;
    category?: Category;
    name?: string;

    constructor(data?: IProductType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.category = _data["category"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ProductType {
        data = typeof data === 'object' ? data : {};
        let result = new ProductType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["category"] = this.category;
        data["name"] = this.name;
        return data;
    }
}

export interface IProductType {
    id?: string;
    category?: Category;
    name?: string;
}

export enum Category {
    Instrument = 1,
    Equipmnet = 2,
}

export class Review implements IReview {
    id?: string;
    customer?: Customer;
    product?: Product;
    grade?: Grade;
    description?: string;

    constructor(data?: IReview) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.customer = _data["customer"] ? Customer.fromJS(_data["customer"]) : <any>undefined;
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : <any>undefined;
            this.grade = _data["grade"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): Review {
        data = typeof data === 'object' ? data : {};
        let result = new Review();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["grade"] = this.grade;
        data["description"] = this.description;
        return data;
    }
}

export interface IReview {
    id?: string;
    customer?: Customer;
    product?: Product;
    grade?: Grade;
    description?: string;
}

export enum Grade {
    E = 1,
    D = 2,
    C = 3,
    B = 4,
    A = 5,
}

export class CartItem implements ICartItem {
    id?: string;
    product?: Product;
    cart?: Cart;
    quantity?: number;

    constructor(data?: ICartItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : <any>undefined;
            this.cart = _data["cart"] ? Cart.fromJS(_data["cart"]) : <any>undefined;
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): CartItem {
        data = typeof data === 'object' ? data : {};
        let result = new CartItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["cart"] = this.cart ? this.cart.toJSON() : <any>undefined;
        data["quantity"] = this.quantity;
        return data;
    }
}

export interface ICartItem {
    id?: string;
    product?: Product;
    cart?: Cart;
    quantity?: number;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export class DeleteCartCommand implements IDeleteCartCommand {
    id?: string;

    constructor(data?: IDeleteCartCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DeleteCartCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteCartCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IDeleteCartCommand {
    id?: string;
}

export class CreateCustomerCommand implements ICreateCustomerCommand {
    firstName?: string;
    lastName?: string;
    email?: string;
    username?: string;
    password?: string;

    constructor(data?: ICreateCustomerCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.username = _data["username"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): CreateCustomerCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCustomerCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["username"] = this.username;
        data["password"] = this.password;
        return data;
    }
}

export interface ICreateCustomerCommand {
    firstName?: string;
    lastName?: string;
    email?: string;
    username?: string;
    password?: string;
}

export class UpdateCustomerCommand implements IUpdateCustomerCommand {
    id?: string;
    firstName?: string;
    lastName?: string;
    email?: string;
    role?: Role;

    constructor(data?: IUpdateCustomerCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.role = _data["role"];
        }
    }

    static fromJS(data: any): UpdateCustomerCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCustomerCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["role"] = this.role;
        return data;
    }
}

export interface IUpdateCustomerCommand {
    id?: string;
    firstName?: string;
    lastName?: string;
    email?: string;
    role?: Role;
}

export class DeleteCustomerCommand implements IDeleteCustomerCommand {
    id?: string;

    constructor(data?: IDeleteCustomerCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DeleteCustomerCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteCustomerCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IDeleteCustomerCommand {
    id?: string;
}

export class AddToCartCommand implements IAddToCartCommand {
    customerId?: string;
    productId?: string;
    quantity?: number;

    constructor(data?: IAddToCartCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customerId = _data["customerId"];
            this.productId = _data["productId"];
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): AddToCartCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddToCartCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerId"] = this.customerId;
        data["productId"] = this.productId;
        data["quantity"] = this.quantity;
        return data;
    }
}

export interface IAddToCartCommand {
    customerId?: string;
    productId?: string;
    quantity?: number;
}

export class EmptyCartCommand implements IEmptyCartCommand {
    customerId?: string;

    constructor(data?: IEmptyCartCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customerId = _data["customerId"];
        }
    }

    static fromJS(data: any): EmptyCartCommand {
        data = typeof data === 'object' ? data : {};
        let result = new EmptyCartCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerId"] = this.customerId;
        return data;
    }
}

export interface IEmptyCartCommand {
    customerId?: string;
}

export class RemoveCartItemCommand implements IRemoveCartItemCommand {
    cartItemId?: string;

    constructor(data?: IRemoveCartItemCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cartItemId = _data["cartItemId"];
        }
    }

    static fromJS(data: any): RemoveCartItemCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RemoveCartItemCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cartItemId"] = this.cartItemId;
        return data;
    }
}

export interface IRemoveCartItemCommand {
    cartItemId?: string;
}

export class PurchaseFromCartCommand implements IPurchaseFromCartCommand {
    customerId?: string;

    constructor(data?: IPurchaseFromCartCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customerId = _data["customerId"];
        }
    }

    static fromJS(data: any): PurchaseFromCartCommand {
        data = typeof data === 'object' ? data : {};
        let result = new PurchaseFromCartCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerId"] = this.customerId;
        return data;
    }
}

export interface IPurchaseFromCartCommand {
    customerId?: string;
}

export class PromoteCustomerCommand implements IPromoteCustomerCommand {
    id?: string;

    constructor(data?: IPromoteCustomerCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PromoteCustomerCommand {
        data = typeof data === 'object' ? data : {};
        let result = new PromoteCustomerCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IPromoteCustomerCommand {
    id?: string;
}

export class AuthenticateCustomerCommand implements IAuthenticateCustomerCommand {
    username?: string;
    password?: string;

    constructor(data?: IAuthenticateCustomerCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): AuthenticateCustomerCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateCustomerCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["password"] = this.password;
        return data;
    }
}

export interface IAuthenticateCustomerCommand {
    username?: string;
    password?: string;
}

export class GenerateJwtTokenCommand implements IGenerateJwtTokenCommand {
    username?: string;

    constructor(data?: IGenerateJwtTokenCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
        }
    }

    static fromJS(data: any): GenerateJwtTokenCommand {
        data = typeof data === 'object' ? data : {};
        let result = new GenerateJwtTokenCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        return data;
    }
}

export interface IGenerateJwtTokenCommand {
    username?: string;
}

export class ChangeCredentialsCommand implements IChangeCredentialsCommand {
    oldPassword?: string;
    username?: string;
    newPassword?: string;
    email?: string;

    constructor(data?: IChangeCredentialsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.oldPassword = _data["oldPassword"];
            this.username = _data["username"];
            this.newPassword = _data["newPassword"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ChangeCredentialsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeCredentialsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["oldPassword"] = this.oldPassword;
        data["username"] = this.username;
        data["newPassword"] = this.newPassword;
        data["email"] = this.email;
        return data;
    }
}

export interface IChangeCredentialsCommand {
    oldPassword?: string;
    username?: string;
    newPassword?: string;
    email?: string;
}

export class DeleteOrderCommand implements IDeleteOrderCommand {
    id?: string;

    constructor(data?: IDeleteOrderCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DeleteOrderCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteOrderCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IDeleteOrderCommand {
    id?: string;
}

export class CreateProductCommand implements ICreateProductCommand {
    name?: string;
    price?: number;
    productType?: string;
    imagePath?: string;

    constructor(data?: ICreateProductCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.price = _data["price"];
            this.productType = _data["productType"];
            this.imagePath = _data["imagePath"];
        }
    }

    static fromJS(data: any): CreateProductCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["price"] = this.price;
        data["productType"] = this.productType;
        data["imagePath"] = this.imagePath;
        return data;
    }
}

export interface ICreateProductCommand {
    name?: string;
    price?: number;
    productType?: string;
    imagePath?: string;
}

export class UpdateProductCommand implements IUpdateProductCommand {
    id?: string;
    name?: string;
    inStock?: boolean;
    price?: number;

    constructor(data?: IUpdateProductCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.inStock = _data["inStock"];
            this.price = _data["price"];
        }
    }

    static fromJS(data: any): UpdateProductCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["inStock"] = this.inStock;
        data["price"] = this.price;
        return data;
    }
}

export interface IUpdateProductCommand {
    id?: string;
    name?: string;
    inStock?: boolean;
    price?: number;
}

export class DeleteProductCommand implements IDeleteProductCommand {
    id?: string;

    constructor(data?: IDeleteProductCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DeleteProductCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteProductCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IDeleteProductCommand {
    id?: string;
}

export class CreateProductTypeCommand implements ICreateProductTypeCommand {
    name?: string;
    category?: Category;

    constructor(data?: ICreateProductTypeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.category = _data["category"];
        }
    }

    static fromJS(data: any): CreateProductTypeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductTypeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["category"] = this.category;
        return data;
    }
}

export interface ICreateProductTypeCommand {
    name?: string;
    category?: Category;
}

export class UpdateProductTypeCommand implements IUpdateProductTypeCommand {
    id?: string;
    name?: string;
    capacity?: number;

    constructor(data?: IUpdateProductTypeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.capacity = _data["capacity"];
        }
    }

    static fromJS(data: any): UpdateProductTypeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductTypeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["capacity"] = this.capacity;
        return data;
    }
}

export interface IUpdateProductTypeCommand {
    id?: string;
    name?: string;
    capacity?: number;
}

export class DeleteProductTypeCommand implements IDeleteProductTypeCommand {
    id?: string;

    constructor(data?: IDeleteProductTypeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DeleteProductTypeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteProductTypeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IDeleteProductTypeCommand {
    id?: string;
}

export class Stock implements IStock {
    id?: string;
    product?: Product;
    warehouse?: Warehouse;
    quantity?: number;

    constructor(data?: IStock) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : <any>undefined;
            this.warehouse = _data["warehouse"] ? Warehouse.fromJS(_data["warehouse"]) : <any>undefined;
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): Stock {
        data = typeof data === 'object' ? data : {};
        let result = new Stock();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["warehouse"] = this.warehouse ? this.warehouse.toJSON() : <any>undefined;
        data["quantity"] = this.quantity;
        return data;
    }
}

export interface IStock {
    id?: string;
    product?: Product;
    warehouse?: Warehouse;
    quantity?: number;
}

export class Warehouse implements IWarehouse {
    id?: string;
    name?: string;
    capacity?: number;

    constructor(data?: IWarehouse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.capacity = _data["capacity"];
        }
    }

    static fromJS(data: any): Warehouse {
        data = typeof data === 'object' ? data : {};
        let result = new Warehouse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["capacity"] = this.capacity;
        return data;
    }
}

export interface IWarehouse {
    id?: string;
    name?: string;
    capacity?: number;
}

export class CreateStockCommand implements ICreateStockCommand {
    productId?: string;
    warehouseId?: string;
    quantity?: number;
    capacity?: number;

    constructor(data?: ICreateStockCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.warehouseId = _data["warehouseId"];
            this.quantity = _data["quantity"];
            this.capacity = _data["capacity"];
        }
    }

    static fromJS(data: any): CreateStockCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateStockCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["warehouseId"] = this.warehouseId;
        data["quantity"] = this.quantity;
        data["capacity"] = this.capacity;
        return data;
    }
}

export interface ICreateStockCommand {
    productId?: string;
    warehouseId?: string;
    quantity?: number;
    capacity?: number;
}

export class UpdateStockCommand implements IUpdateStockCommand {
    id?: string;
    quantity?: number;

    constructor(data?: IUpdateStockCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): UpdateStockCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateStockCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["quantity"] = this.quantity;
        return data;
    }
}

export interface IUpdateStockCommand {
    id?: string;
    quantity?: number;
}

export class DeleteStockCommand implements IDeleteStockCommand {
    id?: string;

    constructor(data?: IDeleteStockCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DeleteStockCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteStockCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IDeleteStockCommand {
    id?: string;
}

export class ProcessPaymentCommand implements IProcessPaymentCommand {
    customerId?: string;
    currency?: string;
    description?: string;

    constructor(data?: IProcessPaymentCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customerId = _data["customerId"];
            this.currency = _data["currency"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): ProcessPaymentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessPaymentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerId"] = this.customerId;
        data["currency"] = this.currency;
        data["description"] = this.description;
        return data;
    }
}

export interface IProcessPaymentCommand {
    customerId?: string;
    currency?: string;
    description?: string;
}

export abstract class StripeEntity implements IStripeEntity {
    /** Gets the raw JObject exposed by the Newtonsoft.Json library.
This can be used to access properties that are not directly exposed by Stripe's .NET
library. */
    rawJObject?: any | undefined;
    stripeResponse?: StripeResponse | undefined;

    constructor(data?: IStripeEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rawJObject = _data["rawJObject"];
            this.stripeResponse = _data["stripeResponse"] ? StripeResponse.fromJS(_data["stripeResponse"]) : <any>undefined;
        }
    }

    static fromJS(data: any): StripeEntity {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntity' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rawJObject"] = this.rawJObject;
        data["stripeResponse"] = this.stripeResponse ? this.stripeResponse.toJSON() : <any>undefined;
        return data;
    }
}

export interface IStripeEntity {
    /** Gets the raw JObject exposed by the Newtonsoft.Json library.
This can be used to access properties that are not directly exposed by Stripe's .NET
library. */
    rawJObject?: any | undefined;
    stripeResponse?: StripeResponse | undefined;
}

export abstract class StripeEntityOfCustomer extends StripeEntity implements IStripeEntityOfCustomer {

    constructor(data?: IStripeEntityOfCustomer) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfCustomer {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfCustomer' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfCustomer extends IStripeEntity {
}

/** This object represents a customer of your business. It lets you create recurring charges and track payments that belong to the same customer.            Related guide: Save a card during payment. */
export class Customer2 extends StripeEntityOfCustomer implements ICustomer2 {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** The customer's address. */
    address?: Address | undefined;
    /** Current balance, if any, being stored on the customer. If negative, the customer has
credit to apply to their next invoice. If positive, the customer has an amount owed that
will be added to their next invoice. The balance does not refer to any unpaid invoices;
it solely takes into account amounts that have yet to be successfully applied to any
invoice. This balance is only taken into account as invoices are finalized. */
    balance?: number;
    /** The current funds being held by Stripe on behalf of the customer. These funds can be
applied towards payment intents with source "cash_balance". The
settings[reconciliation_mode] field describes whether these funds are applied to such
payment intents manually or automatically. */
    cashBalance?: CashBalance | undefined;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** Three-letter ISO code for the currency
the customer can be charged in for recurring billing purposes. */
    currency?: string | undefined;
    /** (ID of the IPaymentSource)
ID of the default payment source for the customer.
            
If you are using payment methods created via the PaymentMethods API, see the invoice_settings.default_payment_method
field instead. */
    defaultSourceId?: string | undefined;
    /** (Expanded)
ID of the default payment source for the customer.
            
If you are using payment methods created via the PaymentMethods API, see the invoice_settings.default_payment_method
field instead.
            
For more information, see the expand documentation. */
    defaultSource?: IPaymentSource | undefined;
    internalDefaultSource?: ExpandableFieldOfIPaymentSource | undefined;
    /** Whether this object is deleted or not. */
    deleted?: boolean | undefined;
    /** When the customer's latest invoice is billed by charging automatically,
delinquent is true if the invoice's latest charge failed. When the
customer's latest invoice is billed by sending an invoice, delinquent is
true if the invoice isn't paid by its due date.
            
If an invoice is marked uncollectible by dunning,
delinquent doesn't get reset to false. */
    delinquent?: boolean | undefined;
    /** An arbitrary string attached to the object. Often useful for displaying to users. */
    description?: string | undefined;
    /** Describes the current discount active on the customer, if there is one. */
    discount?: Discount | undefined;
    /** The customer's email address. */
    email?: string | undefined;
    /** The current multi-currency balances, if any, being stored on the customer. If positive
in a currency, the customer has a credit to apply to their next invoice denominated in
that currency. If negative, the customer has an amount owed that will be added to their
next invoice denominated in that currency. These balances do not refer to any unpaid
invoices. They solely track amounts that have yet to be successfully applied to any
invoice. A balance in a particular currency is only applied to any invoice as an invoice
in that currency is finalized. */
    invoiceCreditBalance?: { [key: string]: number; } | undefined;
    /** The prefix for the customer used to generate unique invoice numbers. */
    invoicePrefix?: string | undefined;
    invoiceSettings?: CustomerInvoiceSettings | undefined;
    /** Has the value true if the object exists in live mode or the value false if
the object exists in test mode. */
    livemode?: boolean;
    /** Set of key-value pairs that you can
attach to an object. This can be useful for storing additional information about the
object in a structured format. */
    metadata?: { [key: string]: string; } | undefined;
    /** The customer's full name or business name. */
    name?: string | undefined;
    /** The suffix of the customer's next invoice number, e.g., 0001. */
    nextInvoiceSequence?: number;
    /** The customer's phone number. */
    phone?: string | undefined;
    /** The customer's preferred locales (languages), ordered by preference. */
    preferredLocales?: string[] | undefined;
    /** Mailing and shipping address for the customer. Appears on invoices emailed to this
customer. */
    shipping?: Shipping | undefined;
    /** The customer's payment sources, if any. */
    sources?: StripeListOfIPaymentSource | undefined;
    /** The customer's current subscriptions, if any. */
    subscriptions?: StripeListOfSubscription | undefined;
    tax?: CustomerTax | undefined;
    /** Describes the customer's tax exemption status. One of none, exempt, or
reverse. When set to reverse, invoice and receipt PDFs include the text
"Reverse charge".
One of: exempt, none, or reverse. */
    taxExempt?: string | undefined;
    /** The customer's tax IDs. */
    taxIds?: StripeListOfTaxId | undefined;
    /** (ID of the TestHelpers.TestClock)
ID of the test clock this customer belongs to. */
    testClockId?: string | undefined;
    /** (Expanded)
ID of the test clock this customer belongs to.
            
For more information, see the expand documentation. */
    testClock?: TestClock | undefined;
    internalTestClock?: ExpandableFieldOfTestClock | undefined;

    constructor(data?: ICustomer2) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.object = _data["object"];
            this.address = _data["address"] ? Address.fromJS(_data["address"]) : <any>undefined;
            this.balance = _data["balance"];
            this.cashBalance = _data["cashBalance"] ? CashBalance.fromJS(_data["cashBalance"]) : <any>undefined;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.currency = _data["currency"];
            this.defaultSourceId = _data["defaultSourceId"];
            this.defaultSource = _data["defaultSource"] ? IPaymentSource.fromJS(_data["defaultSource"]) : <any>undefined;
            this.internalDefaultSource = _data["internalDefaultSource"] ? ExpandableFieldOfIPaymentSource.fromJS(_data["internalDefaultSource"]) : <any>undefined;
            this.deleted = _data["deleted"];
            this.delinquent = _data["delinquent"];
            this.description = _data["description"];
            this.discount = _data["discount"] ? Discount.fromJS(_data["discount"]) : <any>undefined;
            this.email = _data["email"];
            if (_data["invoiceCreditBalance"]) {
                this.invoiceCreditBalance = {} as any;
                for (let key in _data["invoiceCreditBalance"]) {
                    if (_data["invoiceCreditBalance"].hasOwnProperty(key))
                        (<any>this.invoiceCreditBalance)![key] = _data["invoiceCreditBalance"][key];
                }
            }
            this.invoicePrefix = _data["invoicePrefix"];
            this.invoiceSettings = _data["invoiceSettings"] ? CustomerInvoiceSettings.fromJS(_data["invoiceSettings"]) : <any>undefined;
            this.livemode = _data["livemode"];
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
            this.name = _data["name"];
            this.nextInvoiceSequence = _data["nextInvoiceSequence"];
            this.phone = _data["phone"];
            if (Array.isArray(_data["preferredLocales"])) {
                this.preferredLocales = [] as any;
                for (let item of _data["preferredLocales"])
                    this.preferredLocales!.push(item);
            }
            this.shipping = _data["shipping"] ? Shipping.fromJS(_data["shipping"]) : <any>undefined;
            this.sources = _data["sources"] ? StripeListOfIPaymentSource.fromJS(_data["sources"]) : <any>undefined;
            this.subscriptions = _data["subscriptions"] ? StripeListOfSubscription.fromJS(_data["subscriptions"]) : <any>undefined;
            this.tax = _data["tax"] ? CustomerTax.fromJS(_data["tax"]) : <any>undefined;
            this.taxExempt = _data["taxExempt"];
            this.taxIds = _data["taxIds"] ? StripeListOfTaxId.fromJS(_data["taxIds"]) : <any>undefined;
            this.testClockId = _data["testClockId"];
            this.testClock = _data["testClock"] ? TestClock.fromJS(_data["testClock"]) : <any>undefined;
            this.internalTestClock = _data["internalTestClock"] ? ExpandableFieldOfTestClock.fromJS(_data["internalTestClock"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): Customer2 {
        data = typeof data === 'object' ? data : {};
        let result = new Customer2();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["object"] = this.object;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["balance"] = this.balance;
        data["cashBalance"] = this.cashBalance ? this.cashBalance.toJSON() : <any>undefined;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["currency"] = this.currency;
        data["defaultSourceId"] = this.defaultSourceId;
        data["defaultSource"] = this.defaultSource ? this.defaultSource.toJSON() : <any>undefined;
        data["internalDefaultSource"] = this.internalDefaultSource ? this.internalDefaultSource.toJSON() : <any>undefined;
        data["deleted"] = this.deleted;
        data["delinquent"] = this.delinquent;
        data["description"] = this.description;
        data["discount"] = this.discount ? this.discount.toJSON() : <any>undefined;
        data["email"] = this.email;
        if (this.invoiceCreditBalance) {
            data["invoiceCreditBalance"] = {};
            for (let key in this.invoiceCreditBalance) {
                if (this.invoiceCreditBalance.hasOwnProperty(key))
                    (<any>data["invoiceCreditBalance"])[key] = (<any>this.invoiceCreditBalance)[key];
            }
        }
        data["invoicePrefix"] = this.invoicePrefix;
        data["invoiceSettings"] = this.invoiceSettings ? this.invoiceSettings.toJSON() : <any>undefined;
        data["livemode"] = this.livemode;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        data["name"] = this.name;
        data["nextInvoiceSequence"] = this.nextInvoiceSequence;
        data["phone"] = this.phone;
        if (Array.isArray(this.preferredLocales)) {
            data["preferredLocales"] = [];
            for (let item of this.preferredLocales)
                data["preferredLocales"].push(item);
        }
        data["shipping"] = this.shipping ? this.shipping.toJSON() : <any>undefined;
        data["sources"] = this.sources ? this.sources.toJSON() : <any>undefined;
        data["subscriptions"] = this.subscriptions ? this.subscriptions.toJSON() : <any>undefined;
        data["tax"] = this.tax ? this.tax.toJSON() : <any>undefined;
        data["taxExempt"] = this.taxExempt;
        data["taxIds"] = this.taxIds ? this.taxIds.toJSON() : <any>undefined;
        data["testClockId"] = this.testClockId;
        data["testClock"] = this.testClock ? this.testClock.toJSON() : <any>undefined;
        data["internalTestClock"] = this.internalTestClock ? this.internalTestClock.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** This object represents a customer of your business. It lets you create recurring charges and track payments that belong to the same customer.            Related guide: Save a card during payment. */
export interface ICustomer2 extends IStripeEntityOfCustomer {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** The customer's address. */
    address?: Address | undefined;
    /** Current balance, if any, being stored on the customer. If negative, the customer has
credit to apply to their next invoice. If positive, the customer has an amount owed that
will be added to their next invoice. The balance does not refer to any unpaid invoices;
it solely takes into account amounts that have yet to be successfully applied to any
invoice. This balance is only taken into account as invoices are finalized. */
    balance?: number;
    /** The current funds being held by Stripe on behalf of the customer. These funds can be
applied towards payment intents with source "cash_balance". The
settings[reconciliation_mode] field describes whether these funds are applied to such
payment intents manually or automatically. */
    cashBalance?: CashBalance | undefined;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** Three-letter ISO code for the currency
the customer can be charged in for recurring billing purposes. */
    currency?: string | undefined;
    /** (ID of the IPaymentSource)
ID of the default payment source for the customer.
            
If you are using payment methods created via the PaymentMethods API, see the invoice_settings.default_payment_method
field instead. */
    defaultSourceId?: string | undefined;
    /** (Expanded)
ID of the default payment source for the customer.
            
If you are using payment methods created via the PaymentMethods API, see the invoice_settings.default_payment_method
field instead.
            
For more information, see the expand documentation. */
    defaultSource?: IPaymentSource | undefined;
    internalDefaultSource?: ExpandableFieldOfIPaymentSource | undefined;
    /** Whether this object is deleted or not. */
    deleted?: boolean | undefined;
    /** When the customer's latest invoice is billed by charging automatically,
delinquent is true if the invoice's latest charge failed. When the
customer's latest invoice is billed by sending an invoice, delinquent is
true if the invoice isn't paid by its due date.
            
If an invoice is marked uncollectible by dunning,
delinquent doesn't get reset to false. */
    delinquent?: boolean | undefined;
    /** An arbitrary string attached to the object. Often useful for displaying to users. */
    description?: string | undefined;
    /** Describes the current discount active on the customer, if there is one. */
    discount?: Discount | undefined;
    /** The customer's email address. */
    email?: string | undefined;
    /** The current multi-currency balances, if any, being stored on the customer. If positive
in a currency, the customer has a credit to apply to their next invoice denominated in
that currency. If negative, the customer has an amount owed that will be added to their
next invoice denominated in that currency. These balances do not refer to any unpaid
invoices. They solely track amounts that have yet to be successfully applied to any
invoice. A balance in a particular currency is only applied to any invoice as an invoice
in that currency is finalized. */
    invoiceCreditBalance?: { [key: string]: number; } | undefined;
    /** The prefix for the customer used to generate unique invoice numbers. */
    invoicePrefix?: string | undefined;
    invoiceSettings?: CustomerInvoiceSettings | undefined;
    /** Has the value true if the object exists in live mode or the value false if
the object exists in test mode. */
    livemode?: boolean;
    /** Set of key-value pairs that you can
attach to an object. This can be useful for storing additional information about the
object in a structured format. */
    metadata?: { [key: string]: string; } | undefined;
    /** The customer's full name or business name. */
    name?: string | undefined;
    /** The suffix of the customer's next invoice number, e.g., 0001. */
    nextInvoiceSequence?: number;
    /** The customer's phone number. */
    phone?: string | undefined;
    /** The customer's preferred locales (languages), ordered by preference. */
    preferredLocales?: string[] | undefined;
    /** Mailing and shipping address for the customer. Appears on invoices emailed to this
customer. */
    shipping?: Shipping | undefined;
    /** The customer's payment sources, if any. */
    sources?: StripeListOfIPaymentSource | undefined;
    /** The customer's current subscriptions, if any. */
    subscriptions?: StripeListOfSubscription | undefined;
    tax?: CustomerTax | undefined;
    /** Describes the customer's tax exemption status. One of none, exempt, or
reverse. When set to reverse, invoice and receipt PDFs include the text
"Reverse charge".
One of: exempt, none, or reverse. */
    taxExempt?: string | undefined;
    /** The customer's tax IDs. */
    taxIds?: StripeListOfTaxId | undefined;
    /** (ID of the TestHelpers.TestClock)
ID of the test clock this customer belongs to. */
    testClockId?: string | undefined;
    /** (Expanded)
ID of the test clock this customer belongs to.
            
For more information, see the expand documentation. */
    testClock?: TestClock | undefined;
    internalTestClock?: ExpandableFieldOfTestClock | undefined;
}

export abstract class StripeEntityOfAddress extends StripeEntity implements IStripeEntityOfAddress {

    constructor(data?: IStripeEntityOfAddress) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfAddress {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfAddress' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfAddress extends IStripeEntity {
}

export class Address extends StripeEntityOfAddress implements IAddress {
    city?: string | undefined;
    country?: string | undefined;
    line1?: string | undefined;
    line2?: string | undefined;
    postalCode?: string | undefined;
    state?: string | undefined;

    constructor(data?: IAddress) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.city = _data["city"];
            this.country = _data["country"];
            this.line1 = _data["line1"];
            this.line2 = _data["line2"];
            this.postalCode = _data["postalCode"];
            this.state = _data["state"];
        }
    }

    static override fromJS(data: any): Address {
        data = typeof data === 'object' ? data : {};
        let result = new Address();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["city"] = this.city;
        data["country"] = this.country;
        data["line1"] = this.line1;
        data["line2"] = this.line2;
        data["postalCode"] = this.postalCode;
        data["state"] = this.state;
        super.toJSON(data);
        return data;
    }
}

export interface IAddress extends IStripeEntityOfAddress {
    city?: string | undefined;
    country?: string | undefined;
    line1?: string | undefined;
    line2?: string | undefined;
    postalCode?: string | undefined;
    state?: string | undefined;
}

/** Represents a response from Stripe's API. */
export abstract class StripeResponseBase implements IStripeResponseBase {
    /** Gets the HTTP status code of the response. */
    statusCode?: HttpStatusCode;
    /** Gets the HTTP headers of the response. */
    headers?: HttpResponseHeaders | undefined;
    /** Gets the date of the request, as returned by Stripe. */
    date?: Date | undefined;
    /** Gets the idempotency key of the request, as returned by Stripe. */
    idempotencyKey?: string | undefined;
    /** Gets the ID of the request, as returned by Stripe. */
    requestId?: string | undefined;

    constructor(data?: IStripeResponseBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.headers = _data["headers"] ? HttpResponseHeaders.fromJS(_data["headers"]) : <any>undefined;
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.idempotencyKey = _data["idempotencyKey"];
            this.requestId = _data["requestId"];
        }
    }

    static fromJS(data: any): StripeResponseBase {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeResponseBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["headers"] = this.headers ? this.headers.toJSON() : <any>undefined;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["idempotencyKey"] = this.idempotencyKey;
        data["requestId"] = this.requestId;
        return data;
    }
}

/** Represents a response from Stripe's API. */
export interface IStripeResponseBase {
    /** Gets the HTTP status code of the response. */
    statusCode?: HttpStatusCode;
    /** Gets the HTTP headers of the response. */
    headers?: HttpResponseHeaders | undefined;
    /** Gets the date of the request, as returned by Stripe. */
    date?: Date | undefined;
    /** Gets the idempotency key of the request, as returned by Stripe. */
    idempotencyKey?: string | undefined;
    /** Gets the ID of the request, as returned by Stripe. */
    requestId?: string | undefined;
}

/** Represents a buffered textual response from Stripe's API. */
export class StripeResponse extends StripeResponseBase implements IStripeResponse {
    /** Gets the body of the response. */
    content?: string | undefined;

    constructor(data?: IStripeResponse) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.content = _data["content"];
        }
    }

    static override fromJS(data: any): StripeResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StripeResponse();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content;
        super.toJSON(data);
        return data;
    }
}

/** Represents a buffered textual response from Stripe's API. */
export interface IStripeResponse extends IStripeResponseBase {
    /** Gets the body of the response. */
    content?: string | undefined;
}

export enum HttpStatusCode {
    Continue = 100,
    SwitchingProtocols = 101,
    Processing = 102,
    EarlyHints = 103,
    OK = 200,
    Created = 201,
    Accepted = 202,
    NonAuthoritativeInformation = 203,
    NoContent = 204,
    ResetContent = 205,
    PartialContent = 206,
    MultiStatus = 207,
    AlreadyReported = 208,
    IMUsed = 226,
    MultipleChoices = 300,
    Ambiguous = 300,
    MovedPermanently = 301,
    Moved = 301,
    Found = 302,
    Redirect = 302,
    SeeOther = 303,
    RedirectMethod = 303,
    NotModified = 304,
    UseProxy = 305,
    Unused = 306,
    TemporaryRedirect = 307,
    RedirectKeepVerb = 307,
    PermanentRedirect = 308,
    BadRequest = 400,
    Unauthorized = 401,
    PaymentRequired = 402,
    Forbidden = 403,
    NotFound = 404,
    MethodNotAllowed = 405,
    NotAcceptable = 406,
    ProxyAuthenticationRequired = 407,
    RequestTimeout = 408,
    Conflict = 409,
    Gone = 410,
    LengthRequired = 411,
    PreconditionFailed = 412,
    RequestEntityTooLarge = 413,
    RequestUriTooLong = 414,
    UnsupportedMediaType = 415,
    RequestedRangeNotSatisfiable = 416,
    ExpectationFailed = 417,
    MisdirectedRequest = 421,
    UnprocessableEntity = 422,
    Locked = 423,
    FailedDependency = 424,
    UpgradeRequired = 426,
    PreconditionRequired = 428,
    TooManyRequests = 429,
    RequestHeaderFieldsTooLarge = 431,
    UnavailableForLegalReasons = 451,
    InternalServerError = 500,
    NotImplemented = 501,
    BadGateway = 502,
    ServiceUnavailable = 503,
    GatewayTimeout = 504,
    HttpVersionNotSupported = 505,
    VariantAlsoNegotiates = 506,
    InsufficientStorage = 507,
    LoopDetected = 508,
    NotExtended = 510,
    NetworkAuthenticationRequired = 511,
}

export class Anonymous implements IAnonymous {
    acceptRanges?: string[];
    age?: string | undefined;
    eTag?: EntityTagHeaderValue | undefined;
    location?: string | undefined;
    proxyAuthenticate?: AuthenticationHeaderValue[];
    retryAfter?: RetryConditionHeaderValue | undefined;
    server?: ProductInfoHeaderValue[];
    vary?: string[];
    wwwAuthenticate?: AuthenticationHeaderValue[];
    cacheControl?: CacheControlHeaderValue | undefined;
    connection?: string[];
    connectionClose?: boolean | undefined;
    date?: Date | undefined;
    pragma?: NameValueHeaderValue[];
    trailer?: string[];
    transferEncoding?: TransferCodingHeaderValue[];
    transferEncodingChunked?: boolean | undefined;
    upgrade?: ProductHeaderValue[];
    via?: ViaHeaderValue[];
    warning?: WarningHeaderValue[];

    constructor(data?: IAnonymous) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["AcceptRanges"])) {
                this.acceptRanges = [] as any;
                for (let item of _data["AcceptRanges"])
                    this.acceptRanges!.push(item);
            }
            this.age = _data["Age"];
            this.eTag = _data["ETag"] ? EntityTagHeaderValue.fromJS(_data["ETag"]) : <any>undefined;
            this.location = _data["Location"];
            if (Array.isArray(_data["ProxyAuthenticate"])) {
                this.proxyAuthenticate = [] as any;
                for (let item of _data["ProxyAuthenticate"])
                    this.proxyAuthenticate!.push(AuthenticationHeaderValue.fromJS(item));
            }
            this.retryAfter = _data["RetryAfter"] ? RetryConditionHeaderValue.fromJS(_data["RetryAfter"]) : <any>undefined;
            if (Array.isArray(_data["Server"])) {
                this.server = [] as any;
                for (let item of _data["Server"])
                    this.server!.push(ProductInfoHeaderValue.fromJS(item));
            }
            if (Array.isArray(_data["Vary"])) {
                this.vary = [] as any;
                for (let item of _data["Vary"])
                    this.vary!.push(item);
            }
            if (Array.isArray(_data["WwwAuthenticate"])) {
                this.wwwAuthenticate = [] as any;
                for (let item of _data["WwwAuthenticate"])
                    this.wwwAuthenticate!.push(AuthenticationHeaderValue.fromJS(item));
            }
            this.cacheControl = _data["CacheControl"] ? CacheControlHeaderValue.fromJS(_data["CacheControl"]) : <any>undefined;
            if (Array.isArray(_data["Connection"])) {
                this.connection = [] as any;
                for (let item of _data["Connection"])
                    this.connection!.push(item);
            }
            this.connectionClose = _data["ConnectionClose"];
            this.date = _data["Date"] ? new Date(_data["Date"].toString()) : <any>undefined;
            if (Array.isArray(_data["Pragma"])) {
                this.pragma = [] as any;
                for (let item of _data["Pragma"])
                    this.pragma!.push(NameValueHeaderValue.fromJS(item));
            }
            if (Array.isArray(_data["Trailer"])) {
                this.trailer = [] as any;
                for (let item of _data["Trailer"])
                    this.trailer!.push(item);
            }
            if (Array.isArray(_data["TransferEncoding"])) {
                this.transferEncoding = [] as any;
                for (let item of _data["TransferEncoding"])
                    this.transferEncoding!.push(TransferCodingHeaderValue.fromJS(item));
            }
            this.transferEncodingChunked = _data["TransferEncodingChunked"];
            if (Array.isArray(_data["Upgrade"])) {
                this.upgrade = [] as any;
                for (let item of _data["Upgrade"])
                    this.upgrade!.push(ProductHeaderValue.fromJS(item));
            }
            if (Array.isArray(_data["Via"])) {
                this.via = [] as any;
                for (let item of _data["Via"])
                    this.via!.push(ViaHeaderValue.fromJS(item));
            }
            if (Array.isArray(_data["Warning"])) {
                this.warning = [] as any;
                for (let item of _data["Warning"])
                    this.warning!.push(WarningHeaderValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Anonymous {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.acceptRanges)) {
            data["AcceptRanges"] = [];
            for (let item of this.acceptRanges)
                data["AcceptRanges"].push(item);
        }
        data["Age"] = this.age;
        data["ETag"] = this.eTag ? this.eTag.toJSON() : <any>undefined;
        data["Location"] = this.location;
        if (Array.isArray(this.proxyAuthenticate)) {
            data["ProxyAuthenticate"] = [];
            for (let item of this.proxyAuthenticate)
                data["ProxyAuthenticate"].push(item.toJSON());
        }
        data["RetryAfter"] = this.retryAfter ? this.retryAfter.toJSON() : <any>undefined;
        if (Array.isArray(this.server)) {
            data["Server"] = [];
            for (let item of this.server)
                data["Server"].push(item.toJSON());
        }
        if (Array.isArray(this.vary)) {
            data["Vary"] = [];
            for (let item of this.vary)
                data["Vary"].push(item);
        }
        if (Array.isArray(this.wwwAuthenticate)) {
            data["WwwAuthenticate"] = [];
            for (let item of this.wwwAuthenticate)
                data["WwwAuthenticate"].push(item.toJSON());
        }
        data["CacheControl"] = this.cacheControl ? this.cacheControl.toJSON() : <any>undefined;
        if (Array.isArray(this.connection)) {
            data["Connection"] = [];
            for (let item of this.connection)
                data["Connection"].push(item);
        }
        data["ConnectionClose"] = this.connectionClose;
        data["Date"] = this.date ? this.date.toISOString() : <any>undefined;
        if (Array.isArray(this.pragma)) {
            data["Pragma"] = [];
            for (let item of this.pragma)
                data["Pragma"].push(item.toJSON());
        }
        if (Array.isArray(this.trailer)) {
            data["Trailer"] = [];
            for (let item of this.trailer)
                data["Trailer"].push(item);
        }
        if (Array.isArray(this.transferEncoding)) {
            data["TransferEncoding"] = [];
            for (let item of this.transferEncoding)
                data["TransferEncoding"].push(item.toJSON());
        }
        data["TransferEncodingChunked"] = this.transferEncodingChunked;
        if (Array.isArray(this.upgrade)) {
            data["Upgrade"] = [];
            for (let item of this.upgrade)
                data["Upgrade"].push(item.toJSON());
        }
        if (Array.isArray(this.via)) {
            data["Via"] = [];
            for (let item of this.via)
                data["Via"].push(item.toJSON());
        }
        if (Array.isArray(this.warning)) {
            data["Warning"] = [];
            for (let item of this.warning)
                data["Warning"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAnonymous {
    acceptRanges?: string[];
    age?: string | undefined;
    eTag?: EntityTagHeaderValue | undefined;
    location?: string | undefined;
    proxyAuthenticate?: AuthenticationHeaderValue[];
    retryAfter?: RetryConditionHeaderValue | undefined;
    server?: ProductInfoHeaderValue[];
    vary?: string[];
    wwwAuthenticate?: AuthenticationHeaderValue[];
    cacheControl?: CacheControlHeaderValue | undefined;
    connection?: string[];
    connectionClose?: boolean | undefined;
    date?: Date | undefined;
    pragma?: NameValueHeaderValue[];
    trailer?: string[];
    transferEncoding?: TransferCodingHeaderValue[];
    transferEncodingChunked?: boolean | undefined;
    upgrade?: ProductHeaderValue[];
    via?: ViaHeaderValue[];
    warning?: WarningHeaderValue[];
}

export class HttpResponseHeaders extends Anonymous implements IHttpResponseHeaders {

    [key: string]: any;

    constructor(data?: IHttpResponseHeaders) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static override fromJS(data: any): HttpResponseHeaders {
        data = typeof data === 'object' ? data : {};
        let result = new HttpResponseHeaders();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        super.toJSON(data);
        return data;
    }
}

export interface IHttpResponseHeaders extends IAnonymous {

    [key: string]: any;
}

export class EntityTagHeaderValue implements IEntityTagHeaderValue {
    tag?: string;
    isWeak?: boolean;

    constructor(data?: IEntityTagHeaderValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tag = _data["tag"];
            this.isWeak = _data["isWeak"];
        }
    }

    static fromJS(data: any): EntityTagHeaderValue {
        data = typeof data === 'object' ? data : {};
        let result = new EntityTagHeaderValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tag"] = this.tag;
        data["isWeak"] = this.isWeak;
        return data;
    }
}

export interface IEntityTagHeaderValue {
    tag?: string;
    isWeak?: boolean;
}

export class AuthenticationHeaderValue implements IAuthenticationHeaderValue {
    scheme?: string;
    parameter?: string | undefined;

    constructor(data?: IAuthenticationHeaderValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.scheme = _data["scheme"];
            this.parameter = _data["parameter"];
        }
    }

    static fromJS(data: any): AuthenticationHeaderValue {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticationHeaderValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scheme"] = this.scheme;
        data["parameter"] = this.parameter;
        return data;
    }
}

export interface IAuthenticationHeaderValue {
    scheme?: string;
    parameter?: string | undefined;
}

export class RetryConditionHeaderValue implements IRetryConditionHeaderValue {
    date?: Date | undefined;
    delta?: string | undefined;

    constructor(data?: IRetryConditionHeaderValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.delta = _data["delta"];
        }
    }

    static fromJS(data: any): RetryConditionHeaderValue {
        data = typeof data === 'object' ? data : {};
        let result = new RetryConditionHeaderValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["delta"] = this.delta;
        return data;
    }
}

export interface IRetryConditionHeaderValue {
    date?: Date | undefined;
    delta?: string | undefined;
}

export class ProductInfoHeaderValue implements IProductInfoHeaderValue {
    product?: ProductHeaderValue | undefined;
    comment?: string | undefined;

    constructor(data?: IProductInfoHeaderValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.product = _data["product"] ? ProductHeaderValue.fromJS(_data["product"]) : <any>undefined;
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): ProductInfoHeaderValue {
        data = typeof data === 'object' ? data : {};
        let result = new ProductInfoHeaderValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["comment"] = this.comment;
        return data;
    }
}

export interface IProductInfoHeaderValue {
    product?: ProductHeaderValue | undefined;
    comment?: string | undefined;
}

export class ProductHeaderValue implements IProductHeaderValue {
    name?: string;
    version?: string | undefined;

    constructor(data?: IProductHeaderValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): ProductHeaderValue {
        data = typeof data === 'object' ? data : {};
        let result = new ProductHeaderValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["version"] = this.version;
        return data;
    }
}

export interface IProductHeaderValue {
    name?: string;
    version?: string | undefined;
}

export class CacheControlHeaderValue implements ICacheControlHeaderValue {
    noCache?: boolean;
    noCacheHeaders?: string[];
    noStore?: boolean;
    maxAge?: string | undefined;
    sharedMaxAge?: string | undefined;
    maxStale?: boolean;
    maxStaleLimit?: string | undefined;
    minFresh?: string | undefined;
    noTransform?: boolean;
    onlyIfCached?: boolean;
    public?: boolean;
    private?: boolean;
    privateHeaders?: string[];
    mustRevalidate?: boolean;
    proxyRevalidate?: boolean;
    extensions?: NameValueHeaderValue[];

    constructor(data?: ICacheControlHeaderValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.noCache = _data["noCache"];
            if (Array.isArray(_data["noCacheHeaders"])) {
                this.noCacheHeaders = [] as any;
                for (let item of _data["noCacheHeaders"])
                    this.noCacheHeaders!.push(item);
            }
            this.noStore = _data["noStore"];
            this.maxAge = _data["maxAge"];
            this.sharedMaxAge = _data["sharedMaxAge"];
            this.maxStale = _data["maxStale"];
            this.maxStaleLimit = _data["maxStaleLimit"];
            this.minFresh = _data["minFresh"];
            this.noTransform = _data["noTransform"];
            this.onlyIfCached = _data["onlyIfCached"];
            this.public = _data["public"];
            this.private = _data["private"];
            if (Array.isArray(_data["privateHeaders"])) {
                this.privateHeaders = [] as any;
                for (let item of _data["privateHeaders"])
                    this.privateHeaders!.push(item);
            }
            this.mustRevalidate = _data["mustRevalidate"];
            this.proxyRevalidate = _data["proxyRevalidate"];
            if (Array.isArray(_data["extensions"])) {
                this.extensions = [] as any;
                for (let item of _data["extensions"])
                    this.extensions!.push(NameValueHeaderValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CacheControlHeaderValue {
        data = typeof data === 'object' ? data : {};
        let result = new CacheControlHeaderValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["noCache"] = this.noCache;
        if (Array.isArray(this.noCacheHeaders)) {
            data["noCacheHeaders"] = [];
            for (let item of this.noCacheHeaders)
                data["noCacheHeaders"].push(item);
        }
        data["noStore"] = this.noStore;
        data["maxAge"] = this.maxAge;
        data["sharedMaxAge"] = this.sharedMaxAge;
        data["maxStale"] = this.maxStale;
        data["maxStaleLimit"] = this.maxStaleLimit;
        data["minFresh"] = this.minFresh;
        data["noTransform"] = this.noTransform;
        data["onlyIfCached"] = this.onlyIfCached;
        data["public"] = this.public;
        data["private"] = this.private;
        if (Array.isArray(this.privateHeaders)) {
            data["privateHeaders"] = [];
            for (let item of this.privateHeaders)
                data["privateHeaders"].push(item);
        }
        data["mustRevalidate"] = this.mustRevalidate;
        data["proxyRevalidate"] = this.proxyRevalidate;
        if (Array.isArray(this.extensions)) {
            data["extensions"] = [];
            for (let item of this.extensions)
                data["extensions"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICacheControlHeaderValue {
    noCache?: boolean;
    noCacheHeaders?: string[];
    noStore?: boolean;
    maxAge?: string | undefined;
    sharedMaxAge?: string | undefined;
    maxStale?: boolean;
    maxStaleLimit?: string | undefined;
    minFresh?: string | undefined;
    noTransform?: boolean;
    onlyIfCached?: boolean;
    public?: boolean;
    private?: boolean;
    privateHeaders?: string[];
    mustRevalidate?: boolean;
    proxyRevalidate?: boolean;
    extensions?: NameValueHeaderValue[];
}

export class NameValueHeaderValue implements INameValueHeaderValue {
    name?: string;
    value?: string | undefined;

    constructor(data?: INameValueHeaderValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): NameValueHeaderValue {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueHeaderValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface INameValueHeaderValue {
    name?: string;
    value?: string | undefined;
}

export class TransferCodingHeaderValue implements ITransferCodingHeaderValue {
    value?: string;
    parameters?: NameValueHeaderValue[];

    constructor(data?: ITransferCodingHeaderValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            if (Array.isArray(_data["parameters"])) {
                this.parameters = [] as any;
                for (let item of _data["parameters"])
                    this.parameters!.push(NameValueHeaderValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TransferCodingHeaderValue {
        data = typeof data === 'object' ? data : {};
        let result = new TransferCodingHeaderValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        if (Array.isArray(this.parameters)) {
            data["parameters"] = [];
            for (let item of this.parameters)
                data["parameters"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITransferCodingHeaderValue {
    value?: string;
    parameters?: NameValueHeaderValue[];
}

export class ViaHeaderValue implements IViaHeaderValue {
    protocolName?: string | undefined;
    protocolVersion?: string;
    receivedBy?: string;
    comment?: string | undefined;

    constructor(data?: IViaHeaderValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.protocolName = _data["protocolName"];
            this.protocolVersion = _data["protocolVersion"];
            this.receivedBy = _data["receivedBy"];
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): ViaHeaderValue {
        data = typeof data === 'object' ? data : {};
        let result = new ViaHeaderValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["protocolName"] = this.protocolName;
        data["protocolVersion"] = this.protocolVersion;
        data["receivedBy"] = this.receivedBy;
        data["comment"] = this.comment;
        return data;
    }
}

export interface IViaHeaderValue {
    protocolName?: string | undefined;
    protocolVersion?: string;
    receivedBy?: string;
    comment?: string | undefined;
}

export class WarningHeaderValue implements IWarningHeaderValue {
    code?: number;
    agent?: string;
    text?: string;
    date?: Date | undefined;

    constructor(data?: IWarningHeaderValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.agent = _data["agent"];
            this.text = _data["text"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): WarningHeaderValue {
        data = typeof data === 'object' ? data : {};
        let result = new WarningHeaderValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["agent"] = this.agent;
        data["text"] = this.text;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        return data;
    }
}

export interface IWarningHeaderValue {
    code?: number;
    agent?: string;
    text?: string;
    date?: Date | undefined;
}

export class KeyValuePairOfStringAndIEnumerableOfString implements IKeyValuePairOfStringAndIEnumerableOfString {
    key?: string;
    value?: string[];

    constructor(data?: IKeyValuePairOfStringAndIEnumerableOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(item);
            }
        }
    }

    static fromJS(data: any): KeyValuePairOfStringAndIEnumerableOfString {
        data = typeof data === 'object' ? data : {};
        let result = new KeyValuePairOfStringAndIEnumerableOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item);
        }
        return data;
    }
}

export interface IKeyValuePairOfStringAndIEnumerableOfString {
    key?: string;
    value?: string[];
}

export abstract class StripeEntityOfCashBalance extends StripeEntity implements IStripeEntityOfCashBalance {

    constructor(data?: IStripeEntityOfCashBalance) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfCashBalance {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfCashBalance' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfCashBalance extends IStripeEntity {
}

/** A customer's Cash balance represents real funds. Customers can add funds to their cash balance by sending a bank transfer. These funds can be used for payment and can eventually be paid out to your bank account. */
export class CashBalance extends StripeEntityOfCashBalance implements ICashBalance {
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** A hash of all cash balances available to this customer. You cannot delete a customer
with any cash balances, even if the balance is 0. Amounts are represented in the smallest currency unit. */
    available?: { [key: string]: number; } | undefined;
    /** The ID of the customer whose cash balance this object represents. */
    customer?: string | undefined;
    /** Has the value true if the object exists in live mode or the value false if
the object exists in test mode. */
    livemode?: boolean;
    settings?: CashBalanceSettings | undefined;

    constructor(data?: ICashBalance) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.object = _data["object"];
            if (_data["available"]) {
                this.available = {} as any;
                for (let key in _data["available"]) {
                    if (_data["available"].hasOwnProperty(key))
                        (<any>this.available)![key] = _data["available"][key];
                }
            }
            this.customer = _data["customer"];
            this.livemode = _data["livemode"];
            this.settings = _data["settings"] ? CashBalanceSettings.fromJS(_data["settings"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): CashBalance {
        data = typeof data === 'object' ? data : {};
        let result = new CashBalance();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["object"] = this.object;
        if (this.available) {
            data["available"] = {};
            for (let key in this.available) {
                if (this.available.hasOwnProperty(key))
                    (<any>data["available"])[key] = (<any>this.available)[key];
            }
        }
        data["customer"] = this.customer;
        data["livemode"] = this.livemode;
        data["settings"] = this.settings ? this.settings.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** A customer's Cash balance represents real funds. Customers can add funds to their cash balance by sending a bank transfer. These funds can be used for payment and can eventually be paid out to your bank account. */
export interface ICashBalance extends IStripeEntityOfCashBalance {
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** A hash of all cash balances available to this customer. You cannot delete a customer
with any cash balances, even if the balance is 0. Amounts are represented in the smallest currency unit. */
    available?: { [key: string]: number; } | undefined;
    /** The ID of the customer whose cash balance this object represents. */
    customer?: string | undefined;
    /** Has the value true if the object exists in live mode or the value false if
the object exists in test mode. */
    livemode?: boolean;
    settings?: CashBalanceSettings | undefined;
}

export abstract class StripeEntityOfCashBalanceSettings extends StripeEntity implements IStripeEntityOfCashBalanceSettings {

    constructor(data?: IStripeEntityOfCashBalanceSettings) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfCashBalanceSettings {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfCashBalanceSettings' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfCashBalanceSettings extends IStripeEntity {
}

export class CashBalanceSettings extends StripeEntityOfCashBalanceSettings implements ICashBalanceSettings {
    /** The configuration for how funds that land in the customer cash balance are reconciled.
One of: automatic, or manual. */
    reconciliationMode?: string | undefined;
    /** A flag to indicate if reconciliation mode returned is the user's default or is specific
to this customer cash balance. */
    usingMerchantDefault?: boolean;

    constructor(data?: ICashBalanceSettings) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.reconciliationMode = _data["reconciliationMode"];
            this.usingMerchantDefault = _data["usingMerchantDefault"];
        }
    }

    static override fromJS(data: any): CashBalanceSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CashBalanceSettings();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reconciliationMode"] = this.reconciliationMode;
        data["usingMerchantDefault"] = this.usingMerchantDefault;
        super.toJSON(data);
        return data;
    }
}

export interface ICashBalanceSettings extends IStripeEntityOfCashBalanceSettings {
    /** The configuration for how funds that land in the customer cash balance are reconciled.
One of: automatic, or manual. */
    reconciliationMode?: string | undefined;
    /** A flag to indicate if reconciliation mode returned is the user's default or is specific
to this customer cash balance. */
    usingMerchantDefault?: boolean;
}

/** Resources that implement this interface can be used as payment sources when creating charges. Possible concrete classes: */
export abstract class IPaymentSource implements IIPaymentSource {

    constructor(data?: IIPaymentSource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): IPaymentSource {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'IPaymentSource' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

/** Resources that implement this interface can be used as payment sources when creating charges. Possible concrete classes: */
export interface IIPaymentSource {
}

/** Represents a generic expandable field. */
export class ExpandableFieldOfIPaymentSource implements IExpandableFieldOfIPaymentSource {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: IPaymentSource | undefined;

    constructor(data?: IExpandableFieldOfIPaymentSource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.expandedObject = _data["expandedObject"] ? IPaymentSource.fromJS(_data["expandedObject"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExpandableFieldOfIPaymentSource {
        data = typeof data === 'object' ? data : {};
        let result = new ExpandableFieldOfIPaymentSource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["expandedObject"] = this.expandedObject ? this.expandedObject.toJSON() : <any>undefined;
        return data;
    }
}

/** Represents a generic expandable field. */
export interface IExpandableFieldOfIPaymentSource {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: IPaymentSource | undefined;
}

export abstract class StripeEntityOfDiscount extends StripeEntity implements IStripeEntityOfDiscount {

    constructor(data?: IStripeEntityOfDiscount) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfDiscount {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfDiscount' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfDiscount extends IStripeEntity {
}

/** A discount represents the actual application of a coupon or promotion code. It contains information about when the discount began, when it will end, and what it is applied to.            Related guide: Applying discounts to subscriptions. */
export class Discount extends StripeEntityOfDiscount implements IDiscount {
    /** The ID of the discount object. Discounts cannot be fetched by ID. Use
expand[]=discounts in API calls to expand discount IDs in an array. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** The Checkout session that this coupon is applied to, if it is applied to a particular
session in payment mode. Will not be present for subscription mode. */
    checkoutSession?: string | undefined;
    /** A coupon contains information about a percent-off or amount-off discount you might want
to apply to a customer. Coupons may be applied to subscriptions, invoices, checkout sessions, quotes, and more. Coupons do not work with
conventional one-off charges or
payment intents. */
    coupon?: Coupon | undefined;
    /** (ID of the Customer)
The ID of the customer associated with this discount. */
    customerId?: string | undefined;
    /** (Expanded)
The ID of the customer associated with this discount.
            
For more information, see the expand documentation. */
    customer?: Customer2 | undefined;
    internalCustomer?: ExpandableFieldOfCustomer | undefined;
    /** Whether this object is deleted or not. */
    deleted?: boolean | undefined;
    /** If the coupon has a duration of repeating, the date that this discount will end.
If the coupon has a duration of once or forever, this attribute will be
null. */
    end?: Date | undefined;
    /** The invoice that the discount's coupon was applied to, if it was applied directly to a
particular invoice. */
    invoice?: string | undefined;
    /** The invoice item id (or invoice line item id for invoice line items of
type='subscription') that the discount's coupon was applied to, if it was applied
directly to a particular invoice item or invoice line item. */
    invoiceItem?: string | undefined;
    /** (ID of the PromotionCode)
The promotion code applied to create this discount. */
    promotionCodeId?: string | undefined;
    /** (Expanded)
The promotion code applied to create this discount.
            
For more information, see the expand documentation. */
    promotionCode?: PromotionCode | undefined;
    internalPromotionCode?: ExpandableFieldOfPromotionCode | undefined;
    /** Date that the coupon was applied. */
    start?: Date | undefined;
    /** (ID of the Subscription)
The subscription that this coupon is applied to, if it is applied to a particular
subscription. */
    subscriptionId?: string | undefined;
    /** (Expanded)
The subscription that this coupon is applied to, if it is applied to a particular
subscription.
            
For more information, see the expand documentation. */
    subscription?: Subscription | undefined;
    internalSubscription?: ExpandableFieldOfSubscription | undefined;

    constructor(data?: IDiscount) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.object = _data["object"];
            this.checkoutSession = _data["checkoutSession"];
            this.coupon = _data["coupon"] ? Coupon.fromJS(_data["coupon"]) : <any>undefined;
            this.customerId = _data["customerId"];
            this.customer = _data["customer"] ? Customer2.fromJS(_data["customer"]) : <any>undefined;
            this.internalCustomer = _data["internalCustomer"] ? ExpandableFieldOfCustomer.fromJS(_data["internalCustomer"]) : <any>undefined;
            this.deleted = _data["deleted"];
            this.end = _data["end"] ? new Date(_data["end"].toString()) : <any>undefined;
            this.invoice = _data["invoice"];
            this.invoiceItem = _data["invoiceItem"];
            this.promotionCodeId = _data["promotionCodeId"];
            this.promotionCode = _data["promotionCode"] ? PromotionCode.fromJS(_data["promotionCode"]) : <any>undefined;
            this.internalPromotionCode = _data["internalPromotionCode"] ? ExpandableFieldOfPromotionCode.fromJS(_data["internalPromotionCode"]) : <any>undefined;
            this.start = _data["start"] ? new Date(_data["start"].toString()) : <any>undefined;
            this.subscriptionId = _data["subscriptionId"];
            this.subscription = _data["subscription"] ? Subscription.fromJS(_data["subscription"]) : <any>undefined;
            this.internalSubscription = _data["internalSubscription"] ? ExpandableFieldOfSubscription.fromJS(_data["internalSubscription"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): Discount {
        data = typeof data === 'object' ? data : {};
        let result = new Discount();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["object"] = this.object;
        data["checkoutSession"] = this.checkoutSession;
        data["coupon"] = this.coupon ? this.coupon.toJSON() : <any>undefined;
        data["customerId"] = this.customerId;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["internalCustomer"] = this.internalCustomer ? this.internalCustomer.toJSON() : <any>undefined;
        data["deleted"] = this.deleted;
        data["end"] = this.end ? this.end.toISOString() : <any>undefined;
        data["invoice"] = this.invoice;
        data["invoiceItem"] = this.invoiceItem;
        data["promotionCodeId"] = this.promotionCodeId;
        data["promotionCode"] = this.promotionCode ? this.promotionCode.toJSON() : <any>undefined;
        data["internalPromotionCode"] = this.internalPromotionCode ? this.internalPromotionCode.toJSON() : <any>undefined;
        data["start"] = this.start ? this.start.toISOString() : <any>undefined;
        data["subscriptionId"] = this.subscriptionId;
        data["subscription"] = this.subscription ? this.subscription.toJSON() : <any>undefined;
        data["internalSubscription"] = this.internalSubscription ? this.internalSubscription.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** A discount represents the actual application of a coupon or promotion code. It contains information about when the discount began, when it will end, and what it is applied to.            Related guide: Applying discounts to subscriptions. */
export interface IDiscount extends IStripeEntityOfDiscount {
    /** The ID of the discount object. Discounts cannot be fetched by ID. Use
expand[]=discounts in API calls to expand discount IDs in an array. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** The Checkout session that this coupon is applied to, if it is applied to a particular
session in payment mode. Will not be present for subscription mode. */
    checkoutSession?: string | undefined;
    /** A coupon contains information about a percent-off or amount-off discount you might want
to apply to a customer. Coupons may be applied to subscriptions, invoices, checkout sessions, quotes, and more. Coupons do not work with
conventional one-off charges or
payment intents. */
    coupon?: Coupon | undefined;
    /** (ID of the Customer)
The ID of the customer associated with this discount. */
    customerId?: string | undefined;
    /** (Expanded)
The ID of the customer associated with this discount.
            
For more information, see the expand documentation. */
    customer?: Customer2 | undefined;
    internalCustomer?: ExpandableFieldOfCustomer | undefined;
    /** Whether this object is deleted or not. */
    deleted?: boolean | undefined;
    /** If the coupon has a duration of repeating, the date that this discount will end.
If the coupon has a duration of once or forever, this attribute will be
null. */
    end?: Date | undefined;
    /** The invoice that the discount's coupon was applied to, if it was applied directly to a
particular invoice. */
    invoice?: string | undefined;
    /** The invoice item id (or invoice line item id for invoice line items of
type='subscription') that the discount's coupon was applied to, if it was applied
directly to a particular invoice item or invoice line item. */
    invoiceItem?: string | undefined;
    /** (ID of the PromotionCode)
The promotion code applied to create this discount. */
    promotionCodeId?: string | undefined;
    /** (Expanded)
The promotion code applied to create this discount.
            
For more information, see the expand documentation. */
    promotionCode?: PromotionCode | undefined;
    internalPromotionCode?: ExpandableFieldOfPromotionCode | undefined;
    /** Date that the coupon was applied. */
    start?: Date | undefined;
    /** (ID of the Subscription)
The subscription that this coupon is applied to, if it is applied to a particular
subscription. */
    subscriptionId?: string | undefined;
    /** (Expanded)
The subscription that this coupon is applied to, if it is applied to a particular
subscription.
            
For more information, see the expand documentation. */
    subscription?: Subscription | undefined;
    internalSubscription?: ExpandableFieldOfSubscription | undefined;
}

export abstract class StripeEntityOfCoupon extends StripeEntity implements IStripeEntityOfCoupon {

    constructor(data?: IStripeEntityOfCoupon) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfCoupon {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfCoupon' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfCoupon extends IStripeEntity {
}

/** A coupon contains information about a percent-off or amount-off discount you might want to apply to a customer. Coupons may be applied to subscriptions, invoices, checkout sessions, quotes, and more. Coupons do not work with conventional one-off charges or payment intents. */
export class Coupon extends StripeEntityOfCoupon implements ICoupon {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** Amount (in the currency specified) that will be taken off the subtotal of any
invoices for this customer. */
    amountOff?: number | undefined;
    appliesTo?: CouponAppliesTo | undefined;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** If amount_off has been set, the three-letter ISO code for the currency of the amount to
take off. */
    currency?: string | undefined;
    /** Coupons defined in each available currency option. Each key must be a three-letter ISO currency code and a supported currency. */
    currencyOptions?: { [key: string]: CouponCurrencyOptions; } | undefined;
    /** Whether this object is deleted or not. */
    deleted?: boolean | undefined;
    /** One of forever, once, and repeating. Describes how long a customer
who applies this coupon will get the discount.
One of: forever, once, or repeating. */
    duration?: string | undefined;
    /** If duration is repeating, the number of months the coupon applies. Null if
coupon duration is forever or once. */
    durationInMonths?: number | undefined;
    /** Has the value true if the object exists in live mode or the value false if
the object exists in test mode. */
    livemode?: boolean;
    /** Maximum number of times this coupon can be redeemed, in total, across all customers,
before it is no longer valid. */
    maxRedemptions?: number | undefined;
    /** Set of key-value pairs that you can
attach to an object. This can be useful for storing additional information about the
object in a structured format. */
    metadata?: { [key: string]: string; } | undefined;
    /** Name of the coupon displayed to customers on for instance invoices or receipts. */
    name?: string | undefined;
    /** Percent that will be taken off the subtotal of any invoices for this customer for the
duration of the coupon. For example, a coupon with percent_off of 50 will make a %s100
invoice %s50 instead. */
    percentOff?: number | undefined;
    /** Date after which the coupon can no longer be redeemed. */
    redeemBy?: Date | undefined;
    /** Number of times this coupon has been applied to a customer. */
    timesRedeemed?: number;
    /** Taking account of the above properties, whether this coupon can still be applied to a
customer. */
    valid?: boolean;

    constructor(data?: ICoupon) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.object = _data["object"];
            this.amountOff = _data["amountOff"];
            this.appliesTo = _data["appliesTo"] ? CouponAppliesTo.fromJS(_data["appliesTo"]) : <any>undefined;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.currency = _data["currency"];
            if (_data["currencyOptions"]) {
                this.currencyOptions = {} as any;
                for (let key in _data["currencyOptions"]) {
                    if (_data["currencyOptions"].hasOwnProperty(key))
                        (<any>this.currencyOptions)![key] = _data["currencyOptions"][key] ? CouponCurrencyOptions.fromJS(_data["currencyOptions"][key]) : new CouponCurrencyOptions();
                }
            }
            this.deleted = _data["deleted"];
            this.duration = _data["duration"];
            this.durationInMonths = _data["durationInMonths"];
            this.livemode = _data["livemode"];
            this.maxRedemptions = _data["maxRedemptions"];
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
            this.name = _data["name"];
            this.percentOff = _data["percentOff"];
            this.redeemBy = _data["redeemBy"] ? new Date(_data["redeemBy"].toString()) : <any>undefined;
            this.timesRedeemed = _data["timesRedeemed"];
            this.valid = _data["valid"];
        }
    }

    static override fromJS(data: any): Coupon {
        data = typeof data === 'object' ? data : {};
        let result = new Coupon();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["object"] = this.object;
        data["amountOff"] = this.amountOff;
        data["appliesTo"] = this.appliesTo ? this.appliesTo.toJSON() : <any>undefined;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["currency"] = this.currency;
        if (this.currencyOptions) {
            data["currencyOptions"] = {};
            for (let key in this.currencyOptions) {
                if (this.currencyOptions.hasOwnProperty(key))
                    (<any>data["currencyOptions"])[key] = this.currencyOptions[key] ? this.currencyOptions[key].toJSON() : <any>undefined;
            }
        }
        data["deleted"] = this.deleted;
        data["duration"] = this.duration;
        data["durationInMonths"] = this.durationInMonths;
        data["livemode"] = this.livemode;
        data["maxRedemptions"] = this.maxRedemptions;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        data["name"] = this.name;
        data["percentOff"] = this.percentOff;
        data["redeemBy"] = this.redeemBy ? this.redeemBy.toISOString() : <any>undefined;
        data["timesRedeemed"] = this.timesRedeemed;
        data["valid"] = this.valid;
        super.toJSON(data);
        return data;
    }
}

/** A coupon contains information about a percent-off or amount-off discount you might want to apply to a customer. Coupons may be applied to subscriptions, invoices, checkout sessions, quotes, and more. Coupons do not work with conventional one-off charges or payment intents. */
export interface ICoupon extends IStripeEntityOfCoupon {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** Amount (in the currency specified) that will be taken off the subtotal of any
invoices for this customer. */
    amountOff?: number | undefined;
    appliesTo?: CouponAppliesTo | undefined;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** If amount_off has been set, the three-letter ISO code for the currency of the amount to
take off. */
    currency?: string | undefined;
    /** Coupons defined in each available currency option. Each key must be a three-letter ISO currency code and a supported currency. */
    currencyOptions?: { [key: string]: CouponCurrencyOptions; } | undefined;
    /** Whether this object is deleted or not. */
    deleted?: boolean | undefined;
    /** One of forever, once, and repeating. Describes how long a customer
who applies this coupon will get the discount.
One of: forever, once, or repeating. */
    duration?: string | undefined;
    /** If duration is repeating, the number of months the coupon applies. Null if
coupon duration is forever or once. */
    durationInMonths?: number | undefined;
    /** Has the value true if the object exists in live mode or the value false if
the object exists in test mode. */
    livemode?: boolean;
    /** Maximum number of times this coupon can be redeemed, in total, across all customers,
before it is no longer valid. */
    maxRedemptions?: number | undefined;
    /** Set of key-value pairs that you can
attach to an object. This can be useful for storing additional information about the
object in a structured format. */
    metadata?: { [key: string]: string; } | undefined;
    /** Name of the coupon displayed to customers on for instance invoices or receipts. */
    name?: string | undefined;
    /** Percent that will be taken off the subtotal of any invoices for this customer for the
duration of the coupon. For example, a coupon with percent_off of 50 will make a %s100
invoice %s50 instead. */
    percentOff?: number | undefined;
    /** Date after which the coupon can no longer be redeemed. */
    redeemBy?: Date | undefined;
    /** Number of times this coupon has been applied to a customer. */
    timesRedeemed?: number;
    /** Taking account of the above properties, whether this coupon can still be applied to a
customer. */
    valid?: boolean;
}

export abstract class StripeEntityOfCouponAppliesTo extends StripeEntity implements IStripeEntityOfCouponAppliesTo {

    constructor(data?: IStripeEntityOfCouponAppliesTo) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfCouponAppliesTo {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfCouponAppliesTo' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfCouponAppliesTo extends IStripeEntity {
}

export class CouponAppliesTo extends StripeEntityOfCouponAppliesTo implements ICouponAppliesTo {
    /** A list of product IDs this coupon applies to. */
    products?: string[] | undefined;

    constructor(data?: ICouponAppliesTo) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(item);
            }
        }
    }

    static override fromJS(data: any): CouponAppliesTo {
        data = typeof data === 'object' ? data : {};
        let result = new CouponAppliesTo();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface ICouponAppliesTo extends IStripeEntityOfCouponAppliesTo {
    /** A list of product IDs this coupon applies to. */
    products?: string[] | undefined;
}

export abstract class StripeEntityOfCouponCurrencyOptions extends StripeEntity implements IStripeEntityOfCouponCurrencyOptions {

    constructor(data?: IStripeEntityOfCouponCurrencyOptions) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfCouponCurrencyOptions {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfCouponCurrencyOptions' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfCouponCurrencyOptions extends IStripeEntity {
}

export class CouponCurrencyOptions extends StripeEntityOfCouponCurrencyOptions implements ICouponCurrencyOptions {
    /** Amount (in the currency specified) that will be taken off the subtotal of any
invoices for this customer. */
    amountOff?: number;

    constructor(data?: ICouponCurrencyOptions) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.amountOff = _data["amountOff"];
        }
    }

    static override fromJS(data: any): CouponCurrencyOptions {
        data = typeof data === 'object' ? data : {};
        let result = new CouponCurrencyOptions();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amountOff"] = this.amountOff;
        super.toJSON(data);
        return data;
    }
}

export interface ICouponCurrencyOptions extends IStripeEntityOfCouponCurrencyOptions {
    /** Amount (in the currency specified) that will be taken off the subtotal of any
invoices for this customer. */
    amountOff?: number;
}

/** Represents a generic expandable field. */
export class ExpandableFieldOfCustomer implements IExpandableFieldOfCustomer {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: Customer2 | undefined;

    constructor(data?: IExpandableFieldOfCustomer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.expandedObject = _data["expandedObject"] ? Customer2.fromJS(_data["expandedObject"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExpandableFieldOfCustomer {
        data = typeof data === 'object' ? data : {};
        let result = new ExpandableFieldOfCustomer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["expandedObject"] = this.expandedObject ? this.expandedObject.toJSON() : <any>undefined;
        return data;
    }
}

/** Represents a generic expandable field. */
export interface IExpandableFieldOfCustomer {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: Customer2 | undefined;
}

export abstract class StripeEntityOfPromotionCode extends StripeEntity implements IStripeEntityOfPromotionCode {

    constructor(data?: IStripeEntityOfPromotionCode) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPromotionCode {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPromotionCode' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPromotionCode extends IStripeEntity {
}

/** A Promotion Code represents a customer-redeemable code for a coupon. It can be used to create multiple codes for a single coupon. */
export class PromotionCode extends StripeEntityOfPromotionCode implements IPromotionCode {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** Whether the promotion code is currently active. A promotion code is only active if the
coupon is also valid. */
    active?: boolean;
    /** The customer-facing code. Regardless of case, this code must be unique across all active
promotion codes for each customer. */
    code?: string | undefined;
    /** A coupon contains information about a percent-off or amount-off discount you might want
to apply to a customer. Coupons may be applied to subscriptions, invoices, checkout sessions, quotes, and more. Coupons do not work with
conventional one-off charges or
payment intents. */
    coupon?: Coupon | undefined;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** (ID of the Customer)
The customer that this promotion code can be used by. */
    customerId?: string | undefined;
    /** (Expanded)
The customer that this promotion code can be used by.
            
For more information, see the expand documentation. */
    customer?: Customer2 | undefined;
    internalCustomer?: ExpandableFieldOfCustomer | undefined;
    /** Date at which the promotion code can no longer be redeemed. */
    expiresAt?: Date | undefined;
    /** Has the value true if the object exists in live mode or the value false if
the object exists in test mode. */
    livemode?: boolean;
    /** Maximum number of times this promotion code can be redeemed. */
    maxRedemptions?: number | undefined;
    /** Set of key-value pairs that you can
attach to an object. This can be useful for storing additional information about the
object in a structured format. */
    metadata?: { [key: string]: string; } | undefined;
    restrictions?: PromotionCodeRestrictions | undefined;
    /** Number of times this promotion code has been used. */
    timesRedeemed?: number;

    constructor(data?: IPromotionCode) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.object = _data["object"];
            this.active = _data["active"];
            this.code = _data["code"];
            this.coupon = _data["coupon"] ? Coupon.fromJS(_data["coupon"]) : <any>undefined;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.customerId = _data["customerId"];
            this.customer = _data["customer"] ? Customer2.fromJS(_data["customer"]) : <any>undefined;
            this.internalCustomer = _data["internalCustomer"] ? ExpandableFieldOfCustomer.fromJS(_data["internalCustomer"]) : <any>undefined;
            this.expiresAt = _data["expiresAt"] ? new Date(_data["expiresAt"].toString()) : <any>undefined;
            this.livemode = _data["livemode"];
            this.maxRedemptions = _data["maxRedemptions"];
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
            this.restrictions = _data["restrictions"] ? PromotionCodeRestrictions.fromJS(_data["restrictions"]) : <any>undefined;
            this.timesRedeemed = _data["timesRedeemed"];
        }
    }

    static override fromJS(data: any): PromotionCode {
        data = typeof data === 'object' ? data : {};
        let result = new PromotionCode();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["object"] = this.object;
        data["active"] = this.active;
        data["code"] = this.code;
        data["coupon"] = this.coupon ? this.coupon.toJSON() : <any>undefined;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["customerId"] = this.customerId;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["internalCustomer"] = this.internalCustomer ? this.internalCustomer.toJSON() : <any>undefined;
        data["expiresAt"] = this.expiresAt ? this.expiresAt.toISOString() : <any>undefined;
        data["livemode"] = this.livemode;
        data["maxRedemptions"] = this.maxRedemptions;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        data["restrictions"] = this.restrictions ? this.restrictions.toJSON() : <any>undefined;
        data["timesRedeemed"] = this.timesRedeemed;
        super.toJSON(data);
        return data;
    }
}

/** A Promotion Code represents a customer-redeemable code for a coupon. It can be used to create multiple codes for a single coupon. */
export interface IPromotionCode extends IStripeEntityOfPromotionCode {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** Whether the promotion code is currently active. A promotion code is only active if the
coupon is also valid. */
    active?: boolean;
    /** The customer-facing code. Regardless of case, this code must be unique across all active
promotion codes for each customer. */
    code?: string | undefined;
    /** A coupon contains information about a percent-off or amount-off discount you might want
to apply to a customer. Coupons may be applied to subscriptions, invoices, checkout sessions, quotes, and more. Coupons do not work with
conventional one-off charges or
payment intents. */
    coupon?: Coupon | undefined;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** (ID of the Customer)
The customer that this promotion code can be used by. */
    customerId?: string | undefined;
    /** (Expanded)
The customer that this promotion code can be used by.
            
For more information, see the expand documentation. */
    customer?: Customer2 | undefined;
    internalCustomer?: ExpandableFieldOfCustomer | undefined;
    /** Date at which the promotion code can no longer be redeemed. */
    expiresAt?: Date | undefined;
    /** Has the value true if the object exists in live mode or the value false if
the object exists in test mode. */
    livemode?: boolean;
    /** Maximum number of times this promotion code can be redeemed. */
    maxRedemptions?: number | undefined;
    /** Set of key-value pairs that you can
attach to an object. This can be useful for storing additional information about the
object in a structured format. */
    metadata?: { [key: string]: string; } | undefined;
    restrictions?: PromotionCodeRestrictions | undefined;
    /** Number of times this promotion code has been used. */
    timesRedeemed?: number;
}

export abstract class StripeEntityOfPromotionCodeRestrictions extends StripeEntity implements IStripeEntityOfPromotionCodeRestrictions {

    constructor(data?: IStripeEntityOfPromotionCodeRestrictions) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPromotionCodeRestrictions {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPromotionCodeRestrictions' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPromotionCodeRestrictions extends IStripeEntity {
}

export class PromotionCodeRestrictions extends StripeEntityOfPromotionCodeRestrictions implements IPromotionCodeRestrictions {
    /** Promotion code restrictions defined in each available currency option. Each key must be
a three-letter ISO currency
code and a supported currency. */
    currencyOptions?: { [key: string]: PromotionCodeRestrictionsCurrencyOptions; } | undefined;
    /** A Boolean indicating if the Promotion Code should only be redeemed for Customers without
any successful payments or invoices. */
    firstTimeTransaction?: boolean;
    /** Minimum amount required to redeem this Promotion Code into a Coupon (e.g., a purchase
must be $100 or more to work). */
    minimumAmount?: number | undefined;
    /** Three-letter ISO code for
minimum_amount. */
    minimumAmountCurrency?: string | undefined;

    constructor(data?: IPromotionCodeRestrictions) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (_data["currencyOptions"]) {
                this.currencyOptions = {} as any;
                for (let key in _data["currencyOptions"]) {
                    if (_data["currencyOptions"].hasOwnProperty(key))
                        (<any>this.currencyOptions)![key] = _data["currencyOptions"][key] ? PromotionCodeRestrictionsCurrencyOptions.fromJS(_data["currencyOptions"][key]) : new PromotionCodeRestrictionsCurrencyOptions();
                }
            }
            this.firstTimeTransaction = _data["firstTimeTransaction"];
            this.minimumAmount = _data["minimumAmount"];
            this.minimumAmountCurrency = _data["minimumAmountCurrency"];
        }
    }

    static override fromJS(data: any): PromotionCodeRestrictions {
        data = typeof data === 'object' ? data : {};
        let result = new PromotionCodeRestrictions();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.currencyOptions) {
            data["currencyOptions"] = {};
            for (let key in this.currencyOptions) {
                if (this.currencyOptions.hasOwnProperty(key))
                    (<any>data["currencyOptions"])[key] = this.currencyOptions[key] ? this.currencyOptions[key].toJSON() : <any>undefined;
            }
        }
        data["firstTimeTransaction"] = this.firstTimeTransaction;
        data["minimumAmount"] = this.minimumAmount;
        data["minimumAmountCurrency"] = this.minimumAmountCurrency;
        super.toJSON(data);
        return data;
    }
}

export interface IPromotionCodeRestrictions extends IStripeEntityOfPromotionCodeRestrictions {
    /** Promotion code restrictions defined in each available currency option. Each key must be
a three-letter ISO currency
code and a supported currency. */
    currencyOptions?: { [key: string]: PromotionCodeRestrictionsCurrencyOptions; } | undefined;
    /** A Boolean indicating if the Promotion Code should only be redeemed for Customers without
any successful payments or invoices. */
    firstTimeTransaction?: boolean;
    /** Minimum amount required to redeem this Promotion Code into a Coupon (e.g., a purchase
must be $100 or more to work). */
    minimumAmount?: number | undefined;
    /** Three-letter ISO code for
minimum_amount. */
    minimumAmountCurrency?: string | undefined;
}

export abstract class StripeEntityOfPromotionCodeRestrictionsCurrencyOptions extends StripeEntity implements IStripeEntityOfPromotionCodeRestrictionsCurrencyOptions {

    constructor(data?: IStripeEntityOfPromotionCodeRestrictionsCurrencyOptions) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPromotionCodeRestrictionsCurrencyOptions {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPromotionCodeRestrictionsCurrencyOptions' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPromotionCodeRestrictionsCurrencyOptions extends IStripeEntity {
}

export class PromotionCodeRestrictionsCurrencyOptions extends StripeEntityOfPromotionCodeRestrictionsCurrencyOptions implements IPromotionCodeRestrictionsCurrencyOptions {
    /** Minimum amount required to redeem this Promotion Code into a Coupon (e.g., a purchase
must be $100 or more to work). */
    minimumAmount?: number;

    constructor(data?: IPromotionCodeRestrictionsCurrencyOptions) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.minimumAmount = _data["minimumAmount"];
        }
    }

    static override fromJS(data: any): PromotionCodeRestrictionsCurrencyOptions {
        data = typeof data === 'object' ? data : {};
        let result = new PromotionCodeRestrictionsCurrencyOptions();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["minimumAmount"] = this.minimumAmount;
        super.toJSON(data);
        return data;
    }
}

export interface IPromotionCodeRestrictionsCurrencyOptions extends IStripeEntityOfPromotionCodeRestrictionsCurrencyOptions {
    /** Minimum amount required to redeem this Promotion Code into a Coupon (e.g., a purchase
must be $100 or more to work). */
    minimumAmount?: number;
}

/** Represents a generic expandable field. */
export class ExpandableFieldOfPromotionCode implements IExpandableFieldOfPromotionCode {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: PromotionCode | undefined;

    constructor(data?: IExpandableFieldOfPromotionCode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.expandedObject = _data["expandedObject"] ? PromotionCode.fromJS(_data["expandedObject"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExpandableFieldOfPromotionCode {
        data = typeof data === 'object' ? data : {};
        let result = new ExpandableFieldOfPromotionCode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["expandedObject"] = this.expandedObject ? this.expandedObject.toJSON() : <any>undefined;
        return data;
    }
}

/** Represents a generic expandable field. */
export interface IExpandableFieldOfPromotionCode {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: PromotionCode | undefined;
}

export abstract class StripeEntityOfSubscription extends StripeEntity implements IStripeEntityOfSubscription {

    constructor(data?: IStripeEntityOfSubscription) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSubscription {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSubscription' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSubscription extends IStripeEntity {
}

/** Subscriptions allow you to charge a customer on a recurring basis.            Related guide: Creating subscriptions. */
export class Subscription extends StripeEntityOfSubscription implements ISubscription {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** (ID of the Application)
ID of the Connect Application that created the subscription. */
    applicationId?: string | undefined;
    /** (Expanded)
ID of the Connect Application that created the subscription.
            
For more information, see the expand documentation. */
    application?: Application | undefined;
    internalApplication?: ExpandableFieldOfApplication | undefined;
    /** A non-negative decimal between 0 and 100, with at most two decimal places. This
represents the percentage of the subscription invoice subtotal that will be transferred
to the application owner's Stripe account. */
    applicationFeePercent?: number | undefined;
    automaticTax?: SubscriptionAutomaticTax | undefined;
    /** Determines the date of the first full invoice, and, for plans with month or
year intervals, the day of the month for subsequent invoices. The timestamp is in
UTC format. */
    billingCycleAnchor?: Date;
    /** Define thresholds at which an invoice will be sent, and the subscription advanced to a
new billing period. */
    billingThresholds?: SubscriptionBillingThresholds | undefined;
    /** A date in the future at which the subscription will automatically get canceled. */
    cancelAt?: Date | undefined;
    /** If the subscription has been canceled with the at_period_end flag set to
true, cancel_at_period_end on the subscription will be true. You can use
this attribute to determine whether a subscription that has a status of active is
scheduled to be canceled at the end of the current period. */
    cancelAtPeriodEnd?: boolean;
    /** If the subscription has been canceled, the date of that cancellation. If the
subscription was canceled with cancel_at_period_end, canceled_at will
reflect the time of the most recent update request, not the end of the subscription
period when the subscription is automatically moved to a canceled state. */
    canceledAt?: Date | undefined;
    /** Details about why this subscription was cancelled. */
    cancellationDetails?: SubscriptionCancellationDetails | undefined;
    /** Either charge_automatically, or send_invoice. When charging automatically,
Stripe will attempt to pay this subscription at the end of the cycle using the default
source attached to the customer. When sending an invoice, Stripe will email your
customer an invoice with payment instructions and mark the subscription as
active.
One of: charge_automatically, or send_invoice. */
    collectionMethod?: string | undefined;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** Three-letter ISO currency
code, in lowercase. Must be a supported
currency. */
    currency?: string | undefined;
    /** End of the current period that the subscription has been invoiced for. At the end of
this period, a new invoice will be created. */
    currentPeriodEnd?: Date;
    /** Start of the current period that the subscription has been invoiced for. */
    currentPeriodStart?: Date;
    /** (ID of the Customer)
ID of the customer who owns the subscription. */
    customerId?: string | undefined;
    /** (Expanded)
ID of the customer who owns the subscription.
            
For more information, see the expand documentation. */
    customer?: Customer2 | undefined;
    internalCustomer?: ExpandableFieldOfCustomer | undefined;
    /** Number of days a customer has to pay invoices generated by this subscription. This value
will be null for subscriptions where
collection_method=charge_automatically. */
    daysUntilDue?: number | undefined;
    /** (ID of the PaymentMethod)
ID of the default payment method for the subscription. It must belong to the customer
associated with the subscription. This takes precedence over default_source. If
neither are set, invoices will use the customer's invoice_settings.default_payment_method
or default_source. */
    defaultPaymentMethodId?: string | undefined;
    /** (Expanded)
ID of the default payment method for the subscription. It must belong to the customer
associated with the subscription. This takes precedence over default_source. If
neither are set, invoices will use the customer's invoice_settings.default_payment_method
or default_source.
            
For more information, see the expand documentation. */
    defaultPaymentMethod?: PaymentMethod | undefined;
    internalDefaultPaymentMethod?: ExpandableFieldOfPaymentMethod | undefined;
    /** (ID of the IPaymentSource)
ID of the default payment source for the subscription. It must belong to the customer
associated with the subscription and be in a chargeable state. If
default_payment_method is also set, default_payment_method will take
precedence. If neither are set, invoices will use the customer's invoice_settings.default_payment_method
or default_source. */
    defaultSourceId?: string | undefined;
    /** (Expanded)
ID of the default payment source for the subscription. It must belong to the customer
associated with the subscription and be in a chargeable state. If
default_payment_method is also set, default_payment_method will take
precedence. If neither are set, invoices will use the customer's invoice_settings.default_payment_method
or default_source.
            
For more information, see the expand documentation. */
    defaultSource?: IPaymentSource | undefined;
    internalDefaultSource?: ExpandableFieldOfIPaymentSource | undefined;
    /** The tax rates that will apply to any subscription item that does not have
tax_rates set. Invoices created will have their default_tax_rates
populated from the subscription. */
    defaultTaxRates?: TaxRate[] | undefined;
    /** The subscription's description, meant to be displayable to the customer. Use this field
to optionally store an explanation of the subscription for rendering in Stripe surfaces. */
    description?: string | undefined;
    /** Describes the current discount applied to this subscription, if there is one. When
billing, a discount applied to a subscription overrides a discount applied on a
customer-wide basis. */
    discount?: Discount | undefined;
    /** If the subscription has ended, the date the subscription ended. */
    endedAt?: Date | undefined;
    /** List of subscription items, each with an attached price. */
    items?: StripeListOfSubscriptionItem | undefined;
    /** (ID of the Invoice)
The most recent invoice this subscription has generated. */
    latestInvoiceId?: string | undefined;
    /** (Expanded)
The most recent invoice this subscription has generated.
            
For more information, see the expand documentation. */
    latestInvoice?: Invoice | undefined;
    internalLatestInvoice?: ExpandableFieldOfInvoice | undefined;
    /** Has the value true if the object exists in live mode or the value false if
the object exists in test mode. */
    livemode?: boolean;
    /** Set of key-value pairs that you can
attach to an object. This can be useful for storing additional information about the
object in a structured format. */
    metadata?: { [key: string]: string; } | undefined;
    /** Specifies the approximate timestamp on which any pending invoice items will be billed
according to the schedule provided at pending_invoice_item_interval. */
    nextPendingInvoiceItemInvoice?: Date | undefined;
    /** (ID of the Account)
The account (if any) the charge was made on behalf of for charges associated with this
subscription. See the Connect documentation for details. */
    onBehalfOfId?: string | undefined;
    /** (Expanded)
The account (if any) the charge was made on behalf of for charges associated with this
subscription. See the Connect documentation for details.
            
For more information, see the expand documentation. */
    onBehalfOf?: Account | undefined;
    internalOnBehalfOf?: ExpandableFieldOfAccount | undefined;
    /** If specified, payment collection for this subscription will be paused. */
    pauseCollection?: SubscriptionPauseCollection | undefined;
    /** Payment settings passed on to invoices created by the subscription. */
    paymentSettings?: SubscriptionPaymentSettings | undefined;
    /** Specifies an interval for how often to bill for any pending invoice items. It is
analogous to calling Create an
invoice for the given subscription at the specified interval. */
    pendingInvoiceItemInterval?: SubscriptionPendingInvoiceItemInterval | undefined;
    /** (ID of the SetupIntent)
You can use this SetupIntent to
collect user authentication when creating a subscription without immediate payment or
updating a subscription's payment method, allowing you to optimize for off-session
payments. Learn more in the SCA
Migration Guide. */
    pendingSetupIntentId?: string | undefined;
    /** (Expanded)
You can use this SetupIntent to
collect user authentication when creating a subscription without immediate payment or
updating a subscription's payment method, allowing you to optimize for off-session
payments. Learn more in the SCA
Migration Guide.
            
For more information, see the expand documentation. */
    pendingSetupIntent?: SetupIntent | undefined;
    internalPendingSetupIntent?: ExpandableFieldOfSetupIntent | undefined;
    /** If specified, pending updates
that will be applied to the subscription once the latest_invoice has been paid. */
    pendingUpdate?: SubscriptionPendingUpdate | undefined;
    /** (ID of the SubscriptionSchedule)
The schedule attached to the subscription. */
    scheduleId?: string | undefined;
    /** (Expanded)
The schedule attached to the subscription.
            
For more information, see the expand documentation. */
    schedule?: SubscriptionSchedule | undefined;
    internalSchedule?: ExpandableFieldOfSubscriptionSchedule | undefined;
    /** Date when the subscription was first created. The date might differ from the
created date due to backdating. */
    startDate?: Date;
    /** Possible values are incomplete, incomplete_expired, trialing,
active, past_due, canceled, or unpaid.
            
For collection_method=charge_automatically a subscription moves into
incomplete if the initial payment attempt fails. A subscription in this state can
only have metadata and default_source updated. Once the first invoice is paid, the
subscription moves into an active state. If the first invoice is not paid within
23 hours, the subscription transitions to incomplete_expired. This is a terminal
state, the open invoice will be voided and no further invoices will be generated.
            
A subscription that is currently in a trial period is trialing and moves to
active when the trial period is over.
            
If subscription collection_method=charge_automatically it becomes past_due
when payment to renew it fails and canceled or unpaid (depending on your
subscriptions settings) when Stripe has exhausted all payment retry attempts.
            
If subscription collection_method=send_invoice it becomes past_due when
its invoice is not paid by the due date, and canceled or unpaid if it is
still not paid by an additional deadline after that. Note that when a subscription has a
status of unpaid, no subsequent invoices will be attempted (invoices will be
created, but then immediately automatically closed). After receiving updated payment
information from a customer, you may choose to reopen and pay their closed invoices.
One of: active, canceled, incomplete, incomplete_expired,
past_due, paused, trialing, or unpaid. */
    status?: string | undefined;
    /** (ID of the TestHelpers.TestClock)
ID of the test clock this subscription belongs to. */
    testClockId?: string | undefined;
    /** (Expanded)
ID of the test clock this subscription belongs to.
            
For more information, see the expand documentation. */
    testClock?: TestClock | undefined;
    internalTestClock?: ExpandableFieldOfTestClock | undefined;
    /** The account (if any) the subscription's payments will be attributed to for tax
reporting, and where funds from each payment will be transferred to for each of the
subscription's invoices. */
    transferData?: SubscriptionTransferData | undefined;
    /** If the subscription has a trial, the end of that trial. */
    trialEnd?: Date | undefined;
    /** Settings related to subscription trials. */
    trialSettings?: SubscriptionTrialSettings | undefined;
    /** If the subscription has a trial, the beginning of that trial. */
    trialStart?: Date | undefined;

    constructor(data?: ISubscription) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.object = _data["object"];
            this.applicationId = _data["applicationId"];
            this.application = _data["application"] ? Application.fromJS(_data["application"]) : <any>undefined;
            this.internalApplication = _data["internalApplication"] ? ExpandableFieldOfApplication.fromJS(_data["internalApplication"]) : <any>undefined;
            this.applicationFeePercent = _data["applicationFeePercent"];
            this.automaticTax = _data["automaticTax"] ? SubscriptionAutomaticTax.fromJS(_data["automaticTax"]) : <any>undefined;
            this.billingCycleAnchor = _data["billingCycleAnchor"] ? new Date(_data["billingCycleAnchor"].toString()) : <any>undefined;
            this.billingThresholds = _data["billingThresholds"] ? SubscriptionBillingThresholds.fromJS(_data["billingThresholds"]) : <any>undefined;
            this.cancelAt = _data["cancelAt"] ? new Date(_data["cancelAt"].toString()) : <any>undefined;
            this.cancelAtPeriodEnd = _data["cancelAtPeriodEnd"];
            this.canceledAt = _data["canceledAt"] ? new Date(_data["canceledAt"].toString()) : <any>undefined;
            this.cancellationDetails = _data["cancellationDetails"] ? SubscriptionCancellationDetails.fromJS(_data["cancellationDetails"]) : <any>undefined;
            this.collectionMethod = _data["collectionMethod"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.currency = _data["currency"];
            this.currentPeriodEnd = _data["currentPeriodEnd"] ? new Date(_data["currentPeriodEnd"].toString()) : <any>undefined;
            this.currentPeriodStart = _data["currentPeriodStart"] ? new Date(_data["currentPeriodStart"].toString()) : <any>undefined;
            this.customerId = _data["customerId"];
            this.customer = _data["customer"] ? Customer2.fromJS(_data["customer"]) : <any>undefined;
            this.internalCustomer = _data["internalCustomer"] ? ExpandableFieldOfCustomer.fromJS(_data["internalCustomer"]) : <any>undefined;
            this.daysUntilDue = _data["daysUntilDue"];
            this.defaultPaymentMethodId = _data["defaultPaymentMethodId"];
            this.defaultPaymentMethod = _data["defaultPaymentMethod"] ? PaymentMethod.fromJS(_data["defaultPaymentMethod"]) : <any>undefined;
            this.internalDefaultPaymentMethod = _data["internalDefaultPaymentMethod"] ? ExpandableFieldOfPaymentMethod.fromJS(_data["internalDefaultPaymentMethod"]) : <any>undefined;
            this.defaultSourceId = _data["defaultSourceId"];
            this.defaultSource = _data["defaultSource"] ? IPaymentSource.fromJS(_data["defaultSource"]) : <any>undefined;
            this.internalDefaultSource = _data["internalDefaultSource"] ? ExpandableFieldOfIPaymentSource.fromJS(_data["internalDefaultSource"]) : <any>undefined;
            if (Array.isArray(_data["defaultTaxRates"])) {
                this.defaultTaxRates = [] as any;
                for (let item of _data["defaultTaxRates"])
                    this.defaultTaxRates!.push(TaxRate.fromJS(item));
            }
            this.description = _data["description"];
            this.discount = _data["discount"] ? Discount.fromJS(_data["discount"]) : <any>undefined;
            this.endedAt = _data["endedAt"] ? new Date(_data["endedAt"].toString()) : <any>undefined;
            this.items = _data["items"] ? StripeListOfSubscriptionItem.fromJS(_data["items"]) : <any>undefined;
            this.latestInvoiceId = _data["latestInvoiceId"];
            this.latestInvoice = _data["latestInvoice"] ? Invoice.fromJS(_data["latestInvoice"]) : <any>undefined;
            this.internalLatestInvoice = _data["internalLatestInvoice"] ? ExpandableFieldOfInvoice.fromJS(_data["internalLatestInvoice"]) : <any>undefined;
            this.livemode = _data["livemode"];
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
            this.nextPendingInvoiceItemInvoice = _data["nextPendingInvoiceItemInvoice"] ? new Date(_data["nextPendingInvoiceItemInvoice"].toString()) : <any>undefined;
            this.onBehalfOfId = _data["onBehalfOfId"];
            this.onBehalfOf = _data["onBehalfOf"] ? Account.fromJS(_data["onBehalfOf"]) : <any>undefined;
            this.internalOnBehalfOf = _data["internalOnBehalfOf"] ? ExpandableFieldOfAccount.fromJS(_data["internalOnBehalfOf"]) : <any>undefined;
            this.pauseCollection = _data["pauseCollection"] ? SubscriptionPauseCollection.fromJS(_data["pauseCollection"]) : <any>undefined;
            this.paymentSettings = _data["paymentSettings"] ? SubscriptionPaymentSettings.fromJS(_data["paymentSettings"]) : <any>undefined;
            this.pendingInvoiceItemInterval = _data["pendingInvoiceItemInterval"] ? SubscriptionPendingInvoiceItemInterval.fromJS(_data["pendingInvoiceItemInterval"]) : <any>undefined;
            this.pendingSetupIntentId = _data["pendingSetupIntentId"];
            this.pendingSetupIntent = _data["pendingSetupIntent"] ? SetupIntent.fromJS(_data["pendingSetupIntent"]) : <any>undefined;
            this.internalPendingSetupIntent = _data["internalPendingSetupIntent"] ? ExpandableFieldOfSetupIntent.fromJS(_data["internalPendingSetupIntent"]) : <any>undefined;
            this.pendingUpdate = _data["pendingUpdate"] ? SubscriptionPendingUpdate.fromJS(_data["pendingUpdate"]) : <any>undefined;
            this.scheduleId = _data["scheduleId"];
            this.schedule = _data["schedule"] ? SubscriptionSchedule.fromJS(_data["schedule"]) : <any>undefined;
            this.internalSchedule = _data["internalSchedule"] ? ExpandableFieldOfSubscriptionSchedule.fromJS(_data["internalSchedule"]) : <any>undefined;
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.testClockId = _data["testClockId"];
            this.testClock = _data["testClock"] ? TestClock.fromJS(_data["testClock"]) : <any>undefined;
            this.internalTestClock = _data["internalTestClock"] ? ExpandableFieldOfTestClock.fromJS(_data["internalTestClock"]) : <any>undefined;
            this.transferData = _data["transferData"] ? SubscriptionTransferData.fromJS(_data["transferData"]) : <any>undefined;
            this.trialEnd = _data["trialEnd"] ? new Date(_data["trialEnd"].toString()) : <any>undefined;
            this.trialSettings = _data["trialSettings"] ? SubscriptionTrialSettings.fromJS(_data["trialSettings"]) : <any>undefined;
            this.trialStart = _data["trialStart"] ? new Date(_data["trialStart"].toString()) : <any>undefined;
        }
    }

    static override fromJS(data: any): Subscription {
        data = typeof data === 'object' ? data : {};
        let result = new Subscription();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["object"] = this.object;
        data["applicationId"] = this.applicationId;
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["internalApplication"] = this.internalApplication ? this.internalApplication.toJSON() : <any>undefined;
        data["applicationFeePercent"] = this.applicationFeePercent;
        data["automaticTax"] = this.automaticTax ? this.automaticTax.toJSON() : <any>undefined;
        data["billingCycleAnchor"] = this.billingCycleAnchor ? this.billingCycleAnchor.toISOString() : <any>undefined;
        data["billingThresholds"] = this.billingThresholds ? this.billingThresholds.toJSON() : <any>undefined;
        data["cancelAt"] = this.cancelAt ? this.cancelAt.toISOString() : <any>undefined;
        data["cancelAtPeriodEnd"] = this.cancelAtPeriodEnd;
        data["canceledAt"] = this.canceledAt ? this.canceledAt.toISOString() : <any>undefined;
        data["cancellationDetails"] = this.cancellationDetails ? this.cancellationDetails.toJSON() : <any>undefined;
        data["collectionMethod"] = this.collectionMethod;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["currency"] = this.currency;
        data["currentPeriodEnd"] = this.currentPeriodEnd ? this.currentPeriodEnd.toISOString() : <any>undefined;
        data["currentPeriodStart"] = this.currentPeriodStart ? this.currentPeriodStart.toISOString() : <any>undefined;
        data["customerId"] = this.customerId;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["internalCustomer"] = this.internalCustomer ? this.internalCustomer.toJSON() : <any>undefined;
        data["daysUntilDue"] = this.daysUntilDue;
        data["defaultPaymentMethodId"] = this.defaultPaymentMethodId;
        data["defaultPaymentMethod"] = this.defaultPaymentMethod ? this.defaultPaymentMethod.toJSON() : <any>undefined;
        data["internalDefaultPaymentMethod"] = this.internalDefaultPaymentMethod ? this.internalDefaultPaymentMethod.toJSON() : <any>undefined;
        data["defaultSourceId"] = this.defaultSourceId;
        data["defaultSource"] = this.defaultSource ? this.defaultSource.toJSON() : <any>undefined;
        data["internalDefaultSource"] = this.internalDefaultSource ? this.internalDefaultSource.toJSON() : <any>undefined;
        if (Array.isArray(this.defaultTaxRates)) {
            data["defaultTaxRates"] = [];
            for (let item of this.defaultTaxRates)
                data["defaultTaxRates"].push(item.toJSON());
        }
        data["description"] = this.description;
        data["discount"] = this.discount ? this.discount.toJSON() : <any>undefined;
        data["endedAt"] = this.endedAt ? this.endedAt.toISOString() : <any>undefined;
        data["items"] = this.items ? this.items.toJSON() : <any>undefined;
        data["latestInvoiceId"] = this.latestInvoiceId;
        data["latestInvoice"] = this.latestInvoice ? this.latestInvoice.toJSON() : <any>undefined;
        data["internalLatestInvoice"] = this.internalLatestInvoice ? this.internalLatestInvoice.toJSON() : <any>undefined;
        data["livemode"] = this.livemode;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        data["nextPendingInvoiceItemInvoice"] = this.nextPendingInvoiceItemInvoice ? this.nextPendingInvoiceItemInvoice.toISOString() : <any>undefined;
        data["onBehalfOfId"] = this.onBehalfOfId;
        data["onBehalfOf"] = this.onBehalfOf ? this.onBehalfOf.toJSON() : <any>undefined;
        data["internalOnBehalfOf"] = this.internalOnBehalfOf ? this.internalOnBehalfOf.toJSON() : <any>undefined;
        data["pauseCollection"] = this.pauseCollection ? this.pauseCollection.toJSON() : <any>undefined;
        data["paymentSettings"] = this.paymentSettings ? this.paymentSettings.toJSON() : <any>undefined;
        data["pendingInvoiceItemInterval"] = this.pendingInvoiceItemInterval ? this.pendingInvoiceItemInterval.toJSON() : <any>undefined;
        data["pendingSetupIntentId"] = this.pendingSetupIntentId;
        data["pendingSetupIntent"] = this.pendingSetupIntent ? this.pendingSetupIntent.toJSON() : <any>undefined;
        data["internalPendingSetupIntent"] = this.internalPendingSetupIntent ? this.internalPendingSetupIntent.toJSON() : <any>undefined;
        data["pendingUpdate"] = this.pendingUpdate ? this.pendingUpdate.toJSON() : <any>undefined;
        data["scheduleId"] = this.scheduleId;
        data["schedule"] = this.schedule ? this.schedule.toJSON() : <any>undefined;
        data["internalSchedule"] = this.internalSchedule ? this.internalSchedule.toJSON() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["testClockId"] = this.testClockId;
        data["testClock"] = this.testClock ? this.testClock.toJSON() : <any>undefined;
        data["internalTestClock"] = this.internalTestClock ? this.internalTestClock.toJSON() : <any>undefined;
        data["transferData"] = this.transferData ? this.transferData.toJSON() : <any>undefined;
        data["trialEnd"] = this.trialEnd ? this.trialEnd.toISOString() : <any>undefined;
        data["trialSettings"] = this.trialSettings ? this.trialSettings.toJSON() : <any>undefined;
        data["trialStart"] = this.trialStart ? this.trialStart.toISOString() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** Subscriptions allow you to charge a customer on a recurring basis.            Related guide: Creating subscriptions. */
export interface ISubscription extends IStripeEntityOfSubscription {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** (ID of the Application)
ID of the Connect Application that created the subscription. */
    applicationId?: string | undefined;
    /** (Expanded)
ID of the Connect Application that created the subscription.
            
For more information, see the expand documentation. */
    application?: Application | undefined;
    internalApplication?: ExpandableFieldOfApplication | undefined;
    /** A non-negative decimal between 0 and 100, with at most two decimal places. This
represents the percentage of the subscription invoice subtotal that will be transferred
to the application owner's Stripe account. */
    applicationFeePercent?: number | undefined;
    automaticTax?: SubscriptionAutomaticTax | undefined;
    /** Determines the date of the first full invoice, and, for plans with month or
year intervals, the day of the month for subsequent invoices. The timestamp is in
UTC format. */
    billingCycleAnchor?: Date;
    /** Define thresholds at which an invoice will be sent, and the subscription advanced to a
new billing period. */
    billingThresholds?: SubscriptionBillingThresholds | undefined;
    /** A date in the future at which the subscription will automatically get canceled. */
    cancelAt?: Date | undefined;
    /** If the subscription has been canceled with the at_period_end flag set to
true, cancel_at_period_end on the subscription will be true. You can use
this attribute to determine whether a subscription that has a status of active is
scheduled to be canceled at the end of the current period. */
    cancelAtPeriodEnd?: boolean;
    /** If the subscription has been canceled, the date of that cancellation. If the
subscription was canceled with cancel_at_period_end, canceled_at will
reflect the time of the most recent update request, not the end of the subscription
period when the subscription is automatically moved to a canceled state. */
    canceledAt?: Date | undefined;
    /** Details about why this subscription was cancelled. */
    cancellationDetails?: SubscriptionCancellationDetails | undefined;
    /** Either charge_automatically, or send_invoice. When charging automatically,
Stripe will attempt to pay this subscription at the end of the cycle using the default
source attached to the customer. When sending an invoice, Stripe will email your
customer an invoice with payment instructions and mark the subscription as
active.
One of: charge_automatically, or send_invoice. */
    collectionMethod?: string | undefined;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** Three-letter ISO currency
code, in lowercase. Must be a supported
currency. */
    currency?: string | undefined;
    /** End of the current period that the subscription has been invoiced for. At the end of
this period, a new invoice will be created. */
    currentPeriodEnd?: Date;
    /** Start of the current period that the subscription has been invoiced for. */
    currentPeriodStart?: Date;
    /** (ID of the Customer)
ID of the customer who owns the subscription. */
    customerId?: string | undefined;
    /** (Expanded)
ID of the customer who owns the subscription.
            
For more information, see the expand documentation. */
    customer?: Customer2 | undefined;
    internalCustomer?: ExpandableFieldOfCustomer | undefined;
    /** Number of days a customer has to pay invoices generated by this subscription. This value
will be null for subscriptions where
collection_method=charge_automatically. */
    daysUntilDue?: number | undefined;
    /** (ID of the PaymentMethod)
ID of the default payment method for the subscription. It must belong to the customer
associated with the subscription. This takes precedence over default_source. If
neither are set, invoices will use the customer's invoice_settings.default_payment_method
or default_source. */
    defaultPaymentMethodId?: string | undefined;
    /** (Expanded)
ID of the default payment method for the subscription. It must belong to the customer
associated with the subscription. This takes precedence over default_source. If
neither are set, invoices will use the customer's invoice_settings.default_payment_method
or default_source.
            
For more information, see the expand documentation. */
    defaultPaymentMethod?: PaymentMethod | undefined;
    internalDefaultPaymentMethod?: ExpandableFieldOfPaymentMethod | undefined;
    /** (ID of the IPaymentSource)
ID of the default payment source for the subscription. It must belong to the customer
associated with the subscription and be in a chargeable state. If
default_payment_method is also set, default_payment_method will take
precedence. If neither are set, invoices will use the customer's invoice_settings.default_payment_method
or default_source. */
    defaultSourceId?: string | undefined;
    /** (Expanded)
ID of the default payment source for the subscription. It must belong to the customer
associated with the subscription and be in a chargeable state. If
default_payment_method is also set, default_payment_method will take
precedence. If neither are set, invoices will use the customer's invoice_settings.default_payment_method
or default_source.
            
For more information, see the expand documentation. */
    defaultSource?: IPaymentSource | undefined;
    internalDefaultSource?: ExpandableFieldOfIPaymentSource | undefined;
    /** The tax rates that will apply to any subscription item that does not have
tax_rates set. Invoices created will have their default_tax_rates
populated from the subscription. */
    defaultTaxRates?: TaxRate[] | undefined;
    /** The subscription's description, meant to be displayable to the customer. Use this field
to optionally store an explanation of the subscription for rendering in Stripe surfaces. */
    description?: string | undefined;
    /** Describes the current discount applied to this subscription, if there is one. When
billing, a discount applied to a subscription overrides a discount applied on a
customer-wide basis. */
    discount?: Discount | undefined;
    /** If the subscription has ended, the date the subscription ended. */
    endedAt?: Date | undefined;
    /** List of subscription items, each with an attached price. */
    items?: StripeListOfSubscriptionItem | undefined;
    /** (ID of the Invoice)
The most recent invoice this subscription has generated. */
    latestInvoiceId?: string | undefined;
    /** (Expanded)
The most recent invoice this subscription has generated.
            
For more information, see the expand documentation. */
    latestInvoice?: Invoice | undefined;
    internalLatestInvoice?: ExpandableFieldOfInvoice | undefined;
    /** Has the value true if the object exists in live mode or the value false if
the object exists in test mode. */
    livemode?: boolean;
    /** Set of key-value pairs that you can
attach to an object. This can be useful for storing additional information about the
object in a structured format. */
    metadata?: { [key: string]: string; } | undefined;
    /** Specifies the approximate timestamp on which any pending invoice items will be billed
according to the schedule provided at pending_invoice_item_interval. */
    nextPendingInvoiceItemInvoice?: Date | undefined;
    /** (ID of the Account)
The account (if any) the charge was made on behalf of for charges associated with this
subscription. See the Connect documentation for details. */
    onBehalfOfId?: string | undefined;
    /** (Expanded)
The account (if any) the charge was made on behalf of for charges associated with this
subscription. See the Connect documentation for details.
            
For more information, see the expand documentation. */
    onBehalfOf?: Account | undefined;
    internalOnBehalfOf?: ExpandableFieldOfAccount | undefined;
    /** If specified, payment collection for this subscription will be paused. */
    pauseCollection?: SubscriptionPauseCollection | undefined;
    /** Payment settings passed on to invoices created by the subscription. */
    paymentSettings?: SubscriptionPaymentSettings | undefined;
    /** Specifies an interval for how often to bill for any pending invoice items. It is
analogous to calling Create an
invoice for the given subscription at the specified interval. */
    pendingInvoiceItemInterval?: SubscriptionPendingInvoiceItemInterval | undefined;
    /** (ID of the SetupIntent)
You can use this SetupIntent to
collect user authentication when creating a subscription without immediate payment or
updating a subscription's payment method, allowing you to optimize for off-session
payments. Learn more in the SCA
Migration Guide. */
    pendingSetupIntentId?: string | undefined;
    /** (Expanded)
You can use this SetupIntent to
collect user authentication when creating a subscription without immediate payment or
updating a subscription's payment method, allowing you to optimize for off-session
payments. Learn more in the SCA
Migration Guide.
            
For more information, see the expand documentation. */
    pendingSetupIntent?: SetupIntent | undefined;
    internalPendingSetupIntent?: ExpandableFieldOfSetupIntent | undefined;
    /** If specified, pending updates
that will be applied to the subscription once the latest_invoice has been paid. */
    pendingUpdate?: SubscriptionPendingUpdate | undefined;
    /** (ID of the SubscriptionSchedule)
The schedule attached to the subscription. */
    scheduleId?: string | undefined;
    /** (Expanded)
The schedule attached to the subscription.
            
For more information, see the expand documentation. */
    schedule?: SubscriptionSchedule | undefined;
    internalSchedule?: ExpandableFieldOfSubscriptionSchedule | undefined;
    /** Date when the subscription was first created. The date might differ from the
created date due to backdating. */
    startDate?: Date;
    /** Possible values are incomplete, incomplete_expired, trialing,
active, past_due, canceled, or unpaid.
            
For collection_method=charge_automatically a subscription moves into
incomplete if the initial payment attempt fails. A subscription in this state can
only have metadata and default_source updated. Once the first invoice is paid, the
subscription moves into an active state. If the first invoice is not paid within
23 hours, the subscription transitions to incomplete_expired. This is a terminal
state, the open invoice will be voided and no further invoices will be generated.
            
A subscription that is currently in a trial period is trialing and moves to
active when the trial period is over.
            
If subscription collection_method=charge_automatically it becomes past_due
when payment to renew it fails and canceled or unpaid (depending on your
subscriptions settings) when Stripe has exhausted all payment retry attempts.
            
If subscription collection_method=send_invoice it becomes past_due when
its invoice is not paid by the due date, and canceled or unpaid if it is
still not paid by an additional deadline after that. Note that when a subscription has a
status of unpaid, no subsequent invoices will be attempted (invoices will be
created, but then immediately automatically closed). After receiving updated payment
information from a customer, you may choose to reopen and pay their closed invoices.
One of: active, canceled, incomplete, incomplete_expired,
past_due, paused, trialing, or unpaid. */
    status?: string | undefined;
    /** (ID of the TestHelpers.TestClock)
ID of the test clock this subscription belongs to. */
    testClockId?: string | undefined;
    /** (Expanded)
ID of the test clock this subscription belongs to.
            
For more information, see the expand documentation. */
    testClock?: TestClock | undefined;
    internalTestClock?: ExpandableFieldOfTestClock | undefined;
    /** The account (if any) the subscription's payments will be attributed to for tax
reporting, and where funds from each payment will be transferred to for each of the
subscription's invoices. */
    transferData?: SubscriptionTransferData | undefined;
    /** If the subscription has a trial, the end of that trial. */
    trialEnd?: Date | undefined;
    /** Settings related to subscription trials. */
    trialSettings?: SubscriptionTrialSettings | undefined;
    /** If the subscription has a trial, the beginning of that trial. */
    trialStart?: Date | undefined;
}

export abstract class StripeEntityOfApplication extends StripeEntity implements IStripeEntityOfApplication {

    constructor(data?: IStripeEntityOfApplication) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfApplication {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfApplication' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfApplication extends IStripeEntity {
}

export class Application extends StripeEntityOfApplication implements IApplication {
    id?: string | undefined;
    object?: string | undefined;
    name?: string | undefined;

    constructor(data?: IApplication) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.object = _data["object"];
            this.name = _data["name"];
        }
    }

    static override fromJS(data: any): Application {
        data = typeof data === 'object' ? data : {};
        let result = new Application();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["object"] = this.object;
        data["name"] = this.name;
        super.toJSON(data);
        return data;
    }
}

export interface IApplication extends IStripeEntityOfApplication {
    id?: string | undefined;
    object?: string | undefined;
    name?: string | undefined;
}

/** Represents a generic expandable field. */
export class ExpandableFieldOfApplication implements IExpandableFieldOfApplication {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: Application | undefined;

    constructor(data?: IExpandableFieldOfApplication) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.expandedObject = _data["expandedObject"] ? Application.fromJS(_data["expandedObject"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExpandableFieldOfApplication {
        data = typeof data === 'object' ? data : {};
        let result = new ExpandableFieldOfApplication();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["expandedObject"] = this.expandedObject ? this.expandedObject.toJSON() : <any>undefined;
        return data;
    }
}

/** Represents a generic expandable field. */
export interface IExpandableFieldOfApplication {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: Application | undefined;
}

export abstract class StripeEntityOfSubscriptionAutomaticTax extends StripeEntity implements IStripeEntityOfSubscriptionAutomaticTax {

    constructor(data?: IStripeEntityOfSubscriptionAutomaticTax) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSubscriptionAutomaticTax {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSubscriptionAutomaticTax' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSubscriptionAutomaticTax extends IStripeEntity {
}

export class SubscriptionAutomaticTax extends StripeEntityOfSubscriptionAutomaticTax implements ISubscriptionAutomaticTax {
    /** Whether Stripe automatically computes tax on this subscription. */
    enabled?: boolean;

    constructor(data?: ISubscriptionAutomaticTax) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.enabled = _data["enabled"];
        }
    }

    static override fromJS(data: any): SubscriptionAutomaticTax {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionAutomaticTax();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enabled"] = this.enabled;
        super.toJSON(data);
        return data;
    }
}

export interface ISubscriptionAutomaticTax extends IStripeEntityOfSubscriptionAutomaticTax {
    /** Whether Stripe automatically computes tax on this subscription. */
    enabled?: boolean;
}

export abstract class StripeEntityOfSubscriptionBillingThresholds extends StripeEntity implements IStripeEntityOfSubscriptionBillingThresholds {

    constructor(data?: IStripeEntityOfSubscriptionBillingThresholds) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSubscriptionBillingThresholds {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSubscriptionBillingThresholds' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSubscriptionBillingThresholds extends IStripeEntity {
}

export class SubscriptionBillingThresholds extends StripeEntityOfSubscriptionBillingThresholds implements ISubscriptionBillingThresholds {
    /** Monetary threshold that triggers the subscription to create an invoice. */
    amountGte?: number | undefined;
    /** Indicates if the billing_cycle_anchor should be reset when a threshold is
reached. If true, billing_cycle_anchor will be updated to the date/time the
threshold was last reached; otherwise, the value will remain unchanged. This value may
not be true if the subscription contains items with plans that have
aggregate_usage=last_ever. */
    resetBillingCycleAnchor?: boolean | undefined;

    constructor(data?: ISubscriptionBillingThresholds) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.amountGte = _data["amountGte"];
            this.resetBillingCycleAnchor = _data["resetBillingCycleAnchor"];
        }
    }

    static override fromJS(data: any): SubscriptionBillingThresholds {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionBillingThresholds();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amountGte"] = this.amountGte;
        data["resetBillingCycleAnchor"] = this.resetBillingCycleAnchor;
        super.toJSON(data);
        return data;
    }
}

export interface ISubscriptionBillingThresholds extends IStripeEntityOfSubscriptionBillingThresholds {
    /** Monetary threshold that triggers the subscription to create an invoice. */
    amountGte?: number | undefined;
    /** Indicates if the billing_cycle_anchor should be reset when a threshold is
reached. If true, billing_cycle_anchor will be updated to the date/time the
threshold was last reached; otherwise, the value will remain unchanged. This value may
not be true if the subscription contains items with plans that have
aggregate_usage=last_ever. */
    resetBillingCycleAnchor?: boolean | undefined;
}

export abstract class StripeEntityOfSubscriptionCancellationDetails extends StripeEntity implements IStripeEntityOfSubscriptionCancellationDetails {

    constructor(data?: IStripeEntityOfSubscriptionCancellationDetails) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSubscriptionCancellationDetails {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSubscriptionCancellationDetails' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSubscriptionCancellationDetails extends IStripeEntity {
}

export class SubscriptionCancellationDetails extends StripeEntityOfSubscriptionCancellationDetails implements ISubscriptionCancellationDetails {
    /** Additional comments about why the user canceled the subscription, if the subscription
was cancelled explicitly by the user. */
    comment?: string | undefined;
    /** The customer submitted reason for why they cancelled, if the subscription was cancelled
explicitly by the user.
One of: customer_service, low_quality, missing_features,
other, switched_service, too_complex, too_expensive, or
unused. */
    feedback?: string | undefined;
    /** Why this subscription was cancelled.
One of: cancellation_requested, payment_disputed, or
payment_failed. */
    reason?: string | undefined;

    constructor(data?: ISubscriptionCancellationDetails) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.comment = _data["comment"];
            this.feedback = _data["feedback"];
            this.reason = _data["reason"];
        }
    }

    static override fromJS(data: any): SubscriptionCancellationDetails {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionCancellationDetails();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["comment"] = this.comment;
        data["feedback"] = this.feedback;
        data["reason"] = this.reason;
        super.toJSON(data);
        return data;
    }
}

export interface ISubscriptionCancellationDetails extends IStripeEntityOfSubscriptionCancellationDetails {
    /** Additional comments about why the user canceled the subscription, if the subscription
was cancelled explicitly by the user. */
    comment?: string | undefined;
    /** The customer submitted reason for why they cancelled, if the subscription was cancelled
explicitly by the user.
One of: customer_service, low_quality, missing_features,
other, switched_service, too_complex, too_expensive, or
unused. */
    feedback?: string | undefined;
    /** Why this subscription was cancelled.
One of: cancellation_requested, payment_disputed, or
payment_failed. */
    reason?: string | undefined;
}

export abstract class StripeEntityOfPaymentMethod extends StripeEntity implements IStripeEntityOfPaymentMethod {

    constructor(data?: IStripeEntityOfPaymentMethod) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentMethod {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentMethod' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentMethod extends IStripeEntity {
}

/** PaymentMethod objects represent your customer's payment instruments. You can use them with PaymentIntents to collect payments or save them to Customer objects to store instrument details for future payments.            Related guides: Payment Methods and More Payment Scenarios. */
export class PaymentMethod extends StripeEntityOfPaymentMethod implements IPaymentMethod {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    acssDebit?: PaymentMethodAcssDebit | undefined;
    affirm?: PaymentMethodAffirm | undefined;
    afterpayClearpay?: PaymentMethodAfterpayClearpay | undefined;
    alipay?: PaymentMethodAlipay | undefined;
    auBecsDebit?: PaymentMethodAuBecsDebit | undefined;
    bacsDebit?: PaymentMethodBacsDebit | undefined;
    bancontact?: PaymentMethodBancontact | undefined;
    billingDetails?: PaymentMethodBillingDetails | undefined;
    blik?: PaymentMethodBlik | undefined;
    boleto?: PaymentMethodBoleto | undefined;
    card?: PaymentMethodCard | undefined;
    cardPresent?: PaymentMethodCardPresent | undefined;
    cashapp?: PaymentMethodCashapp | undefined;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** (ID of the Customer)
The ID of the Customer to which this PaymentMethod is saved. This will not be set when
the PaymentMethod has not been saved to a Customer. */
    customerId?: string | undefined;
    /** (Expanded)
The ID of the Customer to which this PaymentMethod is saved. This will not be set when
the PaymentMethod has not been saved to a Customer.
            
For more information, see the expand documentation. */
    customer?: Customer2 | undefined;
    internalCustomer?: ExpandableFieldOfCustomer | undefined;
    customerBalance?: PaymentMethodCustomerBalance | undefined;
    eps?: PaymentMethodEps | undefined;
    fpx?: PaymentMethodFpx | undefined;
    giropay?: PaymentMethodGiropay | undefined;
    grabpay?: PaymentMethodGrabpay | undefined;
    ideal?: PaymentMethodIdeal | undefined;
    interacPresent?: PaymentMethodInteracPresent | undefined;
    klarna?: PaymentMethodKlarna | undefined;
    konbini?: PaymentMethodKonbini | undefined;
    link?: PaymentMethodLink | undefined;
    /** Has the value true if the object exists in live mode or the value false if
the object exists in test mode. */
    livemode?: boolean;
    /** Set of key-value pairs that you can
attach to an object. This can be useful for storing additional information about the
object in a structured format. */
    metadata?: { [key: string]: string; } | undefined;
    oxxo?: PaymentMethodOxxo | undefined;
    p24?: PaymentMethodP24 | undefined;
    paynow?: PaymentMethodPaynow | undefined;
    paypal?: PaymentMethodPaypal | undefined;
    pix?: PaymentMethodPix | undefined;
    promptpay?: PaymentMethodPromptpay | undefined;
    /** Options to configure Radar. See Radar Session for more
information. */
    radarOptions?: PaymentMethodRadarOptions | undefined;
    sepaDebit?: PaymentMethodSepaDebit | undefined;
    sofort?: PaymentMethodSofort | undefined;
    /** The type of the PaymentMethod. An additional hash is included on the PaymentMethod with
a name matching this value. It contains additional information specific to the
PaymentMethod type.
One of: acss_debit, affirm, afterpay_clearpay, alipay,
au_becs_debit, bacs_debit, bancontact, blik, boleto,
card, card_present, cashapp, customer_balance, eps,
fpx, giropay, grabpay, ideal, interac_present,
klarna, konbini, link, oxxo, p24, paynow,
paypal, pix, promptpay, sepa_debit, sofort,
us_bank_account, wechat_pay, or zip. */
    type?: string | undefined;
    usBankAccount?: PaymentMethodUsBankAccount | undefined;
    wechatPay?: PaymentMethodWechatPay | undefined;
    zip?: PaymentMethodZip | undefined;

    constructor(data?: IPaymentMethod) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.object = _data["object"];
            this.acssDebit = _data["acssDebit"] ? PaymentMethodAcssDebit.fromJS(_data["acssDebit"]) : <any>undefined;
            this.affirm = _data["affirm"] ? PaymentMethodAffirm.fromJS(_data["affirm"]) : <any>undefined;
            this.afterpayClearpay = _data["afterpayClearpay"] ? PaymentMethodAfterpayClearpay.fromJS(_data["afterpayClearpay"]) : <any>undefined;
            this.alipay = _data["alipay"] ? PaymentMethodAlipay.fromJS(_data["alipay"]) : <any>undefined;
            this.auBecsDebit = _data["auBecsDebit"] ? PaymentMethodAuBecsDebit.fromJS(_data["auBecsDebit"]) : <any>undefined;
            this.bacsDebit = _data["bacsDebit"] ? PaymentMethodBacsDebit.fromJS(_data["bacsDebit"]) : <any>undefined;
            this.bancontact = _data["bancontact"] ? PaymentMethodBancontact.fromJS(_data["bancontact"]) : <any>undefined;
            this.billingDetails = _data["billingDetails"] ? PaymentMethodBillingDetails.fromJS(_data["billingDetails"]) : <any>undefined;
            this.blik = _data["blik"] ? PaymentMethodBlik.fromJS(_data["blik"]) : <any>undefined;
            this.boleto = _data["boleto"] ? PaymentMethodBoleto.fromJS(_data["boleto"]) : <any>undefined;
            this.card = _data["card"] ? PaymentMethodCard.fromJS(_data["card"]) : <any>undefined;
            this.cardPresent = _data["cardPresent"] ? PaymentMethodCardPresent.fromJS(_data["cardPresent"]) : <any>undefined;
            this.cashapp = _data["cashapp"] ? PaymentMethodCashapp.fromJS(_data["cashapp"]) : <any>undefined;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.customerId = _data["customerId"];
            this.customer = _data["customer"] ? Customer2.fromJS(_data["customer"]) : <any>undefined;
            this.internalCustomer = _data["internalCustomer"] ? ExpandableFieldOfCustomer.fromJS(_data["internalCustomer"]) : <any>undefined;
            this.customerBalance = _data["customerBalance"] ? PaymentMethodCustomerBalance.fromJS(_data["customerBalance"]) : <any>undefined;
            this.eps = _data["eps"] ? PaymentMethodEps.fromJS(_data["eps"]) : <any>undefined;
            this.fpx = _data["fpx"] ? PaymentMethodFpx.fromJS(_data["fpx"]) : <any>undefined;
            this.giropay = _data["giropay"] ? PaymentMethodGiropay.fromJS(_data["giropay"]) : <any>undefined;
            this.grabpay = _data["grabpay"] ? PaymentMethodGrabpay.fromJS(_data["grabpay"]) : <any>undefined;
            this.ideal = _data["ideal"] ? PaymentMethodIdeal.fromJS(_data["ideal"]) : <any>undefined;
            this.interacPresent = _data["interacPresent"] ? PaymentMethodInteracPresent.fromJS(_data["interacPresent"]) : <any>undefined;
            this.klarna = _data["klarna"] ? PaymentMethodKlarna.fromJS(_data["klarna"]) : <any>undefined;
            this.konbini = _data["konbini"] ? PaymentMethodKonbini.fromJS(_data["konbini"]) : <any>undefined;
            this.link = _data["link"] ? PaymentMethodLink.fromJS(_data["link"]) : <any>undefined;
            this.livemode = _data["livemode"];
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
            this.oxxo = _data["oxxo"] ? PaymentMethodOxxo.fromJS(_data["oxxo"]) : <any>undefined;
            this.p24 = _data["p24"] ? PaymentMethodP24.fromJS(_data["p24"]) : <any>undefined;
            this.paynow = _data["paynow"] ? PaymentMethodPaynow.fromJS(_data["paynow"]) : <any>undefined;
            this.paypal = _data["paypal"] ? PaymentMethodPaypal.fromJS(_data["paypal"]) : <any>undefined;
            this.pix = _data["pix"] ? PaymentMethodPix.fromJS(_data["pix"]) : <any>undefined;
            this.promptpay = _data["promptpay"] ? PaymentMethodPromptpay.fromJS(_data["promptpay"]) : <any>undefined;
            this.radarOptions = _data["radarOptions"] ? PaymentMethodRadarOptions.fromJS(_data["radarOptions"]) : <any>undefined;
            this.sepaDebit = _data["sepaDebit"] ? PaymentMethodSepaDebit.fromJS(_data["sepaDebit"]) : <any>undefined;
            this.sofort = _data["sofort"] ? PaymentMethodSofort.fromJS(_data["sofort"]) : <any>undefined;
            this.type = _data["type"];
            this.usBankAccount = _data["usBankAccount"] ? PaymentMethodUsBankAccount.fromJS(_data["usBankAccount"]) : <any>undefined;
            this.wechatPay = _data["wechatPay"] ? PaymentMethodWechatPay.fromJS(_data["wechatPay"]) : <any>undefined;
            this.zip = _data["zip"] ? PaymentMethodZip.fromJS(_data["zip"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): PaymentMethod {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethod();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["object"] = this.object;
        data["acssDebit"] = this.acssDebit ? this.acssDebit.toJSON() : <any>undefined;
        data["affirm"] = this.affirm ? this.affirm.toJSON() : <any>undefined;
        data["afterpayClearpay"] = this.afterpayClearpay ? this.afterpayClearpay.toJSON() : <any>undefined;
        data["alipay"] = this.alipay ? this.alipay.toJSON() : <any>undefined;
        data["auBecsDebit"] = this.auBecsDebit ? this.auBecsDebit.toJSON() : <any>undefined;
        data["bacsDebit"] = this.bacsDebit ? this.bacsDebit.toJSON() : <any>undefined;
        data["bancontact"] = this.bancontact ? this.bancontact.toJSON() : <any>undefined;
        data["billingDetails"] = this.billingDetails ? this.billingDetails.toJSON() : <any>undefined;
        data["blik"] = this.blik ? this.blik.toJSON() : <any>undefined;
        data["boleto"] = this.boleto ? this.boleto.toJSON() : <any>undefined;
        data["card"] = this.card ? this.card.toJSON() : <any>undefined;
        data["cardPresent"] = this.cardPresent ? this.cardPresent.toJSON() : <any>undefined;
        data["cashapp"] = this.cashapp ? this.cashapp.toJSON() : <any>undefined;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["customerId"] = this.customerId;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["internalCustomer"] = this.internalCustomer ? this.internalCustomer.toJSON() : <any>undefined;
        data["customerBalance"] = this.customerBalance ? this.customerBalance.toJSON() : <any>undefined;
        data["eps"] = this.eps ? this.eps.toJSON() : <any>undefined;
        data["fpx"] = this.fpx ? this.fpx.toJSON() : <any>undefined;
        data["giropay"] = this.giropay ? this.giropay.toJSON() : <any>undefined;
        data["grabpay"] = this.grabpay ? this.grabpay.toJSON() : <any>undefined;
        data["ideal"] = this.ideal ? this.ideal.toJSON() : <any>undefined;
        data["interacPresent"] = this.interacPresent ? this.interacPresent.toJSON() : <any>undefined;
        data["klarna"] = this.klarna ? this.klarna.toJSON() : <any>undefined;
        data["konbini"] = this.konbini ? this.konbini.toJSON() : <any>undefined;
        data["link"] = this.link ? this.link.toJSON() : <any>undefined;
        data["livemode"] = this.livemode;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        data["oxxo"] = this.oxxo ? this.oxxo.toJSON() : <any>undefined;
        data["p24"] = this.p24 ? this.p24.toJSON() : <any>undefined;
        data["paynow"] = this.paynow ? this.paynow.toJSON() : <any>undefined;
        data["paypal"] = this.paypal ? this.paypal.toJSON() : <any>undefined;
        data["pix"] = this.pix ? this.pix.toJSON() : <any>undefined;
        data["promptpay"] = this.promptpay ? this.promptpay.toJSON() : <any>undefined;
        data["radarOptions"] = this.radarOptions ? this.radarOptions.toJSON() : <any>undefined;
        data["sepaDebit"] = this.sepaDebit ? this.sepaDebit.toJSON() : <any>undefined;
        data["sofort"] = this.sofort ? this.sofort.toJSON() : <any>undefined;
        data["type"] = this.type;
        data["usBankAccount"] = this.usBankAccount ? this.usBankAccount.toJSON() : <any>undefined;
        data["wechatPay"] = this.wechatPay ? this.wechatPay.toJSON() : <any>undefined;
        data["zip"] = this.zip ? this.zip.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** PaymentMethod objects represent your customer's payment instruments. You can use them with PaymentIntents to collect payments or save them to Customer objects to store instrument details for future payments.            Related guides: Payment Methods and More Payment Scenarios. */
export interface IPaymentMethod extends IStripeEntityOfPaymentMethod {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    acssDebit?: PaymentMethodAcssDebit | undefined;
    affirm?: PaymentMethodAffirm | undefined;
    afterpayClearpay?: PaymentMethodAfterpayClearpay | undefined;
    alipay?: PaymentMethodAlipay | undefined;
    auBecsDebit?: PaymentMethodAuBecsDebit | undefined;
    bacsDebit?: PaymentMethodBacsDebit | undefined;
    bancontact?: PaymentMethodBancontact | undefined;
    billingDetails?: PaymentMethodBillingDetails | undefined;
    blik?: PaymentMethodBlik | undefined;
    boleto?: PaymentMethodBoleto | undefined;
    card?: PaymentMethodCard | undefined;
    cardPresent?: PaymentMethodCardPresent | undefined;
    cashapp?: PaymentMethodCashapp | undefined;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** (ID of the Customer)
The ID of the Customer to which this PaymentMethod is saved. This will not be set when
the PaymentMethod has not been saved to a Customer. */
    customerId?: string | undefined;
    /** (Expanded)
The ID of the Customer to which this PaymentMethod is saved. This will not be set when
the PaymentMethod has not been saved to a Customer.
            
For more information, see the expand documentation. */
    customer?: Customer2 | undefined;
    internalCustomer?: ExpandableFieldOfCustomer | undefined;
    customerBalance?: PaymentMethodCustomerBalance | undefined;
    eps?: PaymentMethodEps | undefined;
    fpx?: PaymentMethodFpx | undefined;
    giropay?: PaymentMethodGiropay | undefined;
    grabpay?: PaymentMethodGrabpay | undefined;
    ideal?: PaymentMethodIdeal | undefined;
    interacPresent?: PaymentMethodInteracPresent | undefined;
    klarna?: PaymentMethodKlarna | undefined;
    konbini?: PaymentMethodKonbini | undefined;
    link?: PaymentMethodLink | undefined;
    /** Has the value true if the object exists in live mode or the value false if
the object exists in test mode. */
    livemode?: boolean;
    /** Set of key-value pairs that you can
attach to an object. This can be useful for storing additional information about the
object in a structured format. */
    metadata?: { [key: string]: string; } | undefined;
    oxxo?: PaymentMethodOxxo | undefined;
    p24?: PaymentMethodP24 | undefined;
    paynow?: PaymentMethodPaynow | undefined;
    paypal?: PaymentMethodPaypal | undefined;
    pix?: PaymentMethodPix | undefined;
    promptpay?: PaymentMethodPromptpay | undefined;
    /** Options to configure Radar. See Radar Session for more
information. */
    radarOptions?: PaymentMethodRadarOptions | undefined;
    sepaDebit?: PaymentMethodSepaDebit | undefined;
    sofort?: PaymentMethodSofort | undefined;
    /** The type of the PaymentMethod. An additional hash is included on the PaymentMethod with
a name matching this value. It contains additional information specific to the
PaymentMethod type.
One of: acss_debit, affirm, afterpay_clearpay, alipay,
au_becs_debit, bacs_debit, bancontact, blik, boleto,
card, card_present, cashapp, customer_balance, eps,
fpx, giropay, grabpay, ideal, interac_present,
klarna, konbini, link, oxxo, p24, paynow,
paypal, pix, promptpay, sepa_debit, sofort,
us_bank_account, wechat_pay, or zip. */
    type?: string | undefined;
    usBankAccount?: PaymentMethodUsBankAccount | undefined;
    wechatPay?: PaymentMethodWechatPay | undefined;
    zip?: PaymentMethodZip | undefined;
}

export abstract class StripeEntityOfPaymentMethodAcssDebit extends StripeEntity implements IStripeEntityOfPaymentMethodAcssDebit {

    constructor(data?: IStripeEntityOfPaymentMethodAcssDebit) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentMethodAcssDebit {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentMethodAcssDebit' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentMethodAcssDebit extends IStripeEntity {
}

export class PaymentMethodAcssDebit extends StripeEntityOfPaymentMethodAcssDebit implements IPaymentMethodAcssDebit {
    /** Name of the bank associated with the bank account. */
    bankName?: string | undefined;
    /** Uniquely identifies this particular bank account. You can use this attribute to check
whether two bank accounts are the same. */
    fingerprint?: string | undefined;
    /** Institution number of the bank account. */
    institutionNumber?: string | undefined;
    /** Last four digits of the bank account number. */
    last4?: string | undefined;
    /** Transit number of the bank account. */
    transitNumber?: string | undefined;

    constructor(data?: IPaymentMethodAcssDebit) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.bankName = _data["bankName"];
            this.fingerprint = _data["fingerprint"];
            this.institutionNumber = _data["institutionNumber"];
            this.last4 = _data["last4"];
            this.transitNumber = _data["transitNumber"];
        }
    }

    static override fromJS(data: any): PaymentMethodAcssDebit {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodAcssDebit();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankName"] = this.bankName;
        data["fingerprint"] = this.fingerprint;
        data["institutionNumber"] = this.institutionNumber;
        data["last4"] = this.last4;
        data["transitNumber"] = this.transitNumber;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentMethodAcssDebit extends IStripeEntityOfPaymentMethodAcssDebit {
    /** Name of the bank associated with the bank account. */
    bankName?: string | undefined;
    /** Uniquely identifies this particular bank account. You can use this attribute to check
whether two bank accounts are the same. */
    fingerprint?: string | undefined;
    /** Institution number of the bank account. */
    institutionNumber?: string | undefined;
    /** Last four digits of the bank account number. */
    last4?: string | undefined;
    /** Transit number of the bank account. */
    transitNumber?: string | undefined;
}

export abstract class StripeEntityOfPaymentMethodAffirm extends StripeEntity implements IStripeEntityOfPaymentMethodAffirm {

    constructor(data?: IStripeEntityOfPaymentMethodAffirm) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentMethodAffirm {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentMethodAffirm' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentMethodAffirm extends IStripeEntity {
}

export class PaymentMethodAffirm extends StripeEntityOfPaymentMethodAffirm implements IPaymentMethodAffirm {

    constructor(data?: IPaymentMethodAffirm) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): PaymentMethodAffirm {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodAffirm();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentMethodAffirm extends IStripeEntityOfPaymentMethodAffirm {
}

export abstract class StripeEntityOfPaymentMethodAfterpayClearpay extends StripeEntity implements IStripeEntityOfPaymentMethodAfterpayClearpay {

    constructor(data?: IStripeEntityOfPaymentMethodAfterpayClearpay) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentMethodAfterpayClearpay {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentMethodAfterpayClearpay' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentMethodAfterpayClearpay extends IStripeEntity {
}

export class PaymentMethodAfterpayClearpay extends StripeEntityOfPaymentMethodAfterpayClearpay implements IPaymentMethodAfterpayClearpay {

    constructor(data?: IPaymentMethodAfterpayClearpay) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): PaymentMethodAfterpayClearpay {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodAfterpayClearpay();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentMethodAfterpayClearpay extends IStripeEntityOfPaymentMethodAfterpayClearpay {
}

export abstract class StripeEntityOfPaymentMethodAlipay extends StripeEntity implements IStripeEntityOfPaymentMethodAlipay {

    constructor(data?: IStripeEntityOfPaymentMethodAlipay) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentMethodAlipay {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentMethodAlipay' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentMethodAlipay extends IStripeEntity {
}

export class PaymentMethodAlipay extends StripeEntityOfPaymentMethodAlipay implements IPaymentMethodAlipay {

    constructor(data?: IPaymentMethodAlipay) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): PaymentMethodAlipay {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodAlipay();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentMethodAlipay extends IStripeEntityOfPaymentMethodAlipay {
}

export abstract class StripeEntityOfPaymentMethodAuBecsDebit extends StripeEntity implements IStripeEntityOfPaymentMethodAuBecsDebit {

    constructor(data?: IStripeEntityOfPaymentMethodAuBecsDebit) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentMethodAuBecsDebit {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentMethodAuBecsDebit' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentMethodAuBecsDebit extends IStripeEntity {
}

export class PaymentMethodAuBecsDebit extends StripeEntityOfPaymentMethodAuBecsDebit implements IPaymentMethodAuBecsDebit {
    /** Six-digit number identifying bank and branch associated with this bank account. */
    bsbNumber?: string | undefined;
    /** Uniquely identifies this particular bank account. You can use this attribute to check
whether two bank accounts are the same. */
    fingerprint?: string | undefined;
    /** Last four digits of the bank account number. */
    last4?: string | undefined;

    constructor(data?: IPaymentMethodAuBecsDebit) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.bsbNumber = _data["bsbNumber"];
            this.fingerprint = _data["fingerprint"];
            this.last4 = _data["last4"];
        }
    }

    static override fromJS(data: any): PaymentMethodAuBecsDebit {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodAuBecsDebit();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bsbNumber"] = this.bsbNumber;
        data["fingerprint"] = this.fingerprint;
        data["last4"] = this.last4;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentMethodAuBecsDebit extends IStripeEntityOfPaymentMethodAuBecsDebit {
    /** Six-digit number identifying bank and branch associated with this bank account. */
    bsbNumber?: string | undefined;
    /** Uniquely identifies this particular bank account. You can use this attribute to check
whether two bank accounts are the same. */
    fingerprint?: string | undefined;
    /** Last four digits of the bank account number. */
    last4?: string | undefined;
}

export abstract class StripeEntityOfPaymentMethodBacsDebit extends StripeEntity implements IStripeEntityOfPaymentMethodBacsDebit {

    constructor(data?: IStripeEntityOfPaymentMethodBacsDebit) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentMethodBacsDebit {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentMethodBacsDebit' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentMethodBacsDebit extends IStripeEntity {
}

export class PaymentMethodBacsDebit extends StripeEntityOfPaymentMethodBacsDebit implements IPaymentMethodBacsDebit {
    /** Uniquely identifies this particular bank account. You can use this attribute to check
whether two bank accounts are the same. */
    fingerprint?: string | undefined;
    /** Last four digits of the bank account number. */
    last4?: string | undefined;
    /** Sort code of the bank account. (e.g., 10-20-30). */
    sortCode?: string | undefined;

    constructor(data?: IPaymentMethodBacsDebit) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.fingerprint = _data["fingerprint"];
            this.last4 = _data["last4"];
            this.sortCode = _data["sortCode"];
        }
    }

    static override fromJS(data: any): PaymentMethodBacsDebit {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodBacsDebit();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fingerprint"] = this.fingerprint;
        data["last4"] = this.last4;
        data["sortCode"] = this.sortCode;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentMethodBacsDebit extends IStripeEntityOfPaymentMethodBacsDebit {
    /** Uniquely identifies this particular bank account. You can use this attribute to check
whether two bank accounts are the same. */
    fingerprint?: string | undefined;
    /** Last four digits of the bank account number. */
    last4?: string | undefined;
    /** Sort code of the bank account. (e.g., 10-20-30). */
    sortCode?: string | undefined;
}

export abstract class StripeEntityOfPaymentMethodBancontact extends StripeEntity implements IStripeEntityOfPaymentMethodBancontact {

    constructor(data?: IStripeEntityOfPaymentMethodBancontact) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentMethodBancontact {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentMethodBancontact' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentMethodBancontact extends IStripeEntity {
}

export class PaymentMethodBancontact extends StripeEntityOfPaymentMethodBancontact implements IPaymentMethodBancontact {

    constructor(data?: IPaymentMethodBancontact) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): PaymentMethodBancontact {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodBancontact();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentMethodBancontact extends IStripeEntityOfPaymentMethodBancontact {
}

export abstract class StripeEntityOfPaymentMethodBillingDetails extends StripeEntity implements IStripeEntityOfPaymentMethodBillingDetails {

    constructor(data?: IStripeEntityOfPaymentMethodBillingDetails) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentMethodBillingDetails {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentMethodBillingDetails' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentMethodBillingDetails extends IStripeEntity {
}

export class PaymentMethodBillingDetails extends StripeEntityOfPaymentMethodBillingDetails implements IPaymentMethodBillingDetails {
    /** Billing address. */
    address?: Address | undefined;
    /** Email address. */
    email?: string | undefined;
    /** Full name. */
    name?: string | undefined;
    /** Billing phone number (including extension). */
    phone?: string | undefined;

    constructor(data?: IPaymentMethodBillingDetails) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.address = _data["address"] ? Address.fromJS(_data["address"]) : <any>undefined;
            this.email = _data["email"];
            this.name = _data["name"];
            this.phone = _data["phone"];
        }
    }

    static override fromJS(data: any): PaymentMethodBillingDetails {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodBillingDetails();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["email"] = this.email;
        data["name"] = this.name;
        data["phone"] = this.phone;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentMethodBillingDetails extends IStripeEntityOfPaymentMethodBillingDetails {
    /** Billing address. */
    address?: Address | undefined;
    /** Email address. */
    email?: string | undefined;
    /** Full name. */
    name?: string | undefined;
    /** Billing phone number (including extension). */
    phone?: string | undefined;
}

export abstract class StripeEntityOfPaymentMethodBlik extends StripeEntity implements IStripeEntityOfPaymentMethodBlik {

    constructor(data?: IStripeEntityOfPaymentMethodBlik) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentMethodBlik {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentMethodBlik' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentMethodBlik extends IStripeEntity {
}

export class PaymentMethodBlik extends StripeEntityOfPaymentMethodBlik implements IPaymentMethodBlik {

    constructor(data?: IPaymentMethodBlik) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): PaymentMethodBlik {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodBlik();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentMethodBlik extends IStripeEntityOfPaymentMethodBlik {
}

export abstract class StripeEntityOfPaymentMethodBoleto extends StripeEntity implements IStripeEntityOfPaymentMethodBoleto {

    constructor(data?: IStripeEntityOfPaymentMethodBoleto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentMethodBoleto {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentMethodBoleto' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentMethodBoleto extends IStripeEntity {
}

export class PaymentMethodBoleto extends StripeEntityOfPaymentMethodBoleto implements IPaymentMethodBoleto {
    /** Uniquely identifies the customer tax id (CNPJ or CPF). */
    taxId?: string | undefined;

    constructor(data?: IPaymentMethodBoleto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.taxId = _data["taxId"];
        }
    }

    static override fromJS(data: any): PaymentMethodBoleto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodBoleto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taxId"] = this.taxId;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentMethodBoleto extends IStripeEntityOfPaymentMethodBoleto {
    /** Uniquely identifies the customer tax id (CNPJ or CPF). */
    taxId?: string | undefined;
}

export abstract class StripeEntityOfPaymentMethodCard extends StripeEntity implements IStripeEntityOfPaymentMethodCard {

    constructor(data?: IStripeEntityOfPaymentMethodCard) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentMethodCard {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentMethodCard' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentMethodCard extends IStripeEntity {
}

export class PaymentMethodCard extends StripeEntityOfPaymentMethodCard implements IPaymentMethodCard {
    /** Card brand. Can be amex, diners, discover, eftpos_au,
jcb, mastercard, unionpay, visa, or unknown. */
    brand?: string | undefined;
    /** Checks on Card address and CVC if provided. */
    checks?: PaymentMethodCardChecks | undefined;
    /** Two-letter ISO code representing the country of the card. You could use this attribute
to get a sense of the international breakdown of cards you've collected. */
    country?: string | undefined;
    /** A high-level description of the type of cards issued in this range. (For internal use
only and not typically available in standard API requests.). */
    description?: string | undefined;
    /** Two-digit number representing the card's expiration month. */
    expMonth?: number;
    /** Four-digit number representing the card's expiration year. */
    expYear?: number;
    /** Uniquely identifies this particular card number. You can use this attribute to check
whether two customers who’ve signed up with you are using the same card number, for
example. For payment methods that tokenize card information (Apple Pay, Google Pay), the
tokenized number might be provided instead of the underlying card number.
            
Starting May 1, 2021, card fingerprint in India for Connect will change to allow two
fingerprints for the same card --- one for India and one for the rest of the world.. */
    fingerprint?: string | undefined;
    /** Card funding type. Can be credit, debit, prepaid, or
unknown. */
    funding?: string | undefined;
    /** Issuer identification number of the card. (For internal use only and not typically
available in standard API requests.). */
    iin?: string | undefined;
    /** The name of the card's issuing bank. (For internal use only and not typically available
in standard API requests.). */
    issuer?: string | undefined;
    /** The last four digits of the card. */
    last4?: string | undefined;
    /** Contains information about card networks that can be used to process the payment. */
    networks?: PaymentMethodCardNetworks | undefined;
    /** Contains details on how this Card may be used for 3D Secure authentication. */
    threeDSecureUsage?: PaymentMethodCardThreeDSecureUsage | undefined;
    /** If this Card is part of a card wallet, this contains the details of the card wallet. */
    wallet?: PaymentMethodCardWallet | undefined;

    constructor(data?: IPaymentMethodCard) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.brand = _data["brand"];
            this.checks = _data["checks"] ? PaymentMethodCardChecks.fromJS(_data["checks"]) : <any>undefined;
            this.country = _data["country"];
            this.description = _data["description"];
            this.expMonth = _data["expMonth"];
            this.expYear = _data["expYear"];
            this.fingerprint = _data["fingerprint"];
            this.funding = _data["funding"];
            this.iin = _data["iin"];
            this.issuer = _data["issuer"];
            this.last4 = _data["last4"];
            this.networks = _data["networks"] ? PaymentMethodCardNetworks.fromJS(_data["networks"]) : <any>undefined;
            this.threeDSecureUsage = _data["threeDSecureUsage"] ? PaymentMethodCardThreeDSecureUsage.fromJS(_data["threeDSecureUsage"]) : <any>undefined;
            this.wallet = _data["wallet"] ? PaymentMethodCardWallet.fromJS(_data["wallet"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): PaymentMethodCard {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodCard();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brand"] = this.brand;
        data["checks"] = this.checks ? this.checks.toJSON() : <any>undefined;
        data["country"] = this.country;
        data["description"] = this.description;
        data["expMonth"] = this.expMonth;
        data["expYear"] = this.expYear;
        data["fingerprint"] = this.fingerprint;
        data["funding"] = this.funding;
        data["iin"] = this.iin;
        data["issuer"] = this.issuer;
        data["last4"] = this.last4;
        data["networks"] = this.networks ? this.networks.toJSON() : <any>undefined;
        data["threeDSecureUsage"] = this.threeDSecureUsage ? this.threeDSecureUsage.toJSON() : <any>undefined;
        data["wallet"] = this.wallet ? this.wallet.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentMethodCard extends IStripeEntityOfPaymentMethodCard {
    /** Card brand. Can be amex, diners, discover, eftpos_au,
jcb, mastercard, unionpay, visa, or unknown. */
    brand?: string | undefined;
    /** Checks on Card address and CVC if provided. */
    checks?: PaymentMethodCardChecks | undefined;
    /** Two-letter ISO code representing the country of the card. You could use this attribute
to get a sense of the international breakdown of cards you've collected. */
    country?: string | undefined;
    /** A high-level description of the type of cards issued in this range. (For internal use
only and not typically available in standard API requests.). */
    description?: string | undefined;
    /** Two-digit number representing the card's expiration month. */
    expMonth?: number;
    /** Four-digit number representing the card's expiration year. */
    expYear?: number;
    /** Uniquely identifies this particular card number. You can use this attribute to check
whether two customers who’ve signed up with you are using the same card number, for
example. For payment methods that tokenize card information (Apple Pay, Google Pay), the
tokenized number might be provided instead of the underlying card number.
            
Starting May 1, 2021, card fingerprint in India for Connect will change to allow two
fingerprints for the same card --- one for India and one for the rest of the world.. */
    fingerprint?: string | undefined;
    /** Card funding type. Can be credit, debit, prepaid, or
unknown. */
    funding?: string | undefined;
    /** Issuer identification number of the card. (For internal use only and not typically
available in standard API requests.). */
    iin?: string | undefined;
    /** The name of the card's issuing bank. (For internal use only and not typically available
in standard API requests.). */
    issuer?: string | undefined;
    /** The last four digits of the card. */
    last4?: string | undefined;
    /** Contains information about card networks that can be used to process the payment. */
    networks?: PaymentMethodCardNetworks | undefined;
    /** Contains details on how this Card may be used for 3D Secure authentication. */
    threeDSecureUsage?: PaymentMethodCardThreeDSecureUsage | undefined;
    /** If this Card is part of a card wallet, this contains the details of the card wallet. */
    wallet?: PaymentMethodCardWallet | undefined;
}

export abstract class StripeEntityOfPaymentMethodCardChecks extends StripeEntity implements IStripeEntityOfPaymentMethodCardChecks {

    constructor(data?: IStripeEntityOfPaymentMethodCardChecks) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentMethodCardChecks {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentMethodCardChecks' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentMethodCardChecks extends IStripeEntity {
}

export class PaymentMethodCardChecks extends StripeEntityOfPaymentMethodCardChecks implements IPaymentMethodCardChecks {
    /** If a address line1 was provided, results of the check, one of pass, fail,
unavailable, or unchecked. */
    addressLine1Check?: string | undefined;
    /** If a address postal code was provided, results of the check, one of pass,
fail, unavailable, or unchecked. */
    addressPostalCodeCheck?: string | undefined;
    /** If a CVC was provided, results of the check, one of pass, fail,
unavailable, or unchecked. */
    cvcCheck?: string | undefined;

    constructor(data?: IPaymentMethodCardChecks) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.addressLine1Check = _data["addressLine1Check"];
            this.addressPostalCodeCheck = _data["addressPostalCodeCheck"];
            this.cvcCheck = _data["cvcCheck"];
        }
    }

    static override fromJS(data: any): PaymentMethodCardChecks {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodCardChecks();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["addressLine1Check"] = this.addressLine1Check;
        data["addressPostalCodeCheck"] = this.addressPostalCodeCheck;
        data["cvcCheck"] = this.cvcCheck;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentMethodCardChecks extends IStripeEntityOfPaymentMethodCardChecks {
    /** If a address line1 was provided, results of the check, one of pass, fail,
unavailable, or unchecked. */
    addressLine1Check?: string | undefined;
    /** If a address postal code was provided, results of the check, one of pass,
fail, unavailable, or unchecked. */
    addressPostalCodeCheck?: string | undefined;
    /** If a CVC was provided, results of the check, one of pass, fail,
unavailable, or unchecked. */
    cvcCheck?: string | undefined;
}

export abstract class StripeEntityOfPaymentMethodCardNetworks extends StripeEntity implements IStripeEntityOfPaymentMethodCardNetworks {

    constructor(data?: IStripeEntityOfPaymentMethodCardNetworks) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentMethodCardNetworks {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentMethodCardNetworks' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentMethodCardNetworks extends IStripeEntity {
}

export class PaymentMethodCardNetworks extends StripeEntityOfPaymentMethodCardNetworks implements IPaymentMethodCardNetworks {
    /** All available networks for the card. */
    available?: string[] | undefined;
    /** The preferred network for the card. */
    preferred?: string | undefined;

    constructor(data?: IPaymentMethodCardNetworks) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["available"])) {
                this.available = [] as any;
                for (let item of _data["available"])
                    this.available!.push(item);
            }
            this.preferred = _data["preferred"];
        }
    }

    static override fromJS(data: any): PaymentMethodCardNetworks {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodCardNetworks();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.available)) {
            data["available"] = [];
            for (let item of this.available)
                data["available"].push(item);
        }
        data["preferred"] = this.preferred;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentMethodCardNetworks extends IStripeEntityOfPaymentMethodCardNetworks {
    /** All available networks for the card. */
    available?: string[] | undefined;
    /** The preferred network for the card. */
    preferred?: string | undefined;
}

export abstract class StripeEntityOfPaymentMethodCardThreeDSecureUsage extends StripeEntity implements IStripeEntityOfPaymentMethodCardThreeDSecureUsage {

    constructor(data?: IStripeEntityOfPaymentMethodCardThreeDSecureUsage) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentMethodCardThreeDSecureUsage {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentMethodCardThreeDSecureUsage' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentMethodCardThreeDSecureUsage extends IStripeEntity {
}

export class PaymentMethodCardThreeDSecureUsage extends StripeEntityOfPaymentMethodCardThreeDSecureUsage implements IPaymentMethodCardThreeDSecureUsage {
    /** Whether 3D Secure is supported on this card. */
    supported?: boolean;

    constructor(data?: IPaymentMethodCardThreeDSecureUsage) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.supported = _data["supported"];
        }
    }

    static override fromJS(data: any): PaymentMethodCardThreeDSecureUsage {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodCardThreeDSecureUsage();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["supported"] = this.supported;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentMethodCardThreeDSecureUsage extends IStripeEntityOfPaymentMethodCardThreeDSecureUsage {
    /** Whether 3D Secure is supported on this card. */
    supported?: boolean;
}

export abstract class StripeEntityOfPaymentMethodCardWallet extends StripeEntity implements IStripeEntityOfPaymentMethodCardWallet {

    constructor(data?: IStripeEntityOfPaymentMethodCardWallet) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentMethodCardWallet {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentMethodCardWallet' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentMethodCardWallet extends IStripeEntity {
}

export class PaymentMethodCardWallet extends StripeEntityOfPaymentMethodCardWallet implements IPaymentMethodCardWallet {
    amexExpressCheckout?: PaymentMethodCardWalletAmexExpressCheckout | undefined;
    applePay?: PaymentMethodCardWalletApplePay | undefined;
    /** (For tokenized numbers only.) The last four digits of the device account number. */
    dynamicLast4?: string | undefined;
    googlePay?: PaymentMethodCardWalletGooglePay | undefined;
    link?: PaymentMethodCardWalletLink | undefined;
    masterpass?: PaymentMethodCardWalletMasterpass | undefined;
    samsungPay?: PaymentMethodCardWalletSamsungPay | undefined;
    /** The type of the card wallet, one of amex_express_checkout, apple_pay,
google_pay, masterpass, samsung_pay, visa_checkout, or
link. An additional hash is included on the Wallet subhash with a name matching
this value. It contains additional information specific to the card wallet type.
One of: amex_express_checkout, apple_pay, google_pay, link,
masterpass, samsung_pay, or visa_checkout. */
    type?: string | undefined;
    visaCheckout?: PaymentMethodCardWalletVisaCheckout | undefined;

    constructor(data?: IPaymentMethodCardWallet) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.amexExpressCheckout = _data["amexExpressCheckout"] ? PaymentMethodCardWalletAmexExpressCheckout.fromJS(_data["amexExpressCheckout"]) : <any>undefined;
            this.applePay = _data["applePay"] ? PaymentMethodCardWalletApplePay.fromJS(_data["applePay"]) : <any>undefined;
            this.dynamicLast4 = _data["dynamicLast4"];
            this.googlePay = _data["googlePay"] ? PaymentMethodCardWalletGooglePay.fromJS(_data["googlePay"]) : <any>undefined;
            this.link = _data["link"] ? PaymentMethodCardWalletLink.fromJS(_data["link"]) : <any>undefined;
            this.masterpass = _data["masterpass"] ? PaymentMethodCardWalletMasterpass.fromJS(_data["masterpass"]) : <any>undefined;
            this.samsungPay = _data["samsungPay"] ? PaymentMethodCardWalletSamsungPay.fromJS(_data["samsungPay"]) : <any>undefined;
            this.type = _data["type"];
            this.visaCheckout = _data["visaCheckout"] ? PaymentMethodCardWalletVisaCheckout.fromJS(_data["visaCheckout"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): PaymentMethodCardWallet {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodCardWallet();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amexExpressCheckout"] = this.amexExpressCheckout ? this.amexExpressCheckout.toJSON() : <any>undefined;
        data["applePay"] = this.applePay ? this.applePay.toJSON() : <any>undefined;
        data["dynamicLast4"] = this.dynamicLast4;
        data["googlePay"] = this.googlePay ? this.googlePay.toJSON() : <any>undefined;
        data["link"] = this.link ? this.link.toJSON() : <any>undefined;
        data["masterpass"] = this.masterpass ? this.masterpass.toJSON() : <any>undefined;
        data["samsungPay"] = this.samsungPay ? this.samsungPay.toJSON() : <any>undefined;
        data["type"] = this.type;
        data["visaCheckout"] = this.visaCheckout ? this.visaCheckout.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentMethodCardWallet extends IStripeEntityOfPaymentMethodCardWallet {
    amexExpressCheckout?: PaymentMethodCardWalletAmexExpressCheckout | undefined;
    applePay?: PaymentMethodCardWalletApplePay | undefined;
    /** (For tokenized numbers only.) The last four digits of the device account number. */
    dynamicLast4?: string | undefined;
    googlePay?: PaymentMethodCardWalletGooglePay | undefined;
    link?: PaymentMethodCardWalletLink | undefined;
    masterpass?: PaymentMethodCardWalletMasterpass | undefined;
    samsungPay?: PaymentMethodCardWalletSamsungPay | undefined;
    /** The type of the card wallet, one of amex_express_checkout, apple_pay,
google_pay, masterpass, samsung_pay, visa_checkout, or
link. An additional hash is included on the Wallet subhash with a name matching
this value. It contains additional information specific to the card wallet type.
One of: amex_express_checkout, apple_pay, google_pay, link,
masterpass, samsung_pay, or visa_checkout. */
    type?: string | undefined;
    visaCheckout?: PaymentMethodCardWalletVisaCheckout | undefined;
}

export abstract class StripeEntityOfPaymentMethodCardWalletAmexExpressCheckout extends StripeEntity implements IStripeEntityOfPaymentMethodCardWalletAmexExpressCheckout {

    constructor(data?: IStripeEntityOfPaymentMethodCardWalletAmexExpressCheckout) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentMethodCardWalletAmexExpressCheckout {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentMethodCardWalletAmexExpressCheckout' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentMethodCardWalletAmexExpressCheckout extends IStripeEntity {
}

export class PaymentMethodCardWalletAmexExpressCheckout extends StripeEntityOfPaymentMethodCardWalletAmexExpressCheckout implements IPaymentMethodCardWalletAmexExpressCheckout {

    constructor(data?: IPaymentMethodCardWalletAmexExpressCheckout) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): PaymentMethodCardWalletAmexExpressCheckout {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodCardWalletAmexExpressCheckout();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentMethodCardWalletAmexExpressCheckout extends IStripeEntityOfPaymentMethodCardWalletAmexExpressCheckout {
}

export abstract class StripeEntityOfPaymentMethodCardWalletApplePay extends StripeEntity implements IStripeEntityOfPaymentMethodCardWalletApplePay {

    constructor(data?: IStripeEntityOfPaymentMethodCardWalletApplePay) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentMethodCardWalletApplePay {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentMethodCardWalletApplePay' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentMethodCardWalletApplePay extends IStripeEntity {
}

export class PaymentMethodCardWalletApplePay extends StripeEntityOfPaymentMethodCardWalletApplePay implements IPaymentMethodCardWalletApplePay {

    constructor(data?: IPaymentMethodCardWalletApplePay) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): PaymentMethodCardWalletApplePay {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodCardWalletApplePay();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentMethodCardWalletApplePay extends IStripeEntityOfPaymentMethodCardWalletApplePay {
}

export abstract class StripeEntityOfPaymentMethodCardWalletGooglePay extends StripeEntity implements IStripeEntityOfPaymentMethodCardWalletGooglePay {

    constructor(data?: IStripeEntityOfPaymentMethodCardWalletGooglePay) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentMethodCardWalletGooglePay {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentMethodCardWalletGooglePay' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentMethodCardWalletGooglePay extends IStripeEntity {
}

export class PaymentMethodCardWalletGooglePay extends StripeEntityOfPaymentMethodCardWalletGooglePay implements IPaymentMethodCardWalletGooglePay {

    constructor(data?: IPaymentMethodCardWalletGooglePay) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): PaymentMethodCardWalletGooglePay {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodCardWalletGooglePay();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentMethodCardWalletGooglePay extends IStripeEntityOfPaymentMethodCardWalletGooglePay {
}

export abstract class StripeEntityOfPaymentMethodCardWalletLink extends StripeEntity implements IStripeEntityOfPaymentMethodCardWalletLink {

    constructor(data?: IStripeEntityOfPaymentMethodCardWalletLink) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentMethodCardWalletLink {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentMethodCardWalletLink' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentMethodCardWalletLink extends IStripeEntity {
}

export class PaymentMethodCardWalletLink extends StripeEntityOfPaymentMethodCardWalletLink implements IPaymentMethodCardWalletLink {

    constructor(data?: IPaymentMethodCardWalletLink) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): PaymentMethodCardWalletLink {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodCardWalletLink();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentMethodCardWalletLink extends IStripeEntityOfPaymentMethodCardWalletLink {
}

export abstract class StripeEntityOfPaymentMethodCardWalletMasterpass extends StripeEntity implements IStripeEntityOfPaymentMethodCardWalletMasterpass {

    constructor(data?: IStripeEntityOfPaymentMethodCardWalletMasterpass) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentMethodCardWalletMasterpass {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentMethodCardWalletMasterpass' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentMethodCardWalletMasterpass extends IStripeEntity {
}

export class PaymentMethodCardWalletMasterpass extends StripeEntityOfPaymentMethodCardWalletMasterpass implements IPaymentMethodCardWalletMasterpass {
    /** Owner's verified billing address. Values are verified or provided by the wallet directly
(if supported) at the time of authorization or settlement. They cannot be set or
mutated. */
    billingAddress?: Address | undefined;
    /** Owner's verified email. Values are verified or provided by the wallet directly (if
supported) at the time of authorization or settlement. They cannot be set or mutated. */
    email?: string | undefined;
    /** Owner's verified full name. Values are verified or provided by the wallet directly (if
supported) at the time of authorization or settlement. They cannot be set or mutated. */
    name?: string | undefined;
    /** Owner's verified shipping address. Values are verified or provided by the wallet
directly (if supported) at the time of authorization or settlement. They cannot be set
or mutated. */
    shippingAddress?: Address | undefined;

    constructor(data?: IPaymentMethodCardWalletMasterpass) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.billingAddress = _data["billingAddress"] ? Address.fromJS(_data["billingAddress"]) : <any>undefined;
            this.email = _data["email"];
            this.name = _data["name"];
            this.shippingAddress = _data["shippingAddress"] ? Address.fromJS(_data["shippingAddress"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): PaymentMethodCardWalletMasterpass {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodCardWalletMasterpass();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["billingAddress"] = this.billingAddress ? this.billingAddress.toJSON() : <any>undefined;
        data["email"] = this.email;
        data["name"] = this.name;
        data["shippingAddress"] = this.shippingAddress ? this.shippingAddress.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentMethodCardWalletMasterpass extends IStripeEntityOfPaymentMethodCardWalletMasterpass {
    /** Owner's verified billing address. Values are verified or provided by the wallet directly
(if supported) at the time of authorization or settlement. They cannot be set or
mutated. */
    billingAddress?: Address | undefined;
    /** Owner's verified email. Values are verified or provided by the wallet directly (if
supported) at the time of authorization or settlement. They cannot be set or mutated. */
    email?: string | undefined;
    /** Owner's verified full name. Values are verified or provided by the wallet directly (if
supported) at the time of authorization or settlement. They cannot be set or mutated. */
    name?: string | undefined;
    /** Owner's verified shipping address. Values are verified or provided by the wallet
directly (if supported) at the time of authorization or settlement. They cannot be set
or mutated. */
    shippingAddress?: Address | undefined;
}

export abstract class StripeEntityOfPaymentMethodCardWalletSamsungPay extends StripeEntity implements IStripeEntityOfPaymentMethodCardWalletSamsungPay {

    constructor(data?: IStripeEntityOfPaymentMethodCardWalletSamsungPay) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentMethodCardWalletSamsungPay {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentMethodCardWalletSamsungPay' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentMethodCardWalletSamsungPay extends IStripeEntity {
}

export class PaymentMethodCardWalletSamsungPay extends StripeEntityOfPaymentMethodCardWalletSamsungPay implements IPaymentMethodCardWalletSamsungPay {

    constructor(data?: IPaymentMethodCardWalletSamsungPay) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): PaymentMethodCardWalletSamsungPay {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodCardWalletSamsungPay();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentMethodCardWalletSamsungPay extends IStripeEntityOfPaymentMethodCardWalletSamsungPay {
}

export abstract class StripeEntityOfPaymentMethodCardWalletVisaCheckout extends StripeEntity implements IStripeEntityOfPaymentMethodCardWalletVisaCheckout {

    constructor(data?: IStripeEntityOfPaymentMethodCardWalletVisaCheckout) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentMethodCardWalletVisaCheckout {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentMethodCardWalletVisaCheckout' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentMethodCardWalletVisaCheckout extends IStripeEntity {
}

export class PaymentMethodCardWalletVisaCheckout extends StripeEntityOfPaymentMethodCardWalletVisaCheckout implements IPaymentMethodCardWalletVisaCheckout {
    /** Owner's verified billing address. Values are verified or provided by the wallet directly
(if supported) at the time of authorization or settlement. They cannot be set or
mutated. */
    billingAddress?: Address | undefined;
    /** Owner's verified email. Values are verified or provided by the wallet directly (if
supported) at the time of authorization or settlement. They cannot be set or mutated. */
    email?: string | undefined;
    /** Owner's verified full name. Values are verified or provided by the wallet directly (if
supported) at the time of authorization or settlement. They cannot be set or mutated. */
    name?: string | undefined;
    /** Owner's verified shipping address. Values are verified or provided by the wallet
directly (if supported) at the time of authorization or settlement. They cannot be set
or mutated. */
    shippingAddress?: Address | undefined;

    constructor(data?: IPaymentMethodCardWalletVisaCheckout) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.billingAddress = _data["billingAddress"] ? Address.fromJS(_data["billingAddress"]) : <any>undefined;
            this.email = _data["email"];
            this.name = _data["name"];
            this.shippingAddress = _data["shippingAddress"] ? Address.fromJS(_data["shippingAddress"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): PaymentMethodCardWalletVisaCheckout {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodCardWalletVisaCheckout();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["billingAddress"] = this.billingAddress ? this.billingAddress.toJSON() : <any>undefined;
        data["email"] = this.email;
        data["name"] = this.name;
        data["shippingAddress"] = this.shippingAddress ? this.shippingAddress.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentMethodCardWalletVisaCheckout extends IStripeEntityOfPaymentMethodCardWalletVisaCheckout {
    /** Owner's verified billing address. Values are verified or provided by the wallet directly
(if supported) at the time of authorization or settlement. They cannot be set or
mutated. */
    billingAddress?: Address | undefined;
    /** Owner's verified email. Values are verified or provided by the wallet directly (if
supported) at the time of authorization or settlement. They cannot be set or mutated. */
    email?: string | undefined;
    /** Owner's verified full name. Values are verified or provided by the wallet directly (if
supported) at the time of authorization or settlement. They cannot be set or mutated. */
    name?: string | undefined;
    /** Owner's verified shipping address. Values are verified or provided by the wallet
directly (if supported) at the time of authorization or settlement. They cannot be set
or mutated. */
    shippingAddress?: Address | undefined;
}

export abstract class StripeEntityOfPaymentMethodCardPresent extends StripeEntity implements IStripeEntityOfPaymentMethodCardPresent {

    constructor(data?: IStripeEntityOfPaymentMethodCardPresent) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentMethodCardPresent {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentMethodCardPresent' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentMethodCardPresent extends IStripeEntity {
}

export class PaymentMethodCardPresent extends StripeEntityOfPaymentMethodCardPresent implements IPaymentMethodCardPresent {
    /** Card brand. Can be amex, diners, discover, eftpos_au,
jcb, mastercard, unionpay, visa, or unknown. */
    brand?: string | undefined;
    /** The cardholder name as read from the card, in ISO 7813 format. May include
alphanumeric characters, special characters and first/last name separator (/). In
some cases, the cardholder name may not be available depending on how the issuer has
configured the card. Cardholder name is typically not available on swipe or contactless
payments, such as those made with Apple Pay and Google Pay. */
    cardholderName?: string | undefined;
    /** Two-letter ISO code representing the country of the card. You could use this attribute
to get a sense of the international breakdown of cards you've collected. */
    country?: string | undefined;
    /** Two-digit number representing the card's expiration month. */
    expMonth?: number;
    /** Four-digit number representing the card's expiration year. */
    expYear?: number;
    /** Uniquely identifies this particular card number. You can use this attribute to check
whether two customers who’ve signed up with you are using the same card number, for
example. For payment methods that tokenize card information (Apple Pay, Google Pay), the
tokenized number might be provided instead of the underlying card number.
            
Starting May 1, 2021, card fingerprint in India for Connect will change to allow two
fingerprints for the same card --- one for India and one for the rest of the world.. */
    fingerprint?: string | undefined;
    /** Card funding type. Can be credit, debit, prepaid, or
unknown. */
    funding?: string | undefined;
    /** The last four digits of the card. */
    last4?: string | undefined;
    /** Contains information about card networks that can be used to process the payment. */
    networks?: PaymentMethodCardPresentNetworks | undefined;
    /** How card details were read in this transaction.
One of: contact_emv, contactless_emv, contactless_magstripe_mode,
magnetic_stripe_fallback, or magnetic_stripe_track2. */
    readMethod?: string | undefined;

    constructor(data?: IPaymentMethodCardPresent) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.brand = _data["brand"];
            this.cardholderName = _data["cardholderName"];
            this.country = _data["country"];
            this.expMonth = _data["expMonth"];
            this.expYear = _data["expYear"];
            this.fingerprint = _data["fingerprint"];
            this.funding = _data["funding"];
            this.last4 = _data["last4"];
            this.networks = _data["networks"] ? PaymentMethodCardPresentNetworks.fromJS(_data["networks"]) : <any>undefined;
            this.readMethod = _data["readMethod"];
        }
    }

    static override fromJS(data: any): PaymentMethodCardPresent {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodCardPresent();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brand"] = this.brand;
        data["cardholderName"] = this.cardholderName;
        data["country"] = this.country;
        data["expMonth"] = this.expMonth;
        data["expYear"] = this.expYear;
        data["fingerprint"] = this.fingerprint;
        data["funding"] = this.funding;
        data["last4"] = this.last4;
        data["networks"] = this.networks ? this.networks.toJSON() : <any>undefined;
        data["readMethod"] = this.readMethod;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentMethodCardPresent extends IStripeEntityOfPaymentMethodCardPresent {
    /** Card brand. Can be amex, diners, discover, eftpos_au,
jcb, mastercard, unionpay, visa, or unknown. */
    brand?: string | undefined;
    /** The cardholder name as read from the card, in ISO 7813 format. May include
alphanumeric characters, special characters and first/last name separator (/). In
some cases, the cardholder name may not be available depending on how the issuer has
configured the card. Cardholder name is typically not available on swipe or contactless
payments, such as those made with Apple Pay and Google Pay. */
    cardholderName?: string | undefined;
    /** Two-letter ISO code representing the country of the card. You could use this attribute
to get a sense of the international breakdown of cards you've collected. */
    country?: string | undefined;
    /** Two-digit number representing the card's expiration month. */
    expMonth?: number;
    /** Four-digit number representing the card's expiration year. */
    expYear?: number;
    /** Uniquely identifies this particular card number. You can use this attribute to check
whether two customers who’ve signed up with you are using the same card number, for
example. For payment methods that tokenize card information (Apple Pay, Google Pay), the
tokenized number might be provided instead of the underlying card number.
            
Starting May 1, 2021, card fingerprint in India for Connect will change to allow two
fingerprints for the same card --- one for India and one for the rest of the world.. */
    fingerprint?: string | undefined;
    /** Card funding type. Can be credit, debit, prepaid, or
unknown. */
    funding?: string | undefined;
    /** The last four digits of the card. */
    last4?: string | undefined;
    /** Contains information about card networks that can be used to process the payment. */
    networks?: PaymentMethodCardPresentNetworks | undefined;
    /** How card details were read in this transaction.
One of: contact_emv, contactless_emv, contactless_magstripe_mode,
magnetic_stripe_fallback, or magnetic_stripe_track2. */
    readMethod?: string | undefined;
}

export abstract class StripeEntityOfPaymentMethodCardPresentNetworks extends StripeEntity implements IStripeEntityOfPaymentMethodCardPresentNetworks {

    constructor(data?: IStripeEntityOfPaymentMethodCardPresentNetworks) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentMethodCardPresentNetworks {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentMethodCardPresentNetworks' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentMethodCardPresentNetworks extends IStripeEntity {
}

export class PaymentMethodCardPresentNetworks extends StripeEntityOfPaymentMethodCardPresentNetworks implements IPaymentMethodCardPresentNetworks {
    /** All available networks for the card. */
    available?: string[] | undefined;
    /** The preferred network for the card. */
    preferred?: string | undefined;

    constructor(data?: IPaymentMethodCardPresentNetworks) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["available"])) {
                this.available = [] as any;
                for (let item of _data["available"])
                    this.available!.push(item);
            }
            this.preferred = _data["preferred"];
        }
    }

    static override fromJS(data: any): PaymentMethodCardPresentNetworks {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodCardPresentNetworks();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.available)) {
            data["available"] = [];
            for (let item of this.available)
                data["available"].push(item);
        }
        data["preferred"] = this.preferred;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentMethodCardPresentNetworks extends IStripeEntityOfPaymentMethodCardPresentNetworks {
    /** All available networks for the card. */
    available?: string[] | undefined;
    /** The preferred network for the card. */
    preferred?: string | undefined;
}

export abstract class StripeEntityOfPaymentMethodCashapp extends StripeEntity implements IStripeEntityOfPaymentMethodCashapp {

    constructor(data?: IStripeEntityOfPaymentMethodCashapp) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentMethodCashapp {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentMethodCashapp' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentMethodCashapp extends IStripeEntity {
}

export class PaymentMethodCashapp extends StripeEntityOfPaymentMethodCashapp implements IPaymentMethodCashapp {
    /** A unique and immutable identifier assigned by Cash App to every buyer. */
    buyerId?: string | undefined;
    /** A public identifier for buyers using Cash App. */
    cashtag?: string | undefined;

    constructor(data?: IPaymentMethodCashapp) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.buyerId = _data["buyerId"];
            this.cashtag = _data["cashtag"];
        }
    }

    static override fromJS(data: any): PaymentMethodCashapp {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodCashapp();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["buyerId"] = this.buyerId;
        data["cashtag"] = this.cashtag;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentMethodCashapp extends IStripeEntityOfPaymentMethodCashapp {
    /** A unique and immutable identifier assigned by Cash App to every buyer. */
    buyerId?: string | undefined;
    /** A public identifier for buyers using Cash App. */
    cashtag?: string | undefined;
}

export abstract class StripeEntityOfPaymentMethodCustomerBalance extends StripeEntity implements IStripeEntityOfPaymentMethodCustomerBalance {

    constructor(data?: IStripeEntityOfPaymentMethodCustomerBalance) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentMethodCustomerBalance {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentMethodCustomerBalance' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentMethodCustomerBalance extends IStripeEntity {
}

export class PaymentMethodCustomerBalance extends StripeEntityOfPaymentMethodCustomerBalance implements IPaymentMethodCustomerBalance {

    constructor(data?: IPaymentMethodCustomerBalance) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): PaymentMethodCustomerBalance {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodCustomerBalance();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentMethodCustomerBalance extends IStripeEntityOfPaymentMethodCustomerBalance {
}

export abstract class StripeEntityOfPaymentMethodEps extends StripeEntity implements IStripeEntityOfPaymentMethodEps {

    constructor(data?: IStripeEntityOfPaymentMethodEps) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentMethodEps {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentMethodEps' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentMethodEps extends IStripeEntity {
}

export class PaymentMethodEps extends StripeEntityOfPaymentMethodEps implements IPaymentMethodEps {
    /** The customer's bank. Should be one of arzte_und_apotheker_bank,
austrian_anadi_bank_ag, bank_austria, bankhaus_carl_spangler,
bankhaus_schelhammer_und_schattera_ag, bawag_psk_ag, bks_bank_ag,
brull_kallmus_bank_ag, btv_vier_lander_bank,
capital_bank_grawe_gruppe_ag, deutsche_bank_ag, dolomitenbank,
easybank_ag, erste_bank_und_sparkassen,
hypo_alpeadriabank_international_ag,
hypo_noe_lb_fur_niederosterreich_u_wien,
hypo_oberosterreich_salzburg_steiermark, hypo_tirol_bank_ag,
hypo_vorarlberg_bank_ag, hypo_bank_burgenland_aktiengesellschaft,
marchfelder_bank, oberbank_ag, raiffeisen_bankengruppe_osterreich,
schoellerbank_ag, sparda_bank_wien, volksbank_gruppe,
volkskreditbank_ag, or vr_bank_braunau.
One of: arzte_und_apotheker_bank, austrian_anadi_bank_ag,
bank_austria, bankhaus_carl_spangler,
bankhaus_schelhammer_und_schattera_ag, bawag_psk_ag, bks_bank_ag,
brull_kallmus_bank_ag, btv_vier_lander_bank,
capital_bank_grawe_gruppe_ag, deutsche_bank_ag, dolomitenbank,
easybank_ag, erste_bank_und_sparkassen,
hypo_alpeadriabank_international_ag,
hypo_bank_burgenland_aktiengesellschaft,
hypo_noe_lb_fur_niederosterreich_u_wien,
hypo_oberosterreich_salzburg_steiermark, hypo_tirol_bank_ag,
hypo_vorarlberg_bank_ag, marchfelder_bank, oberbank_ag,
raiffeisen_bankengruppe_osterreich, schoellerbank_ag,
sparda_bank_wien, volksbank_gruppe, volkskreditbank_ag, or
vr_bank_braunau. */
    bank?: string | undefined;

    constructor(data?: IPaymentMethodEps) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.bank = _data["bank"];
        }
    }

    static override fromJS(data: any): PaymentMethodEps {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodEps();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bank"] = this.bank;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentMethodEps extends IStripeEntityOfPaymentMethodEps {
    /** The customer's bank. Should be one of arzte_und_apotheker_bank,
austrian_anadi_bank_ag, bank_austria, bankhaus_carl_spangler,
bankhaus_schelhammer_und_schattera_ag, bawag_psk_ag, bks_bank_ag,
brull_kallmus_bank_ag, btv_vier_lander_bank,
capital_bank_grawe_gruppe_ag, deutsche_bank_ag, dolomitenbank,
easybank_ag, erste_bank_und_sparkassen,
hypo_alpeadriabank_international_ag,
hypo_noe_lb_fur_niederosterreich_u_wien,
hypo_oberosterreich_salzburg_steiermark, hypo_tirol_bank_ag,
hypo_vorarlberg_bank_ag, hypo_bank_burgenland_aktiengesellschaft,
marchfelder_bank, oberbank_ag, raiffeisen_bankengruppe_osterreich,
schoellerbank_ag, sparda_bank_wien, volksbank_gruppe,
volkskreditbank_ag, or vr_bank_braunau.
One of: arzte_und_apotheker_bank, austrian_anadi_bank_ag,
bank_austria, bankhaus_carl_spangler,
bankhaus_schelhammer_und_schattera_ag, bawag_psk_ag, bks_bank_ag,
brull_kallmus_bank_ag, btv_vier_lander_bank,
capital_bank_grawe_gruppe_ag, deutsche_bank_ag, dolomitenbank,
easybank_ag, erste_bank_und_sparkassen,
hypo_alpeadriabank_international_ag,
hypo_bank_burgenland_aktiengesellschaft,
hypo_noe_lb_fur_niederosterreich_u_wien,
hypo_oberosterreich_salzburg_steiermark, hypo_tirol_bank_ag,
hypo_vorarlberg_bank_ag, marchfelder_bank, oberbank_ag,
raiffeisen_bankengruppe_osterreich, schoellerbank_ag,
sparda_bank_wien, volksbank_gruppe, volkskreditbank_ag, or
vr_bank_braunau. */
    bank?: string | undefined;
}

export abstract class StripeEntityOfPaymentMethodFpx extends StripeEntity implements IStripeEntityOfPaymentMethodFpx {

    constructor(data?: IStripeEntityOfPaymentMethodFpx) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentMethodFpx {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentMethodFpx' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentMethodFpx extends IStripeEntity {
}

export class PaymentMethodFpx extends StripeEntityOfPaymentMethodFpx implements IPaymentMethodFpx {
    /** Account holder type, if provided. Can be one of individual or company.
One of: company, or individual. */
    accountHolderType?: string | undefined;
    /** The customer's bank, if provided. Can be one of affin_bank, agrobank,
alliance_bank, ambank, bank_islam, bank_muamalat,
bank_rakyat, bsn, cimb, hong_leong_bank, hsbc,
kfh, maybank2u, ocbc, public_bank, rhb,
standard_chartered, uob, deutsche_bank, maybank2e,
pb_enterprise, or bank_of_china.
One of: affin_bank, agrobank, alliance_bank, ambank,
bank_islam, bank_muamalat, bank_of_china, bank_rakyat,
bsn, cimb, deutsche_bank, hong_leong_bank, hsbc,
kfh, maybank2e, maybank2u, ocbc, pb_enterprise,
public_bank, rhb, standard_chartered, or uob. */
    bank?: string | undefined;

    constructor(data?: IPaymentMethodFpx) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.accountHolderType = _data["accountHolderType"];
            this.bank = _data["bank"];
        }
    }

    static override fromJS(data: any): PaymentMethodFpx {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodFpx();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountHolderType"] = this.accountHolderType;
        data["bank"] = this.bank;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentMethodFpx extends IStripeEntityOfPaymentMethodFpx {
    /** Account holder type, if provided. Can be one of individual or company.
One of: company, or individual. */
    accountHolderType?: string | undefined;
    /** The customer's bank, if provided. Can be one of affin_bank, agrobank,
alliance_bank, ambank, bank_islam, bank_muamalat,
bank_rakyat, bsn, cimb, hong_leong_bank, hsbc,
kfh, maybank2u, ocbc, public_bank, rhb,
standard_chartered, uob, deutsche_bank, maybank2e,
pb_enterprise, or bank_of_china.
One of: affin_bank, agrobank, alliance_bank, ambank,
bank_islam, bank_muamalat, bank_of_china, bank_rakyat,
bsn, cimb, deutsche_bank, hong_leong_bank, hsbc,
kfh, maybank2e, maybank2u, ocbc, pb_enterprise,
public_bank, rhb, standard_chartered, or uob. */
    bank?: string | undefined;
}

export abstract class StripeEntityOfPaymentMethodGiropay extends StripeEntity implements IStripeEntityOfPaymentMethodGiropay {

    constructor(data?: IStripeEntityOfPaymentMethodGiropay) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentMethodGiropay {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentMethodGiropay' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentMethodGiropay extends IStripeEntity {
}

export class PaymentMethodGiropay extends StripeEntityOfPaymentMethodGiropay implements IPaymentMethodGiropay {

    constructor(data?: IPaymentMethodGiropay) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): PaymentMethodGiropay {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodGiropay();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentMethodGiropay extends IStripeEntityOfPaymentMethodGiropay {
}

export abstract class StripeEntityOfPaymentMethodGrabpay extends StripeEntity implements IStripeEntityOfPaymentMethodGrabpay {

    constructor(data?: IStripeEntityOfPaymentMethodGrabpay) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentMethodGrabpay {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentMethodGrabpay' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentMethodGrabpay extends IStripeEntity {
}

export class PaymentMethodGrabpay extends StripeEntityOfPaymentMethodGrabpay implements IPaymentMethodGrabpay {

    constructor(data?: IPaymentMethodGrabpay) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): PaymentMethodGrabpay {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodGrabpay();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentMethodGrabpay extends IStripeEntityOfPaymentMethodGrabpay {
}

export abstract class StripeEntityOfPaymentMethodIdeal extends StripeEntity implements IStripeEntityOfPaymentMethodIdeal {

    constructor(data?: IStripeEntityOfPaymentMethodIdeal) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentMethodIdeal {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentMethodIdeal' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentMethodIdeal extends IStripeEntity {
}

export class PaymentMethodIdeal extends StripeEntityOfPaymentMethodIdeal implements IPaymentMethodIdeal {
    /** The customer's bank, if provided. Can be one of abn_amro, asn_bank,
bunq, handelsbanken, ing, knab, moneyou,
rabobank, regiobank, revolut, sns_bank, triodos_bank,
van_lanschot, or yoursafe.
One of: abn_amro, asn_bank, bunq, handelsbanken, ing,
knab, moneyou, rabobank, regiobank, revolut,
sns_bank, triodos_bank, van_lanschot, or yoursafe. */
    bank?: string | undefined;
    /** The Bank Identifier Code of the customer's bank, if the bank was provided.
One of: ABNANL2A, ASNBNL21, BITSNL2A, BUNQNL2A,
FVLBNL22, HANDNL2A, INGBNL2A, KNABNL2H, MOYONL21,
RABONL2U, RBRBNL21, REVOIE23, REVOLT21, SNSBNL2A, or
TRIONL2U. */
    bic?: string | undefined;

    constructor(data?: IPaymentMethodIdeal) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.bank = _data["bank"];
            this.bic = _data["bic"];
        }
    }

    static override fromJS(data: any): PaymentMethodIdeal {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodIdeal();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bank"] = this.bank;
        data["bic"] = this.bic;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentMethodIdeal extends IStripeEntityOfPaymentMethodIdeal {
    /** The customer's bank, if provided. Can be one of abn_amro, asn_bank,
bunq, handelsbanken, ing, knab, moneyou,
rabobank, regiobank, revolut, sns_bank, triodos_bank,
van_lanschot, or yoursafe.
One of: abn_amro, asn_bank, bunq, handelsbanken, ing,
knab, moneyou, rabobank, regiobank, revolut,
sns_bank, triodos_bank, van_lanschot, or yoursafe. */
    bank?: string | undefined;
    /** The Bank Identifier Code of the customer's bank, if the bank was provided.
One of: ABNANL2A, ASNBNL21, BITSNL2A, BUNQNL2A,
FVLBNL22, HANDNL2A, INGBNL2A, KNABNL2H, MOYONL21,
RABONL2U, RBRBNL21, REVOIE23, REVOLT21, SNSBNL2A, or
TRIONL2U. */
    bic?: string | undefined;
}

export abstract class StripeEntityOfPaymentMethodInteracPresent extends StripeEntity implements IStripeEntityOfPaymentMethodInteracPresent {

    constructor(data?: IStripeEntityOfPaymentMethodInteracPresent) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentMethodInteracPresent {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentMethodInteracPresent' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentMethodInteracPresent extends IStripeEntity {
}

export class PaymentMethodInteracPresent extends StripeEntityOfPaymentMethodInteracPresent implements IPaymentMethodInteracPresent {
    /** Card brand. Can be interac, mastercard or visa. */
    brand?: string | undefined;
    /** The cardholder name as read from the card, in ISO 7813 format. May include
alphanumeric characters, special characters and first/last name separator (/). In
some cases, the cardholder name may not be available depending on how the issuer has
configured the card. Cardholder name is typically not available on swipe or contactless
payments, such as those made with Apple Pay and Google Pay. */
    cardholderName?: string | undefined;
    /** Two-letter ISO code representing the country of the card. You could use this attribute
to get a sense of the international breakdown of cards you've collected. */
    country?: string | undefined;
    /** Two-digit number representing the card's expiration month. */
    expMonth?: number;
    /** Four-digit number representing the card's expiration year. */
    expYear?: number;
    /** Uniquely identifies this particular card number. You can use this attribute to check
whether two customers who’ve signed up with you are using the same card number, for
example. For payment methods that tokenize card information (Apple Pay, Google Pay), the
tokenized number might be provided instead of the underlying card number.
            
Starting May 1, 2021, card fingerprint in India for Connect will change to allow two
fingerprints for the same card --- one for India and one for the rest of the world.. */
    fingerprint?: string | undefined;
    /** Card funding type. Can be credit, debit, prepaid, or
unknown. */
    funding?: string | undefined;
    /** The last four digits of the card. */
    last4?: string | undefined;
    /** Contains information about card networks that can be used to process the payment. */
    networks?: PaymentMethodInteracPresentNetworks | undefined;
    /** EMV tag 5F2D. Preferred languages specified by the integrated circuit chip. */
    preferredLocales?: string[] | undefined;
    /** How card details were read in this transaction.
One of: contact_emv, contactless_emv, contactless_magstripe_mode,
magnetic_stripe_fallback, or magnetic_stripe_track2. */
    readMethod?: string | undefined;

    constructor(data?: IPaymentMethodInteracPresent) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.brand = _data["brand"];
            this.cardholderName = _data["cardholderName"];
            this.country = _data["country"];
            this.expMonth = _data["expMonth"];
            this.expYear = _data["expYear"];
            this.fingerprint = _data["fingerprint"];
            this.funding = _data["funding"];
            this.last4 = _data["last4"];
            this.networks = _data["networks"] ? PaymentMethodInteracPresentNetworks.fromJS(_data["networks"]) : <any>undefined;
            if (Array.isArray(_data["preferredLocales"])) {
                this.preferredLocales = [] as any;
                for (let item of _data["preferredLocales"])
                    this.preferredLocales!.push(item);
            }
            this.readMethod = _data["readMethod"];
        }
    }

    static override fromJS(data: any): PaymentMethodInteracPresent {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodInteracPresent();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brand"] = this.brand;
        data["cardholderName"] = this.cardholderName;
        data["country"] = this.country;
        data["expMonth"] = this.expMonth;
        data["expYear"] = this.expYear;
        data["fingerprint"] = this.fingerprint;
        data["funding"] = this.funding;
        data["last4"] = this.last4;
        data["networks"] = this.networks ? this.networks.toJSON() : <any>undefined;
        if (Array.isArray(this.preferredLocales)) {
            data["preferredLocales"] = [];
            for (let item of this.preferredLocales)
                data["preferredLocales"].push(item);
        }
        data["readMethod"] = this.readMethod;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentMethodInteracPresent extends IStripeEntityOfPaymentMethodInteracPresent {
    /** Card brand. Can be interac, mastercard or visa. */
    brand?: string | undefined;
    /** The cardholder name as read from the card, in ISO 7813 format. May include
alphanumeric characters, special characters and first/last name separator (/). In
some cases, the cardholder name may not be available depending on how the issuer has
configured the card. Cardholder name is typically not available on swipe or contactless
payments, such as those made with Apple Pay and Google Pay. */
    cardholderName?: string | undefined;
    /** Two-letter ISO code representing the country of the card. You could use this attribute
to get a sense of the international breakdown of cards you've collected. */
    country?: string | undefined;
    /** Two-digit number representing the card's expiration month. */
    expMonth?: number;
    /** Four-digit number representing the card's expiration year. */
    expYear?: number;
    /** Uniquely identifies this particular card number. You can use this attribute to check
whether two customers who’ve signed up with you are using the same card number, for
example. For payment methods that tokenize card information (Apple Pay, Google Pay), the
tokenized number might be provided instead of the underlying card number.
            
Starting May 1, 2021, card fingerprint in India for Connect will change to allow two
fingerprints for the same card --- one for India and one for the rest of the world.. */
    fingerprint?: string | undefined;
    /** Card funding type. Can be credit, debit, prepaid, or
unknown. */
    funding?: string | undefined;
    /** The last four digits of the card. */
    last4?: string | undefined;
    /** Contains information about card networks that can be used to process the payment. */
    networks?: PaymentMethodInteracPresentNetworks | undefined;
    /** EMV tag 5F2D. Preferred languages specified by the integrated circuit chip. */
    preferredLocales?: string[] | undefined;
    /** How card details were read in this transaction.
One of: contact_emv, contactless_emv, contactless_magstripe_mode,
magnetic_stripe_fallback, or magnetic_stripe_track2. */
    readMethod?: string | undefined;
}

export abstract class StripeEntityOfPaymentMethodInteracPresentNetworks extends StripeEntity implements IStripeEntityOfPaymentMethodInteracPresentNetworks {

    constructor(data?: IStripeEntityOfPaymentMethodInteracPresentNetworks) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentMethodInteracPresentNetworks {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentMethodInteracPresentNetworks' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentMethodInteracPresentNetworks extends IStripeEntity {
}

export class PaymentMethodInteracPresentNetworks extends StripeEntityOfPaymentMethodInteracPresentNetworks implements IPaymentMethodInteracPresentNetworks {
    /** All available networks for the card. */
    available?: string[] | undefined;
    /** The preferred network for the card. */
    preferred?: string | undefined;

    constructor(data?: IPaymentMethodInteracPresentNetworks) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["available"])) {
                this.available = [] as any;
                for (let item of _data["available"])
                    this.available!.push(item);
            }
            this.preferred = _data["preferred"];
        }
    }

    static override fromJS(data: any): PaymentMethodInteracPresentNetworks {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodInteracPresentNetworks();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.available)) {
            data["available"] = [];
            for (let item of this.available)
                data["available"].push(item);
        }
        data["preferred"] = this.preferred;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentMethodInteracPresentNetworks extends IStripeEntityOfPaymentMethodInteracPresentNetworks {
    /** All available networks for the card. */
    available?: string[] | undefined;
    /** The preferred network for the card. */
    preferred?: string | undefined;
}

export abstract class StripeEntityOfPaymentMethodKlarna extends StripeEntity implements IStripeEntityOfPaymentMethodKlarna {

    constructor(data?: IStripeEntityOfPaymentMethodKlarna) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentMethodKlarna {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentMethodKlarna' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentMethodKlarna extends IStripeEntity {
}

export class PaymentMethodKlarna extends StripeEntityOfPaymentMethodKlarna implements IPaymentMethodKlarna {
    /** The customer's date of birth, if provided. */
    dob?: PaymentMethodKlarnaDob | undefined;

    constructor(data?: IPaymentMethodKlarna) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.dob = _data["dob"] ? PaymentMethodKlarnaDob.fromJS(_data["dob"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): PaymentMethodKlarna {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodKlarna();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dob"] = this.dob ? this.dob.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentMethodKlarna extends IStripeEntityOfPaymentMethodKlarna {
    /** The customer's date of birth, if provided. */
    dob?: PaymentMethodKlarnaDob | undefined;
}

export abstract class StripeEntityOfPaymentMethodKlarnaDob extends StripeEntity implements IStripeEntityOfPaymentMethodKlarnaDob {

    constructor(data?: IStripeEntityOfPaymentMethodKlarnaDob) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentMethodKlarnaDob {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentMethodKlarnaDob' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentMethodKlarnaDob extends IStripeEntity {
}

export class PaymentMethodKlarnaDob extends StripeEntityOfPaymentMethodKlarnaDob implements IPaymentMethodKlarnaDob {
    /** The day of birth, between 1 and 31. */
    day?: number | undefined;
    /** The month of birth, between 1 and 12. */
    month?: number | undefined;
    /** The four-digit year of birth. */
    year?: number | undefined;

    constructor(data?: IPaymentMethodKlarnaDob) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.day = _data["day"];
            this.month = _data["month"];
            this.year = _data["year"];
        }
    }

    static override fromJS(data: any): PaymentMethodKlarnaDob {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodKlarnaDob();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["day"] = this.day;
        data["month"] = this.month;
        data["year"] = this.year;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentMethodKlarnaDob extends IStripeEntityOfPaymentMethodKlarnaDob {
    /** The day of birth, between 1 and 31. */
    day?: number | undefined;
    /** The month of birth, between 1 and 12. */
    month?: number | undefined;
    /** The four-digit year of birth. */
    year?: number | undefined;
}

export abstract class StripeEntityOfPaymentMethodKonbini extends StripeEntity implements IStripeEntityOfPaymentMethodKonbini {

    constructor(data?: IStripeEntityOfPaymentMethodKonbini) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentMethodKonbini {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentMethodKonbini' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentMethodKonbini extends IStripeEntity {
}

export class PaymentMethodKonbini extends StripeEntityOfPaymentMethodKonbini implements IPaymentMethodKonbini {

    constructor(data?: IPaymentMethodKonbini) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): PaymentMethodKonbini {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodKonbini();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentMethodKonbini extends IStripeEntityOfPaymentMethodKonbini {
}

export abstract class StripeEntityOfPaymentMethodLink extends StripeEntity implements IStripeEntityOfPaymentMethodLink {

    constructor(data?: IStripeEntityOfPaymentMethodLink) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentMethodLink {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentMethodLink' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentMethodLink extends IStripeEntity {
}

export class PaymentMethodLink extends StripeEntityOfPaymentMethodLink implements IPaymentMethodLink {
    /** Two-letter ISO code representing the funding source (i.e. card, bank) country beneath
the Link payment method. You could use this attribute to get a sense of the
international breakdown of funding sources you've collected. */
    country?: string | undefined;
    /** Account owner's email address. */
    email?: string | undefined;
    /** Token used for persistent Link logins. */
    persistentToken?: string | undefined;

    constructor(data?: IPaymentMethodLink) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.country = _data["country"];
            this.email = _data["email"];
            this.persistentToken = _data["persistentToken"];
        }
    }

    static override fromJS(data: any): PaymentMethodLink {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodLink();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["country"] = this.country;
        data["email"] = this.email;
        data["persistentToken"] = this.persistentToken;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentMethodLink extends IStripeEntityOfPaymentMethodLink {
    /** Two-letter ISO code representing the funding source (i.e. card, bank) country beneath
the Link payment method. You could use this attribute to get a sense of the
international breakdown of funding sources you've collected. */
    country?: string | undefined;
    /** Account owner's email address. */
    email?: string | undefined;
    /** Token used for persistent Link logins. */
    persistentToken?: string | undefined;
}

export abstract class StripeEntityOfPaymentMethodOxxo extends StripeEntity implements IStripeEntityOfPaymentMethodOxxo {

    constructor(data?: IStripeEntityOfPaymentMethodOxxo) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentMethodOxxo {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentMethodOxxo' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentMethodOxxo extends IStripeEntity {
}

export class PaymentMethodOxxo extends StripeEntityOfPaymentMethodOxxo implements IPaymentMethodOxxo {

    constructor(data?: IPaymentMethodOxxo) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): PaymentMethodOxxo {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodOxxo();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentMethodOxxo extends IStripeEntityOfPaymentMethodOxxo {
}

export abstract class StripeEntityOfPaymentMethodP24 extends StripeEntity implements IStripeEntityOfPaymentMethodP24 {

    constructor(data?: IStripeEntityOfPaymentMethodP24) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentMethodP24 {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentMethodP24' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentMethodP24 extends IStripeEntity {
}

export class PaymentMethodP24 extends StripeEntityOfPaymentMethodP24 implements IPaymentMethodP24 {
    /** The customer's bank, if provided.
One of: alior_bank, bank_millennium, bank_nowy_bfg_sa,
bank_pekao_sa, banki_spbdzielcze, blik, bnp_paribas,
boz, citi_handlowy, credit_agricole, envelobank,
etransfer_pocztowy24, getin_bank, ideabank, ing,
inteligo, mbank_mtransfer, nest_przelew, noble_pay,
pbac_z_ipko, plus_bank, santander_przelew24,
tmobile_usbugi_bankowe, toyota_bank, or volkswagen_bank. */
    bank?: string | undefined;

    constructor(data?: IPaymentMethodP24) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.bank = _data["bank"];
        }
    }

    static override fromJS(data: any): PaymentMethodP24 {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodP24();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bank"] = this.bank;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentMethodP24 extends IStripeEntityOfPaymentMethodP24 {
    /** The customer's bank, if provided.
One of: alior_bank, bank_millennium, bank_nowy_bfg_sa,
bank_pekao_sa, banki_spbdzielcze, blik, bnp_paribas,
boz, citi_handlowy, credit_agricole, envelobank,
etransfer_pocztowy24, getin_bank, ideabank, ing,
inteligo, mbank_mtransfer, nest_przelew, noble_pay,
pbac_z_ipko, plus_bank, santander_przelew24,
tmobile_usbugi_bankowe, toyota_bank, or volkswagen_bank. */
    bank?: string | undefined;
}

export abstract class StripeEntityOfPaymentMethodPaynow extends StripeEntity implements IStripeEntityOfPaymentMethodPaynow {

    constructor(data?: IStripeEntityOfPaymentMethodPaynow) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentMethodPaynow {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentMethodPaynow' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentMethodPaynow extends IStripeEntity {
}

export class PaymentMethodPaynow extends StripeEntityOfPaymentMethodPaynow implements IPaymentMethodPaynow {

    constructor(data?: IPaymentMethodPaynow) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): PaymentMethodPaynow {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodPaynow();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentMethodPaynow extends IStripeEntityOfPaymentMethodPaynow {
}

export abstract class StripeEntityOfPaymentMethodPaypal extends StripeEntity implements IStripeEntityOfPaymentMethodPaypal {

    constructor(data?: IStripeEntityOfPaymentMethodPaypal) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentMethodPaypal {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentMethodPaypal' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentMethodPaypal extends IStripeEntity {
}

export class PaymentMethodPaypal extends StripeEntityOfPaymentMethodPaypal implements IPaymentMethodPaypal {
    /** PayPal account PayerID. This identifier uniquely identifies the PayPal customer. */
    payerId?: string | undefined;

    constructor(data?: IPaymentMethodPaypal) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.payerId = _data["payerId"];
        }
    }

    static override fromJS(data: any): PaymentMethodPaypal {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodPaypal();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["payerId"] = this.payerId;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentMethodPaypal extends IStripeEntityOfPaymentMethodPaypal {
    /** PayPal account PayerID. This identifier uniquely identifies the PayPal customer. */
    payerId?: string | undefined;
}

export abstract class StripeEntityOfPaymentMethodPix extends StripeEntity implements IStripeEntityOfPaymentMethodPix {

    constructor(data?: IStripeEntityOfPaymentMethodPix) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentMethodPix {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentMethodPix' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentMethodPix extends IStripeEntity {
}

export class PaymentMethodPix extends StripeEntityOfPaymentMethodPix implements IPaymentMethodPix {

    constructor(data?: IPaymentMethodPix) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): PaymentMethodPix {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodPix();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentMethodPix extends IStripeEntityOfPaymentMethodPix {
}

export abstract class StripeEntityOfPaymentMethodPromptpay extends StripeEntity implements IStripeEntityOfPaymentMethodPromptpay {

    constructor(data?: IStripeEntityOfPaymentMethodPromptpay) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentMethodPromptpay {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentMethodPromptpay' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentMethodPromptpay extends IStripeEntity {
}

export class PaymentMethodPromptpay extends StripeEntityOfPaymentMethodPromptpay implements IPaymentMethodPromptpay {

    constructor(data?: IPaymentMethodPromptpay) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): PaymentMethodPromptpay {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodPromptpay();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentMethodPromptpay extends IStripeEntityOfPaymentMethodPromptpay {
}

export abstract class StripeEntityOfPaymentMethodRadarOptions extends StripeEntity implements IStripeEntityOfPaymentMethodRadarOptions {

    constructor(data?: IStripeEntityOfPaymentMethodRadarOptions) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentMethodRadarOptions {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentMethodRadarOptions' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentMethodRadarOptions extends IStripeEntity {
}

export class PaymentMethodRadarOptions extends StripeEntityOfPaymentMethodRadarOptions implements IPaymentMethodRadarOptions {
    /** A Radar Session is a snapshot
of the browser metadata and device details that help Radar make more accurate
predictions on your payments. */
    session?: string | undefined;

    constructor(data?: IPaymentMethodRadarOptions) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.session = _data["session"];
        }
    }

    static override fromJS(data: any): PaymentMethodRadarOptions {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodRadarOptions();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["session"] = this.session;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentMethodRadarOptions extends IStripeEntityOfPaymentMethodRadarOptions {
    /** A Radar Session is a snapshot
of the browser metadata and device details that help Radar make more accurate
predictions on your payments. */
    session?: string | undefined;
}

export abstract class StripeEntityOfPaymentMethodSepaDebit extends StripeEntity implements IStripeEntityOfPaymentMethodSepaDebit {

    constructor(data?: IStripeEntityOfPaymentMethodSepaDebit) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentMethodSepaDebit {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentMethodSepaDebit' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentMethodSepaDebit extends IStripeEntity {
}

export class PaymentMethodSepaDebit extends StripeEntityOfPaymentMethodSepaDebit implements IPaymentMethodSepaDebit {
    /** Bank code of bank associated with the bank account. */
    bankCode?: string | undefined;
    /** Branch code of bank associated with the bank account. */
    branchCode?: string | undefined;
    /** Two-letter ISO code representing the country the bank account is located in. */
    country?: string | undefined;
    /** Uniquely identifies this particular bank account. You can use this attribute to check
whether two bank accounts are the same. */
    fingerprint?: string | undefined;
    /** Information about the object that generated this PaymentMethod. */
    generatedFrom?: PaymentMethodSepaDebitGeneratedFrom | undefined;
    /** Last four characters of the IBAN. */
    last4?: string | undefined;

    constructor(data?: IPaymentMethodSepaDebit) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.bankCode = _data["bankCode"];
            this.branchCode = _data["branchCode"];
            this.country = _data["country"];
            this.fingerprint = _data["fingerprint"];
            this.generatedFrom = _data["generatedFrom"] ? PaymentMethodSepaDebitGeneratedFrom.fromJS(_data["generatedFrom"]) : <any>undefined;
            this.last4 = _data["last4"];
        }
    }

    static override fromJS(data: any): PaymentMethodSepaDebit {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodSepaDebit();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankCode"] = this.bankCode;
        data["branchCode"] = this.branchCode;
        data["country"] = this.country;
        data["fingerprint"] = this.fingerprint;
        data["generatedFrom"] = this.generatedFrom ? this.generatedFrom.toJSON() : <any>undefined;
        data["last4"] = this.last4;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentMethodSepaDebit extends IStripeEntityOfPaymentMethodSepaDebit {
    /** Bank code of bank associated with the bank account. */
    bankCode?: string | undefined;
    /** Branch code of bank associated with the bank account. */
    branchCode?: string | undefined;
    /** Two-letter ISO code representing the country the bank account is located in. */
    country?: string | undefined;
    /** Uniquely identifies this particular bank account. You can use this attribute to check
whether two bank accounts are the same. */
    fingerprint?: string | undefined;
    /** Information about the object that generated this PaymentMethod. */
    generatedFrom?: PaymentMethodSepaDebitGeneratedFrom | undefined;
    /** Last four characters of the IBAN. */
    last4?: string | undefined;
}

export abstract class StripeEntityOfPaymentMethodSepaDebitGeneratedFrom extends StripeEntity implements IStripeEntityOfPaymentMethodSepaDebitGeneratedFrom {

    constructor(data?: IStripeEntityOfPaymentMethodSepaDebitGeneratedFrom) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentMethodSepaDebitGeneratedFrom {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentMethodSepaDebitGeneratedFrom' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentMethodSepaDebitGeneratedFrom extends IStripeEntity {
}

export class PaymentMethodSepaDebitGeneratedFrom extends StripeEntityOfPaymentMethodSepaDebitGeneratedFrom implements IPaymentMethodSepaDebitGeneratedFrom {
    /** (ID of the Charge)
The ID of the Charge that generated this PaymentMethod, if any. */
    chargeId?: string | undefined;
    /** (Expanded)
The ID of the Charge that generated this PaymentMethod, if any.
            
For more information, see the expand documentation. */
    charge?: Charge | undefined;
    internalCharge?: ExpandableFieldOfCharge | undefined;
    /** (ID of the SetupAttempt)
The ID of the SetupAttempt that generated this PaymentMethod, if any. */
    setupAttemptId?: string | undefined;
    /** (Expanded)
The ID of the SetupAttempt that generated this PaymentMethod, if any.
            
For more information, see the expand documentation. */
    setupAttempt?: SetupAttempt | undefined;
    internalSetupAttempt?: ExpandableFieldOfSetupAttempt | undefined;

    constructor(data?: IPaymentMethodSepaDebitGeneratedFrom) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.chargeId = _data["chargeId"];
            this.charge = _data["charge"] ? Charge.fromJS(_data["charge"]) : <any>undefined;
            this.internalCharge = _data["internalCharge"] ? ExpandableFieldOfCharge.fromJS(_data["internalCharge"]) : <any>undefined;
            this.setupAttemptId = _data["setupAttemptId"];
            this.setupAttempt = _data["setupAttempt"] ? SetupAttempt.fromJS(_data["setupAttempt"]) : <any>undefined;
            this.internalSetupAttempt = _data["internalSetupAttempt"] ? ExpandableFieldOfSetupAttempt.fromJS(_data["internalSetupAttempt"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): PaymentMethodSepaDebitGeneratedFrom {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodSepaDebitGeneratedFrom();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["chargeId"] = this.chargeId;
        data["charge"] = this.charge ? this.charge.toJSON() : <any>undefined;
        data["internalCharge"] = this.internalCharge ? this.internalCharge.toJSON() : <any>undefined;
        data["setupAttemptId"] = this.setupAttemptId;
        data["setupAttempt"] = this.setupAttempt ? this.setupAttempt.toJSON() : <any>undefined;
        data["internalSetupAttempt"] = this.internalSetupAttempt ? this.internalSetupAttempt.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentMethodSepaDebitGeneratedFrom extends IStripeEntityOfPaymentMethodSepaDebitGeneratedFrom {
    /** (ID of the Charge)
The ID of the Charge that generated this PaymentMethod, if any. */
    chargeId?: string | undefined;
    /** (Expanded)
The ID of the Charge that generated this PaymentMethod, if any.
            
For more information, see the expand documentation. */
    charge?: Charge | undefined;
    internalCharge?: ExpandableFieldOfCharge | undefined;
    /** (ID of the SetupAttempt)
The ID of the SetupAttempt that generated this PaymentMethod, if any. */
    setupAttemptId?: string | undefined;
    /** (Expanded)
The ID of the SetupAttempt that generated this PaymentMethod, if any.
            
For more information, see the expand documentation. */
    setupAttempt?: SetupAttempt | undefined;
    internalSetupAttempt?: ExpandableFieldOfSetupAttempt | undefined;
}

export abstract class StripeEntityOfCharge extends StripeEntity implements IStripeEntityOfCharge {

    constructor(data?: IStripeEntityOfCharge) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfCharge {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfCharge' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfCharge extends IStripeEntity {
}

/** To charge a credit or a debit card, you create a Charge object. You can retrieve and refund individual charges as well as list all charges. Charges are identified by a unique, random ID.            Related guide: Accept a payment with the Charges API. */
export class Charge extends StripeEntityOfCharge implements ICharge {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** Amount intended to be collected by this payment. A positive integer representing how
much to charge in the smallest
currency unit (e.g., 100 cents to charge $1.00 or 100 to charge ¥100, a zero-decimal
currency). The minimum amount is $0.50 US or equivalent
in charge currency. The amount value supports up to eight digits (e.g., a value of
99999999 for a USD charge of $999,999.99). */
    amount?: number;
    /** Amount in %s captured (can be less than the amount attribute on the charge if a partial
capture was made). */
    amountCaptured?: number;
    /** Amount in %s refunded (can be less than the amount attribute on the charge if a partial
refund was issued). */
    amountRefunded?: number;
    /** (ID of the Application)
ID of the Connect application that created the charge. */
    applicationId?: string | undefined;
    /** (Expanded)
ID of the Connect application that created the charge.
            
For more information, see the expand documentation. */
    application?: Application | undefined;
    internalApplication?: ExpandableFieldOfApplication | undefined;
    /** (ID of the ApplicationFee)
The application fee (if any) for the charge. See the Connect
documentation for details. */
    applicationFeeId?: string | undefined;
    /** (Expanded)
The application fee (if any) for the charge. See the Connect
documentation for details.
            
For more information, see the expand documentation. */
    applicationFee?: ApplicationFee | undefined;
    internalApplicationFee?: ExpandableFieldOfApplicationFee | undefined;
    /** The amount of the application fee (if any) requested for the charge. See the Connect
documentation for details. */
    applicationFeeAmount?: number | undefined;
    /** Authorization code on the charge. */
    authorizationCode?: string | undefined;
    /** (ID of the BalanceTransaction)
ID of the balance transaction that describes the impact of this charge on your account
balance (not including refunds or disputes). */
    balanceTransactionId?: string | undefined;
    /** (Expanded)
ID of the balance transaction that describes the impact of this charge on your account
balance (not including refunds or disputes).
            
For more information, see the expand documentation. */
    balanceTransaction?: BalanceTransaction | undefined;
    internalBalanceTransaction?: ExpandableFieldOfBalanceTransaction | undefined;
    billingDetails?: ChargeBillingDetails | undefined;
    /** The full statement descriptor that is passed to card networks, and that is displayed on
your customers' credit card and bank statements. Allows you to see what the statement
descriptor looks like after the static and dynamic portions are combined. */
    calculatedStatementDescriptor?: string | undefined;
    /** If the charge was created without capturing, this Boolean represents whether it is still
uncaptured or has since been captured. */
    captured?: boolean;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** Three-letter ISO currency
code, in lowercase. Must be a supported
currency. */
    currency?: string | undefined;
    /** (ID of the Customer)
ID of the customer this charge is for if one exists. */
    customerId?: string | undefined;
    /** (Expanded)
ID of the customer this charge is for if one exists.
            
For more information, see the expand documentation. */
    customer?: Customer2 | undefined;
    internalCustomer?: ExpandableFieldOfCustomer | undefined;
    /** An arbitrary string attached to the object. Often useful for displaying to users. */
    description?: string | undefined;
    /** (ID of the Account)
ID of an existing, connected Stripe account to transfer funds to if transfer_data
was specified in the charge request. */
    destinationId?: string | undefined;
    /** (Expanded)
ID of an existing, connected Stripe account to transfer funds to if transfer_data
was specified in the charge request.
            
For more information, see the expand documentation. */
    destination?: Account | undefined;
    internalDestination?: ExpandableFieldOfAccount | undefined;
    /** (ID of the Dispute)
Details about the dispute if the charge has been disputed. */
    disputeId?: string | undefined;
    /** (Expanded)
Details about the dispute if the charge has been disputed.
            
For more information, see the expand documentation. */
    dispute?: Dispute | undefined;
    internalDispute?: ExpandableFieldOfDispute | undefined;
    /** Whether the charge has been disputed. */
    disputed?: boolean;
    /** (ID of the BalanceTransaction)
ID of the balance transaction that describes the reversal of the balance on your account
due to payment failure. */
    failureBalanceTransactionId?: string | undefined;
    /** (Expanded)
ID of the balance transaction that describes the reversal of the balance on your account
due to payment failure.
            
For more information, see the expand documentation. */
    failureBalanceTransaction?: BalanceTransaction | undefined;
    internalFailureBalanceTransaction?: ExpandableFieldOfBalanceTransaction | undefined;
    /** Error code explaining reason for charge failure if available (see the errors section for a list of codes). */
    failureCode?: string | undefined;
    /** Message to user further explaining reason for charge failure if available. */
    failureMessage?: string | undefined;
    /** Information on fraud assessments for the charge. */
    fraudDetails?: ChargeFraudDetails | undefined;
    /** (ID of the Invoice)
ID of the invoice this charge is for if one exists. */
    invoiceId?: string | undefined;
    /** (Expanded)
ID of the invoice this charge is for if one exists.
            
For more information, see the expand documentation. */
    invoice?: Invoice | undefined;
    internalInvoice?: ExpandableFieldOfInvoice | undefined;
    level3?: ChargeLevel3 | undefined;
    /** Has the value true if the object exists in live mode or the value false if
the object exists in test mode. */
    livemode?: boolean;
    /** Set of key-value pairs that you can
attach to an object. This can be useful for storing additional information about the
object in a structured format. */
    metadata?: { [key: string]: string; } | undefined;
    /** (ID of the Account)
The account (if any) the charge was made on behalf of without triggering an automatic
transfer. See the Connect
documentation for details. */
    onBehalfOfId?: string | undefined;
    /** (Expanded)
The account (if any) the charge was made on behalf of without triggering an automatic
transfer. See the Connect
documentation for details.
            
For more information, see the expand documentation. */
    onBehalfOf?: Account | undefined;
    internalOnBehalfOf?: ExpandableFieldOfAccount | undefined;
    /** Details about whether the payment was accepted, and why. See understanding declines for details. */
    outcome?: ChargeOutcome | undefined;
    /** true if the charge succeeded, or was successfully authorized for later capture. */
    paid?: boolean;
    /** (ID of the PaymentIntent)
ID of the PaymentIntent associated with this charge, if one exists. */
    paymentIntentId?: string | undefined;
    /** (Expanded)
ID of the PaymentIntent associated with this charge, if one exists.
            
For more information, see the expand documentation. */
    paymentIntent?: PaymentIntent | undefined;
    internalPaymentIntent?: ExpandableFieldOfPaymentIntent | undefined;
    /** ID of the payment method used in this charge. */
    paymentMethod?: string | undefined;
    /** Details about the payment method at the time of the transaction. */
    paymentMethodDetails?: ChargePaymentMethodDetails | undefined;
    /** Options to configure Radar. See Radar Session for more
information. */
    radarOptions?: ChargeRadarOptions | undefined;
    /** This is the email address that the receipt for this charge was sent to. */
    receiptEmail?: string | undefined;
    /** This is the transaction number that appears on email receipts sent for this charge. This
attribute will be null until a receipt has been sent. */
    receiptNumber?: string | undefined;
    /** This is the URL to view the receipt for this charge. The receipt is kept up-to-date to
the latest state of the charge, including any refunds. If the charge is for an Invoice,
the receipt will be stylized as an Invoice receipt. */
    receiptUrl?: string | undefined;
    /** Whether the charge has been fully refunded. If the charge is only partially refunded,
this attribute will still be false. */
    refunded?: boolean;
    /** A list of refunds that have been applied to the charge. */
    refunds?: StripeListOfRefund | undefined;
    /** (ID of the Review)
ID of the review associated with this charge if one exists. */
    reviewId?: string | undefined;
    /** (Expanded)
ID of the review associated with this charge if one exists.
            
For more information, see the expand documentation. */
    review?: Review2 | undefined;
    internalReview?: ExpandableFieldOfReview | undefined;
    /** Shipping information for the charge. */
    shipping?: Shipping | undefined;
    /** This is a legacy field that will be removed in the future. It contains the Source, Card,
or BankAccount object used for the charge. For details about the payment method used for
this charge, refer to payment_method or payment_method_details instead. */
    source?: IPaymentSource | undefined;
    /** (ID of the Transfer)
The transfer ID which created this charge. Only present if the charge came from another
Stripe account. See the
Connect documentation for details. */
    sourceTransferId?: string | undefined;
    /** (Expanded)
The transfer ID which created this charge. Only present if the charge came from another
Stripe account. See the
Connect documentation for details.
            
For more information, see the expand documentation. */
    sourceTransfer?: Transfer | undefined;
    internalSourceTransfer?: ExpandableFieldOfTransfer | undefined;
    /** For card charges, use statement_descriptor_suffix instead. Otherwise, you can use
this value as the complete description of a charge on your customers’ statements. Must
contain at least one letter, maximum 22 characters. */
    statementDescriptor?: string | undefined;
    /** Provides information about the charge that customers see on their statements.
Concatenated with the prefix (shortened descriptor) or statement descriptor that’s set
on the account to form the complete statement descriptor. Maximum 22 characters for the
concatenated descriptor. */
    statementDescriptorSuffix?: string | undefined;
    /** The status of the payment is either succeeded, pending, or failed.
One of: failed, pending, or succeeded. */
    status?: string | undefined;
    /** (ID of the Transfer)
ID of the transfer to the destination account (only applicable if the charge was
created using the destination parameter). */
    transferId?: string | undefined;
    /** (Expanded)
ID of the transfer to the destination account (only applicable if the charge was
created using the destination parameter).
            
For more information, see the expand documentation. */
    transfer?: Transfer | undefined;
    internalTransfer?: ExpandableFieldOfTransfer | undefined;
    /** An optional dictionary including the account to automatically transfer to as part of a
destination charge. See
the Connect documentation for details. */
    transferData?: ChargeTransferData | undefined;
    /** A string that identifies this transaction as part of a group. See the Connect
documentation for details. */
    transferGroup?: string | undefined;

    constructor(data?: ICharge) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.object = _data["object"];
            this.amount = _data["amount"];
            this.amountCaptured = _data["amountCaptured"];
            this.amountRefunded = _data["amountRefunded"];
            this.applicationId = _data["applicationId"];
            this.application = _data["application"] ? Application.fromJS(_data["application"]) : <any>undefined;
            this.internalApplication = _data["internalApplication"] ? ExpandableFieldOfApplication.fromJS(_data["internalApplication"]) : <any>undefined;
            this.applicationFeeId = _data["applicationFeeId"];
            this.applicationFee = _data["applicationFee"] ? ApplicationFee.fromJS(_data["applicationFee"]) : <any>undefined;
            this.internalApplicationFee = _data["internalApplicationFee"] ? ExpandableFieldOfApplicationFee.fromJS(_data["internalApplicationFee"]) : <any>undefined;
            this.applicationFeeAmount = _data["applicationFeeAmount"];
            this.authorizationCode = _data["authorizationCode"];
            this.balanceTransactionId = _data["balanceTransactionId"];
            this.balanceTransaction = _data["balanceTransaction"] ? BalanceTransaction.fromJS(_data["balanceTransaction"]) : <any>undefined;
            this.internalBalanceTransaction = _data["internalBalanceTransaction"] ? ExpandableFieldOfBalanceTransaction.fromJS(_data["internalBalanceTransaction"]) : <any>undefined;
            this.billingDetails = _data["billingDetails"] ? ChargeBillingDetails.fromJS(_data["billingDetails"]) : <any>undefined;
            this.calculatedStatementDescriptor = _data["calculatedStatementDescriptor"];
            this.captured = _data["captured"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.currency = _data["currency"];
            this.customerId = _data["customerId"];
            this.customer = _data["customer"] ? Customer2.fromJS(_data["customer"]) : <any>undefined;
            this.internalCustomer = _data["internalCustomer"] ? ExpandableFieldOfCustomer.fromJS(_data["internalCustomer"]) : <any>undefined;
            this.description = _data["description"];
            this.destinationId = _data["destinationId"];
            this.destination = _data["destination"] ? Account.fromJS(_data["destination"]) : <any>undefined;
            this.internalDestination = _data["internalDestination"] ? ExpandableFieldOfAccount.fromJS(_data["internalDestination"]) : <any>undefined;
            this.disputeId = _data["disputeId"];
            this.dispute = _data["dispute"] ? Dispute.fromJS(_data["dispute"]) : <any>undefined;
            this.internalDispute = _data["internalDispute"] ? ExpandableFieldOfDispute.fromJS(_data["internalDispute"]) : <any>undefined;
            this.disputed = _data["disputed"];
            this.failureBalanceTransactionId = _data["failureBalanceTransactionId"];
            this.failureBalanceTransaction = _data["failureBalanceTransaction"] ? BalanceTransaction.fromJS(_data["failureBalanceTransaction"]) : <any>undefined;
            this.internalFailureBalanceTransaction = _data["internalFailureBalanceTransaction"] ? ExpandableFieldOfBalanceTransaction.fromJS(_data["internalFailureBalanceTransaction"]) : <any>undefined;
            this.failureCode = _data["failureCode"];
            this.failureMessage = _data["failureMessage"];
            this.fraudDetails = _data["fraudDetails"] ? ChargeFraudDetails.fromJS(_data["fraudDetails"]) : <any>undefined;
            this.invoiceId = _data["invoiceId"];
            this.invoice = _data["invoice"] ? Invoice.fromJS(_data["invoice"]) : <any>undefined;
            this.internalInvoice = _data["internalInvoice"] ? ExpandableFieldOfInvoice.fromJS(_data["internalInvoice"]) : <any>undefined;
            this.level3 = _data["level3"] ? ChargeLevel3.fromJS(_data["level3"]) : <any>undefined;
            this.livemode = _data["livemode"];
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
            this.onBehalfOfId = _data["onBehalfOfId"];
            this.onBehalfOf = _data["onBehalfOf"] ? Account.fromJS(_data["onBehalfOf"]) : <any>undefined;
            this.internalOnBehalfOf = _data["internalOnBehalfOf"] ? ExpandableFieldOfAccount.fromJS(_data["internalOnBehalfOf"]) : <any>undefined;
            this.outcome = _data["outcome"] ? ChargeOutcome.fromJS(_data["outcome"]) : <any>undefined;
            this.paid = _data["paid"];
            this.paymentIntentId = _data["paymentIntentId"];
            this.paymentIntent = _data["paymentIntent"] ? PaymentIntent.fromJS(_data["paymentIntent"]) : <any>undefined;
            this.internalPaymentIntent = _data["internalPaymentIntent"] ? ExpandableFieldOfPaymentIntent.fromJS(_data["internalPaymentIntent"]) : <any>undefined;
            this.paymentMethod = _data["paymentMethod"];
            this.paymentMethodDetails = _data["paymentMethodDetails"] ? ChargePaymentMethodDetails.fromJS(_data["paymentMethodDetails"]) : <any>undefined;
            this.radarOptions = _data["radarOptions"] ? ChargeRadarOptions.fromJS(_data["radarOptions"]) : <any>undefined;
            this.receiptEmail = _data["receiptEmail"];
            this.receiptNumber = _data["receiptNumber"];
            this.receiptUrl = _data["receiptUrl"];
            this.refunded = _data["refunded"];
            this.refunds = _data["refunds"] ? StripeListOfRefund.fromJS(_data["refunds"]) : <any>undefined;
            this.reviewId = _data["reviewId"];
            this.review = _data["review"] ? Review2.fromJS(_data["review"]) : <any>undefined;
            this.internalReview = _data["internalReview"] ? ExpandableFieldOfReview.fromJS(_data["internalReview"]) : <any>undefined;
            this.shipping = _data["shipping"] ? Shipping.fromJS(_data["shipping"]) : <any>undefined;
            this.source = _data["source"] ? IPaymentSource.fromJS(_data["source"]) : <any>undefined;
            this.sourceTransferId = _data["sourceTransferId"];
            this.sourceTransfer = _data["sourceTransfer"] ? Transfer.fromJS(_data["sourceTransfer"]) : <any>undefined;
            this.internalSourceTransfer = _data["internalSourceTransfer"] ? ExpandableFieldOfTransfer.fromJS(_data["internalSourceTransfer"]) : <any>undefined;
            this.statementDescriptor = _data["statementDescriptor"];
            this.statementDescriptorSuffix = _data["statementDescriptorSuffix"];
            this.status = _data["status"];
            this.transferId = _data["transferId"];
            this.transfer = _data["transfer"] ? Transfer.fromJS(_data["transfer"]) : <any>undefined;
            this.internalTransfer = _data["internalTransfer"] ? ExpandableFieldOfTransfer.fromJS(_data["internalTransfer"]) : <any>undefined;
            this.transferData = _data["transferData"] ? ChargeTransferData.fromJS(_data["transferData"]) : <any>undefined;
            this.transferGroup = _data["transferGroup"];
        }
    }

    static override fromJS(data: any): Charge {
        data = typeof data === 'object' ? data : {};
        let result = new Charge();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["object"] = this.object;
        data["amount"] = this.amount;
        data["amountCaptured"] = this.amountCaptured;
        data["amountRefunded"] = this.amountRefunded;
        data["applicationId"] = this.applicationId;
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["internalApplication"] = this.internalApplication ? this.internalApplication.toJSON() : <any>undefined;
        data["applicationFeeId"] = this.applicationFeeId;
        data["applicationFee"] = this.applicationFee ? this.applicationFee.toJSON() : <any>undefined;
        data["internalApplicationFee"] = this.internalApplicationFee ? this.internalApplicationFee.toJSON() : <any>undefined;
        data["applicationFeeAmount"] = this.applicationFeeAmount;
        data["authorizationCode"] = this.authorizationCode;
        data["balanceTransactionId"] = this.balanceTransactionId;
        data["balanceTransaction"] = this.balanceTransaction ? this.balanceTransaction.toJSON() : <any>undefined;
        data["internalBalanceTransaction"] = this.internalBalanceTransaction ? this.internalBalanceTransaction.toJSON() : <any>undefined;
        data["billingDetails"] = this.billingDetails ? this.billingDetails.toJSON() : <any>undefined;
        data["calculatedStatementDescriptor"] = this.calculatedStatementDescriptor;
        data["captured"] = this.captured;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["currency"] = this.currency;
        data["customerId"] = this.customerId;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["internalCustomer"] = this.internalCustomer ? this.internalCustomer.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["destinationId"] = this.destinationId;
        data["destination"] = this.destination ? this.destination.toJSON() : <any>undefined;
        data["internalDestination"] = this.internalDestination ? this.internalDestination.toJSON() : <any>undefined;
        data["disputeId"] = this.disputeId;
        data["dispute"] = this.dispute ? this.dispute.toJSON() : <any>undefined;
        data["internalDispute"] = this.internalDispute ? this.internalDispute.toJSON() : <any>undefined;
        data["disputed"] = this.disputed;
        data["failureBalanceTransactionId"] = this.failureBalanceTransactionId;
        data["failureBalanceTransaction"] = this.failureBalanceTransaction ? this.failureBalanceTransaction.toJSON() : <any>undefined;
        data["internalFailureBalanceTransaction"] = this.internalFailureBalanceTransaction ? this.internalFailureBalanceTransaction.toJSON() : <any>undefined;
        data["failureCode"] = this.failureCode;
        data["failureMessage"] = this.failureMessage;
        data["fraudDetails"] = this.fraudDetails ? this.fraudDetails.toJSON() : <any>undefined;
        data["invoiceId"] = this.invoiceId;
        data["invoice"] = this.invoice ? this.invoice.toJSON() : <any>undefined;
        data["internalInvoice"] = this.internalInvoice ? this.internalInvoice.toJSON() : <any>undefined;
        data["level3"] = this.level3 ? this.level3.toJSON() : <any>undefined;
        data["livemode"] = this.livemode;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        data["onBehalfOfId"] = this.onBehalfOfId;
        data["onBehalfOf"] = this.onBehalfOf ? this.onBehalfOf.toJSON() : <any>undefined;
        data["internalOnBehalfOf"] = this.internalOnBehalfOf ? this.internalOnBehalfOf.toJSON() : <any>undefined;
        data["outcome"] = this.outcome ? this.outcome.toJSON() : <any>undefined;
        data["paid"] = this.paid;
        data["paymentIntentId"] = this.paymentIntentId;
        data["paymentIntent"] = this.paymentIntent ? this.paymentIntent.toJSON() : <any>undefined;
        data["internalPaymentIntent"] = this.internalPaymentIntent ? this.internalPaymentIntent.toJSON() : <any>undefined;
        data["paymentMethod"] = this.paymentMethod;
        data["paymentMethodDetails"] = this.paymentMethodDetails ? this.paymentMethodDetails.toJSON() : <any>undefined;
        data["radarOptions"] = this.radarOptions ? this.radarOptions.toJSON() : <any>undefined;
        data["receiptEmail"] = this.receiptEmail;
        data["receiptNumber"] = this.receiptNumber;
        data["receiptUrl"] = this.receiptUrl;
        data["refunded"] = this.refunded;
        data["refunds"] = this.refunds ? this.refunds.toJSON() : <any>undefined;
        data["reviewId"] = this.reviewId;
        data["review"] = this.review ? this.review.toJSON() : <any>undefined;
        data["internalReview"] = this.internalReview ? this.internalReview.toJSON() : <any>undefined;
        data["shipping"] = this.shipping ? this.shipping.toJSON() : <any>undefined;
        data["source"] = this.source ? this.source.toJSON() : <any>undefined;
        data["sourceTransferId"] = this.sourceTransferId;
        data["sourceTransfer"] = this.sourceTransfer ? this.sourceTransfer.toJSON() : <any>undefined;
        data["internalSourceTransfer"] = this.internalSourceTransfer ? this.internalSourceTransfer.toJSON() : <any>undefined;
        data["statementDescriptor"] = this.statementDescriptor;
        data["statementDescriptorSuffix"] = this.statementDescriptorSuffix;
        data["status"] = this.status;
        data["transferId"] = this.transferId;
        data["transfer"] = this.transfer ? this.transfer.toJSON() : <any>undefined;
        data["internalTransfer"] = this.internalTransfer ? this.internalTransfer.toJSON() : <any>undefined;
        data["transferData"] = this.transferData ? this.transferData.toJSON() : <any>undefined;
        data["transferGroup"] = this.transferGroup;
        super.toJSON(data);
        return data;
    }
}

/** To charge a credit or a debit card, you create a Charge object. You can retrieve and refund individual charges as well as list all charges. Charges are identified by a unique, random ID.            Related guide: Accept a payment with the Charges API. */
export interface ICharge extends IStripeEntityOfCharge {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** Amount intended to be collected by this payment. A positive integer representing how
much to charge in the smallest
currency unit (e.g., 100 cents to charge $1.00 or 100 to charge ¥100, a zero-decimal
currency). The minimum amount is $0.50 US or equivalent
in charge currency. The amount value supports up to eight digits (e.g., a value of
99999999 for a USD charge of $999,999.99). */
    amount?: number;
    /** Amount in %s captured (can be less than the amount attribute on the charge if a partial
capture was made). */
    amountCaptured?: number;
    /** Amount in %s refunded (can be less than the amount attribute on the charge if a partial
refund was issued). */
    amountRefunded?: number;
    /** (ID of the Application)
ID of the Connect application that created the charge. */
    applicationId?: string | undefined;
    /** (Expanded)
ID of the Connect application that created the charge.
            
For more information, see the expand documentation. */
    application?: Application | undefined;
    internalApplication?: ExpandableFieldOfApplication | undefined;
    /** (ID of the ApplicationFee)
The application fee (if any) for the charge. See the Connect
documentation for details. */
    applicationFeeId?: string | undefined;
    /** (Expanded)
The application fee (if any) for the charge. See the Connect
documentation for details.
            
For more information, see the expand documentation. */
    applicationFee?: ApplicationFee | undefined;
    internalApplicationFee?: ExpandableFieldOfApplicationFee | undefined;
    /** The amount of the application fee (if any) requested for the charge. See the Connect
documentation for details. */
    applicationFeeAmount?: number | undefined;
    /** Authorization code on the charge. */
    authorizationCode?: string | undefined;
    /** (ID of the BalanceTransaction)
ID of the balance transaction that describes the impact of this charge on your account
balance (not including refunds or disputes). */
    balanceTransactionId?: string | undefined;
    /** (Expanded)
ID of the balance transaction that describes the impact of this charge on your account
balance (not including refunds or disputes).
            
For more information, see the expand documentation. */
    balanceTransaction?: BalanceTransaction | undefined;
    internalBalanceTransaction?: ExpandableFieldOfBalanceTransaction | undefined;
    billingDetails?: ChargeBillingDetails | undefined;
    /** The full statement descriptor that is passed to card networks, and that is displayed on
your customers' credit card and bank statements. Allows you to see what the statement
descriptor looks like after the static and dynamic portions are combined. */
    calculatedStatementDescriptor?: string | undefined;
    /** If the charge was created without capturing, this Boolean represents whether it is still
uncaptured or has since been captured. */
    captured?: boolean;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** Three-letter ISO currency
code, in lowercase. Must be a supported
currency. */
    currency?: string | undefined;
    /** (ID of the Customer)
ID of the customer this charge is for if one exists. */
    customerId?: string | undefined;
    /** (Expanded)
ID of the customer this charge is for if one exists.
            
For more information, see the expand documentation. */
    customer?: Customer2 | undefined;
    internalCustomer?: ExpandableFieldOfCustomer | undefined;
    /** An arbitrary string attached to the object. Often useful for displaying to users. */
    description?: string | undefined;
    /** (ID of the Account)
ID of an existing, connected Stripe account to transfer funds to if transfer_data
was specified in the charge request. */
    destinationId?: string | undefined;
    /** (Expanded)
ID of an existing, connected Stripe account to transfer funds to if transfer_data
was specified in the charge request.
            
For more information, see the expand documentation. */
    destination?: Account | undefined;
    internalDestination?: ExpandableFieldOfAccount | undefined;
    /** (ID of the Dispute)
Details about the dispute if the charge has been disputed. */
    disputeId?: string | undefined;
    /** (Expanded)
Details about the dispute if the charge has been disputed.
            
For more information, see the expand documentation. */
    dispute?: Dispute | undefined;
    internalDispute?: ExpandableFieldOfDispute | undefined;
    /** Whether the charge has been disputed. */
    disputed?: boolean;
    /** (ID of the BalanceTransaction)
ID of the balance transaction that describes the reversal of the balance on your account
due to payment failure. */
    failureBalanceTransactionId?: string | undefined;
    /** (Expanded)
ID of the balance transaction that describes the reversal of the balance on your account
due to payment failure.
            
For more information, see the expand documentation. */
    failureBalanceTransaction?: BalanceTransaction | undefined;
    internalFailureBalanceTransaction?: ExpandableFieldOfBalanceTransaction | undefined;
    /** Error code explaining reason for charge failure if available (see the errors section for a list of codes). */
    failureCode?: string | undefined;
    /** Message to user further explaining reason for charge failure if available. */
    failureMessage?: string | undefined;
    /** Information on fraud assessments for the charge. */
    fraudDetails?: ChargeFraudDetails | undefined;
    /** (ID of the Invoice)
ID of the invoice this charge is for if one exists. */
    invoiceId?: string | undefined;
    /** (Expanded)
ID of the invoice this charge is for if one exists.
            
For more information, see the expand documentation. */
    invoice?: Invoice | undefined;
    internalInvoice?: ExpandableFieldOfInvoice | undefined;
    level3?: ChargeLevel3 | undefined;
    /** Has the value true if the object exists in live mode or the value false if
the object exists in test mode. */
    livemode?: boolean;
    /** Set of key-value pairs that you can
attach to an object. This can be useful for storing additional information about the
object in a structured format. */
    metadata?: { [key: string]: string; } | undefined;
    /** (ID of the Account)
The account (if any) the charge was made on behalf of without triggering an automatic
transfer. See the Connect
documentation for details. */
    onBehalfOfId?: string | undefined;
    /** (Expanded)
The account (if any) the charge was made on behalf of without triggering an automatic
transfer. See the Connect
documentation for details.
            
For more information, see the expand documentation. */
    onBehalfOf?: Account | undefined;
    internalOnBehalfOf?: ExpandableFieldOfAccount | undefined;
    /** Details about whether the payment was accepted, and why. See understanding declines for details. */
    outcome?: ChargeOutcome | undefined;
    /** true if the charge succeeded, or was successfully authorized for later capture. */
    paid?: boolean;
    /** (ID of the PaymentIntent)
ID of the PaymentIntent associated with this charge, if one exists. */
    paymentIntentId?: string | undefined;
    /** (Expanded)
ID of the PaymentIntent associated with this charge, if one exists.
            
For more information, see the expand documentation. */
    paymentIntent?: PaymentIntent | undefined;
    internalPaymentIntent?: ExpandableFieldOfPaymentIntent | undefined;
    /** ID of the payment method used in this charge. */
    paymentMethod?: string | undefined;
    /** Details about the payment method at the time of the transaction. */
    paymentMethodDetails?: ChargePaymentMethodDetails | undefined;
    /** Options to configure Radar. See Radar Session for more
information. */
    radarOptions?: ChargeRadarOptions | undefined;
    /** This is the email address that the receipt for this charge was sent to. */
    receiptEmail?: string | undefined;
    /** This is the transaction number that appears on email receipts sent for this charge. This
attribute will be null until a receipt has been sent. */
    receiptNumber?: string | undefined;
    /** This is the URL to view the receipt for this charge. The receipt is kept up-to-date to
the latest state of the charge, including any refunds. If the charge is for an Invoice,
the receipt will be stylized as an Invoice receipt. */
    receiptUrl?: string | undefined;
    /** Whether the charge has been fully refunded. If the charge is only partially refunded,
this attribute will still be false. */
    refunded?: boolean;
    /** A list of refunds that have been applied to the charge. */
    refunds?: StripeListOfRefund | undefined;
    /** (ID of the Review)
ID of the review associated with this charge if one exists. */
    reviewId?: string | undefined;
    /** (Expanded)
ID of the review associated with this charge if one exists.
            
For more information, see the expand documentation. */
    review?: Review2 | undefined;
    internalReview?: ExpandableFieldOfReview | undefined;
    /** Shipping information for the charge. */
    shipping?: Shipping | undefined;
    /** This is a legacy field that will be removed in the future. It contains the Source, Card,
or BankAccount object used for the charge. For details about the payment method used for
this charge, refer to payment_method or payment_method_details instead. */
    source?: IPaymentSource | undefined;
    /** (ID of the Transfer)
The transfer ID which created this charge. Only present if the charge came from another
Stripe account. See the
Connect documentation for details. */
    sourceTransferId?: string | undefined;
    /** (Expanded)
The transfer ID which created this charge. Only present if the charge came from another
Stripe account. See the
Connect documentation for details.
            
For more information, see the expand documentation. */
    sourceTransfer?: Transfer | undefined;
    internalSourceTransfer?: ExpandableFieldOfTransfer | undefined;
    /** For card charges, use statement_descriptor_suffix instead. Otherwise, you can use
this value as the complete description of a charge on your customers’ statements. Must
contain at least one letter, maximum 22 characters. */
    statementDescriptor?: string | undefined;
    /** Provides information about the charge that customers see on their statements.
Concatenated with the prefix (shortened descriptor) or statement descriptor that’s set
on the account to form the complete statement descriptor. Maximum 22 characters for the
concatenated descriptor. */
    statementDescriptorSuffix?: string | undefined;
    /** The status of the payment is either succeeded, pending, or failed.
One of: failed, pending, or succeeded. */
    status?: string | undefined;
    /** (ID of the Transfer)
ID of the transfer to the destination account (only applicable if the charge was
created using the destination parameter). */
    transferId?: string | undefined;
    /** (Expanded)
ID of the transfer to the destination account (only applicable if the charge was
created using the destination parameter).
            
For more information, see the expand documentation. */
    transfer?: Transfer | undefined;
    internalTransfer?: ExpandableFieldOfTransfer | undefined;
    /** An optional dictionary including the account to automatically transfer to as part of a
destination charge. See
the Connect documentation for details. */
    transferData?: ChargeTransferData | undefined;
    /** A string that identifies this transaction as part of a group. See the Connect
documentation for details. */
    transferGroup?: string | undefined;
}

export abstract class StripeEntityOfApplicationFee extends StripeEntity implements IStripeEntityOfApplicationFee {

    constructor(data?: IStripeEntityOfApplicationFee) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfApplicationFee {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfApplicationFee' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfApplicationFee extends IStripeEntity {
}

export class ApplicationFee extends StripeEntityOfApplicationFee implements IApplicationFee {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** (ID of the Account)
ID of the Stripe account this fee was taken from. */
    accountId?: string | undefined;
    /** (Expanded)
ID of the Stripe account this fee was taken from.
            
For more information, see the expand documentation. */
    account?: Account | undefined;
    internalAccount?: ExpandableFieldOfAccount | undefined;
    /** Amount earned, in %s. */
    amount?: number;
    /** Amount in %s refunded (can be less than the amount attribute on the fee if a partial
refund was issued). */
    amountRefunded?: number;
    /** (ID of the Application)
ID of the Connect application that earned the fee. */
    applicationId?: string | undefined;
    /** (Expanded)
ID of the Connect application that earned the fee.
            
For more information, see the expand documentation. */
    application?: Application | undefined;
    internalApplication?: ExpandableFieldOfApplication | undefined;
    /** (ID of the BalanceTransaction)
Balance transaction that describes the impact of this collected application fee on your
account balance (not including refunds). */
    balanceTransactionId?: string | undefined;
    /** (Expanded)
Balance transaction that describes the impact of this collected application fee on your
account balance (not including refunds).
            
For more information, see the expand documentation. */
    balanceTransaction?: BalanceTransaction | undefined;
    internalBalanceTransaction?: ExpandableFieldOfBalanceTransaction | undefined;
    /** (ID of the Charge)
ID of the charge that the application fee was taken from. */
    chargeId?: string | undefined;
    /** (Expanded)
ID of the charge that the application fee was taken from.
            
For more information, see the expand documentation. */
    charge?: Charge | undefined;
    internalCharge?: ExpandableFieldOfCharge | undefined;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** Three-letter ISO currency
code, in lowercase. Must be a supported
currency. */
    currency?: string | undefined;
    /** Has the value true if the object exists in live mode or the value false if
the object exists in test mode. */
    livemode?: boolean;
    /** (ID of the Charge)
ID of the corresponding charge on the platform account, if this fee was the result of a
charge using the destination parameter. */
    originatingTransactionId?: string | undefined;
    /** (Expanded)
ID of the corresponding charge on the platform account, if this fee was the result of a
charge using the destination parameter.
            
For more information, see the expand documentation. */
    originatingTransaction?: Charge | undefined;
    internalOriginatingTransaction?: ExpandableFieldOfCharge | undefined;
    /** Whether the fee has been fully refunded. If the fee is only partially refunded, this
attribute will still be false. */
    refunded?: boolean;
    /** A list of refunds that have been applied to the fee. */
    refunds?: StripeListOfApplicationFeeRefund | undefined;

    constructor(data?: IApplicationFee) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.object = _data["object"];
            this.accountId = _data["accountId"];
            this.account = _data["account"] ? Account.fromJS(_data["account"]) : <any>undefined;
            this.internalAccount = _data["internalAccount"] ? ExpandableFieldOfAccount.fromJS(_data["internalAccount"]) : <any>undefined;
            this.amount = _data["amount"];
            this.amountRefunded = _data["amountRefunded"];
            this.applicationId = _data["applicationId"];
            this.application = _data["application"] ? Application.fromJS(_data["application"]) : <any>undefined;
            this.internalApplication = _data["internalApplication"] ? ExpandableFieldOfApplication.fromJS(_data["internalApplication"]) : <any>undefined;
            this.balanceTransactionId = _data["balanceTransactionId"];
            this.balanceTransaction = _data["balanceTransaction"] ? BalanceTransaction.fromJS(_data["balanceTransaction"]) : <any>undefined;
            this.internalBalanceTransaction = _data["internalBalanceTransaction"] ? ExpandableFieldOfBalanceTransaction.fromJS(_data["internalBalanceTransaction"]) : <any>undefined;
            this.chargeId = _data["chargeId"];
            this.charge = _data["charge"] ? Charge.fromJS(_data["charge"]) : <any>undefined;
            this.internalCharge = _data["internalCharge"] ? ExpandableFieldOfCharge.fromJS(_data["internalCharge"]) : <any>undefined;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.currency = _data["currency"];
            this.livemode = _data["livemode"];
            this.originatingTransactionId = _data["originatingTransactionId"];
            this.originatingTransaction = _data["originatingTransaction"] ? Charge.fromJS(_data["originatingTransaction"]) : <any>undefined;
            this.internalOriginatingTransaction = _data["internalOriginatingTransaction"] ? ExpandableFieldOfCharge.fromJS(_data["internalOriginatingTransaction"]) : <any>undefined;
            this.refunded = _data["refunded"];
            this.refunds = _data["refunds"] ? StripeListOfApplicationFeeRefund.fromJS(_data["refunds"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): ApplicationFee {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationFee();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["object"] = this.object;
        data["accountId"] = this.accountId;
        data["account"] = this.account ? this.account.toJSON() : <any>undefined;
        data["internalAccount"] = this.internalAccount ? this.internalAccount.toJSON() : <any>undefined;
        data["amount"] = this.amount;
        data["amountRefunded"] = this.amountRefunded;
        data["applicationId"] = this.applicationId;
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["internalApplication"] = this.internalApplication ? this.internalApplication.toJSON() : <any>undefined;
        data["balanceTransactionId"] = this.balanceTransactionId;
        data["balanceTransaction"] = this.balanceTransaction ? this.balanceTransaction.toJSON() : <any>undefined;
        data["internalBalanceTransaction"] = this.internalBalanceTransaction ? this.internalBalanceTransaction.toJSON() : <any>undefined;
        data["chargeId"] = this.chargeId;
        data["charge"] = this.charge ? this.charge.toJSON() : <any>undefined;
        data["internalCharge"] = this.internalCharge ? this.internalCharge.toJSON() : <any>undefined;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["currency"] = this.currency;
        data["livemode"] = this.livemode;
        data["originatingTransactionId"] = this.originatingTransactionId;
        data["originatingTransaction"] = this.originatingTransaction ? this.originatingTransaction.toJSON() : <any>undefined;
        data["internalOriginatingTransaction"] = this.internalOriginatingTransaction ? this.internalOriginatingTransaction.toJSON() : <any>undefined;
        data["refunded"] = this.refunded;
        data["refunds"] = this.refunds ? this.refunds.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IApplicationFee extends IStripeEntityOfApplicationFee {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** (ID of the Account)
ID of the Stripe account this fee was taken from. */
    accountId?: string | undefined;
    /** (Expanded)
ID of the Stripe account this fee was taken from.
            
For more information, see the expand documentation. */
    account?: Account | undefined;
    internalAccount?: ExpandableFieldOfAccount | undefined;
    /** Amount earned, in %s. */
    amount?: number;
    /** Amount in %s refunded (can be less than the amount attribute on the fee if a partial
refund was issued). */
    amountRefunded?: number;
    /** (ID of the Application)
ID of the Connect application that earned the fee. */
    applicationId?: string | undefined;
    /** (Expanded)
ID of the Connect application that earned the fee.
            
For more information, see the expand documentation. */
    application?: Application | undefined;
    internalApplication?: ExpandableFieldOfApplication | undefined;
    /** (ID of the BalanceTransaction)
Balance transaction that describes the impact of this collected application fee on your
account balance (not including refunds). */
    balanceTransactionId?: string | undefined;
    /** (Expanded)
Balance transaction that describes the impact of this collected application fee on your
account balance (not including refunds).
            
For more information, see the expand documentation. */
    balanceTransaction?: BalanceTransaction | undefined;
    internalBalanceTransaction?: ExpandableFieldOfBalanceTransaction | undefined;
    /** (ID of the Charge)
ID of the charge that the application fee was taken from. */
    chargeId?: string | undefined;
    /** (Expanded)
ID of the charge that the application fee was taken from.
            
For more information, see the expand documentation. */
    charge?: Charge | undefined;
    internalCharge?: ExpandableFieldOfCharge | undefined;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** Three-letter ISO currency
code, in lowercase. Must be a supported
currency. */
    currency?: string | undefined;
    /** Has the value true if the object exists in live mode or the value false if
the object exists in test mode. */
    livemode?: boolean;
    /** (ID of the Charge)
ID of the corresponding charge on the platform account, if this fee was the result of a
charge using the destination parameter. */
    originatingTransactionId?: string | undefined;
    /** (Expanded)
ID of the corresponding charge on the platform account, if this fee was the result of a
charge using the destination parameter.
            
For more information, see the expand documentation. */
    originatingTransaction?: Charge | undefined;
    internalOriginatingTransaction?: ExpandableFieldOfCharge | undefined;
    /** Whether the fee has been fully refunded. If the fee is only partially refunded, this
attribute will still be false. */
    refunded?: boolean;
    /** A list of refunds that have been applied to the fee. */
    refunds?: StripeListOfApplicationFeeRefund | undefined;
}

export abstract class StripeEntityOfAccount extends StripeEntity implements IStripeEntityOfAccount {

    constructor(data?: IStripeEntityOfAccount) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfAccount {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfAccount' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfAccount extends IStripeEntity {
}

/** This is an object representing a Stripe account. You can retrieve it to see properties on the account like its current requirements or if the account is enabled to make live charges or receive payouts.            For Custom accounts, the properties below are always returned. For other accounts, some properties are returned until that account has started to go through Connect Onboarding. Once you create an Account Link for a Standard or Express account, some parameters are no longer returned. These are marked as Custom Only or Custom and Express below. Learn about the differences between accounts. */
export class Account extends StripeEntityOfAccount implements IAccount {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** Business information about the account. */
    businessProfile?: AccountBusinessProfile | undefined;
    /** The business type.
One of: company, government_entity, individual, or
non_profit. */
    businessType?: string | undefined;
    capabilities?: AccountCapabilities | undefined;
    /** Whether the account can create live charges. */
    chargesEnabled?: boolean;
    company?: AccountCompany | undefined;
    controller?: AccountController | undefined;
    /** The account's country. */
    country?: string | undefined;
    /** Time at which the account was connected. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** Three-letter ISO currency code representing the default currency for the account. This
must be a currency that Stripe supports in the
account's country. */
    defaultCurrency?: string | undefined;
    /** Whether this object is deleted or not. */
    deleted?: boolean | undefined;
    /** Whether account details have been submitted. Standard accounts cannot receive payouts
before this is true. */
    detailsSubmitted?: boolean;
    /** An email address associated with the account. It's not used for authentication and
Stripe doesn't market to this field without explicit approval from the platform. */
    email?: string | undefined;
    /** External accounts (bank accounts and debit cards) currently attached to this account. */
    externalAccounts?: StripeListOfIExternalAccount | undefined;
    futureRequirements?: AccountFutureRequirements | undefined;
    /** This is an object representing a person associated with a Stripe account.
            
A platform cannot access a Standard or Express account's persons after the account
starts onboarding, such as after generating an account link for the account. See the Standard onboarding or Express onboarding
documentation for information about platform pre-filling and account onboarding
steps.
            
Related guide: Handling
identity verification with the API. */
    individual?: Person | undefined;
    /** Set of key-value pairs that you can
attach to an object. This can be useful for storing additional information about the
object in a structured format. */
    metadata?: { [key: string]: string; } | undefined;
    /** Whether Stripe can send payouts to this account. */
    payoutsEnabled?: boolean;
    requirements?: AccountRequirements | undefined;
    /** Options for customizing how the account functions within Stripe. */
    settings?: AccountSettings | undefined;
    tosAcceptance?: AccountTosAcceptance | undefined;
    /** The Stripe account type. Can be standard, express, or custom.
One of: custom, express, or standard. */
    type?: string | undefined;

    constructor(data?: IAccount) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.object = _data["object"];
            this.businessProfile = _data["businessProfile"] ? AccountBusinessProfile.fromJS(_data["businessProfile"]) : <any>undefined;
            this.businessType = _data["businessType"];
            this.capabilities = _data["capabilities"] ? AccountCapabilities.fromJS(_data["capabilities"]) : <any>undefined;
            this.chargesEnabled = _data["chargesEnabled"];
            this.company = _data["company"] ? AccountCompany.fromJS(_data["company"]) : <any>undefined;
            this.controller = _data["controller"] ? AccountController.fromJS(_data["controller"]) : <any>undefined;
            this.country = _data["country"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.defaultCurrency = _data["defaultCurrency"];
            this.deleted = _data["deleted"];
            this.detailsSubmitted = _data["detailsSubmitted"];
            this.email = _data["email"];
            this.externalAccounts = _data["externalAccounts"] ? StripeListOfIExternalAccount.fromJS(_data["externalAccounts"]) : <any>undefined;
            this.futureRequirements = _data["futureRequirements"] ? AccountFutureRequirements.fromJS(_data["futureRequirements"]) : <any>undefined;
            this.individual = _data["individual"] ? Person.fromJS(_data["individual"]) : <any>undefined;
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
            this.payoutsEnabled = _data["payoutsEnabled"];
            this.requirements = _data["requirements"] ? AccountRequirements.fromJS(_data["requirements"]) : <any>undefined;
            this.settings = _data["settings"] ? AccountSettings.fromJS(_data["settings"]) : <any>undefined;
            this.tosAcceptance = _data["tosAcceptance"] ? AccountTosAcceptance.fromJS(_data["tosAcceptance"]) : <any>undefined;
            this.type = _data["type"];
        }
    }

    static override fromJS(data: any): Account {
        data = typeof data === 'object' ? data : {};
        let result = new Account();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["object"] = this.object;
        data["businessProfile"] = this.businessProfile ? this.businessProfile.toJSON() : <any>undefined;
        data["businessType"] = this.businessType;
        data["capabilities"] = this.capabilities ? this.capabilities.toJSON() : <any>undefined;
        data["chargesEnabled"] = this.chargesEnabled;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        data["controller"] = this.controller ? this.controller.toJSON() : <any>undefined;
        data["country"] = this.country;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["defaultCurrency"] = this.defaultCurrency;
        data["deleted"] = this.deleted;
        data["detailsSubmitted"] = this.detailsSubmitted;
        data["email"] = this.email;
        data["externalAccounts"] = this.externalAccounts ? this.externalAccounts.toJSON() : <any>undefined;
        data["futureRequirements"] = this.futureRequirements ? this.futureRequirements.toJSON() : <any>undefined;
        data["individual"] = this.individual ? this.individual.toJSON() : <any>undefined;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        data["payoutsEnabled"] = this.payoutsEnabled;
        data["requirements"] = this.requirements ? this.requirements.toJSON() : <any>undefined;
        data["settings"] = this.settings ? this.settings.toJSON() : <any>undefined;
        data["tosAcceptance"] = this.tosAcceptance ? this.tosAcceptance.toJSON() : <any>undefined;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** This is an object representing a Stripe account. You can retrieve it to see properties on the account like its current requirements or if the account is enabled to make live charges or receive payouts.            For Custom accounts, the properties below are always returned. For other accounts, some properties are returned until that account has started to go through Connect Onboarding. Once you create an Account Link for a Standard or Express account, some parameters are no longer returned. These are marked as Custom Only or Custom and Express below. Learn about the differences between accounts. */
export interface IAccount extends IStripeEntityOfAccount {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** Business information about the account. */
    businessProfile?: AccountBusinessProfile | undefined;
    /** The business type.
One of: company, government_entity, individual, or
non_profit. */
    businessType?: string | undefined;
    capabilities?: AccountCapabilities | undefined;
    /** Whether the account can create live charges. */
    chargesEnabled?: boolean;
    company?: AccountCompany | undefined;
    controller?: AccountController | undefined;
    /** The account's country. */
    country?: string | undefined;
    /** Time at which the account was connected. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** Three-letter ISO currency code representing the default currency for the account. This
must be a currency that Stripe supports in the
account's country. */
    defaultCurrency?: string | undefined;
    /** Whether this object is deleted or not. */
    deleted?: boolean | undefined;
    /** Whether account details have been submitted. Standard accounts cannot receive payouts
before this is true. */
    detailsSubmitted?: boolean;
    /** An email address associated with the account. It's not used for authentication and
Stripe doesn't market to this field without explicit approval from the platform. */
    email?: string | undefined;
    /** External accounts (bank accounts and debit cards) currently attached to this account. */
    externalAccounts?: StripeListOfIExternalAccount | undefined;
    futureRequirements?: AccountFutureRequirements | undefined;
    /** This is an object representing a person associated with a Stripe account.
            
A platform cannot access a Standard or Express account's persons after the account
starts onboarding, such as after generating an account link for the account. See the Standard onboarding or Express onboarding
documentation for information about platform pre-filling and account onboarding
steps.
            
Related guide: Handling
identity verification with the API. */
    individual?: Person | undefined;
    /** Set of key-value pairs that you can
attach to an object. This can be useful for storing additional information about the
object in a structured format. */
    metadata?: { [key: string]: string; } | undefined;
    /** Whether Stripe can send payouts to this account. */
    payoutsEnabled?: boolean;
    requirements?: AccountRequirements | undefined;
    /** Options for customizing how the account functions within Stripe. */
    settings?: AccountSettings | undefined;
    tosAcceptance?: AccountTosAcceptance | undefined;
    /** The Stripe account type. Can be standard, express, or custom.
One of: custom, express, or standard. */
    type?: string | undefined;
}

export abstract class StripeEntityOfAccountBusinessProfile extends StripeEntity implements IStripeEntityOfAccountBusinessProfile {

    constructor(data?: IStripeEntityOfAccountBusinessProfile) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfAccountBusinessProfile {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfAccountBusinessProfile' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfAccountBusinessProfile extends IStripeEntity {
}

export class AccountBusinessProfile extends StripeEntityOfAccountBusinessProfile implements IAccountBusinessProfile {
    /** The merchant category code for the
account. MCCs are used to classify businesses based on the goods or services they
provide. */
    mcc?: string | undefined;
    /** The customer-facing business name. */
    name?: string | undefined;
    /** Internal-only description of the product sold or service provided by the business. It's
used by Stripe for risk and underwriting purposes. */
    productDescription?: string | undefined;
    /** A publicly available mailing address for sending support issues to. */
    supportAddress?: Address | undefined;
    /** A publicly available email address for sending support issues to. */
    supportEmail?: string | undefined;
    /** A publicly available phone number to call with support issues. */
    supportPhone?: string | undefined;
    /** A publicly available website for handling support issues. */
    supportUrl?: string | undefined;
    /** The business's publicly available website. */
    url?: string | undefined;

    constructor(data?: IAccountBusinessProfile) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.mcc = _data["mcc"];
            this.name = _data["name"];
            this.productDescription = _data["productDescription"];
            this.supportAddress = _data["supportAddress"] ? Address.fromJS(_data["supportAddress"]) : <any>undefined;
            this.supportEmail = _data["supportEmail"];
            this.supportPhone = _data["supportPhone"];
            this.supportUrl = _data["supportUrl"];
            this.url = _data["url"];
        }
    }

    static override fromJS(data: any): AccountBusinessProfile {
        data = typeof data === 'object' ? data : {};
        let result = new AccountBusinessProfile();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mcc"] = this.mcc;
        data["name"] = this.name;
        data["productDescription"] = this.productDescription;
        data["supportAddress"] = this.supportAddress ? this.supportAddress.toJSON() : <any>undefined;
        data["supportEmail"] = this.supportEmail;
        data["supportPhone"] = this.supportPhone;
        data["supportUrl"] = this.supportUrl;
        data["url"] = this.url;
        super.toJSON(data);
        return data;
    }
}

export interface IAccountBusinessProfile extends IStripeEntityOfAccountBusinessProfile {
    /** The merchant category code for the
account. MCCs are used to classify businesses based on the goods or services they
provide. */
    mcc?: string | undefined;
    /** The customer-facing business name. */
    name?: string | undefined;
    /** Internal-only description of the product sold or service provided by the business. It's
used by Stripe for risk and underwriting purposes. */
    productDescription?: string | undefined;
    /** A publicly available mailing address for sending support issues to. */
    supportAddress?: Address | undefined;
    /** A publicly available email address for sending support issues to. */
    supportEmail?: string | undefined;
    /** A publicly available phone number to call with support issues. */
    supportPhone?: string | undefined;
    /** A publicly available website for handling support issues. */
    supportUrl?: string | undefined;
    /** The business's publicly available website. */
    url?: string | undefined;
}

export abstract class StripeEntityOfAccountCapabilities extends StripeEntity implements IStripeEntityOfAccountCapabilities {

    constructor(data?: IStripeEntityOfAccountCapabilities) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfAccountCapabilities {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfAccountCapabilities' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfAccountCapabilities extends IStripeEntity {
}

export class AccountCapabilities extends StripeEntityOfAccountCapabilities implements IAccountCapabilities {
    /** The status of the Canadian pre-authorized debits payments capability of the account, or
whether the account can directly process Canadian pre-authorized debits charges.
One of: active, inactive, or pending. */
    acssDebitPayments?: string | undefined;
    /** The status of the Affirm capability of the account, or whether the account can directly
process Affirm charges.
One of: active, inactive, or pending. */
    affirmPayments?: string | undefined;
    /** The status of the Afterpay Clearpay capability of the account, or whether the account
can directly process Afterpay Clearpay charges.
One of: active, inactive, or pending. */
    afterpayClearpayPayments?: string | undefined;
    /** The status of the BECS Direct Debit (AU) payments capability of the account, or whether
the account can directly process BECS Direct Debit (AU) charges.
One of: active, inactive, or pending. */
    auBecsDebitPayments?: string | undefined;
    /** The status of the Bacs Direct Debits payments capability of the account, or whether the
account can directly process Bacs Direct Debits charges.
One of: active, inactive, or pending. */
    bacsDebitPayments?: string | undefined;
    /** The status of the Bancontact payments capability of the account, or whether the account
can directly process Bancontact charges.
One of: active, inactive, or pending. */
    bancontactPayments?: string | undefined;
    /** The status of the customer_balance payments capability of the account, or whether the
account can directly process customer_balance charges.
One of: active, inactive, or pending. */
    bankTransferPayments?: string | undefined;
    /** The status of the blik payments capability of the account, or whether the account can
directly process blik charges.
One of: active, inactive, or pending. */
    blikPayments?: string | undefined;
    /** The status of the boleto payments capability of the account, or whether the account can
directly process boleto charges.
One of: active, inactive, or pending. */
    boletoPayments?: string | undefined;
    /** The status of the card issuing capability of the account, or whether you can use Issuing
to distribute funds on cards.
One of: active, inactive, or pending. */
    cardIssuing?: string | undefined;
    /** The status of the card payments capability of the account, or whether the account can
directly process credit and debit card charges.
One of: active, inactive, or pending. */
    cardPayments?: string | undefined;
    /** The status of the Cartes Bancaires payments capability of the account, or whether the
account can directly process Cartes Bancaires card charges in EUR currency.
One of: active, inactive, or pending. */
    cartesBancairesPayments?: string | undefined;
    /** The status of the Cash App Pay capability of the account, or whether the account can
directly process Cash App Pay payments.
One of: active, inactive, or pending. */
    cashappPayments?: string | undefined;
    /** The status of the EPS payments capability of the account, or whether the account can
directly process EPS charges.
One of: active, inactive, or pending. */
    epsPayments?: string | undefined;
    /** The status of the FPX payments capability of the account, or whether the account can
directly process FPX charges.
One of: active, inactive, or pending. */
    fpxPayments?: string | undefined;
    /** The status of the giropay payments capability of the account, or whether the account can
directly process giropay charges.
One of: active, inactive, or pending. */
    giropayPayments?: string | undefined;
    /** The status of the GrabPay payments capability of the account, or whether the account can
directly process GrabPay charges.
One of: active, inactive, or pending. */
    grabpayPayments?: string | undefined;
    /** The status of the iDEAL payments capability of the account, or whether the account can
directly process iDEAL charges.
One of: active, inactive, or pending. */
    idealPayments?: string | undefined;
    /** The status of the india_international_payments capability of the account, or whether the
account can process international charges (non INR) in India.
One of: active, inactive, or pending. */
    indiaInternationalPayments?: string | undefined;
    /** The status of the JCB payments capability of the account, or whether the account (Japan
only) can directly process JCB credit card charges in JPY currency.
One of: active, inactive, or pending. */
    jcbPayments?: string | undefined;
    /** The status of the Klarna payments capability of the account, or whether the account can
directly process Klarna charges.
One of: active, inactive, or pending. */
    klarnaPayments?: string | undefined;
    /** The status of the konbini payments capability of the account, or whether the account can
directly process konbini charges.
One of: active, inactive, or pending. */
    konbiniPayments?: string | undefined;
    /** The status of the legacy payments capability of the account.
One of: active, inactive, or pending. */
    legacyPayments?: string | undefined;
    /** The status of the link_payments capability of the account, or whether the account can
directly process Link charges.
One of: active, inactive, or pending. */
    linkPayments?: string | undefined;
    /** The status of the OXXO payments capability of the account, or whether the account can
directly process OXXO charges.
One of: active, inactive, or pending. */
    oxxoPayments?: string | undefined;
    /** The status of the P24 payments capability of the account, or whether the account can
directly process P24 charges.
One of: active, inactive, or pending. */
    p24Payments?: string | undefined;
    /** The status of the paynow payments capability of the account, or whether the account can
directly process paynow charges.
One of: active, inactive, or pending. */
    paynowPayments?: string | undefined;
    /** The status of the promptpay payments capability of the account, or whether the account
can directly process promptpay charges.
One of: active, inactive, or pending. */
    promptpayPayments?: string | undefined;
    /** The status of the SEPA Direct Debits payments capability of the account, or whether the
account can directly process SEPA Direct Debits charges.
One of: active, inactive, or pending. */
    sepaDebitPayments?: string | undefined;
    /** The status of the Sofort payments capability of the account, or whether the account can
directly process Sofort charges.
One of: active, inactive, or pending. */
    sofortPayments?: string | undefined;
    /** The status of the tax reporting 1099-K (US) capability of the account.
One of: active, inactive, or pending. */
    taxReportingUs1099K?: string | undefined;
    /** The status of the tax reporting 1099-MISC (US) capability of the account.
One of: active, inactive, or pending. */
    taxReportingUs1099Misc?: string | undefined;
    /** The status of the transfers capability of the account, or whether your platform can
transfer funds to the account.
One of: active, inactive, or pending. */
    transfers?: string | undefined;
    /** The status of the banking capability, or whether the account can have bank accounts.
One of: active, inactive, or pending. */
    treasury?: string | undefined;
    /** The status of the US bank account ACH payments capability of the account, or whether the
account can directly process US bank account charges.
One of: active, inactive, or pending. */
    usBankAccountAchPayments?: string | undefined;
    /** The status of the Zip capability of the account, or whether the account can directly
process Zip charges.
One of: active, inactive, or pending. */
    zipPayments?: string | undefined;

    constructor(data?: IAccountCapabilities) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.acssDebitPayments = _data["acssDebitPayments"];
            this.affirmPayments = _data["affirmPayments"];
            this.afterpayClearpayPayments = _data["afterpayClearpayPayments"];
            this.auBecsDebitPayments = _data["auBecsDebitPayments"];
            this.bacsDebitPayments = _data["bacsDebitPayments"];
            this.bancontactPayments = _data["bancontactPayments"];
            this.bankTransferPayments = _data["bankTransferPayments"];
            this.blikPayments = _data["blikPayments"];
            this.boletoPayments = _data["boletoPayments"];
            this.cardIssuing = _data["cardIssuing"];
            this.cardPayments = _data["cardPayments"];
            this.cartesBancairesPayments = _data["cartesBancairesPayments"];
            this.cashappPayments = _data["cashappPayments"];
            this.epsPayments = _data["epsPayments"];
            this.fpxPayments = _data["fpxPayments"];
            this.giropayPayments = _data["giropayPayments"];
            this.grabpayPayments = _data["grabpayPayments"];
            this.idealPayments = _data["idealPayments"];
            this.indiaInternationalPayments = _data["indiaInternationalPayments"];
            this.jcbPayments = _data["jcbPayments"];
            this.klarnaPayments = _data["klarnaPayments"];
            this.konbiniPayments = _data["konbiniPayments"];
            this.legacyPayments = _data["legacyPayments"];
            this.linkPayments = _data["linkPayments"];
            this.oxxoPayments = _data["oxxoPayments"];
            this.p24Payments = _data["p24Payments"];
            this.paynowPayments = _data["paynowPayments"];
            this.promptpayPayments = _data["promptpayPayments"];
            this.sepaDebitPayments = _data["sepaDebitPayments"];
            this.sofortPayments = _data["sofortPayments"];
            this.taxReportingUs1099K = _data["taxReportingUs1099K"];
            this.taxReportingUs1099Misc = _data["taxReportingUs1099Misc"];
            this.transfers = _data["transfers"];
            this.treasury = _data["treasury"];
            this.usBankAccountAchPayments = _data["usBankAccountAchPayments"];
            this.zipPayments = _data["zipPayments"];
        }
    }

    static override fromJS(data: any): AccountCapabilities {
        data = typeof data === 'object' ? data : {};
        let result = new AccountCapabilities();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["acssDebitPayments"] = this.acssDebitPayments;
        data["affirmPayments"] = this.affirmPayments;
        data["afterpayClearpayPayments"] = this.afterpayClearpayPayments;
        data["auBecsDebitPayments"] = this.auBecsDebitPayments;
        data["bacsDebitPayments"] = this.bacsDebitPayments;
        data["bancontactPayments"] = this.bancontactPayments;
        data["bankTransferPayments"] = this.bankTransferPayments;
        data["blikPayments"] = this.blikPayments;
        data["boletoPayments"] = this.boletoPayments;
        data["cardIssuing"] = this.cardIssuing;
        data["cardPayments"] = this.cardPayments;
        data["cartesBancairesPayments"] = this.cartesBancairesPayments;
        data["cashappPayments"] = this.cashappPayments;
        data["epsPayments"] = this.epsPayments;
        data["fpxPayments"] = this.fpxPayments;
        data["giropayPayments"] = this.giropayPayments;
        data["grabpayPayments"] = this.grabpayPayments;
        data["idealPayments"] = this.idealPayments;
        data["indiaInternationalPayments"] = this.indiaInternationalPayments;
        data["jcbPayments"] = this.jcbPayments;
        data["klarnaPayments"] = this.klarnaPayments;
        data["konbiniPayments"] = this.konbiniPayments;
        data["legacyPayments"] = this.legacyPayments;
        data["linkPayments"] = this.linkPayments;
        data["oxxoPayments"] = this.oxxoPayments;
        data["p24Payments"] = this.p24Payments;
        data["paynowPayments"] = this.paynowPayments;
        data["promptpayPayments"] = this.promptpayPayments;
        data["sepaDebitPayments"] = this.sepaDebitPayments;
        data["sofortPayments"] = this.sofortPayments;
        data["taxReportingUs1099K"] = this.taxReportingUs1099K;
        data["taxReportingUs1099Misc"] = this.taxReportingUs1099Misc;
        data["transfers"] = this.transfers;
        data["treasury"] = this.treasury;
        data["usBankAccountAchPayments"] = this.usBankAccountAchPayments;
        data["zipPayments"] = this.zipPayments;
        super.toJSON(data);
        return data;
    }
}

export interface IAccountCapabilities extends IStripeEntityOfAccountCapabilities {
    /** The status of the Canadian pre-authorized debits payments capability of the account, or
whether the account can directly process Canadian pre-authorized debits charges.
One of: active, inactive, or pending. */
    acssDebitPayments?: string | undefined;
    /** The status of the Affirm capability of the account, or whether the account can directly
process Affirm charges.
One of: active, inactive, or pending. */
    affirmPayments?: string | undefined;
    /** The status of the Afterpay Clearpay capability of the account, or whether the account
can directly process Afterpay Clearpay charges.
One of: active, inactive, or pending. */
    afterpayClearpayPayments?: string | undefined;
    /** The status of the BECS Direct Debit (AU) payments capability of the account, or whether
the account can directly process BECS Direct Debit (AU) charges.
One of: active, inactive, or pending. */
    auBecsDebitPayments?: string | undefined;
    /** The status of the Bacs Direct Debits payments capability of the account, or whether the
account can directly process Bacs Direct Debits charges.
One of: active, inactive, or pending. */
    bacsDebitPayments?: string | undefined;
    /** The status of the Bancontact payments capability of the account, or whether the account
can directly process Bancontact charges.
One of: active, inactive, or pending. */
    bancontactPayments?: string | undefined;
    /** The status of the customer_balance payments capability of the account, or whether the
account can directly process customer_balance charges.
One of: active, inactive, or pending. */
    bankTransferPayments?: string | undefined;
    /** The status of the blik payments capability of the account, or whether the account can
directly process blik charges.
One of: active, inactive, or pending. */
    blikPayments?: string | undefined;
    /** The status of the boleto payments capability of the account, or whether the account can
directly process boleto charges.
One of: active, inactive, or pending. */
    boletoPayments?: string | undefined;
    /** The status of the card issuing capability of the account, or whether you can use Issuing
to distribute funds on cards.
One of: active, inactive, or pending. */
    cardIssuing?: string | undefined;
    /** The status of the card payments capability of the account, or whether the account can
directly process credit and debit card charges.
One of: active, inactive, or pending. */
    cardPayments?: string | undefined;
    /** The status of the Cartes Bancaires payments capability of the account, or whether the
account can directly process Cartes Bancaires card charges in EUR currency.
One of: active, inactive, or pending. */
    cartesBancairesPayments?: string | undefined;
    /** The status of the Cash App Pay capability of the account, or whether the account can
directly process Cash App Pay payments.
One of: active, inactive, or pending. */
    cashappPayments?: string | undefined;
    /** The status of the EPS payments capability of the account, or whether the account can
directly process EPS charges.
One of: active, inactive, or pending. */
    epsPayments?: string | undefined;
    /** The status of the FPX payments capability of the account, or whether the account can
directly process FPX charges.
One of: active, inactive, or pending. */
    fpxPayments?: string | undefined;
    /** The status of the giropay payments capability of the account, or whether the account can
directly process giropay charges.
One of: active, inactive, or pending. */
    giropayPayments?: string | undefined;
    /** The status of the GrabPay payments capability of the account, or whether the account can
directly process GrabPay charges.
One of: active, inactive, or pending. */
    grabpayPayments?: string | undefined;
    /** The status of the iDEAL payments capability of the account, or whether the account can
directly process iDEAL charges.
One of: active, inactive, or pending. */
    idealPayments?: string | undefined;
    /** The status of the india_international_payments capability of the account, or whether the
account can process international charges (non INR) in India.
One of: active, inactive, or pending. */
    indiaInternationalPayments?: string | undefined;
    /** The status of the JCB payments capability of the account, or whether the account (Japan
only) can directly process JCB credit card charges in JPY currency.
One of: active, inactive, or pending. */
    jcbPayments?: string | undefined;
    /** The status of the Klarna payments capability of the account, or whether the account can
directly process Klarna charges.
One of: active, inactive, or pending. */
    klarnaPayments?: string | undefined;
    /** The status of the konbini payments capability of the account, or whether the account can
directly process konbini charges.
One of: active, inactive, or pending. */
    konbiniPayments?: string | undefined;
    /** The status of the legacy payments capability of the account.
One of: active, inactive, or pending. */
    legacyPayments?: string | undefined;
    /** The status of the link_payments capability of the account, or whether the account can
directly process Link charges.
One of: active, inactive, or pending. */
    linkPayments?: string | undefined;
    /** The status of the OXXO payments capability of the account, or whether the account can
directly process OXXO charges.
One of: active, inactive, or pending. */
    oxxoPayments?: string | undefined;
    /** The status of the P24 payments capability of the account, or whether the account can
directly process P24 charges.
One of: active, inactive, or pending. */
    p24Payments?: string | undefined;
    /** The status of the paynow payments capability of the account, or whether the account can
directly process paynow charges.
One of: active, inactive, or pending. */
    paynowPayments?: string | undefined;
    /** The status of the promptpay payments capability of the account, or whether the account
can directly process promptpay charges.
One of: active, inactive, or pending. */
    promptpayPayments?: string | undefined;
    /** The status of the SEPA Direct Debits payments capability of the account, or whether the
account can directly process SEPA Direct Debits charges.
One of: active, inactive, or pending. */
    sepaDebitPayments?: string | undefined;
    /** The status of the Sofort payments capability of the account, or whether the account can
directly process Sofort charges.
One of: active, inactive, or pending. */
    sofortPayments?: string | undefined;
    /** The status of the tax reporting 1099-K (US) capability of the account.
One of: active, inactive, or pending. */
    taxReportingUs1099K?: string | undefined;
    /** The status of the tax reporting 1099-MISC (US) capability of the account.
One of: active, inactive, or pending. */
    taxReportingUs1099Misc?: string | undefined;
    /** The status of the transfers capability of the account, or whether your platform can
transfer funds to the account.
One of: active, inactive, or pending. */
    transfers?: string | undefined;
    /** The status of the banking capability, or whether the account can have bank accounts.
One of: active, inactive, or pending. */
    treasury?: string | undefined;
    /** The status of the US bank account ACH payments capability of the account, or whether the
account can directly process US bank account charges.
One of: active, inactive, or pending. */
    usBankAccountAchPayments?: string | undefined;
    /** The status of the Zip capability of the account, or whether the account can directly
process Zip charges.
One of: active, inactive, or pending. */
    zipPayments?: string | undefined;
}

export abstract class StripeEntityOfAccountCompany extends StripeEntity implements IStripeEntityOfAccountCompany {

    constructor(data?: IStripeEntityOfAccountCompany) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfAccountCompany {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfAccountCompany' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfAccountCompany extends IStripeEntity {
}

export class AccountCompany extends StripeEntityOfAccountCompany implements IAccountCompany {
    address?: Address | undefined;
    /** The Kana variation of the company's primary address (Japan only). */
    addressKana?: AddressJapan | undefined;
    /** The Kanji variation of the company's primary address (Japan only). */
    addressKanji?: AddressJapan | undefined;
    /** Whether the company's directors have been provided. This Boolean will be true if
you've manually indicated that all directors are provided via the
directors_provided parameter. */
    directorsProvided?: boolean;
    /** Whether the company's executives have been provided. This Boolean will be true if
you've manually indicated that all executives are provided via the
executives_provided parameter, or if Stripe determined that sufficient
executives were provided. */
    executivesProvided?: boolean;
    /** The export license ID number of the company, also referred as Import Export Code (India
only). */
    exportLicenseId?: string | undefined;
    /** The purpose code to use for export transactions (India only). */
    exportPurposeCode?: string | undefined;
    /** The company's legal name. */
    name?: string | undefined;
    /** The Kana variation of the company's legal name (Japan only). */
    nameKana?: string | undefined;
    /** The Kanji variation of the company's legal name (Japan only). */
    nameKanji?: string | undefined;
    /** Whether the company's owners have been provided. This Boolean will be true if
you've manually indicated that all owners are provided via the
owners_provided parameter, or if Stripe determined that sufficient owners
were provided. Stripe determines ownership requirements using both the number of owners
provided and their total percent ownership (calculated by adding the
percent_ownership of each owner together). */
    ownersProvided?: boolean;
    /** This hash is used to attest that the beneficial owner information provided to Stripe is
both current and correct. */
    ownershipDeclaration?: AccountCompanyOwnershipDeclaration | undefined;
    /** The company's phone number (used for verification). */
    phone?: string | undefined;
    /** The category identifying the legal structure of the company or legal entity. See Business
structure for more details.
One of: free_zone_establishment, free_zone_llc,
government_instrumentality, governmental_unit,
incorporated_non_profit, limited_liability_partnership, llc,
multi_member_llc, private_company, private_corporation,
private_partnership, public_company, public_corporation,
public_partnership, single_member_llc, sole_establishment,
sole_proprietorship, tax_exempt_government_instrumentality,
unincorporated_association, or unincorporated_non_profit. */
    structure?: string | undefined;
    /** Whether the company's business ID number was provided. */
    taxIdProvided?: boolean;
    /** The jurisdiction in which the tax_id is registered (Germany-based companies
only). */
    taxIdRegistrar?: string | undefined;
    /** Whether the company's business VAT number was provided. */
    vatIdProvided?: boolean;
    /** Information on the verification state of the company. */
    verification?: AccountCompanyVerification | undefined;

    constructor(data?: IAccountCompany) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.address = _data["address"] ? Address.fromJS(_data["address"]) : <any>undefined;
            this.addressKana = _data["addressKana"] ? AddressJapan.fromJS(_data["addressKana"]) : <any>undefined;
            this.addressKanji = _data["addressKanji"] ? AddressJapan.fromJS(_data["addressKanji"]) : <any>undefined;
            this.directorsProvided = _data["directorsProvided"];
            this.executivesProvided = _data["executivesProvided"];
            this.exportLicenseId = _data["exportLicenseId"];
            this.exportPurposeCode = _data["exportPurposeCode"];
            this.name = _data["name"];
            this.nameKana = _data["nameKana"];
            this.nameKanji = _data["nameKanji"];
            this.ownersProvided = _data["ownersProvided"];
            this.ownershipDeclaration = _data["ownershipDeclaration"] ? AccountCompanyOwnershipDeclaration.fromJS(_data["ownershipDeclaration"]) : <any>undefined;
            this.phone = _data["phone"];
            this.structure = _data["structure"];
            this.taxIdProvided = _data["taxIdProvided"];
            this.taxIdRegistrar = _data["taxIdRegistrar"];
            this.vatIdProvided = _data["vatIdProvided"];
            this.verification = _data["verification"] ? AccountCompanyVerification.fromJS(_data["verification"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): AccountCompany {
        data = typeof data === 'object' ? data : {};
        let result = new AccountCompany();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["addressKana"] = this.addressKana ? this.addressKana.toJSON() : <any>undefined;
        data["addressKanji"] = this.addressKanji ? this.addressKanji.toJSON() : <any>undefined;
        data["directorsProvided"] = this.directorsProvided;
        data["executivesProvided"] = this.executivesProvided;
        data["exportLicenseId"] = this.exportLicenseId;
        data["exportPurposeCode"] = this.exportPurposeCode;
        data["name"] = this.name;
        data["nameKana"] = this.nameKana;
        data["nameKanji"] = this.nameKanji;
        data["ownersProvided"] = this.ownersProvided;
        data["ownershipDeclaration"] = this.ownershipDeclaration ? this.ownershipDeclaration.toJSON() : <any>undefined;
        data["phone"] = this.phone;
        data["structure"] = this.structure;
        data["taxIdProvided"] = this.taxIdProvided;
        data["taxIdRegistrar"] = this.taxIdRegistrar;
        data["vatIdProvided"] = this.vatIdProvided;
        data["verification"] = this.verification ? this.verification.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IAccountCompany extends IStripeEntityOfAccountCompany {
    address?: Address | undefined;
    /** The Kana variation of the company's primary address (Japan only). */
    addressKana?: AddressJapan | undefined;
    /** The Kanji variation of the company's primary address (Japan only). */
    addressKanji?: AddressJapan | undefined;
    /** Whether the company's directors have been provided. This Boolean will be true if
you've manually indicated that all directors are provided via the
directors_provided parameter. */
    directorsProvided?: boolean;
    /** Whether the company's executives have been provided. This Boolean will be true if
you've manually indicated that all executives are provided via the
executives_provided parameter, or if Stripe determined that sufficient
executives were provided. */
    executivesProvided?: boolean;
    /** The export license ID number of the company, also referred as Import Export Code (India
only). */
    exportLicenseId?: string | undefined;
    /** The purpose code to use for export transactions (India only). */
    exportPurposeCode?: string | undefined;
    /** The company's legal name. */
    name?: string | undefined;
    /** The Kana variation of the company's legal name (Japan only). */
    nameKana?: string | undefined;
    /** The Kanji variation of the company's legal name (Japan only). */
    nameKanji?: string | undefined;
    /** Whether the company's owners have been provided. This Boolean will be true if
you've manually indicated that all owners are provided via the
owners_provided parameter, or if Stripe determined that sufficient owners
were provided. Stripe determines ownership requirements using both the number of owners
provided and their total percent ownership (calculated by adding the
percent_ownership of each owner together). */
    ownersProvided?: boolean;
    /** This hash is used to attest that the beneficial owner information provided to Stripe is
both current and correct. */
    ownershipDeclaration?: AccountCompanyOwnershipDeclaration | undefined;
    /** The company's phone number (used for verification). */
    phone?: string | undefined;
    /** The category identifying the legal structure of the company or legal entity. See Business
structure for more details.
One of: free_zone_establishment, free_zone_llc,
government_instrumentality, governmental_unit,
incorporated_non_profit, limited_liability_partnership, llc,
multi_member_llc, private_company, private_corporation,
private_partnership, public_company, public_corporation,
public_partnership, single_member_llc, sole_establishment,
sole_proprietorship, tax_exempt_government_instrumentality,
unincorporated_association, or unincorporated_non_profit. */
    structure?: string | undefined;
    /** Whether the company's business ID number was provided. */
    taxIdProvided?: boolean;
    /** The jurisdiction in which the tax_id is registered (Germany-based companies
only). */
    taxIdRegistrar?: string | undefined;
    /** Whether the company's business VAT number was provided. */
    vatIdProvided?: boolean;
    /** Information on the verification state of the company. */
    verification?: AccountCompanyVerification | undefined;
}

export class AddressJapan extends Address implements IAddressJapan {
    town?: string | undefined;

    constructor(data?: IAddressJapan) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.town = _data["town"];
        }
    }

    static override fromJS(data: any): AddressJapan {
        data = typeof data === 'object' ? data : {};
        let result = new AddressJapan();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["town"] = this.town;
        super.toJSON(data);
        return data;
    }
}

export interface IAddressJapan extends IAddress {
    town?: string | undefined;
}

export abstract class StripeEntityOfAccountCompanyOwnershipDeclaration extends StripeEntity implements IStripeEntityOfAccountCompanyOwnershipDeclaration {

    constructor(data?: IStripeEntityOfAccountCompanyOwnershipDeclaration) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfAccountCompanyOwnershipDeclaration {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfAccountCompanyOwnershipDeclaration' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfAccountCompanyOwnershipDeclaration extends IStripeEntity {
}

export class AccountCompanyOwnershipDeclaration extends StripeEntityOfAccountCompanyOwnershipDeclaration implements IAccountCompanyOwnershipDeclaration {
    /** The Unix timestamp marking when the beneficial owner attestation was made. */
    date?: Date | undefined;
    /** The IP address from which the beneficial owner attestation was made. */
    ip?: string | undefined;
    /** The user-agent string from the browser where the beneficial owner attestation was made. */
    userAgent?: string | undefined;

    constructor(data?: IAccountCompanyOwnershipDeclaration) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.ip = _data["ip"];
            this.userAgent = _data["userAgent"];
        }
    }

    static override fromJS(data: any): AccountCompanyOwnershipDeclaration {
        data = typeof data === 'object' ? data : {};
        let result = new AccountCompanyOwnershipDeclaration();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["ip"] = this.ip;
        data["userAgent"] = this.userAgent;
        super.toJSON(data);
        return data;
    }
}

export interface IAccountCompanyOwnershipDeclaration extends IStripeEntityOfAccountCompanyOwnershipDeclaration {
    /** The Unix timestamp marking when the beneficial owner attestation was made. */
    date?: Date | undefined;
    /** The IP address from which the beneficial owner attestation was made. */
    ip?: string | undefined;
    /** The user-agent string from the browser where the beneficial owner attestation was made. */
    userAgent?: string | undefined;
}

export abstract class StripeEntityOfAccountCompanyVerification extends StripeEntity implements IStripeEntityOfAccountCompanyVerification {

    constructor(data?: IStripeEntityOfAccountCompanyVerification) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfAccountCompanyVerification {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfAccountCompanyVerification' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfAccountCompanyVerification extends IStripeEntity {
}

export class AccountCompanyVerification extends StripeEntityOfAccountCompanyVerification implements IAccountCompanyVerification {
    document?: AccountCompanyVerificationDocument | undefined;

    constructor(data?: IAccountCompanyVerification) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.document = _data["document"] ? AccountCompanyVerificationDocument.fromJS(_data["document"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): AccountCompanyVerification {
        data = typeof data === 'object' ? data : {};
        let result = new AccountCompanyVerification();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["document"] = this.document ? this.document.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IAccountCompanyVerification extends IStripeEntityOfAccountCompanyVerification {
    document?: AccountCompanyVerificationDocument | undefined;
}

export abstract class StripeEntityOfAccountCompanyVerificationDocument extends StripeEntity implements IStripeEntityOfAccountCompanyVerificationDocument {

    constructor(data?: IStripeEntityOfAccountCompanyVerificationDocument) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfAccountCompanyVerificationDocument {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfAccountCompanyVerificationDocument' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfAccountCompanyVerificationDocument extends IStripeEntity {
}

export class AccountCompanyVerificationDocument extends StripeEntityOfAccountCompanyVerificationDocument implements IAccountCompanyVerificationDocument {
    /** (ID of the File)
The back of a document returned by a file upload with a purpose
value of additional_verification. */
    backId?: string | undefined;
    /** (Expanded)
The back of a document returned by a file upload with a purpose
value of additional_verification.
            
For more information, see the expand documentation. */
    back?: File | undefined;
    internalBack?: ExpandableFieldOfFile | undefined;
    /** A user-displayable string describing the verification state of this document. */
    details?: string | undefined;
    /** One of document_corrupt, document_expired, document_failed_copy,
document_failed_greyscale, document_failed_other,
document_failed_test_mode, document_fraudulent,
document_incomplete, document_invalid, document_manipulated,
document_not_readable, document_not_uploaded,
document_type_not_supported, or document_too_large. A machine-readable
code specifying the verification state for this document. */
    detailsCode?: string | undefined;
    /** (ID of the File)
The front of a document returned by a file upload with a purpose
value of additional_verification. */
    frontId?: string | undefined;
    /** (Expanded)
The front of a document returned by a file upload with a purpose
value of additional_verification.
            
For more information, see the expand documentation. */
    front?: File | undefined;
    internalFront?: ExpandableFieldOfFile | undefined;

    constructor(data?: IAccountCompanyVerificationDocument) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.backId = _data["backId"];
            this.back = _data["back"] ? File.fromJS(_data["back"]) : <any>undefined;
            this.internalBack = _data["internalBack"] ? ExpandableFieldOfFile.fromJS(_data["internalBack"]) : <any>undefined;
            this.details = _data["details"];
            this.detailsCode = _data["detailsCode"];
            this.frontId = _data["frontId"];
            this.front = _data["front"] ? File.fromJS(_data["front"]) : <any>undefined;
            this.internalFront = _data["internalFront"] ? ExpandableFieldOfFile.fromJS(_data["internalFront"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): AccountCompanyVerificationDocument {
        data = typeof data === 'object' ? data : {};
        let result = new AccountCompanyVerificationDocument();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["backId"] = this.backId;
        data["back"] = this.back ? this.back.toJSON() : <any>undefined;
        data["internalBack"] = this.internalBack ? this.internalBack.toJSON() : <any>undefined;
        data["details"] = this.details;
        data["detailsCode"] = this.detailsCode;
        data["frontId"] = this.frontId;
        data["front"] = this.front ? this.front.toJSON() : <any>undefined;
        data["internalFront"] = this.internalFront ? this.internalFront.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IAccountCompanyVerificationDocument extends IStripeEntityOfAccountCompanyVerificationDocument {
    /** (ID of the File)
The back of a document returned by a file upload with a purpose
value of additional_verification. */
    backId?: string | undefined;
    /** (Expanded)
The back of a document returned by a file upload with a purpose
value of additional_verification.
            
For more information, see the expand documentation. */
    back?: File | undefined;
    internalBack?: ExpandableFieldOfFile | undefined;
    /** A user-displayable string describing the verification state of this document. */
    details?: string | undefined;
    /** One of document_corrupt, document_expired, document_failed_copy,
document_failed_greyscale, document_failed_other,
document_failed_test_mode, document_fraudulent,
document_incomplete, document_invalid, document_manipulated,
document_not_readable, document_not_uploaded,
document_type_not_supported, or document_too_large. A machine-readable
code specifying the verification state for this document. */
    detailsCode?: string | undefined;
    /** (ID of the File)
The front of a document returned by a file upload with a purpose
value of additional_verification. */
    frontId?: string | undefined;
    /** (Expanded)
The front of a document returned by a file upload with a purpose
value of additional_verification.
            
For more information, see the expand documentation. */
    front?: File | undefined;
    internalFront?: ExpandableFieldOfFile | undefined;
}

export abstract class StripeEntityOfFile extends StripeEntity implements IStripeEntityOfFile {

    constructor(data?: IStripeEntityOfFile) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfFile {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfFile' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfFile extends IStripeEntity {
}

/** This is an object representing a file hosted on Stripe's servers. The file may have been uploaded by yourself using the create file request (for example, when uploading dispute evidence) or it may have been created by Stripe (for example, the results of a Sigma scheduled query).            Related guide: File upload guide. */
export class File extends StripeEntityOfFile implements IFile {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** The time at which the file expires and is no longer available in epoch seconds. */
    expiresAt?: Date | undefined;
    /** A filename for the file, suitable for saving to a filesystem. */
    filename?: string | undefined;
    /** A list of file links that point at
this file. */
    links?: StripeListOfFileLink | undefined;
    /** The purpose of the
uploaded file.
One of: account_requirement, additional_verification,
business_icon, business_logo, customer_signature,
dispute_evidence, document_provider_identity_document,
finance_report_run, identity_document,
identity_document_downloadable, pci_document, selfie,
sigma_scheduled_query, tax_document_user_upload, or
terminal_reader_splashscreen. */
    purpose?: string | undefined;
    /** The size in bytes of the file object. */
    size?: number;
    /** A user friendly title for the document. */
    title?: string | undefined;
    /** The type of the file returned (e.g., csv, pdf, jpg, or png). */
    type?: string | undefined;
    /** The URL from which the file can be downloaded using your live secret API key. */
    url?: string | undefined;

    constructor(data?: IFile) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.object = _data["object"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.expiresAt = _data["expiresAt"] ? new Date(_data["expiresAt"].toString()) : <any>undefined;
            this.filename = _data["filename"];
            this.links = _data["links"] ? StripeListOfFileLink.fromJS(_data["links"]) : <any>undefined;
            this.purpose = _data["purpose"];
            this.size = _data["size"];
            this.title = _data["title"];
            this.type = _data["type"];
            this.url = _data["url"];
        }
    }

    static override fromJS(data: any): File {
        data = typeof data === 'object' ? data : {};
        let result = new File();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["object"] = this.object;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["expiresAt"] = this.expiresAt ? this.expiresAt.toISOString() : <any>undefined;
        data["filename"] = this.filename;
        data["links"] = this.links ? this.links.toJSON() : <any>undefined;
        data["purpose"] = this.purpose;
        data["size"] = this.size;
        data["title"] = this.title;
        data["type"] = this.type;
        data["url"] = this.url;
        super.toJSON(data);
        return data;
    }
}

/** This is an object representing a file hosted on Stripe's servers. The file may have been uploaded by yourself using the create file request (for example, when uploading dispute evidence) or it may have been created by Stripe (for example, the results of a Sigma scheduled query).            Related guide: File upload guide. */
export interface IFile extends IStripeEntityOfFile {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** The time at which the file expires and is no longer available in epoch seconds. */
    expiresAt?: Date | undefined;
    /** A filename for the file, suitable for saving to a filesystem. */
    filename?: string | undefined;
    /** A list of file links that point at
this file. */
    links?: StripeListOfFileLink | undefined;
    /** The purpose of the
uploaded file.
One of: account_requirement, additional_verification,
business_icon, business_logo, customer_signature,
dispute_evidence, document_provider_identity_document,
finance_report_run, identity_document,
identity_document_downloadable, pci_document, selfie,
sigma_scheduled_query, tax_document_user_upload, or
terminal_reader_splashscreen. */
    purpose?: string | undefined;
    /** The size in bytes of the file object. */
    size?: number;
    /** A user friendly title for the document. */
    title?: string | undefined;
    /** The type of the file returned (e.g., csv, pdf, jpg, or png). */
    type?: string | undefined;
    /** The URL from which the file can be downloaded using your live secret API key. */
    url?: string | undefined;
}

export abstract class StripeEntityOfStripeListOfFileLink extends StripeEntity implements IStripeEntityOfStripeListOfFileLink {

    constructor(data?: IStripeEntityOfStripeListOfFileLink) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfStripeListOfFileLink {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfStripeListOfFileLink' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfStripeListOfFileLink extends IStripeEntity {
}

export class StripeListOfFileLink extends StripeEntityOfStripeListOfFileLink implements IStripeListOfFileLink {
    /** A string describing the object type returned. */
    object?: string | undefined;
    /** A list containing the actual response elements, paginated by any request parameters. */
    data?: FileLink[] | undefined;
    /** Whether or not there are more elements available after this set. If false,
this set comprises the end of the list. */
    hasMore?: boolean;
    /** The URL for accessing this list. */
    url?: string | undefined;

    constructor(data?: IStripeListOfFileLink) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.object = _data["object"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(FileLink.fromJS(item));
            }
            this.hasMore = _data["hasMore"];
            this.url = _data["url"];
        }
    }

    static override fromJS(data: any): StripeListOfFileLink {
        data = typeof data === 'object' ? data : {};
        let result = new StripeListOfFileLink();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["object"] = this.object;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["hasMore"] = this.hasMore;
        data["url"] = this.url;
        super.toJSON(data);
        return data;
    }
}

export interface IStripeListOfFileLink extends IStripeEntityOfStripeListOfFileLink {
    /** A string describing the object type returned. */
    object?: string | undefined;
    /** A list containing the actual response elements, paginated by any request parameters. */
    data?: FileLink[] | undefined;
    /** Whether or not there are more elements available after this set. If false,
this set comprises the end of the list. */
    hasMore?: boolean;
    /** The URL for accessing this list. */
    url?: string | undefined;
}

export abstract class StripeEntityOfFileLink extends StripeEntity implements IStripeEntityOfFileLink {

    constructor(data?: IStripeEntityOfFileLink) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfFileLink {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfFileLink' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfFileLink extends IStripeEntity {
}

/** To share the contents of a File object with non-Stripe users, you can create a FileLink. FileLinks contain a URL that can be used to retrieve the contents of the file without authentication. */
export class FileLink extends StripeEntityOfFileLink implements IFileLink {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** Whether this link is already expired. */
    expired?: boolean;
    /** Time at which the link expires. */
    expiresAt?: Date | undefined;
    /** (ID of the File)
The file object this link points to. */
    fileId?: string | undefined;
    /** (Expanded)
The file object this link points to.
            
For more information, see the expand documentation. */
    file?: File | undefined;
    internalFile?: ExpandableFieldOfFile | undefined;
    /** Has the value true if the object exists in live mode or the value false if
the object exists in test mode. */
    livemode?: boolean;
    /** Set of key-value pairs that you can
attach to an object. This can be useful for storing additional information about the
object in a structured format. */
    metadata?: { [key: string]: string; } | undefined;
    /** The publicly accessible URL to download the file. */
    url?: string | undefined;

    constructor(data?: IFileLink) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.object = _data["object"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.expired = _data["expired"];
            this.expiresAt = _data["expiresAt"] ? new Date(_data["expiresAt"].toString()) : <any>undefined;
            this.fileId = _data["fileId"];
            this.file = _data["file"] ? File.fromJS(_data["file"]) : <any>undefined;
            this.internalFile = _data["internalFile"] ? ExpandableFieldOfFile.fromJS(_data["internalFile"]) : <any>undefined;
            this.livemode = _data["livemode"];
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
            this.url = _data["url"];
        }
    }

    static override fromJS(data: any): FileLink {
        data = typeof data === 'object' ? data : {};
        let result = new FileLink();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["object"] = this.object;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["expired"] = this.expired;
        data["expiresAt"] = this.expiresAt ? this.expiresAt.toISOString() : <any>undefined;
        data["fileId"] = this.fileId;
        data["file"] = this.file ? this.file.toJSON() : <any>undefined;
        data["internalFile"] = this.internalFile ? this.internalFile.toJSON() : <any>undefined;
        data["livemode"] = this.livemode;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        data["url"] = this.url;
        super.toJSON(data);
        return data;
    }
}

/** To share the contents of a File object with non-Stripe users, you can create a FileLink. FileLinks contain a URL that can be used to retrieve the contents of the file without authentication. */
export interface IFileLink extends IStripeEntityOfFileLink {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** Whether this link is already expired. */
    expired?: boolean;
    /** Time at which the link expires. */
    expiresAt?: Date | undefined;
    /** (ID of the File)
The file object this link points to. */
    fileId?: string | undefined;
    /** (Expanded)
The file object this link points to.
            
For more information, see the expand documentation. */
    file?: File | undefined;
    internalFile?: ExpandableFieldOfFile | undefined;
    /** Has the value true if the object exists in live mode or the value false if
the object exists in test mode. */
    livemode?: boolean;
    /** Set of key-value pairs that you can
attach to an object. This can be useful for storing additional information about the
object in a structured format. */
    metadata?: { [key: string]: string; } | undefined;
    /** The publicly accessible URL to download the file. */
    url?: string | undefined;
}

/** Represents a generic expandable field. */
export class ExpandableFieldOfFile implements IExpandableFieldOfFile {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: File | undefined;

    constructor(data?: IExpandableFieldOfFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.expandedObject = _data["expandedObject"] ? File.fromJS(_data["expandedObject"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExpandableFieldOfFile {
        data = typeof data === 'object' ? data : {};
        let result = new ExpandableFieldOfFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["expandedObject"] = this.expandedObject ? this.expandedObject.toJSON() : <any>undefined;
        return data;
    }
}

/** Represents a generic expandable field. */
export interface IExpandableFieldOfFile {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: File | undefined;
}

export abstract class StripeEntityOfAccountController extends StripeEntity implements IStripeEntityOfAccountController {

    constructor(data?: IStripeEntityOfAccountController) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfAccountController {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfAccountController' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfAccountController extends IStripeEntity {
}

export class AccountController extends StripeEntityOfAccountController implements IAccountController {
    /** true if the Connect application retrieving the resource controls the account and
can therefore exercise platform
controls. Otherwise, this field is null. */
    isController?: boolean;
    /** The controller type. Can be application, if a Connect application controls the
account, or account, if the account controls itself.
One of: account, or application. */
    type?: string | undefined;

    constructor(data?: IAccountController) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.isController = _data["isController"];
            this.type = _data["type"];
        }
    }

    static override fromJS(data: any): AccountController {
        data = typeof data === 'object' ? data : {};
        let result = new AccountController();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isController"] = this.isController;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

export interface IAccountController extends IStripeEntityOfAccountController {
    /** true if the Connect application retrieving the resource controls the account and
can therefore exercise platform
controls. Otherwise, this field is null. */
    isController?: boolean;
    /** The controller type. Can be application, if a Connect application controls the
account, or account, if the account controls itself.
One of: account, or application. */
    type?: string | undefined;
}

export abstract class StripeEntityOfStripeListOfIExternalAccount extends StripeEntity implements IStripeEntityOfStripeListOfIExternalAccount {

    constructor(data?: IStripeEntityOfStripeListOfIExternalAccount) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfStripeListOfIExternalAccount {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfStripeListOfIExternalAccount' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfStripeListOfIExternalAccount extends IStripeEntity {
}

export class StripeListOfIExternalAccount extends StripeEntityOfStripeListOfIExternalAccount implements IStripeListOfIExternalAccount {
    /** A string describing the object type returned. */
    object?: string | undefined;
    /** A list containing the actual response elements, paginated by any request parameters. */
    data?: IExternalAccount[] | undefined;
    /** Whether or not there are more elements available after this set. If false,
this set comprises the end of the list. */
    hasMore?: boolean;
    /** The URL for accessing this list. */
    url?: string | undefined;

    constructor(data?: IStripeListOfIExternalAccount) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.object = _data["object"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(IExternalAccount.fromJS(item));
            }
            this.hasMore = _data["hasMore"];
            this.url = _data["url"];
        }
    }

    static override fromJS(data: any): StripeListOfIExternalAccount {
        data = typeof data === 'object' ? data : {};
        let result = new StripeListOfIExternalAccount();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["object"] = this.object;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["hasMore"] = this.hasMore;
        data["url"] = this.url;
        super.toJSON(data);
        return data;
    }
}

export interface IStripeListOfIExternalAccount extends IStripeEntityOfStripeListOfIExternalAccount {
    /** A string describing the object type returned. */
    object?: string | undefined;
    /** A list containing the actual response elements, paginated by any request parameters. */
    data?: IExternalAccount[] | undefined;
    /** Whether or not there are more elements available after this set. If false,
this set comprises the end of the list. */
    hasMore?: boolean;
    /** The URL for accessing this list. */
    url?: string | undefined;
}

/** Resources that implement this interface can be used as external accounts, i.e. they can be attached to a Stripe account to receive payouts. Possible concrete classes: */
export abstract class IExternalAccount implements IIExternalAccount {
    account?: Account | undefined;
    accountId?: string | undefined;

    constructor(data?: IIExternalAccount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.account = _data["account"] ? Account.fromJS(_data["account"]) : <any>undefined;
            this.accountId = _data["accountId"];
        }
    }

    static fromJS(data: any): IExternalAccount {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'IExternalAccount' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["account"] = this.account ? this.account.toJSON() : <any>undefined;
        data["accountId"] = this.accountId;
        return data;
    }
}

/** Resources that implement this interface can be used as external accounts, i.e. they can be attached to a Stripe account to receive payouts. Possible concrete classes: */
export interface IIExternalAccount {
    account?: Account | undefined;
    accountId?: string | undefined;
}

export abstract class StripeEntityOfAccountFutureRequirements extends StripeEntity implements IStripeEntityOfAccountFutureRequirements {

    constructor(data?: IStripeEntityOfAccountFutureRequirements) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfAccountFutureRequirements {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfAccountFutureRequirements' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfAccountFutureRequirements extends IStripeEntity {
}

export class AccountFutureRequirements extends StripeEntityOfAccountFutureRequirements implements IAccountFutureRequirements {
    /** Fields that are due and can be satisfied by providing the corresponding alternative
fields instead. */
    alternatives?: AccountFutureRequirementsAlternative[] | undefined;
    /** Date on which future_requirements merges with the main requirements hash
and future_requirements becomes empty. After the transition, currently_due
requirements may immediately become past_due, but the account may also be given a
grace period depending on its enablement state prior to transitioning. */
    currentDeadline?: Date | undefined;
    /** Fields that need to be collected to keep the account enabled. If not collected by
future_requirements[current_deadline], these fields will transition to the main
requirements hash. */
    currentlyDue?: string[] | undefined;
    /** This is typed as a string for consistency with requirements.disabled_reason, but
it safe to assume future_requirements.disabled_reason is empty because fields in
future_requirements will never disable the account. */
    disabledReason?: string | undefined;
    /** Fields that are currently_due and need to be collected again because validation
or verification failed. */
    errors?: AccountFutureRequirementsError[] | undefined;
    /** Fields that need to be collected assuming all volume thresholds are reached. As they
become required, they appear in currently_due as well. */
    eventuallyDue?: string[] | undefined;
    /** Fields that weren't collected by requirements.current_deadline. These fields need
to be collected to enable the capability on the account. New fields will never appear
here; future_requirements.past_due will always be a subset of
requirements.past_due. */
    pastDue?: string[] | undefined;
    /** Fields that may become required depending on the results of verification or review. Will
be an empty array unless an asynchronous verification is pending. If verification fails,
these fields move to eventually_due or currently_due. */
    pendingVerification?: string[] | undefined;

    constructor(data?: IAccountFutureRequirements) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["alternatives"])) {
                this.alternatives = [] as any;
                for (let item of _data["alternatives"])
                    this.alternatives!.push(AccountFutureRequirementsAlternative.fromJS(item));
            }
            this.currentDeadline = _data["currentDeadline"] ? new Date(_data["currentDeadline"].toString()) : <any>undefined;
            if (Array.isArray(_data["currentlyDue"])) {
                this.currentlyDue = [] as any;
                for (let item of _data["currentlyDue"])
                    this.currentlyDue!.push(item);
            }
            this.disabledReason = _data["disabledReason"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(AccountFutureRequirementsError.fromJS(item));
            }
            if (Array.isArray(_data["eventuallyDue"])) {
                this.eventuallyDue = [] as any;
                for (let item of _data["eventuallyDue"])
                    this.eventuallyDue!.push(item);
            }
            if (Array.isArray(_data["pastDue"])) {
                this.pastDue = [] as any;
                for (let item of _data["pastDue"])
                    this.pastDue!.push(item);
            }
            if (Array.isArray(_data["pendingVerification"])) {
                this.pendingVerification = [] as any;
                for (let item of _data["pendingVerification"])
                    this.pendingVerification!.push(item);
            }
        }
    }

    static override fromJS(data: any): AccountFutureRequirements {
        data = typeof data === 'object' ? data : {};
        let result = new AccountFutureRequirements();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.alternatives)) {
            data["alternatives"] = [];
            for (let item of this.alternatives)
                data["alternatives"].push(item.toJSON());
        }
        data["currentDeadline"] = this.currentDeadline ? this.currentDeadline.toISOString() : <any>undefined;
        if (Array.isArray(this.currentlyDue)) {
            data["currentlyDue"] = [];
            for (let item of this.currentlyDue)
                data["currentlyDue"].push(item);
        }
        data["disabledReason"] = this.disabledReason;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        if (Array.isArray(this.eventuallyDue)) {
            data["eventuallyDue"] = [];
            for (let item of this.eventuallyDue)
                data["eventuallyDue"].push(item);
        }
        if (Array.isArray(this.pastDue)) {
            data["pastDue"] = [];
            for (let item of this.pastDue)
                data["pastDue"].push(item);
        }
        if (Array.isArray(this.pendingVerification)) {
            data["pendingVerification"] = [];
            for (let item of this.pendingVerification)
                data["pendingVerification"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IAccountFutureRequirements extends IStripeEntityOfAccountFutureRequirements {
    /** Fields that are due and can be satisfied by providing the corresponding alternative
fields instead. */
    alternatives?: AccountFutureRequirementsAlternative[] | undefined;
    /** Date on which future_requirements merges with the main requirements hash
and future_requirements becomes empty. After the transition, currently_due
requirements may immediately become past_due, but the account may also be given a
grace period depending on its enablement state prior to transitioning. */
    currentDeadline?: Date | undefined;
    /** Fields that need to be collected to keep the account enabled. If not collected by
future_requirements[current_deadline], these fields will transition to the main
requirements hash. */
    currentlyDue?: string[] | undefined;
    /** This is typed as a string for consistency with requirements.disabled_reason, but
it safe to assume future_requirements.disabled_reason is empty because fields in
future_requirements will never disable the account. */
    disabledReason?: string | undefined;
    /** Fields that are currently_due and need to be collected again because validation
or verification failed. */
    errors?: AccountFutureRequirementsError[] | undefined;
    /** Fields that need to be collected assuming all volume thresholds are reached. As they
become required, they appear in currently_due as well. */
    eventuallyDue?: string[] | undefined;
    /** Fields that weren't collected by requirements.current_deadline. These fields need
to be collected to enable the capability on the account. New fields will never appear
here; future_requirements.past_due will always be a subset of
requirements.past_due. */
    pastDue?: string[] | undefined;
    /** Fields that may become required depending on the results of verification or review. Will
be an empty array unless an asynchronous verification is pending. If verification fails,
these fields move to eventually_due or currently_due. */
    pendingVerification?: string[] | undefined;
}

export abstract class StripeEntityOfAccountFutureRequirementsAlternative extends StripeEntity implements IStripeEntityOfAccountFutureRequirementsAlternative {

    constructor(data?: IStripeEntityOfAccountFutureRequirementsAlternative) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfAccountFutureRequirementsAlternative {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfAccountFutureRequirementsAlternative' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfAccountFutureRequirementsAlternative extends IStripeEntity {
}

export class AccountFutureRequirementsAlternative extends StripeEntityOfAccountFutureRequirementsAlternative implements IAccountFutureRequirementsAlternative {
    /** Fields that can be provided to satisfy all fields in original_fields_due. */
    alternativeFieldsDue?: string[] | undefined;
    /** Fields that are due and can be satisfied by providing all fields in
alternative_fields_due. */
    originalFieldsDue?: string[] | undefined;

    constructor(data?: IAccountFutureRequirementsAlternative) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["alternativeFieldsDue"])) {
                this.alternativeFieldsDue = [] as any;
                for (let item of _data["alternativeFieldsDue"])
                    this.alternativeFieldsDue!.push(item);
            }
            if (Array.isArray(_data["originalFieldsDue"])) {
                this.originalFieldsDue = [] as any;
                for (let item of _data["originalFieldsDue"])
                    this.originalFieldsDue!.push(item);
            }
        }
    }

    static override fromJS(data: any): AccountFutureRequirementsAlternative {
        data = typeof data === 'object' ? data : {};
        let result = new AccountFutureRequirementsAlternative();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.alternativeFieldsDue)) {
            data["alternativeFieldsDue"] = [];
            for (let item of this.alternativeFieldsDue)
                data["alternativeFieldsDue"].push(item);
        }
        if (Array.isArray(this.originalFieldsDue)) {
            data["originalFieldsDue"] = [];
            for (let item of this.originalFieldsDue)
                data["originalFieldsDue"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IAccountFutureRequirementsAlternative extends IStripeEntityOfAccountFutureRequirementsAlternative {
    /** Fields that can be provided to satisfy all fields in original_fields_due. */
    alternativeFieldsDue?: string[] | undefined;
    /** Fields that are due and can be satisfied by providing all fields in
alternative_fields_due. */
    originalFieldsDue?: string[] | undefined;
}

export abstract class StripeEntityOfAccountFutureRequirementsError extends StripeEntity implements IStripeEntityOfAccountFutureRequirementsError {

    constructor(data?: IStripeEntityOfAccountFutureRequirementsError) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfAccountFutureRequirementsError {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfAccountFutureRequirementsError' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfAccountFutureRequirementsError extends IStripeEntity {
}

export class AccountFutureRequirementsError extends StripeEntityOfAccountFutureRequirementsError implements IAccountFutureRequirementsError {
    /** The code for the type of error.
One of: invalid_address_city_state_postal_code, invalid_dob_age_under_18,
invalid_representative_country, invalid_street_address,
invalid_tos_acceptance, invalid_value_other,
verification_document_address_mismatch,
verification_document_address_missing, verification_document_corrupt,
verification_document_country_not_supported,
verification_document_dob_mismatch, verification_document_duplicate_type,
verification_document_expired, verification_document_failed_copy,
verification_document_failed_greyscale,
verification_document_failed_other,
verification_document_failed_test_mode, verification_document_fraudulent,
verification_document_id_number_mismatch,
verification_document_id_number_missing, verification_document_incomplete,
verification_document_invalid,
verification_document_issue_or_expiry_date_missing,
verification_document_manipulated, verification_document_missing_back,
verification_document_missing_front, verification_document_name_mismatch,
verification_document_name_missing,
verification_document_nationality_mismatch,
verification_document_not_readable, verification_document_not_signed,
verification_document_not_uploaded, verification_document_photo_mismatch,
verification_document_too_large, verification_document_type_not_supported,
verification_failed_address_match,
verification_failed_business_iec_number,
verification_failed_document_match, verification_failed_id_number_match,
verification_failed_keyed_identity, verification_failed_keyed_match,
verification_failed_name_match, verification_failed_other,
verification_failed_residential_address, verification_failed_tax_id_match,
verification_failed_tax_id_not_issued, verification_missing_executives,
verification_missing_owners, or
verification_requires_additional_memorandum_of_associations. */
    code?: string | undefined;
    /** An informative message that indicates the error type and provides additional details
about the error. */
    reason?: string | undefined;
    /** The specific user onboarding requirement field (in the requirements hash) that needs to
be resolved. */
    requirement?: string | undefined;

    constructor(data?: IAccountFutureRequirementsError) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.code = _data["code"];
            this.reason = _data["reason"];
            this.requirement = _data["requirement"];
        }
    }

    static override fromJS(data: any): AccountFutureRequirementsError {
        data = typeof data === 'object' ? data : {};
        let result = new AccountFutureRequirementsError();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["reason"] = this.reason;
        data["requirement"] = this.requirement;
        super.toJSON(data);
        return data;
    }
}

export interface IAccountFutureRequirementsError extends IStripeEntityOfAccountFutureRequirementsError {
    /** The code for the type of error.
One of: invalid_address_city_state_postal_code, invalid_dob_age_under_18,
invalid_representative_country, invalid_street_address,
invalid_tos_acceptance, invalid_value_other,
verification_document_address_mismatch,
verification_document_address_missing, verification_document_corrupt,
verification_document_country_not_supported,
verification_document_dob_mismatch, verification_document_duplicate_type,
verification_document_expired, verification_document_failed_copy,
verification_document_failed_greyscale,
verification_document_failed_other,
verification_document_failed_test_mode, verification_document_fraudulent,
verification_document_id_number_mismatch,
verification_document_id_number_missing, verification_document_incomplete,
verification_document_invalid,
verification_document_issue_or_expiry_date_missing,
verification_document_manipulated, verification_document_missing_back,
verification_document_missing_front, verification_document_name_mismatch,
verification_document_name_missing,
verification_document_nationality_mismatch,
verification_document_not_readable, verification_document_not_signed,
verification_document_not_uploaded, verification_document_photo_mismatch,
verification_document_too_large, verification_document_type_not_supported,
verification_failed_address_match,
verification_failed_business_iec_number,
verification_failed_document_match, verification_failed_id_number_match,
verification_failed_keyed_identity, verification_failed_keyed_match,
verification_failed_name_match, verification_failed_other,
verification_failed_residential_address, verification_failed_tax_id_match,
verification_failed_tax_id_not_issued, verification_missing_executives,
verification_missing_owners, or
verification_requires_additional_memorandum_of_associations. */
    code?: string | undefined;
    /** An informative message that indicates the error type and provides additional details
about the error. */
    reason?: string | undefined;
    /** The specific user onboarding requirement field (in the requirements hash) that needs to
be resolved. */
    requirement?: string | undefined;
}

export abstract class StripeEntityOfPerson extends StripeEntity implements IStripeEntityOfPerson {

    constructor(data?: IStripeEntityOfPerson) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPerson {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPerson' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPerson extends IStripeEntity {
}

/** This is an object representing a person associated with a Stripe account.            A platform cannot access a Standard or Express account's persons after the account starts onboarding, such as after generating an account link for the account. See the Standard onboarding or Express onboarding documentation for information about platform pre-filling and account onboarding steps.            Related guide: Handling identity verification with the API. */
export class Person extends StripeEntityOfPerson implements IPerson {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** The account the person is associated with. */
    account?: string | undefined;
    address?: Address | undefined;
    /** The Kana variation of the person's address (Japan only). */
    addressKana?: AddressJapan | undefined;
    /** The Kanji variation of the person's address (Japan only). */
    addressKanji?: AddressJapan | undefined;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** Whether this object is deleted or not. */
    deleted?: boolean | undefined;
    dob?: Dob | undefined;
    /** The person's email address. */
    email?: string | undefined;
    /** The person's first name. */
    firstName?: string | undefined;
    /** The Kana variation of the person's first name (Japan only). */
    firstNameKana?: string | undefined;
    /** The Kanji variation of the person's first name (Japan only). */
    firstNameKanji?: string | undefined;
    /** A list of alternate names or aliases that the person is known by. */
    fullNameAliases?: string[] | undefined;
    /** Information about the upcoming new requirements for this person, including what
information needs to be collected, and by when. */
    futureRequirements?: PersonFutureRequirements | undefined;
    /** The person's gender (International regulations require either "male" or "female"). */
    gender?: string | undefined;
    /** Whether the person's id_number was provided. */
    idNumberProvided?: boolean;
    /** Whether the person's id_number_secondary was provided. */
    idNumberSecondaryProvided?: boolean;
    /** The person's last name. */
    lastName?: string | undefined;
    /** The Kana variation of the person's last name (Japan only). */
    lastNameKana?: string | undefined;
    /** The Kanji variation of the person's last name (Japan only). */
    lastNameKanji?: string | undefined;
    /** The person's maiden name. */
    maidenName?: string | undefined;
    /** Set of key-value pairs that you can
attach to an object. This can be useful for storing additional information about the
object in a structured format. */
    metadata?: { [key: string]: string; } | undefined;
    /** The country where the person is a national. */
    nationality?: string | undefined;
    /** The person's phone number. */
    phone?: string | undefined;
    /** Indicates if the person or any of their representatives, family members, or other
closely related persons, declares that they hold or have held an important public job or
function, in any jurisdiction.
One of: existing, or none. */
    politicalExposure?: string | undefined;
    registeredAddress?: Address | undefined;
    relationship?: PersonRelationship | undefined;
    /** Information about the requirements for this person, including what information needs to
be collected, and by when. */
    requirements?: PersonRequirements | undefined;
    /** Whether the last four digits of the person's Social Security number have been provided
(U.S. only). */
    ssnLast4Provided?: boolean;
    verification?: PersonVerification | undefined;

    constructor(data?: IPerson) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.object = _data["object"];
            this.account = _data["account"];
            this.address = _data["address"] ? Address.fromJS(_data["address"]) : <any>undefined;
            this.addressKana = _data["addressKana"] ? AddressJapan.fromJS(_data["addressKana"]) : <any>undefined;
            this.addressKanji = _data["addressKanji"] ? AddressJapan.fromJS(_data["addressKanji"]) : <any>undefined;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.deleted = _data["deleted"];
            this.dob = _data["dob"] ? Dob.fromJS(_data["dob"]) : <any>undefined;
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.firstNameKana = _data["firstNameKana"];
            this.firstNameKanji = _data["firstNameKanji"];
            if (Array.isArray(_data["fullNameAliases"])) {
                this.fullNameAliases = [] as any;
                for (let item of _data["fullNameAliases"])
                    this.fullNameAliases!.push(item);
            }
            this.futureRequirements = _data["futureRequirements"] ? PersonFutureRequirements.fromJS(_data["futureRequirements"]) : <any>undefined;
            this.gender = _data["gender"];
            this.idNumberProvided = _data["idNumberProvided"];
            this.idNumberSecondaryProvided = _data["idNumberSecondaryProvided"];
            this.lastName = _data["lastName"];
            this.lastNameKana = _data["lastNameKana"];
            this.lastNameKanji = _data["lastNameKanji"];
            this.maidenName = _data["maidenName"];
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
            this.nationality = _data["nationality"];
            this.phone = _data["phone"];
            this.politicalExposure = _data["politicalExposure"];
            this.registeredAddress = _data["registeredAddress"] ? Address.fromJS(_data["registeredAddress"]) : <any>undefined;
            this.relationship = _data["relationship"] ? PersonRelationship.fromJS(_data["relationship"]) : <any>undefined;
            this.requirements = _data["requirements"] ? PersonRequirements.fromJS(_data["requirements"]) : <any>undefined;
            this.ssnLast4Provided = _data["ssnLast4Provided"];
            this.verification = _data["verification"] ? PersonVerification.fromJS(_data["verification"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): Person {
        data = typeof data === 'object' ? data : {};
        let result = new Person();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["object"] = this.object;
        data["account"] = this.account;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["addressKana"] = this.addressKana ? this.addressKana.toJSON() : <any>undefined;
        data["addressKanji"] = this.addressKanji ? this.addressKanji.toJSON() : <any>undefined;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["deleted"] = this.deleted;
        data["dob"] = this.dob ? this.dob.toJSON() : <any>undefined;
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["firstNameKana"] = this.firstNameKana;
        data["firstNameKanji"] = this.firstNameKanji;
        if (Array.isArray(this.fullNameAliases)) {
            data["fullNameAliases"] = [];
            for (let item of this.fullNameAliases)
                data["fullNameAliases"].push(item);
        }
        data["futureRequirements"] = this.futureRequirements ? this.futureRequirements.toJSON() : <any>undefined;
        data["gender"] = this.gender;
        data["idNumberProvided"] = this.idNumberProvided;
        data["idNumberSecondaryProvided"] = this.idNumberSecondaryProvided;
        data["lastName"] = this.lastName;
        data["lastNameKana"] = this.lastNameKana;
        data["lastNameKanji"] = this.lastNameKanji;
        data["maidenName"] = this.maidenName;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        data["nationality"] = this.nationality;
        data["phone"] = this.phone;
        data["politicalExposure"] = this.politicalExposure;
        data["registeredAddress"] = this.registeredAddress ? this.registeredAddress.toJSON() : <any>undefined;
        data["relationship"] = this.relationship ? this.relationship.toJSON() : <any>undefined;
        data["requirements"] = this.requirements ? this.requirements.toJSON() : <any>undefined;
        data["ssnLast4Provided"] = this.ssnLast4Provided;
        data["verification"] = this.verification ? this.verification.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** This is an object representing a person associated with a Stripe account.            A platform cannot access a Standard or Express account's persons after the account starts onboarding, such as after generating an account link for the account. See the Standard onboarding or Express onboarding documentation for information about platform pre-filling and account onboarding steps.            Related guide: Handling identity verification with the API. */
export interface IPerson extends IStripeEntityOfPerson {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** The account the person is associated with. */
    account?: string | undefined;
    address?: Address | undefined;
    /** The Kana variation of the person's address (Japan only). */
    addressKana?: AddressJapan | undefined;
    /** The Kanji variation of the person's address (Japan only). */
    addressKanji?: AddressJapan | undefined;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** Whether this object is deleted or not. */
    deleted?: boolean | undefined;
    dob?: Dob | undefined;
    /** The person's email address. */
    email?: string | undefined;
    /** The person's first name. */
    firstName?: string | undefined;
    /** The Kana variation of the person's first name (Japan only). */
    firstNameKana?: string | undefined;
    /** The Kanji variation of the person's first name (Japan only). */
    firstNameKanji?: string | undefined;
    /** A list of alternate names or aliases that the person is known by. */
    fullNameAliases?: string[] | undefined;
    /** Information about the upcoming new requirements for this person, including what
information needs to be collected, and by when. */
    futureRequirements?: PersonFutureRequirements | undefined;
    /** The person's gender (International regulations require either "male" or "female"). */
    gender?: string | undefined;
    /** Whether the person's id_number was provided. */
    idNumberProvided?: boolean;
    /** Whether the person's id_number_secondary was provided. */
    idNumberSecondaryProvided?: boolean;
    /** The person's last name. */
    lastName?: string | undefined;
    /** The Kana variation of the person's last name (Japan only). */
    lastNameKana?: string | undefined;
    /** The Kanji variation of the person's last name (Japan only). */
    lastNameKanji?: string | undefined;
    /** The person's maiden name. */
    maidenName?: string | undefined;
    /** Set of key-value pairs that you can
attach to an object. This can be useful for storing additional information about the
object in a structured format. */
    metadata?: { [key: string]: string; } | undefined;
    /** The country where the person is a national. */
    nationality?: string | undefined;
    /** The person's phone number. */
    phone?: string | undefined;
    /** Indicates if the person or any of their representatives, family members, or other
closely related persons, declares that they hold or have held an important public job or
function, in any jurisdiction.
One of: existing, or none. */
    politicalExposure?: string | undefined;
    registeredAddress?: Address | undefined;
    relationship?: PersonRelationship | undefined;
    /** Information about the requirements for this person, including what information needs to
be collected, and by when. */
    requirements?: PersonRequirements | undefined;
    /** Whether the last four digits of the person's Social Security number have been provided
(U.S. only). */
    ssnLast4Provided?: boolean;
    verification?: PersonVerification | undefined;
}

export abstract class StripeEntityOfDob extends StripeEntity implements IStripeEntityOfDob {

    constructor(data?: IStripeEntityOfDob) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfDob {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfDob' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfDob extends IStripeEntity {
}

export class Dob extends StripeEntityOfDob implements IDob {
    day?: number | undefined;
    month?: number | undefined;
    year?: number | undefined;

    constructor(data?: IDob) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.day = _data["day"];
            this.month = _data["month"];
            this.year = _data["year"];
        }
    }

    static override fromJS(data: any): Dob {
        data = typeof data === 'object' ? data : {};
        let result = new Dob();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["day"] = this.day;
        data["month"] = this.month;
        data["year"] = this.year;
        super.toJSON(data);
        return data;
    }
}

export interface IDob extends IStripeEntityOfDob {
    day?: number | undefined;
    month?: number | undefined;
    year?: number | undefined;
}

export abstract class StripeEntityOfPersonFutureRequirements extends StripeEntity implements IStripeEntityOfPersonFutureRequirements {

    constructor(data?: IStripeEntityOfPersonFutureRequirements) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPersonFutureRequirements {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPersonFutureRequirements' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPersonFutureRequirements extends IStripeEntity {
}

export class PersonFutureRequirements extends StripeEntityOfPersonFutureRequirements implements IPersonFutureRequirements {
    /** Fields that are due and can be satisfied by providing the corresponding alternative
fields instead. */
    alternatives?: PersonFutureRequirementsAlternative[] | undefined;
    /** Fields that need to be collected to keep the person's account enabled. If not collected
by the account's future_requirements[current_deadline], these fields will
transition to the main requirements hash, and may immediately become
past_due, but the account may also be given a grace period depending on the
account's enablement state prior to transition. */
    currentlyDue?: string[] | undefined;
    /** Fields that are currently_due and need to be collected again because validation
or verification failed. */
    errors?: PersonFutureRequirementsError[] | undefined;
    /** Fields that need to be collected assuming all volume thresholds are reached. As they
become required, they appear in currently_due as well, and the account's
future_requirements[current_deadline] becomes set. */
    eventuallyDue?: string[] | undefined;
    /** Fields that weren't collected by the account's requirements.current_deadline.
These fields need to be collected to enable the person's account. New fields will never
appear here; future_requirements.past_due will always be a subset of
requirements.past_due. */
    pastDue?: string[] | undefined;
    /** Fields that may become required depending on the results of verification or review. Will
be an empty array unless an asynchronous verification is pending. If verification fails,
these fields move to eventually_due or currently_due. */
    pendingVerification?: string[] | undefined;

    constructor(data?: IPersonFutureRequirements) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["alternatives"])) {
                this.alternatives = [] as any;
                for (let item of _data["alternatives"])
                    this.alternatives!.push(PersonFutureRequirementsAlternative.fromJS(item));
            }
            if (Array.isArray(_data["currentlyDue"])) {
                this.currentlyDue = [] as any;
                for (let item of _data["currentlyDue"])
                    this.currentlyDue!.push(item);
            }
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(PersonFutureRequirementsError.fromJS(item));
            }
            if (Array.isArray(_data["eventuallyDue"])) {
                this.eventuallyDue = [] as any;
                for (let item of _data["eventuallyDue"])
                    this.eventuallyDue!.push(item);
            }
            if (Array.isArray(_data["pastDue"])) {
                this.pastDue = [] as any;
                for (let item of _data["pastDue"])
                    this.pastDue!.push(item);
            }
            if (Array.isArray(_data["pendingVerification"])) {
                this.pendingVerification = [] as any;
                for (let item of _data["pendingVerification"])
                    this.pendingVerification!.push(item);
            }
        }
    }

    static override fromJS(data: any): PersonFutureRequirements {
        data = typeof data === 'object' ? data : {};
        let result = new PersonFutureRequirements();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.alternatives)) {
            data["alternatives"] = [];
            for (let item of this.alternatives)
                data["alternatives"].push(item.toJSON());
        }
        if (Array.isArray(this.currentlyDue)) {
            data["currentlyDue"] = [];
            for (let item of this.currentlyDue)
                data["currentlyDue"].push(item);
        }
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        if (Array.isArray(this.eventuallyDue)) {
            data["eventuallyDue"] = [];
            for (let item of this.eventuallyDue)
                data["eventuallyDue"].push(item);
        }
        if (Array.isArray(this.pastDue)) {
            data["pastDue"] = [];
            for (let item of this.pastDue)
                data["pastDue"].push(item);
        }
        if (Array.isArray(this.pendingVerification)) {
            data["pendingVerification"] = [];
            for (let item of this.pendingVerification)
                data["pendingVerification"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IPersonFutureRequirements extends IStripeEntityOfPersonFutureRequirements {
    /** Fields that are due and can be satisfied by providing the corresponding alternative
fields instead. */
    alternatives?: PersonFutureRequirementsAlternative[] | undefined;
    /** Fields that need to be collected to keep the person's account enabled. If not collected
by the account's future_requirements[current_deadline], these fields will
transition to the main requirements hash, and may immediately become
past_due, but the account may also be given a grace period depending on the
account's enablement state prior to transition. */
    currentlyDue?: string[] | undefined;
    /** Fields that are currently_due and need to be collected again because validation
or verification failed. */
    errors?: PersonFutureRequirementsError[] | undefined;
    /** Fields that need to be collected assuming all volume thresholds are reached. As they
become required, they appear in currently_due as well, and the account's
future_requirements[current_deadline] becomes set. */
    eventuallyDue?: string[] | undefined;
    /** Fields that weren't collected by the account's requirements.current_deadline.
These fields need to be collected to enable the person's account. New fields will never
appear here; future_requirements.past_due will always be a subset of
requirements.past_due. */
    pastDue?: string[] | undefined;
    /** Fields that may become required depending on the results of verification or review. Will
be an empty array unless an asynchronous verification is pending. If verification fails,
these fields move to eventually_due or currently_due. */
    pendingVerification?: string[] | undefined;
}

export abstract class StripeEntityOfPersonFutureRequirementsAlternative extends StripeEntity implements IStripeEntityOfPersonFutureRequirementsAlternative {

    constructor(data?: IStripeEntityOfPersonFutureRequirementsAlternative) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPersonFutureRequirementsAlternative {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPersonFutureRequirementsAlternative' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPersonFutureRequirementsAlternative extends IStripeEntity {
}

export class PersonFutureRequirementsAlternative extends StripeEntityOfPersonFutureRequirementsAlternative implements IPersonFutureRequirementsAlternative {
    /** Fields that can be provided to satisfy all fields in original_fields_due. */
    alternativeFieldsDue?: string[] | undefined;
    /** Fields that are due and can be satisfied by providing all fields in
alternative_fields_due. */
    originalFieldsDue?: string[] | undefined;

    constructor(data?: IPersonFutureRequirementsAlternative) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["alternativeFieldsDue"])) {
                this.alternativeFieldsDue = [] as any;
                for (let item of _data["alternativeFieldsDue"])
                    this.alternativeFieldsDue!.push(item);
            }
            if (Array.isArray(_data["originalFieldsDue"])) {
                this.originalFieldsDue = [] as any;
                for (let item of _data["originalFieldsDue"])
                    this.originalFieldsDue!.push(item);
            }
        }
    }

    static override fromJS(data: any): PersonFutureRequirementsAlternative {
        data = typeof data === 'object' ? data : {};
        let result = new PersonFutureRequirementsAlternative();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.alternativeFieldsDue)) {
            data["alternativeFieldsDue"] = [];
            for (let item of this.alternativeFieldsDue)
                data["alternativeFieldsDue"].push(item);
        }
        if (Array.isArray(this.originalFieldsDue)) {
            data["originalFieldsDue"] = [];
            for (let item of this.originalFieldsDue)
                data["originalFieldsDue"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IPersonFutureRequirementsAlternative extends IStripeEntityOfPersonFutureRequirementsAlternative {
    /** Fields that can be provided to satisfy all fields in original_fields_due. */
    alternativeFieldsDue?: string[] | undefined;
    /** Fields that are due and can be satisfied by providing all fields in
alternative_fields_due. */
    originalFieldsDue?: string[] | undefined;
}

export abstract class StripeEntityOfPersonFutureRequirementsError extends StripeEntity implements IStripeEntityOfPersonFutureRequirementsError {

    constructor(data?: IStripeEntityOfPersonFutureRequirementsError) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPersonFutureRequirementsError {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPersonFutureRequirementsError' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPersonFutureRequirementsError extends IStripeEntity {
}

export class PersonFutureRequirementsError extends StripeEntityOfPersonFutureRequirementsError implements IPersonFutureRequirementsError {
    /** The code for the type of error.
One of: invalid_address_city_state_postal_code, invalid_dob_age_under_18,
invalid_representative_country, invalid_street_address,
invalid_tos_acceptance, invalid_value_other,
verification_document_address_mismatch,
verification_document_address_missing, verification_document_corrupt,
verification_document_country_not_supported,
verification_document_dob_mismatch, verification_document_duplicate_type,
verification_document_expired, verification_document_failed_copy,
verification_document_failed_greyscale,
verification_document_failed_other,
verification_document_failed_test_mode, verification_document_fraudulent,
verification_document_id_number_mismatch,
verification_document_id_number_missing, verification_document_incomplete,
verification_document_invalid,
verification_document_issue_or_expiry_date_missing,
verification_document_manipulated, verification_document_missing_back,
verification_document_missing_front, verification_document_name_mismatch,
verification_document_name_missing,
verification_document_nationality_mismatch,
verification_document_not_readable, verification_document_not_signed,
verification_document_not_uploaded, verification_document_photo_mismatch,
verification_document_too_large, verification_document_type_not_supported,
verification_failed_address_match,
verification_failed_business_iec_number,
verification_failed_document_match, verification_failed_id_number_match,
verification_failed_keyed_identity, verification_failed_keyed_match,
verification_failed_name_match, verification_failed_other,
verification_failed_residential_address, verification_failed_tax_id_match,
verification_failed_tax_id_not_issued, verification_missing_executives,
verification_missing_owners, or
verification_requires_additional_memorandum_of_associations. */
    code?: string | undefined;
    /** An informative message that indicates the error type and provides additional details
about the error. */
    reason?: string | undefined;
    /** The specific user onboarding requirement field (in the requirements hash) that needs to
be resolved. */
    requirement?: string | undefined;

    constructor(data?: IPersonFutureRequirementsError) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.code = _data["code"];
            this.reason = _data["reason"];
            this.requirement = _data["requirement"];
        }
    }

    static override fromJS(data: any): PersonFutureRequirementsError {
        data = typeof data === 'object' ? data : {};
        let result = new PersonFutureRequirementsError();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["reason"] = this.reason;
        data["requirement"] = this.requirement;
        super.toJSON(data);
        return data;
    }
}

export interface IPersonFutureRequirementsError extends IStripeEntityOfPersonFutureRequirementsError {
    /** The code for the type of error.
One of: invalid_address_city_state_postal_code, invalid_dob_age_under_18,
invalid_representative_country, invalid_street_address,
invalid_tos_acceptance, invalid_value_other,
verification_document_address_mismatch,
verification_document_address_missing, verification_document_corrupt,
verification_document_country_not_supported,
verification_document_dob_mismatch, verification_document_duplicate_type,
verification_document_expired, verification_document_failed_copy,
verification_document_failed_greyscale,
verification_document_failed_other,
verification_document_failed_test_mode, verification_document_fraudulent,
verification_document_id_number_mismatch,
verification_document_id_number_missing, verification_document_incomplete,
verification_document_invalid,
verification_document_issue_or_expiry_date_missing,
verification_document_manipulated, verification_document_missing_back,
verification_document_missing_front, verification_document_name_mismatch,
verification_document_name_missing,
verification_document_nationality_mismatch,
verification_document_not_readable, verification_document_not_signed,
verification_document_not_uploaded, verification_document_photo_mismatch,
verification_document_too_large, verification_document_type_not_supported,
verification_failed_address_match,
verification_failed_business_iec_number,
verification_failed_document_match, verification_failed_id_number_match,
verification_failed_keyed_identity, verification_failed_keyed_match,
verification_failed_name_match, verification_failed_other,
verification_failed_residential_address, verification_failed_tax_id_match,
verification_failed_tax_id_not_issued, verification_missing_executives,
verification_missing_owners, or
verification_requires_additional_memorandum_of_associations. */
    code?: string | undefined;
    /** An informative message that indicates the error type and provides additional details
about the error. */
    reason?: string | undefined;
    /** The specific user onboarding requirement field (in the requirements hash) that needs to
be resolved. */
    requirement?: string | undefined;
}

export abstract class StripeEntityOfPersonRelationship extends StripeEntity implements IStripeEntityOfPersonRelationship {

    constructor(data?: IStripeEntityOfPersonRelationship) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPersonRelationship {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPersonRelationship' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPersonRelationship extends IStripeEntity {
}

export class PersonRelationship extends StripeEntityOfPersonRelationship implements IPersonRelationship {
    /** Whether the person is a director of the account's legal entity. Directors are typically
members of the governing board of the company, or responsible for ensuring the company
meets its regulatory obligations. */
    director?: boolean | undefined;
    /** Whether the person has significant responsibility to control, manage, or direct the
organization. */
    executive?: boolean | undefined;
    /** Whether the person is an owner of the account’s legal entity. */
    owner?: boolean | undefined;
    /** The percent owned by the person of the account's legal entity. */
    percentOwnership?: number | undefined;
    /** Whether the person is authorized as the primary representative of the account. This is
the person nominated by the business to provide information about themselves, and
general information about the account. There can only be one representative at any given
time. At the time the account is created, this person should be set to the person
responsible for opening the account. */
    representative?: boolean | undefined;
    /** The person's title (e.g., CEO, Support Engineer). */
    title?: string | undefined;

    constructor(data?: IPersonRelationship) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.director = _data["director"];
            this.executive = _data["executive"];
            this.owner = _data["owner"];
            this.percentOwnership = _data["percentOwnership"];
            this.representative = _data["representative"];
            this.title = _data["title"];
        }
    }

    static override fromJS(data: any): PersonRelationship {
        data = typeof data === 'object' ? data : {};
        let result = new PersonRelationship();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["director"] = this.director;
        data["executive"] = this.executive;
        data["owner"] = this.owner;
        data["percentOwnership"] = this.percentOwnership;
        data["representative"] = this.representative;
        data["title"] = this.title;
        super.toJSON(data);
        return data;
    }
}

export interface IPersonRelationship extends IStripeEntityOfPersonRelationship {
    /** Whether the person is a director of the account's legal entity. Directors are typically
members of the governing board of the company, or responsible for ensuring the company
meets its regulatory obligations. */
    director?: boolean | undefined;
    /** Whether the person has significant responsibility to control, manage, or direct the
organization. */
    executive?: boolean | undefined;
    /** Whether the person is an owner of the account’s legal entity. */
    owner?: boolean | undefined;
    /** The percent owned by the person of the account's legal entity. */
    percentOwnership?: number | undefined;
    /** Whether the person is authorized as the primary representative of the account. This is
the person nominated by the business to provide information about themselves, and
general information about the account. There can only be one representative at any given
time. At the time the account is created, this person should be set to the person
responsible for opening the account. */
    representative?: boolean | undefined;
    /** The person's title (e.g., CEO, Support Engineer). */
    title?: string | undefined;
}

export abstract class StripeEntityOfPersonRequirements extends StripeEntity implements IStripeEntityOfPersonRequirements {

    constructor(data?: IStripeEntityOfPersonRequirements) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPersonRequirements {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPersonRequirements' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPersonRequirements extends IStripeEntity {
}

export class PersonRequirements extends StripeEntityOfPersonRequirements implements IPersonRequirements {
    /** Fields that are due and can be satisfied by providing the corresponding alternative
fields instead. */
    alternatives?: PersonRequirementsAlternative[] | undefined;
    /** Fields that need to be collected to keep the person's account enabled. If not collected
by the account's current_deadline, these fields appear in past_due as
well, and the account is disabled. */
    currentlyDue?: string[] | undefined;
    /** Fields that are currently_due and need to be collected again because validation
or verification failed. */
    errors?: PersonRequirementsError[] | undefined;
    /** Fields that need to be collected assuming all volume thresholds are reached. As they
become required, they appear in currently_due as well, and the account's
current_deadline becomes set. */
    eventuallyDue?: string[] | undefined;
    /** Fields that weren't collected by the account's current_deadline. These fields
need to be collected to enable the person's account. */
    pastDue?: string[] | undefined;
    /** Fields that may become required depending on the results of verification or review. Will
be an empty array unless an asynchronous verification is pending. If verification fails,
these fields move to eventually_due, currently_due, or past_due. */
    pendingVerification?: string[] | undefined;

    constructor(data?: IPersonRequirements) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["alternatives"])) {
                this.alternatives = [] as any;
                for (let item of _data["alternatives"])
                    this.alternatives!.push(PersonRequirementsAlternative.fromJS(item));
            }
            if (Array.isArray(_data["currentlyDue"])) {
                this.currentlyDue = [] as any;
                for (let item of _data["currentlyDue"])
                    this.currentlyDue!.push(item);
            }
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(PersonRequirementsError.fromJS(item));
            }
            if (Array.isArray(_data["eventuallyDue"])) {
                this.eventuallyDue = [] as any;
                for (let item of _data["eventuallyDue"])
                    this.eventuallyDue!.push(item);
            }
            if (Array.isArray(_data["pastDue"])) {
                this.pastDue = [] as any;
                for (let item of _data["pastDue"])
                    this.pastDue!.push(item);
            }
            if (Array.isArray(_data["pendingVerification"])) {
                this.pendingVerification = [] as any;
                for (let item of _data["pendingVerification"])
                    this.pendingVerification!.push(item);
            }
        }
    }

    static override fromJS(data: any): PersonRequirements {
        data = typeof data === 'object' ? data : {};
        let result = new PersonRequirements();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.alternatives)) {
            data["alternatives"] = [];
            for (let item of this.alternatives)
                data["alternatives"].push(item.toJSON());
        }
        if (Array.isArray(this.currentlyDue)) {
            data["currentlyDue"] = [];
            for (let item of this.currentlyDue)
                data["currentlyDue"].push(item);
        }
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        if (Array.isArray(this.eventuallyDue)) {
            data["eventuallyDue"] = [];
            for (let item of this.eventuallyDue)
                data["eventuallyDue"].push(item);
        }
        if (Array.isArray(this.pastDue)) {
            data["pastDue"] = [];
            for (let item of this.pastDue)
                data["pastDue"].push(item);
        }
        if (Array.isArray(this.pendingVerification)) {
            data["pendingVerification"] = [];
            for (let item of this.pendingVerification)
                data["pendingVerification"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IPersonRequirements extends IStripeEntityOfPersonRequirements {
    /** Fields that are due and can be satisfied by providing the corresponding alternative
fields instead. */
    alternatives?: PersonRequirementsAlternative[] | undefined;
    /** Fields that need to be collected to keep the person's account enabled. If not collected
by the account's current_deadline, these fields appear in past_due as
well, and the account is disabled. */
    currentlyDue?: string[] | undefined;
    /** Fields that are currently_due and need to be collected again because validation
or verification failed. */
    errors?: PersonRequirementsError[] | undefined;
    /** Fields that need to be collected assuming all volume thresholds are reached. As they
become required, they appear in currently_due as well, and the account's
current_deadline becomes set. */
    eventuallyDue?: string[] | undefined;
    /** Fields that weren't collected by the account's current_deadline. These fields
need to be collected to enable the person's account. */
    pastDue?: string[] | undefined;
    /** Fields that may become required depending on the results of verification or review. Will
be an empty array unless an asynchronous verification is pending. If verification fails,
these fields move to eventually_due, currently_due, or past_due. */
    pendingVerification?: string[] | undefined;
}

export abstract class StripeEntityOfPersonRequirementsAlternative extends StripeEntity implements IStripeEntityOfPersonRequirementsAlternative {

    constructor(data?: IStripeEntityOfPersonRequirementsAlternative) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPersonRequirementsAlternative {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPersonRequirementsAlternative' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPersonRequirementsAlternative extends IStripeEntity {
}

export class PersonRequirementsAlternative extends StripeEntityOfPersonRequirementsAlternative implements IPersonRequirementsAlternative {
    /** Fields that can be provided to satisfy all fields in original_fields_due. */
    alternativeFieldsDue?: string[] | undefined;
    /** Fields that are due and can be satisfied by providing all fields in
alternative_fields_due. */
    originalFieldsDue?: string[] | undefined;

    constructor(data?: IPersonRequirementsAlternative) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["alternativeFieldsDue"])) {
                this.alternativeFieldsDue = [] as any;
                for (let item of _data["alternativeFieldsDue"])
                    this.alternativeFieldsDue!.push(item);
            }
            if (Array.isArray(_data["originalFieldsDue"])) {
                this.originalFieldsDue = [] as any;
                for (let item of _data["originalFieldsDue"])
                    this.originalFieldsDue!.push(item);
            }
        }
    }

    static override fromJS(data: any): PersonRequirementsAlternative {
        data = typeof data === 'object' ? data : {};
        let result = new PersonRequirementsAlternative();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.alternativeFieldsDue)) {
            data["alternativeFieldsDue"] = [];
            for (let item of this.alternativeFieldsDue)
                data["alternativeFieldsDue"].push(item);
        }
        if (Array.isArray(this.originalFieldsDue)) {
            data["originalFieldsDue"] = [];
            for (let item of this.originalFieldsDue)
                data["originalFieldsDue"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IPersonRequirementsAlternative extends IStripeEntityOfPersonRequirementsAlternative {
    /** Fields that can be provided to satisfy all fields in original_fields_due. */
    alternativeFieldsDue?: string[] | undefined;
    /** Fields that are due and can be satisfied by providing all fields in
alternative_fields_due. */
    originalFieldsDue?: string[] | undefined;
}

export abstract class StripeEntityOfPersonRequirementsError extends StripeEntity implements IStripeEntityOfPersonRequirementsError {

    constructor(data?: IStripeEntityOfPersonRequirementsError) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPersonRequirementsError {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPersonRequirementsError' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPersonRequirementsError extends IStripeEntity {
}

export class PersonRequirementsError extends StripeEntityOfPersonRequirementsError implements IPersonRequirementsError {
    /** The code for the type of error.
One of: invalid_address_city_state_postal_code, invalid_dob_age_under_18,
invalid_representative_country, invalid_street_address,
invalid_tos_acceptance, invalid_value_other,
verification_document_address_mismatch,
verification_document_address_missing, verification_document_corrupt,
verification_document_country_not_supported,
verification_document_dob_mismatch, verification_document_duplicate_type,
verification_document_expired, verification_document_failed_copy,
verification_document_failed_greyscale,
verification_document_failed_other,
verification_document_failed_test_mode, verification_document_fraudulent,
verification_document_id_number_mismatch,
verification_document_id_number_missing, verification_document_incomplete,
verification_document_invalid,
verification_document_issue_or_expiry_date_missing,
verification_document_manipulated, verification_document_missing_back,
verification_document_missing_front, verification_document_name_mismatch,
verification_document_name_missing,
verification_document_nationality_mismatch,
verification_document_not_readable, verification_document_not_signed,
verification_document_not_uploaded, verification_document_photo_mismatch,
verification_document_too_large, verification_document_type_not_supported,
verification_failed_address_match,
verification_failed_business_iec_number,
verification_failed_document_match, verification_failed_id_number_match,
verification_failed_keyed_identity, verification_failed_keyed_match,
verification_failed_name_match, verification_failed_other,
verification_failed_residential_address, verification_failed_tax_id_match,
verification_failed_tax_id_not_issued, verification_missing_executives,
verification_missing_owners, or
verification_requires_additional_memorandum_of_associations. */
    code?: string | undefined;
    /** An informative message that indicates the error type and provides additional details
about the error. */
    reason?: string | undefined;
    /** The specific user onboarding requirement field (in the requirements hash) that needs to
be resolved. */
    requirement?: string | undefined;

    constructor(data?: IPersonRequirementsError) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.code = _data["code"];
            this.reason = _data["reason"];
            this.requirement = _data["requirement"];
        }
    }

    static override fromJS(data: any): PersonRequirementsError {
        data = typeof data === 'object' ? data : {};
        let result = new PersonRequirementsError();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["reason"] = this.reason;
        data["requirement"] = this.requirement;
        super.toJSON(data);
        return data;
    }
}

export interface IPersonRequirementsError extends IStripeEntityOfPersonRequirementsError {
    /** The code for the type of error.
One of: invalid_address_city_state_postal_code, invalid_dob_age_under_18,
invalid_representative_country, invalid_street_address,
invalid_tos_acceptance, invalid_value_other,
verification_document_address_mismatch,
verification_document_address_missing, verification_document_corrupt,
verification_document_country_not_supported,
verification_document_dob_mismatch, verification_document_duplicate_type,
verification_document_expired, verification_document_failed_copy,
verification_document_failed_greyscale,
verification_document_failed_other,
verification_document_failed_test_mode, verification_document_fraudulent,
verification_document_id_number_mismatch,
verification_document_id_number_missing, verification_document_incomplete,
verification_document_invalid,
verification_document_issue_or_expiry_date_missing,
verification_document_manipulated, verification_document_missing_back,
verification_document_missing_front, verification_document_name_mismatch,
verification_document_name_missing,
verification_document_nationality_mismatch,
verification_document_not_readable, verification_document_not_signed,
verification_document_not_uploaded, verification_document_photo_mismatch,
verification_document_too_large, verification_document_type_not_supported,
verification_failed_address_match,
verification_failed_business_iec_number,
verification_failed_document_match, verification_failed_id_number_match,
verification_failed_keyed_identity, verification_failed_keyed_match,
verification_failed_name_match, verification_failed_other,
verification_failed_residential_address, verification_failed_tax_id_match,
verification_failed_tax_id_not_issued, verification_missing_executives,
verification_missing_owners, or
verification_requires_additional_memorandum_of_associations. */
    code?: string | undefined;
    /** An informative message that indicates the error type and provides additional details
about the error. */
    reason?: string | undefined;
    /** The specific user onboarding requirement field (in the requirements hash) that needs to
be resolved. */
    requirement?: string | undefined;
}

export abstract class StripeEntityOfPersonVerification extends StripeEntity implements IStripeEntityOfPersonVerification {

    constructor(data?: IStripeEntityOfPersonVerification) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPersonVerification {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPersonVerification' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPersonVerification extends IStripeEntity {
}

export class PersonVerification extends StripeEntityOfPersonVerification implements IPersonVerification {
    /** A document showing address, either a passport, local ID card, or utility bill from a
well-known utility company. */
    additionalDocument?: PersonVerificationAdditionalDocument | undefined;
    /** A user-displayable string describing the verification state for the person. For example,
this may say "Provided identity information could not be verified". */
    details?: string | undefined;
    /** One of document_address_mismatch, document_dob_mismatch,
document_duplicate_type, document_id_number_mismatch,
document_name_mismatch, document_nationality_mismatch,
failed_keyed_identity, or failed_other. A machine-readable code specifying
the verification state for the person. */
    detailsCode?: string | undefined;
    document?: PersonVerificationDocument | undefined;
    /** The state of verification for the person. Possible values are unverified,
pending, or verified. */
    status?: string | undefined;

    constructor(data?: IPersonVerification) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.additionalDocument = _data["additionalDocument"] ? PersonVerificationAdditionalDocument.fromJS(_data["additionalDocument"]) : <any>undefined;
            this.details = _data["details"];
            this.detailsCode = _data["detailsCode"];
            this.document = _data["document"] ? PersonVerificationDocument.fromJS(_data["document"]) : <any>undefined;
            this.status = _data["status"];
        }
    }

    static override fromJS(data: any): PersonVerification {
        data = typeof data === 'object' ? data : {};
        let result = new PersonVerification();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["additionalDocument"] = this.additionalDocument ? this.additionalDocument.toJSON() : <any>undefined;
        data["details"] = this.details;
        data["detailsCode"] = this.detailsCode;
        data["document"] = this.document ? this.document.toJSON() : <any>undefined;
        data["status"] = this.status;
        super.toJSON(data);
        return data;
    }
}

export interface IPersonVerification extends IStripeEntityOfPersonVerification {
    /** A document showing address, either a passport, local ID card, or utility bill from a
well-known utility company. */
    additionalDocument?: PersonVerificationAdditionalDocument | undefined;
    /** A user-displayable string describing the verification state for the person. For example,
this may say "Provided identity information could not be verified". */
    details?: string | undefined;
    /** One of document_address_mismatch, document_dob_mismatch,
document_duplicate_type, document_id_number_mismatch,
document_name_mismatch, document_nationality_mismatch,
failed_keyed_identity, or failed_other. A machine-readable code specifying
the verification state for the person. */
    detailsCode?: string | undefined;
    document?: PersonVerificationDocument | undefined;
    /** The state of verification for the person. Possible values are unverified,
pending, or verified. */
    status?: string | undefined;
}

export abstract class StripeEntityOfPersonVerificationAdditionalDocument extends StripeEntity implements IStripeEntityOfPersonVerificationAdditionalDocument {

    constructor(data?: IStripeEntityOfPersonVerificationAdditionalDocument) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPersonVerificationAdditionalDocument {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPersonVerificationAdditionalDocument' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPersonVerificationAdditionalDocument extends IStripeEntity {
}

export class PersonVerificationAdditionalDocument extends StripeEntityOfPersonVerificationAdditionalDocument implements IPersonVerificationAdditionalDocument {
    /** (ID of the File)
The back of an ID returned by a file
upload with a purpose value of identity_document. */
    backId?: string | undefined;
    /** (Expanded)
The back of an ID returned by a file
upload with a purpose value of identity_document.
            
For more information, see the expand documentation. */
    back?: File | undefined;
    internalBack?: ExpandableFieldOfFile | undefined;
    /** A user-displayable string describing the verification state of this document. For
example, if a document is uploaded and the picture is too fuzzy, this may say "Identity
document is too unclear to read". */
    details?: string | undefined;
    /** One of document_corrupt, document_country_not_supported,
document_expired, document_failed_copy, document_failed_other,
document_failed_test_mode, document_fraudulent,
document_failed_greyscale, document_incomplete, document_invalid,
document_manipulated, document_missing_back,
document_missing_front, document_not_readable,
document_not_uploaded, document_photo_mismatch, document_too_large,
or document_type_not_supported. A machine-readable code specifying the
verification state for this document. */
    detailsCode?: string | undefined;
    /** (ID of the File)
The front of an ID returned by a file
upload with a purpose value of identity_document. */
    frontId?: string | undefined;
    /** (Expanded)
The front of an ID returned by a file
upload with a purpose value of identity_document.
            
For more information, see the expand documentation. */
    front?: File | undefined;
    internalFront?: ExpandableFieldOfFile | undefined;

    constructor(data?: IPersonVerificationAdditionalDocument) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.backId = _data["backId"];
            this.back = _data["back"] ? File.fromJS(_data["back"]) : <any>undefined;
            this.internalBack = _data["internalBack"] ? ExpandableFieldOfFile.fromJS(_data["internalBack"]) : <any>undefined;
            this.details = _data["details"];
            this.detailsCode = _data["detailsCode"];
            this.frontId = _data["frontId"];
            this.front = _data["front"] ? File.fromJS(_data["front"]) : <any>undefined;
            this.internalFront = _data["internalFront"] ? ExpandableFieldOfFile.fromJS(_data["internalFront"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): PersonVerificationAdditionalDocument {
        data = typeof data === 'object' ? data : {};
        let result = new PersonVerificationAdditionalDocument();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["backId"] = this.backId;
        data["back"] = this.back ? this.back.toJSON() : <any>undefined;
        data["internalBack"] = this.internalBack ? this.internalBack.toJSON() : <any>undefined;
        data["details"] = this.details;
        data["detailsCode"] = this.detailsCode;
        data["frontId"] = this.frontId;
        data["front"] = this.front ? this.front.toJSON() : <any>undefined;
        data["internalFront"] = this.internalFront ? this.internalFront.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IPersonVerificationAdditionalDocument extends IStripeEntityOfPersonVerificationAdditionalDocument {
    /** (ID of the File)
The back of an ID returned by a file
upload with a purpose value of identity_document. */
    backId?: string | undefined;
    /** (Expanded)
The back of an ID returned by a file
upload with a purpose value of identity_document.
            
For more information, see the expand documentation. */
    back?: File | undefined;
    internalBack?: ExpandableFieldOfFile | undefined;
    /** A user-displayable string describing the verification state of this document. For
example, if a document is uploaded and the picture is too fuzzy, this may say "Identity
document is too unclear to read". */
    details?: string | undefined;
    /** One of document_corrupt, document_country_not_supported,
document_expired, document_failed_copy, document_failed_other,
document_failed_test_mode, document_fraudulent,
document_failed_greyscale, document_incomplete, document_invalid,
document_manipulated, document_missing_back,
document_missing_front, document_not_readable,
document_not_uploaded, document_photo_mismatch, document_too_large,
or document_type_not_supported. A machine-readable code specifying the
verification state for this document. */
    detailsCode?: string | undefined;
    /** (ID of the File)
The front of an ID returned by a file
upload with a purpose value of identity_document. */
    frontId?: string | undefined;
    /** (Expanded)
The front of an ID returned by a file
upload with a purpose value of identity_document.
            
For more information, see the expand documentation. */
    front?: File | undefined;
    internalFront?: ExpandableFieldOfFile | undefined;
}

export abstract class StripeEntityOfPersonVerificationDocument extends StripeEntity implements IStripeEntityOfPersonVerificationDocument {

    constructor(data?: IStripeEntityOfPersonVerificationDocument) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPersonVerificationDocument {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPersonVerificationDocument' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPersonVerificationDocument extends IStripeEntity {
}

export class PersonVerificationDocument extends StripeEntityOfPersonVerificationDocument implements IPersonVerificationDocument {
    /** (ID of the File)
The back of an ID returned by a file
upload with a purpose value of identity_document. */
    backId?: string | undefined;
    /** (Expanded)
The back of an ID returned by a file
upload with a purpose value of identity_document.
            
For more information, see the expand documentation. */
    back?: File | undefined;
    internalBack?: ExpandableFieldOfFile | undefined;
    /** A user-displayable string describing the verification state of this document. For
example, if a document is uploaded and the picture is too fuzzy, this may say "Identity
document is too unclear to read". */
    details?: string | undefined;
    /** One of document_corrupt, document_country_not_supported,
document_expired, document_failed_copy, document_failed_other,
document_failed_test_mode, document_fraudulent,
document_failed_greyscale, document_incomplete, document_invalid,
document_manipulated, document_missing_back,
document_missing_front, document_not_readable,
document_not_uploaded, document_photo_mismatch, document_too_large,
or document_type_not_supported. A machine-readable code specifying the
verification state for this document. */
    detailsCode?: string | undefined;
    /** (ID of the File)
The front of an ID returned by a file
upload with a purpose value of identity_document. */
    frontId?: string | undefined;
    /** (Expanded)
The front of an ID returned by a file
upload with a purpose value of identity_document.
            
For more information, see the expand documentation. */
    front?: File | undefined;
    internalFront?: ExpandableFieldOfFile | undefined;

    constructor(data?: IPersonVerificationDocument) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.backId = _data["backId"];
            this.back = _data["back"] ? File.fromJS(_data["back"]) : <any>undefined;
            this.internalBack = _data["internalBack"] ? ExpandableFieldOfFile.fromJS(_data["internalBack"]) : <any>undefined;
            this.details = _data["details"];
            this.detailsCode = _data["detailsCode"];
            this.frontId = _data["frontId"];
            this.front = _data["front"] ? File.fromJS(_data["front"]) : <any>undefined;
            this.internalFront = _data["internalFront"] ? ExpandableFieldOfFile.fromJS(_data["internalFront"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): PersonVerificationDocument {
        data = typeof data === 'object' ? data : {};
        let result = new PersonVerificationDocument();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["backId"] = this.backId;
        data["back"] = this.back ? this.back.toJSON() : <any>undefined;
        data["internalBack"] = this.internalBack ? this.internalBack.toJSON() : <any>undefined;
        data["details"] = this.details;
        data["detailsCode"] = this.detailsCode;
        data["frontId"] = this.frontId;
        data["front"] = this.front ? this.front.toJSON() : <any>undefined;
        data["internalFront"] = this.internalFront ? this.internalFront.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IPersonVerificationDocument extends IStripeEntityOfPersonVerificationDocument {
    /** (ID of the File)
The back of an ID returned by a file
upload with a purpose value of identity_document. */
    backId?: string | undefined;
    /** (Expanded)
The back of an ID returned by a file
upload with a purpose value of identity_document.
            
For more information, see the expand documentation. */
    back?: File | undefined;
    internalBack?: ExpandableFieldOfFile | undefined;
    /** A user-displayable string describing the verification state of this document. For
example, if a document is uploaded and the picture is too fuzzy, this may say "Identity
document is too unclear to read". */
    details?: string | undefined;
    /** One of document_corrupt, document_country_not_supported,
document_expired, document_failed_copy, document_failed_other,
document_failed_test_mode, document_fraudulent,
document_failed_greyscale, document_incomplete, document_invalid,
document_manipulated, document_missing_back,
document_missing_front, document_not_readable,
document_not_uploaded, document_photo_mismatch, document_too_large,
or document_type_not_supported. A machine-readable code specifying the
verification state for this document. */
    detailsCode?: string | undefined;
    /** (ID of the File)
The front of an ID returned by a file
upload with a purpose value of identity_document. */
    frontId?: string | undefined;
    /** (Expanded)
The front of an ID returned by a file
upload with a purpose value of identity_document.
            
For more information, see the expand documentation. */
    front?: File | undefined;
    internalFront?: ExpandableFieldOfFile | undefined;
}

export abstract class StripeEntityOfAccountRequirements extends StripeEntity implements IStripeEntityOfAccountRequirements {

    constructor(data?: IStripeEntityOfAccountRequirements) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfAccountRequirements {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfAccountRequirements' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfAccountRequirements extends IStripeEntity {
}

export class AccountRequirements extends StripeEntityOfAccountRequirements implements IAccountRequirements {
    /** Fields that are due and can be satisfied by providing the corresponding alternative
fields instead. */
    alternatives?: AccountRequirementsAlternative[] | undefined;
    /** Date by which the fields in currently_due must be collected to keep the account
enabled. These fields may disable the account sooner if the next threshold is reached
before they are collected. */
    currentDeadline?: Date | undefined;
    /** Fields that need to be collected to keep the account enabled. If not collected by
current_deadline, these fields appear in past_due as well, and the account
is disabled. */
    currentlyDue?: string[] | undefined;
    /** If the account is disabled, this string describes why. Can be
requirements.past_due, requirements.pending_verification, listed,
platform_paused, rejected.fraud, rejected.listed,
rejected.terms_of_service, rejected.other, under_review, or
other. */
    disabledReason?: string | undefined;
    /** Fields that are currently_due and need to be collected again because validation
or verification failed. */
    errors?: AccountRequirementsError[] | undefined;
    /** Fields that need to be collected assuming all volume thresholds are reached. As they
become required, they appear in currently_due as well, and
current_deadline becomes set. */
    eventuallyDue?: string[] | undefined;
    /** Fields that weren't collected by current_deadline. These fields need to be
collected to enable the account. */
    pastDue?: string[] | undefined;
    /** Fields that may become required depending on the results of verification or review. Will
be an empty array unless an asynchronous verification is pending. If verification fails,
these fields move to eventually_due, currently_due, or past_due. */
    pendingVerification?: string[] | undefined;

    constructor(data?: IAccountRequirements) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["alternatives"])) {
                this.alternatives = [] as any;
                for (let item of _data["alternatives"])
                    this.alternatives!.push(AccountRequirementsAlternative.fromJS(item));
            }
            this.currentDeadline = _data["currentDeadline"] ? new Date(_data["currentDeadline"].toString()) : <any>undefined;
            if (Array.isArray(_data["currentlyDue"])) {
                this.currentlyDue = [] as any;
                for (let item of _data["currentlyDue"])
                    this.currentlyDue!.push(item);
            }
            this.disabledReason = _data["disabledReason"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(AccountRequirementsError.fromJS(item));
            }
            if (Array.isArray(_data["eventuallyDue"])) {
                this.eventuallyDue = [] as any;
                for (let item of _data["eventuallyDue"])
                    this.eventuallyDue!.push(item);
            }
            if (Array.isArray(_data["pastDue"])) {
                this.pastDue = [] as any;
                for (let item of _data["pastDue"])
                    this.pastDue!.push(item);
            }
            if (Array.isArray(_data["pendingVerification"])) {
                this.pendingVerification = [] as any;
                for (let item of _data["pendingVerification"])
                    this.pendingVerification!.push(item);
            }
        }
    }

    static override fromJS(data: any): AccountRequirements {
        data = typeof data === 'object' ? data : {};
        let result = new AccountRequirements();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.alternatives)) {
            data["alternatives"] = [];
            for (let item of this.alternatives)
                data["alternatives"].push(item.toJSON());
        }
        data["currentDeadline"] = this.currentDeadline ? this.currentDeadline.toISOString() : <any>undefined;
        if (Array.isArray(this.currentlyDue)) {
            data["currentlyDue"] = [];
            for (let item of this.currentlyDue)
                data["currentlyDue"].push(item);
        }
        data["disabledReason"] = this.disabledReason;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        if (Array.isArray(this.eventuallyDue)) {
            data["eventuallyDue"] = [];
            for (let item of this.eventuallyDue)
                data["eventuallyDue"].push(item);
        }
        if (Array.isArray(this.pastDue)) {
            data["pastDue"] = [];
            for (let item of this.pastDue)
                data["pastDue"].push(item);
        }
        if (Array.isArray(this.pendingVerification)) {
            data["pendingVerification"] = [];
            for (let item of this.pendingVerification)
                data["pendingVerification"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IAccountRequirements extends IStripeEntityOfAccountRequirements {
    /** Fields that are due and can be satisfied by providing the corresponding alternative
fields instead. */
    alternatives?: AccountRequirementsAlternative[] | undefined;
    /** Date by which the fields in currently_due must be collected to keep the account
enabled. These fields may disable the account sooner if the next threshold is reached
before they are collected. */
    currentDeadline?: Date | undefined;
    /** Fields that need to be collected to keep the account enabled. If not collected by
current_deadline, these fields appear in past_due as well, and the account
is disabled. */
    currentlyDue?: string[] | undefined;
    /** If the account is disabled, this string describes why. Can be
requirements.past_due, requirements.pending_verification, listed,
platform_paused, rejected.fraud, rejected.listed,
rejected.terms_of_service, rejected.other, under_review, or
other. */
    disabledReason?: string | undefined;
    /** Fields that are currently_due and need to be collected again because validation
or verification failed. */
    errors?: AccountRequirementsError[] | undefined;
    /** Fields that need to be collected assuming all volume thresholds are reached. As they
become required, they appear in currently_due as well, and
current_deadline becomes set. */
    eventuallyDue?: string[] | undefined;
    /** Fields that weren't collected by current_deadline. These fields need to be
collected to enable the account. */
    pastDue?: string[] | undefined;
    /** Fields that may become required depending on the results of verification or review. Will
be an empty array unless an asynchronous verification is pending. If verification fails,
these fields move to eventually_due, currently_due, or past_due. */
    pendingVerification?: string[] | undefined;
}

export abstract class StripeEntityOfAccountRequirementsAlternative extends StripeEntity implements IStripeEntityOfAccountRequirementsAlternative {

    constructor(data?: IStripeEntityOfAccountRequirementsAlternative) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfAccountRequirementsAlternative {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfAccountRequirementsAlternative' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfAccountRequirementsAlternative extends IStripeEntity {
}

export class AccountRequirementsAlternative extends StripeEntityOfAccountRequirementsAlternative implements IAccountRequirementsAlternative {
    /** Fields that can be provided to satisfy all fields in original_fields_due. */
    alternativeFieldsDue?: string[] | undefined;
    /** Fields that are due and can be satisfied by providing all fields in
alternative_fields_due. */
    originalFieldsDue?: string[] | undefined;

    constructor(data?: IAccountRequirementsAlternative) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["alternativeFieldsDue"])) {
                this.alternativeFieldsDue = [] as any;
                for (let item of _data["alternativeFieldsDue"])
                    this.alternativeFieldsDue!.push(item);
            }
            if (Array.isArray(_data["originalFieldsDue"])) {
                this.originalFieldsDue = [] as any;
                for (let item of _data["originalFieldsDue"])
                    this.originalFieldsDue!.push(item);
            }
        }
    }

    static override fromJS(data: any): AccountRequirementsAlternative {
        data = typeof data === 'object' ? data : {};
        let result = new AccountRequirementsAlternative();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.alternativeFieldsDue)) {
            data["alternativeFieldsDue"] = [];
            for (let item of this.alternativeFieldsDue)
                data["alternativeFieldsDue"].push(item);
        }
        if (Array.isArray(this.originalFieldsDue)) {
            data["originalFieldsDue"] = [];
            for (let item of this.originalFieldsDue)
                data["originalFieldsDue"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IAccountRequirementsAlternative extends IStripeEntityOfAccountRequirementsAlternative {
    /** Fields that can be provided to satisfy all fields in original_fields_due. */
    alternativeFieldsDue?: string[] | undefined;
    /** Fields that are due and can be satisfied by providing all fields in
alternative_fields_due. */
    originalFieldsDue?: string[] | undefined;
}

export abstract class StripeEntityOfAccountRequirementsError extends StripeEntity implements IStripeEntityOfAccountRequirementsError {

    constructor(data?: IStripeEntityOfAccountRequirementsError) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfAccountRequirementsError {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfAccountRequirementsError' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfAccountRequirementsError extends IStripeEntity {
}

export class AccountRequirementsError extends StripeEntityOfAccountRequirementsError implements IAccountRequirementsError {
    /** The code for the type of error.
One of: invalid_address_city_state_postal_code, invalid_dob_age_under_18,
invalid_representative_country, invalid_street_address,
invalid_tos_acceptance, invalid_value_other,
verification_document_address_mismatch,
verification_document_address_missing, verification_document_corrupt,
verification_document_country_not_supported,
verification_document_dob_mismatch, verification_document_duplicate_type,
verification_document_expired, verification_document_failed_copy,
verification_document_failed_greyscale,
verification_document_failed_other,
verification_document_failed_test_mode, verification_document_fraudulent,
verification_document_id_number_mismatch,
verification_document_id_number_missing, verification_document_incomplete,
verification_document_invalid,
verification_document_issue_or_expiry_date_missing,
verification_document_manipulated, verification_document_missing_back,
verification_document_missing_front, verification_document_name_mismatch,
verification_document_name_missing,
verification_document_nationality_mismatch,
verification_document_not_readable, verification_document_not_signed,
verification_document_not_uploaded, verification_document_photo_mismatch,
verification_document_too_large, verification_document_type_not_supported,
verification_failed_address_match,
verification_failed_business_iec_number,
verification_failed_document_match, verification_failed_id_number_match,
verification_failed_keyed_identity, verification_failed_keyed_match,
verification_failed_name_match, verification_failed_other,
verification_failed_residential_address, verification_failed_tax_id_match,
verification_failed_tax_id_not_issued, verification_missing_executives,
verification_missing_owners, or
verification_requires_additional_memorandum_of_associations. */
    code?: string | undefined;
    /** An informative message that indicates the error type and provides additional details
about the error. */
    reason?: string | undefined;
    /** The specific user onboarding requirement field (in the requirements hash) that needs to
be resolved. */
    requirement?: string | undefined;

    constructor(data?: IAccountRequirementsError) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.code = _data["code"];
            this.reason = _data["reason"];
            this.requirement = _data["requirement"];
        }
    }

    static override fromJS(data: any): AccountRequirementsError {
        data = typeof data === 'object' ? data : {};
        let result = new AccountRequirementsError();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["reason"] = this.reason;
        data["requirement"] = this.requirement;
        super.toJSON(data);
        return data;
    }
}

export interface IAccountRequirementsError extends IStripeEntityOfAccountRequirementsError {
    /** The code for the type of error.
One of: invalid_address_city_state_postal_code, invalid_dob_age_under_18,
invalid_representative_country, invalid_street_address,
invalid_tos_acceptance, invalid_value_other,
verification_document_address_mismatch,
verification_document_address_missing, verification_document_corrupt,
verification_document_country_not_supported,
verification_document_dob_mismatch, verification_document_duplicate_type,
verification_document_expired, verification_document_failed_copy,
verification_document_failed_greyscale,
verification_document_failed_other,
verification_document_failed_test_mode, verification_document_fraudulent,
verification_document_id_number_mismatch,
verification_document_id_number_missing, verification_document_incomplete,
verification_document_invalid,
verification_document_issue_or_expiry_date_missing,
verification_document_manipulated, verification_document_missing_back,
verification_document_missing_front, verification_document_name_mismatch,
verification_document_name_missing,
verification_document_nationality_mismatch,
verification_document_not_readable, verification_document_not_signed,
verification_document_not_uploaded, verification_document_photo_mismatch,
verification_document_too_large, verification_document_type_not_supported,
verification_failed_address_match,
verification_failed_business_iec_number,
verification_failed_document_match, verification_failed_id_number_match,
verification_failed_keyed_identity, verification_failed_keyed_match,
verification_failed_name_match, verification_failed_other,
verification_failed_residential_address, verification_failed_tax_id_match,
verification_failed_tax_id_not_issued, verification_missing_executives,
verification_missing_owners, or
verification_requires_additional_memorandum_of_associations. */
    code?: string | undefined;
    /** An informative message that indicates the error type and provides additional details
about the error. */
    reason?: string | undefined;
    /** The specific user onboarding requirement field (in the requirements hash) that needs to
be resolved. */
    requirement?: string | undefined;
}

export abstract class StripeEntityOfAccountSettings extends StripeEntity implements IStripeEntityOfAccountSettings {

    constructor(data?: IStripeEntityOfAccountSettings) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfAccountSettings {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfAccountSettings' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfAccountSettings extends IStripeEntity {
}

export class AccountSettings extends StripeEntityOfAccountSettings implements IAccountSettings {
    bacsDebitPayments?: AccountSettingsBacsDebitPayments | undefined;
    branding?: AccountSettingsBranding | undefined;
    cardIssuing?: AccountSettingsCardIssuing | undefined;
    cardPayments?: AccountSettingsCardPayments | undefined;
    dashboard?: AccountSettingsDashboard | undefined;
    payments?: AccountSettingsPayments | undefined;
    payouts?: AccountSettingsPayouts | undefined;
    sepaDebitPayments?: AccountSettingsSepaDebitPayments | undefined;
    treasury?: AccountSettingsTreasury | undefined;

    constructor(data?: IAccountSettings) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.bacsDebitPayments = _data["bacsDebitPayments"] ? AccountSettingsBacsDebitPayments.fromJS(_data["bacsDebitPayments"]) : <any>undefined;
            this.branding = _data["branding"] ? AccountSettingsBranding.fromJS(_data["branding"]) : <any>undefined;
            this.cardIssuing = _data["cardIssuing"] ? AccountSettingsCardIssuing.fromJS(_data["cardIssuing"]) : <any>undefined;
            this.cardPayments = _data["cardPayments"] ? AccountSettingsCardPayments.fromJS(_data["cardPayments"]) : <any>undefined;
            this.dashboard = _data["dashboard"] ? AccountSettingsDashboard.fromJS(_data["dashboard"]) : <any>undefined;
            this.payments = _data["payments"] ? AccountSettingsPayments.fromJS(_data["payments"]) : <any>undefined;
            this.payouts = _data["payouts"] ? AccountSettingsPayouts.fromJS(_data["payouts"]) : <any>undefined;
            this.sepaDebitPayments = _data["sepaDebitPayments"] ? AccountSettingsSepaDebitPayments.fromJS(_data["sepaDebitPayments"]) : <any>undefined;
            this.treasury = _data["treasury"] ? AccountSettingsTreasury.fromJS(_data["treasury"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): AccountSettings {
        data = typeof data === 'object' ? data : {};
        let result = new AccountSettings();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bacsDebitPayments"] = this.bacsDebitPayments ? this.bacsDebitPayments.toJSON() : <any>undefined;
        data["branding"] = this.branding ? this.branding.toJSON() : <any>undefined;
        data["cardIssuing"] = this.cardIssuing ? this.cardIssuing.toJSON() : <any>undefined;
        data["cardPayments"] = this.cardPayments ? this.cardPayments.toJSON() : <any>undefined;
        data["dashboard"] = this.dashboard ? this.dashboard.toJSON() : <any>undefined;
        data["payments"] = this.payments ? this.payments.toJSON() : <any>undefined;
        data["payouts"] = this.payouts ? this.payouts.toJSON() : <any>undefined;
        data["sepaDebitPayments"] = this.sepaDebitPayments ? this.sepaDebitPayments.toJSON() : <any>undefined;
        data["treasury"] = this.treasury ? this.treasury.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IAccountSettings extends IStripeEntityOfAccountSettings {
    bacsDebitPayments?: AccountSettingsBacsDebitPayments | undefined;
    branding?: AccountSettingsBranding | undefined;
    cardIssuing?: AccountSettingsCardIssuing | undefined;
    cardPayments?: AccountSettingsCardPayments | undefined;
    dashboard?: AccountSettingsDashboard | undefined;
    payments?: AccountSettingsPayments | undefined;
    payouts?: AccountSettingsPayouts | undefined;
    sepaDebitPayments?: AccountSettingsSepaDebitPayments | undefined;
    treasury?: AccountSettingsTreasury | undefined;
}

export abstract class StripeEntityOfAccountSettingsBacsDebitPayments extends StripeEntity implements IStripeEntityOfAccountSettingsBacsDebitPayments {

    constructor(data?: IStripeEntityOfAccountSettingsBacsDebitPayments) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfAccountSettingsBacsDebitPayments {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfAccountSettingsBacsDebitPayments' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfAccountSettingsBacsDebitPayments extends IStripeEntity {
}

export class AccountSettingsBacsDebitPayments extends StripeEntityOfAccountSettingsBacsDebitPayments implements IAccountSettingsBacsDebitPayments {
    /** The Bacs Direct Debit Display Name for this account. For payments made with Bacs Direct
Debit, this will appear on the mandate, and as the statement descriptor. */
    displayName?: string | undefined;

    constructor(data?: IAccountSettingsBacsDebitPayments) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.displayName = _data["displayName"];
        }
    }

    static override fromJS(data: any): AccountSettingsBacsDebitPayments {
        data = typeof data === 'object' ? data : {};
        let result = new AccountSettingsBacsDebitPayments();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        super.toJSON(data);
        return data;
    }
}

export interface IAccountSettingsBacsDebitPayments extends IStripeEntityOfAccountSettingsBacsDebitPayments {
    /** The Bacs Direct Debit Display Name for this account. For payments made with Bacs Direct
Debit, this will appear on the mandate, and as the statement descriptor. */
    displayName?: string | undefined;
}

export abstract class StripeEntityOfAccountSettingsBranding extends StripeEntity implements IStripeEntityOfAccountSettingsBranding {

    constructor(data?: IStripeEntityOfAccountSettingsBranding) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfAccountSettingsBranding {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfAccountSettingsBranding' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfAccountSettingsBranding extends IStripeEntity {
}

export class AccountSettingsBranding extends StripeEntityOfAccountSettingsBranding implements IAccountSettingsBranding {
    /** (ID of the File)
(ID of a file upload) An icon
for the account. Must be square and at least 128px x 128px. */
    iconId?: string | undefined;
    /** (Expanded)
(ID of a file upload) An icon
for the account. Must be square and at least 128px x 128px.
            
For more information, see the expand documentation. */
    icon?: File | undefined;
    internalIcon?: ExpandableFieldOfFile | undefined;
    /** (ID of the File)
(ID of a file upload) A logo
for the account that will be used in Checkout instead of the icon and without the
account's name next to it if provided. Must be at least 128px x 128px. */
    logoId?: string | undefined;
    /** (Expanded)
(ID of a file upload) A logo
for the account that will be used in Checkout instead of the icon and without the
account's name next to it if provided. Must be at least 128px x 128px.
            
For more information, see the expand documentation. */
    logo?: File | undefined;
    internalLogo?: ExpandableFieldOfFile | undefined;
    /** A CSS hex color value representing the primary branding color for this account. */
    primaryColor?: string | undefined;
    /** A CSS hex color value representing the secondary branding color for this account. */
    secondaryColor?: string | undefined;

    constructor(data?: IAccountSettingsBranding) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.iconId = _data["iconId"];
            this.icon = _data["icon"] ? File.fromJS(_data["icon"]) : <any>undefined;
            this.internalIcon = _data["internalIcon"] ? ExpandableFieldOfFile.fromJS(_data["internalIcon"]) : <any>undefined;
            this.logoId = _data["logoId"];
            this.logo = _data["logo"] ? File.fromJS(_data["logo"]) : <any>undefined;
            this.internalLogo = _data["internalLogo"] ? ExpandableFieldOfFile.fromJS(_data["internalLogo"]) : <any>undefined;
            this.primaryColor = _data["primaryColor"];
            this.secondaryColor = _data["secondaryColor"];
        }
    }

    static override fromJS(data: any): AccountSettingsBranding {
        data = typeof data === 'object' ? data : {};
        let result = new AccountSettingsBranding();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["iconId"] = this.iconId;
        data["icon"] = this.icon ? this.icon.toJSON() : <any>undefined;
        data["internalIcon"] = this.internalIcon ? this.internalIcon.toJSON() : <any>undefined;
        data["logoId"] = this.logoId;
        data["logo"] = this.logo ? this.logo.toJSON() : <any>undefined;
        data["internalLogo"] = this.internalLogo ? this.internalLogo.toJSON() : <any>undefined;
        data["primaryColor"] = this.primaryColor;
        data["secondaryColor"] = this.secondaryColor;
        super.toJSON(data);
        return data;
    }
}

export interface IAccountSettingsBranding extends IStripeEntityOfAccountSettingsBranding {
    /** (ID of the File)
(ID of a file upload) An icon
for the account. Must be square and at least 128px x 128px. */
    iconId?: string | undefined;
    /** (Expanded)
(ID of a file upload) An icon
for the account. Must be square and at least 128px x 128px.
            
For more information, see the expand documentation. */
    icon?: File | undefined;
    internalIcon?: ExpandableFieldOfFile | undefined;
    /** (ID of the File)
(ID of a file upload) A logo
for the account that will be used in Checkout instead of the icon and without the
account's name next to it if provided. Must be at least 128px x 128px. */
    logoId?: string | undefined;
    /** (Expanded)
(ID of a file upload) A logo
for the account that will be used in Checkout instead of the icon and without the
account's name next to it if provided. Must be at least 128px x 128px.
            
For more information, see the expand documentation. */
    logo?: File | undefined;
    internalLogo?: ExpandableFieldOfFile | undefined;
    /** A CSS hex color value representing the primary branding color for this account. */
    primaryColor?: string | undefined;
    /** A CSS hex color value representing the secondary branding color for this account. */
    secondaryColor?: string | undefined;
}

export abstract class StripeEntityOfAccountSettingsCardIssuing extends StripeEntity implements IStripeEntityOfAccountSettingsCardIssuing {

    constructor(data?: IStripeEntityOfAccountSettingsCardIssuing) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfAccountSettingsCardIssuing {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfAccountSettingsCardIssuing' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfAccountSettingsCardIssuing extends IStripeEntity {
}

export class AccountSettingsCardIssuing extends StripeEntityOfAccountSettingsCardIssuing implements IAccountSettingsCardIssuing {
    tosAcceptance?: AccountSettingsCardIssuingTosAcceptance | undefined;

    constructor(data?: IAccountSettingsCardIssuing) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.tosAcceptance = _data["tosAcceptance"] ? AccountSettingsCardIssuingTosAcceptance.fromJS(_data["tosAcceptance"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): AccountSettingsCardIssuing {
        data = typeof data === 'object' ? data : {};
        let result = new AccountSettingsCardIssuing();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tosAcceptance"] = this.tosAcceptance ? this.tosAcceptance.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IAccountSettingsCardIssuing extends IStripeEntityOfAccountSettingsCardIssuing {
    tosAcceptance?: AccountSettingsCardIssuingTosAcceptance | undefined;
}

export abstract class StripeEntityOfAccountSettingsCardIssuingTosAcceptance extends StripeEntity implements IStripeEntityOfAccountSettingsCardIssuingTosAcceptance {

    constructor(data?: IStripeEntityOfAccountSettingsCardIssuingTosAcceptance) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfAccountSettingsCardIssuingTosAcceptance {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfAccountSettingsCardIssuingTosAcceptance' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfAccountSettingsCardIssuingTosAcceptance extends IStripeEntity {
}

export class AccountSettingsCardIssuingTosAcceptance extends StripeEntityOfAccountSettingsCardIssuingTosAcceptance implements IAccountSettingsCardIssuingTosAcceptance {
    /** The Unix timestamp marking when the account representative accepted the service
agreement. */
    date?: number | undefined;
    /** The IP address from which the account representative accepted the service agreement. */
    ip?: string | undefined;
    /** The user agent of the browser from which the account representative accepted the service
agreement. */
    userAgent?: string | undefined;

    constructor(data?: IAccountSettingsCardIssuingTosAcceptance) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.date = _data["date"];
            this.ip = _data["ip"];
            this.userAgent = _data["userAgent"];
        }
    }

    static override fromJS(data: any): AccountSettingsCardIssuingTosAcceptance {
        data = typeof data === 'object' ? data : {};
        let result = new AccountSettingsCardIssuingTosAcceptance();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date;
        data["ip"] = this.ip;
        data["userAgent"] = this.userAgent;
        super.toJSON(data);
        return data;
    }
}

export interface IAccountSettingsCardIssuingTosAcceptance extends IStripeEntityOfAccountSettingsCardIssuingTosAcceptance {
    /** The Unix timestamp marking when the account representative accepted the service
agreement. */
    date?: number | undefined;
    /** The IP address from which the account representative accepted the service agreement. */
    ip?: string | undefined;
    /** The user agent of the browser from which the account representative accepted the service
agreement. */
    userAgent?: string | undefined;
}

export abstract class StripeEntityOfAccountSettingsCardPayments extends StripeEntity implements IStripeEntityOfAccountSettingsCardPayments {

    constructor(data?: IStripeEntityOfAccountSettingsCardPayments) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfAccountSettingsCardPayments {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfAccountSettingsCardPayments' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfAccountSettingsCardPayments extends IStripeEntity {
}

export class AccountSettingsCardPayments extends StripeEntityOfAccountSettingsCardPayments implements IAccountSettingsCardPayments {
    declineOn?: AccountSettingsDeclineOn | undefined;
    /** The default text that appears on credit card statements when a charge is made. This
field prefixes any dynamic statement_descriptor specified on the charge.
statement_descriptor_prefix is useful for maximizing descriptor space for the
dynamic portion. */
    statementDescriptorPrefix?: string | undefined;
    /** The Kana variation of the default text that appears on credit card statements when a
charge is made (Japan only). This field prefixes any dynamic
statement_descriptor_suffix_kana specified on the charge.
statement_descriptor_prefix_kana is useful for maximizing descriptor space for
the dynamic portion. */
    statementDescriptorPrefixKana?: string | undefined;
    /** The Kanji variation of the default text that appears on credit card statements when a
charge is made (Japan only). This field prefixes any dynamic
statement_descriptor_suffix_kanji specified on the charge.
statement_descriptor_prefix_kanji is useful for maximizing descriptor space for
the dynamic portion. */
    statementDescriptorPrefixKanji?: string | undefined;

    constructor(data?: IAccountSettingsCardPayments) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.declineOn = _data["declineOn"] ? AccountSettingsDeclineOn.fromJS(_data["declineOn"]) : <any>undefined;
            this.statementDescriptorPrefix = _data["statementDescriptorPrefix"];
            this.statementDescriptorPrefixKana = _data["statementDescriptorPrefixKana"];
            this.statementDescriptorPrefixKanji = _data["statementDescriptorPrefixKanji"];
        }
    }

    static override fromJS(data: any): AccountSettingsCardPayments {
        data = typeof data === 'object' ? data : {};
        let result = new AccountSettingsCardPayments();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["declineOn"] = this.declineOn ? this.declineOn.toJSON() : <any>undefined;
        data["statementDescriptorPrefix"] = this.statementDescriptorPrefix;
        data["statementDescriptorPrefixKana"] = this.statementDescriptorPrefixKana;
        data["statementDescriptorPrefixKanji"] = this.statementDescriptorPrefixKanji;
        super.toJSON(data);
        return data;
    }
}

export interface IAccountSettingsCardPayments extends IStripeEntityOfAccountSettingsCardPayments {
    declineOn?: AccountSettingsDeclineOn | undefined;
    /** The default text that appears on credit card statements when a charge is made. This
field prefixes any dynamic statement_descriptor specified on the charge.
statement_descriptor_prefix is useful for maximizing descriptor space for the
dynamic portion. */
    statementDescriptorPrefix?: string | undefined;
    /** The Kana variation of the default text that appears on credit card statements when a
charge is made (Japan only). This field prefixes any dynamic
statement_descriptor_suffix_kana specified on the charge.
statement_descriptor_prefix_kana is useful for maximizing descriptor space for
the dynamic portion. */
    statementDescriptorPrefixKana?: string | undefined;
    /** The Kanji variation of the default text that appears on credit card statements when a
charge is made (Japan only). This field prefixes any dynamic
statement_descriptor_suffix_kanji specified on the charge.
statement_descriptor_prefix_kanji is useful for maximizing descriptor space for
the dynamic portion. */
    statementDescriptorPrefixKanji?: string | undefined;
}

export abstract class StripeEntityOfAccountSettingsDeclineOn extends StripeEntity implements IStripeEntityOfAccountSettingsDeclineOn {

    constructor(data?: IStripeEntityOfAccountSettingsDeclineOn) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfAccountSettingsDeclineOn {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfAccountSettingsDeclineOn' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfAccountSettingsDeclineOn extends IStripeEntity {
}

export class AccountSettingsDeclineOn extends StripeEntityOfAccountSettingsDeclineOn implements IAccountSettingsDeclineOn {
    avsFailure?: boolean;
    cvcFailure?: boolean;

    constructor(data?: IAccountSettingsDeclineOn) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.avsFailure = _data["avsFailure"];
            this.cvcFailure = _data["cvcFailure"];
        }
    }

    static override fromJS(data: any): AccountSettingsDeclineOn {
        data = typeof data === 'object' ? data : {};
        let result = new AccountSettingsDeclineOn();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avsFailure"] = this.avsFailure;
        data["cvcFailure"] = this.cvcFailure;
        super.toJSON(data);
        return data;
    }
}

export interface IAccountSettingsDeclineOn extends IStripeEntityOfAccountSettingsDeclineOn {
    avsFailure?: boolean;
    cvcFailure?: boolean;
}

export abstract class StripeEntityOfAccountSettingsDashboard extends StripeEntity implements IStripeEntityOfAccountSettingsDashboard {

    constructor(data?: IStripeEntityOfAccountSettingsDashboard) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfAccountSettingsDashboard {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfAccountSettingsDashboard' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfAccountSettingsDashboard extends IStripeEntity {
}

export class AccountSettingsDashboard extends StripeEntityOfAccountSettingsDashboard implements IAccountSettingsDashboard {
    /** The display name for this account. This is used on the Stripe Dashboard to differentiate
between accounts. */
    displayName?: string | undefined;
    /** The timezone used in the Stripe Dashboard for this account. A list of possible time zone
values is maintained at the IANA Time Zone
Database. */
    timezone?: string | undefined;

    constructor(data?: IAccountSettingsDashboard) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.displayName = _data["displayName"];
            this.timezone = _data["timezone"];
        }
    }

    static override fromJS(data: any): AccountSettingsDashboard {
        data = typeof data === 'object' ? data : {};
        let result = new AccountSettingsDashboard();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["timezone"] = this.timezone;
        super.toJSON(data);
        return data;
    }
}

export interface IAccountSettingsDashboard extends IStripeEntityOfAccountSettingsDashboard {
    /** The display name for this account. This is used on the Stripe Dashboard to differentiate
between accounts. */
    displayName?: string | undefined;
    /** The timezone used in the Stripe Dashboard for this account. A list of possible time zone
values is maintained at the IANA Time Zone
Database. */
    timezone?: string | undefined;
}

export abstract class StripeEntityOfAccountSettingsPayments extends StripeEntity implements IStripeEntityOfAccountSettingsPayments {

    constructor(data?: IStripeEntityOfAccountSettingsPayments) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfAccountSettingsPayments {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfAccountSettingsPayments' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfAccountSettingsPayments extends IStripeEntity {
}

export class AccountSettingsPayments extends StripeEntityOfAccountSettingsPayments implements IAccountSettingsPayments {
    /** The default text that appears on credit card statements when a charge is made. This
field prefixes any dynamic statement_descriptor specified on the charge. */
    statementDescriptor?: string | undefined;
    /** The Kana variation of the default text that appears on credit card statements when a
charge is made (Japan only). */
    statementDescriptorKana?: string | undefined;
    /** The Kanji variation of the default text that appears on credit card statements when a
charge is made (Japan only). */
    statementDescriptorKanji?: string | undefined;
    /** The Kana variation of the default text that appears on credit card statements when a
charge is made (Japan only). This field prefixes any dynamic
statement_descriptor_suffix_kana specified on the charge.
statement_descriptor_prefix_kana is useful for maximizing descriptor space for
the dynamic portion. */
    statementDescriptorPrefixKana?: string | undefined;
    /** The Kanji variation of the default text that appears on credit card statements when a
charge is made (Japan only). This field prefixes any dynamic
statement_descriptor_suffix_kanji specified on the charge.
statement_descriptor_prefix_kanji is useful for maximizing descriptor space for
the dynamic portion. */
    statementDescriptorPrefixKanji?: string | undefined;

    constructor(data?: IAccountSettingsPayments) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.statementDescriptor = _data["statementDescriptor"];
            this.statementDescriptorKana = _data["statementDescriptorKana"];
            this.statementDescriptorKanji = _data["statementDescriptorKanji"];
            this.statementDescriptorPrefixKana = _data["statementDescriptorPrefixKana"];
            this.statementDescriptorPrefixKanji = _data["statementDescriptorPrefixKanji"];
        }
    }

    static override fromJS(data: any): AccountSettingsPayments {
        data = typeof data === 'object' ? data : {};
        let result = new AccountSettingsPayments();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statementDescriptor"] = this.statementDescriptor;
        data["statementDescriptorKana"] = this.statementDescriptorKana;
        data["statementDescriptorKanji"] = this.statementDescriptorKanji;
        data["statementDescriptorPrefixKana"] = this.statementDescriptorPrefixKana;
        data["statementDescriptorPrefixKanji"] = this.statementDescriptorPrefixKanji;
        super.toJSON(data);
        return data;
    }
}

export interface IAccountSettingsPayments extends IStripeEntityOfAccountSettingsPayments {
    /** The default text that appears on credit card statements when a charge is made. This
field prefixes any dynamic statement_descriptor specified on the charge. */
    statementDescriptor?: string | undefined;
    /** The Kana variation of the default text that appears on credit card statements when a
charge is made (Japan only). */
    statementDescriptorKana?: string | undefined;
    /** The Kanji variation of the default text that appears on credit card statements when a
charge is made (Japan only). */
    statementDescriptorKanji?: string | undefined;
    /** The Kana variation of the default text that appears on credit card statements when a
charge is made (Japan only). This field prefixes any dynamic
statement_descriptor_suffix_kana specified on the charge.
statement_descriptor_prefix_kana is useful for maximizing descriptor space for
the dynamic portion. */
    statementDescriptorPrefixKana?: string | undefined;
    /** The Kanji variation of the default text that appears on credit card statements when a
charge is made (Japan only). This field prefixes any dynamic
statement_descriptor_suffix_kanji specified on the charge.
statement_descriptor_prefix_kanji is useful for maximizing descriptor space for
the dynamic portion. */
    statementDescriptorPrefixKanji?: string | undefined;
}

export abstract class StripeEntityOfAccountSettingsPayouts extends StripeEntity implements IStripeEntityOfAccountSettingsPayouts {

    constructor(data?: IStripeEntityOfAccountSettingsPayouts) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfAccountSettingsPayouts {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfAccountSettingsPayouts' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfAccountSettingsPayouts extends IStripeEntity {
}

export class AccountSettingsPayouts extends StripeEntityOfAccountSettingsPayouts implements IAccountSettingsPayouts {
    /** A Boolean indicating if Stripe should try to reclaim negative balances from an attached
bank account. See our Understanding Connect Account
Balances documentation for details. Default value is false for Custom
accounts, otherwise true. */
    debitNegativeBalances?: boolean;
    schedule?: AccountSettingsPayoutsSchedule | undefined;
    /** The text that appears on the bank account statement for payouts. If not set, this
defaults to the platform's bank descriptor as set in the Dashboard. */
    statementDescriptor?: string | undefined;

    constructor(data?: IAccountSettingsPayouts) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.debitNegativeBalances = _data["debitNegativeBalances"];
            this.schedule = _data["schedule"] ? AccountSettingsPayoutsSchedule.fromJS(_data["schedule"]) : <any>undefined;
            this.statementDescriptor = _data["statementDescriptor"];
        }
    }

    static override fromJS(data: any): AccountSettingsPayouts {
        data = typeof data === 'object' ? data : {};
        let result = new AccountSettingsPayouts();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["debitNegativeBalances"] = this.debitNegativeBalances;
        data["schedule"] = this.schedule ? this.schedule.toJSON() : <any>undefined;
        data["statementDescriptor"] = this.statementDescriptor;
        super.toJSON(data);
        return data;
    }
}

export interface IAccountSettingsPayouts extends IStripeEntityOfAccountSettingsPayouts {
    /** A Boolean indicating if Stripe should try to reclaim negative balances from an attached
bank account. See our Understanding Connect Account
Balances documentation for details. Default value is false for Custom
accounts, otherwise true. */
    debitNegativeBalances?: boolean;
    schedule?: AccountSettingsPayoutsSchedule | undefined;
    /** The text that appears on the bank account statement for payouts. If not set, this
defaults to the platform's bank descriptor as set in the Dashboard. */
    statementDescriptor?: string | undefined;
}

export abstract class StripeEntityOfAccountSettingsPayoutsSchedule extends StripeEntity implements IStripeEntityOfAccountSettingsPayoutsSchedule {

    constructor(data?: IStripeEntityOfAccountSettingsPayoutsSchedule) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfAccountSettingsPayoutsSchedule {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfAccountSettingsPayoutsSchedule' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfAccountSettingsPayoutsSchedule extends IStripeEntity {
}

export class AccountSettingsPayoutsSchedule extends StripeEntityOfAccountSettingsPayoutsSchedule implements IAccountSettingsPayoutsSchedule {
    /** The number of days charges for the account will be held before being paid out. */
    delayDays?: number;
    /** How frequently funds will be paid out. One of manual (payouts only created via
API call), daily, weekly, or monthly. */
    interval?: string | undefined;
    /** The day of the month funds will be paid out. Only shown if interval is monthly.
Payouts scheduled between the 29th and 31st of the month are sent on the last day of
shorter months. */
    monthlyAnchor?: number;
    /** The day of the week funds will be paid out, of the style 'monday', 'tuesday', etc. Only
shown if interval is weekly. */
    weeklyAnchor?: string | undefined;

    constructor(data?: IAccountSettingsPayoutsSchedule) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.delayDays = _data["delayDays"];
            this.interval = _data["interval"];
            this.monthlyAnchor = _data["monthlyAnchor"];
            this.weeklyAnchor = _data["weeklyAnchor"];
        }
    }

    static override fromJS(data: any): AccountSettingsPayoutsSchedule {
        data = typeof data === 'object' ? data : {};
        let result = new AccountSettingsPayoutsSchedule();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["delayDays"] = this.delayDays;
        data["interval"] = this.interval;
        data["monthlyAnchor"] = this.monthlyAnchor;
        data["weeklyAnchor"] = this.weeklyAnchor;
        super.toJSON(data);
        return data;
    }
}

export interface IAccountSettingsPayoutsSchedule extends IStripeEntityOfAccountSettingsPayoutsSchedule {
    /** The number of days charges for the account will be held before being paid out. */
    delayDays?: number;
    /** How frequently funds will be paid out. One of manual (payouts only created via
API call), daily, weekly, or monthly. */
    interval?: string | undefined;
    /** The day of the month funds will be paid out. Only shown if interval is monthly.
Payouts scheduled between the 29th and 31st of the month are sent on the last day of
shorter months. */
    monthlyAnchor?: number;
    /** The day of the week funds will be paid out, of the style 'monday', 'tuesday', etc. Only
shown if interval is weekly. */
    weeklyAnchor?: string | undefined;
}

export abstract class StripeEntityOfAccountSettingsSepaDebitPayments extends StripeEntity implements IStripeEntityOfAccountSettingsSepaDebitPayments {

    constructor(data?: IStripeEntityOfAccountSettingsSepaDebitPayments) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfAccountSettingsSepaDebitPayments {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfAccountSettingsSepaDebitPayments' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfAccountSettingsSepaDebitPayments extends IStripeEntity {
}

export class AccountSettingsSepaDebitPayments extends StripeEntityOfAccountSettingsSepaDebitPayments implements IAccountSettingsSepaDebitPayments {
    /** SEPA creditor identifier that identifies the company making the payment. */
    creditorId?: string | undefined;

    constructor(data?: IAccountSettingsSepaDebitPayments) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.creditorId = _data["creditorId"];
        }
    }

    static override fromJS(data: any): AccountSettingsSepaDebitPayments {
        data = typeof data === 'object' ? data : {};
        let result = new AccountSettingsSepaDebitPayments();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["creditorId"] = this.creditorId;
        super.toJSON(data);
        return data;
    }
}

export interface IAccountSettingsSepaDebitPayments extends IStripeEntityOfAccountSettingsSepaDebitPayments {
    /** SEPA creditor identifier that identifies the company making the payment. */
    creditorId?: string | undefined;
}

export abstract class StripeEntityOfAccountSettingsTreasury extends StripeEntity implements IStripeEntityOfAccountSettingsTreasury {

    constructor(data?: IStripeEntityOfAccountSettingsTreasury) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfAccountSettingsTreasury {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfAccountSettingsTreasury' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfAccountSettingsTreasury extends IStripeEntity {
}

export class AccountSettingsTreasury extends StripeEntityOfAccountSettingsTreasury implements IAccountSettingsTreasury {
    tosAcceptance?: AccountSettingsTreasuryTosAcceptance | undefined;

    constructor(data?: IAccountSettingsTreasury) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.tosAcceptance = _data["tosAcceptance"] ? AccountSettingsTreasuryTosAcceptance.fromJS(_data["tosAcceptance"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): AccountSettingsTreasury {
        data = typeof data === 'object' ? data : {};
        let result = new AccountSettingsTreasury();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tosAcceptance"] = this.tosAcceptance ? this.tosAcceptance.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IAccountSettingsTreasury extends IStripeEntityOfAccountSettingsTreasury {
    tosAcceptance?: AccountSettingsTreasuryTosAcceptance | undefined;
}

export abstract class StripeEntityOfAccountSettingsTreasuryTosAcceptance extends StripeEntity implements IStripeEntityOfAccountSettingsTreasuryTosAcceptance {

    constructor(data?: IStripeEntityOfAccountSettingsTreasuryTosAcceptance) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfAccountSettingsTreasuryTosAcceptance {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfAccountSettingsTreasuryTosAcceptance' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfAccountSettingsTreasuryTosAcceptance extends IStripeEntity {
}

export class AccountSettingsTreasuryTosAcceptance extends StripeEntityOfAccountSettingsTreasuryTosAcceptance implements IAccountSettingsTreasuryTosAcceptance {
    /** The Unix timestamp marking when the account representative accepted the service
agreement. */
    date?: number | undefined;
    /** The IP address from which the account representative accepted the service agreement. */
    ip?: string | undefined;
    /** The user agent of the browser from which the account representative accepted the service
agreement. */
    userAgent?: string | undefined;

    constructor(data?: IAccountSettingsTreasuryTosAcceptance) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.date = _data["date"];
            this.ip = _data["ip"];
            this.userAgent = _data["userAgent"];
        }
    }

    static override fromJS(data: any): AccountSettingsTreasuryTosAcceptance {
        data = typeof data === 'object' ? data : {};
        let result = new AccountSettingsTreasuryTosAcceptance();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date;
        data["ip"] = this.ip;
        data["userAgent"] = this.userAgent;
        super.toJSON(data);
        return data;
    }
}

export interface IAccountSettingsTreasuryTosAcceptance extends IStripeEntityOfAccountSettingsTreasuryTosAcceptance {
    /** The Unix timestamp marking when the account representative accepted the service
agreement. */
    date?: number | undefined;
    /** The IP address from which the account representative accepted the service agreement. */
    ip?: string | undefined;
    /** The user agent of the browser from which the account representative accepted the service
agreement. */
    userAgent?: string | undefined;
}

export abstract class StripeEntityOfAccountTosAcceptance extends StripeEntity implements IStripeEntityOfAccountTosAcceptance {

    constructor(data?: IStripeEntityOfAccountTosAcceptance) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfAccountTosAcceptance {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfAccountTosAcceptance' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfAccountTosAcceptance extends IStripeEntity {
}

export class AccountTosAcceptance extends StripeEntityOfAccountTosAcceptance implements IAccountTosAcceptance {
    /** The Unix timestamp marking when the account representative accepted their service
agreement. */
    date?: Date | undefined;
    /** The IP address from which the account representative accepted their service agreement. */
    ip?: string | undefined;
    /** The user's service agreement type. */
    serviceAgreement?: string | undefined;
    /** The user agent of the browser from which the account representative accepted their
service agreement. */
    userAgent?: string | undefined;

    constructor(data?: IAccountTosAcceptance) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.ip = _data["ip"];
            this.serviceAgreement = _data["serviceAgreement"];
            this.userAgent = _data["userAgent"];
        }
    }

    static override fromJS(data: any): AccountTosAcceptance {
        data = typeof data === 'object' ? data : {};
        let result = new AccountTosAcceptance();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["ip"] = this.ip;
        data["serviceAgreement"] = this.serviceAgreement;
        data["userAgent"] = this.userAgent;
        super.toJSON(data);
        return data;
    }
}

export interface IAccountTosAcceptance extends IStripeEntityOfAccountTosAcceptance {
    /** The Unix timestamp marking when the account representative accepted their service
agreement. */
    date?: Date | undefined;
    /** The IP address from which the account representative accepted their service agreement. */
    ip?: string | undefined;
    /** The user's service agreement type. */
    serviceAgreement?: string | undefined;
    /** The user agent of the browser from which the account representative accepted their
service agreement. */
    userAgent?: string | undefined;
}

/** Represents a generic expandable field. */
export class ExpandableFieldOfAccount implements IExpandableFieldOfAccount {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: Account | undefined;

    constructor(data?: IExpandableFieldOfAccount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.expandedObject = _data["expandedObject"] ? Account.fromJS(_data["expandedObject"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExpandableFieldOfAccount {
        data = typeof data === 'object' ? data : {};
        let result = new ExpandableFieldOfAccount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["expandedObject"] = this.expandedObject ? this.expandedObject.toJSON() : <any>undefined;
        return data;
    }
}

/** Represents a generic expandable field. */
export interface IExpandableFieldOfAccount {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: Account | undefined;
}

export abstract class StripeEntityOfBalanceTransaction extends StripeEntity implements IStripeEntityOfBalanceTransaction {

    constructor(data?: IStripeEntityOfBalanceTransaction) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfBalanceTransaction {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfBalanceTransaction' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfBalanceTransaction extends IStripeEntity {
}

/** Balance transactions represent funds moving through your Stripe account. They're created for every type of transaction that comes into or flows out of your Stripe account balance.            Related guide: Balance transaction types. */
export class BalanceTransaction extends StripeEntityOfBalanceTransaction implements IBalanceTransaction {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** Gross amount of the transaction, in %s. */
    amount?: number;
    /** The date the transaction's net funds will become available in the Stripe balance. */
    availableOn?: Date;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** Three-letter ISO currency
code, in lowercase. Must be a supported
currency. */
    currency?: string | undefined;
    /** An arbitrary string attached to the object. Often useful for displaying to users. */
    description?: string | undefined;
    /** The exchange rate used, if applicable, for this transaction. Specifically, if money was
converted from currency A to currency B, then the amount in currency A, times
exchange_rate, would be the amount in currency B. For example, suppose you
charged a customer 10.00 EUR. Then the PaymentIntent's amount would be
1000 and currency would be eur. Suppose this was converted into
12.34 USD in your Stripe account. Then the BalanceTransaction's amount would be
1234, currency would be usd, and exchange_rate would be
1.234. */
    exchangeRate?: number | undefined;
    /** Fees (in %s) paid for this transaction. */
    fee?: number;
    /** Detailed breakdown of fees (in %s) paid for this transaction. */
    feeDetails?: BalanceTransactionFeeDetail[] | undefined;
    /** Net amount of the transaction, in %s. */
    net?: number;
    /** Learn more about how
reporting categories can help you understand balance transactions from an accounting
perspective. */
    reportingCategory?: string | undefined;
    /** (ID of the IBalanceTransactionSource)
The Stripe object to which this transaction is related. */
    sourceId?: string | undefined;
    /** (Expanded)
The Stripe object to which this transaction is related.
            
For more information, see the expand documentation. */
    source?: IBalanceTransactionSource | undefined;
    internalSource?: ExpandableFieldOfIBalanceTransactionSource | undefined;
    /** If the transaction's net funds are available in the Stripe balance yet. Either
available or pending. */
    status?: string | undefined;
    /** Transaction type: adjustment, advance, advance_funding,
anticipation_repayment, application_fee, application_fee_refund,
charge, connect_collection_transfer, contribution,
issuing_authorization_hold, issuing_authorization_release,
issuing_dispute, issuing_transaction, payment,
payment_failure_refund, payment_refund, payout,
payout_cancel, payout_failure, refund, refund_failure,
reserve_transaction, reserved_funds, stripe_fee,
stripe_fx_fee, tax_fee, topup, topup_reversal,
transfer, transfer_cancel, transfer_failure, or
transfer_refund. Learn more about
balance transaction types and what they represent. If you are looking to classify
transactions for accounting purposes, you might want to consider
reporting_category instead.
One of: adjustment, advance, advance_funding,
anticipation_repayment, application_fee, application_fee_refund,
charge, connect_collection_transfer, contribution,
issuing_authorization_hold, issuing_authorization_release,
issuing_dispute, issuing_transaction, payment,
payment_failure_refund, payment_refund, payout,
payout_cancel, payout_failure, refund, refund_failure,
reserve_transaction, reserved_funds, stripe_fee,
stripe_fx_fee, tax_fee, topup, topup_reversal,
transfer, transfer_cancel, transfer_failure, or
transfer_refund. */
    type?: string | undefined;

    constructor(data?: IBalanceTransaction) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.object = _data["object"];
            this.amount = _data["amount"];
            this.availableOn = _data["availableOn"] ? new Date(_data["availableOn"].toString()) : <any>undefined;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.currency = _data["currency"];
            this.description = _data["description"];
            this.exchangeRate = _data["exchangeRate"];
            this.fee = _data["fee"];
            if (Array.isArray(_data["feeDetails"])) {
                this.feeDetails = [] as any;
                for (let item of _data["feeDetails"])
                    this.feeDetails!.push(BalanceTransactionFeeDetail.fromJS(item));
            }
            this.net = _data["net"];
            this.reportingCategory = _data["reportingCategory"];
            this.sourceId = _data["sourceId"];
            this.source = _data["source"] ? IBalanceTransactionSource.fromJS(_data["source"]) : <any>undefined;
            this.internalSource = _data["internalSource"] ? ExpandableFieldOfIBalanceTransactionSource.fromJS(_data["internalSource"]) : <any>undefined;
            this.status = _data["status"];
            this.type = _data["type"];
        }
    }

    static override fromJS(data: any): BalanceTransaction {
        data = typeof data === 'object' ? data : {};
        let result = new BalanceTransaction();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["object"] = this.object;
        data["amount"] = this.amount;
        data["availableOn"] = this.availableOn ? this.availableOn.toISOString() : <any>undefined;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["currency"] = this.currency;
        data["description"] = this.description;
        data["exchangeRate"] = this.exchangeRate;
        data["fee"] = this.fee;
        if (Array.isArray(this.feeDetails)) {
            data["feeDetails"] = [];
            for (let item of this.feeDetails)
                data["feeDetails"].push(item.toJSON());
        }
        data["net"] = this.net;
        data["reportingCategory"] = this.reportingCategory;
        data["sourceId"] = this.sourceId;
        data["source"] = this.source ? this.source.toJSON() : <any>undefined;
        data["internalSource"] = this.internalSource ? this.internalSource.toJSON() : <any>undefined;
        data["status"] = this.status;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** Balance transactions represent funds moving through your Stripe account. They're created for every type of transaction that comes into or flows out of your Stripe account balance.            Related guide: Balance transaction types. */
export interface IBalanceTransaction extends IStripeEntityOfBalanceTransaction {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** Gross amount of the transaction, in %s. */
    amount?: number;
    /** The date the transaction's net funds will become available in the Stripe balance. */
    availableOn?: Date;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** Three-letter ISO currency
code, in lowercase. Must be a supported
currency. */
    currency?: string | undefined;
    /** An arbitrary string attached to the object. Often useful for displaying to users. */
    description?: string | undefined;
    /** The exchange rate used, if applicable, for this transaction. Specifically, if money was
converted from currency A to currency B, then the amount in currency A, times
exchange_rate, would be the amount in currency B. For example, suppose you
charged a customer 10.00 EUR. Then the PaymentIntent's amount would be
1000 and currency would be eur. Suppose this was converted into
12.34 USD in your Stripe account. Then the BalanceTransaction's amount would be
1234, currency would be usd, and exchange_rate would be
1.234. */
    exchangeRate?: number | undefined;
    /** Fees (in %s) paid for this transaction. */
    fee?: number;
    /** Detailed breakdown of fees (in %s) paid for this transaction. */
    feeDetails?: BalanceTransactionFeeDetail[] | undefined;
    /** Net amount of the transaction, in %s. */
    net?: number;
    /** Learn more about how
reporting categories can help you understand balance transactions from an accounting
perspective. */
    reportingCategory?: string | undefined;
    /** (ID of the IBalanceTransactionSource)
The Stripe object to which this transaction is related. */
    sourceId?: string | undefined;
    /** (Expanded)
The Stripe object to which this transaction is related.
            
For more information, see the expand documentation. */
    source?: IBalanceTransactionSource | undefined;
    internalSource?: ExpandableFieldOfIBalanceTransactionSource | undefined;
    /** If the transaction's net funds are available in the Stripe balance yet. Either
available or pending. */
    status?: string | undefined;
    /** Transaction type: adjustment, advance, advance_funding,
anticipation_repayment, application_fee, application_fee_refund,
charge, connect_collection_transfer, contribution,
issuing_authorization_hold, issuing_authorization_release,
issuing_dispute, issuing_transaction, payment,
payment_failure_refund, payment_refund, payout,
payout_cancel, payout_failure, refund, refund_failure,
reserve_transaction, reserved_funds, stripe_fee,
stripe_fx_fee, tax_fee, topup, topup_reversal,
transfer, transfer_cancel, transfer_failure, or
transfer_refund. Learn more about
balance transaction types and what they represent. If you are looking to classify
transactions for accounting purposes, you might want to consider
reporting_category instead.
One of: adjustment, advance, advance_funding,
anticipation_repayment, application_fee, application_fee_refund,
charge, connect_collection_transfer, contribution,
issuing_authorization_hold, issuing_authorization_release,
issuing_dispute, issuing_transaction, payment,
payment_failure_refund, payment_refund, payout,
payout_cancel, payout_failure, refund, refund_failure,
reserve_transaction, reserved_funds, stripe_fee,
stripe_fx_fee, tax_fee, topup, topup_reversal,
transfer, transfer_cancel, transfer_failure, or
transfer_refund. */
    type?: string | undefined;
}

export abstract class StripeEntityOfBalanceTransactionFeeDetail extends StripeEntity implements IStripeEntityOfBalanceTransactionFeeDetail {

    constructor(data?: IStripeEntityOfBalanceTransactionFeeDetail) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfBalanceTransactionFeeDetail {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfBalanceTransactionFeeDetail' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfBalanceTransactionFeeDetail extends IStripeEntity {
}

export class BalanceTransactionFeeDetail extends StripeEntityOfBalanceTransactionFeeDetail implements IBalanceTransactionFeeDetail {
    /** Amount of the fee, in cents. */
    amount?: number;
    /** ID of the Connect application that earned the fee. */
    application?: string | undefined;
    /** Three-letter ISO currency
code, in lowercase. Must be a supported
currency. */
    currency?: string | undefined;
    /** An arbitrary string attached to the object. Often useful for displaying to users. */
    description?: string | undefined;
    /** Type of the fee, one of: application_fee, stripe_fee or tax. */
    type?: string | undefined;

    constructor(data?: IBalanceTransactionFeeDetail) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.amount = _data["amount"];
            this.application = _data["application"];
            this.currency = _data["currency"];
            this.description = _data["description"];
            this.type = _data["type"];
        }
    }

    static override fromJS(data: any): BalanceTransactionFeeDetail {
        data = typeof data === 'object' ? data : {};
        let result = new BalanceTransactionFeeDetail();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["application"] = this.application;
        data["currency"] = this.currency;
        data["description"] = this.description;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

export interface IBalanceTransactionFeeDetail extends IStripeEntityOfBalanceTransactionFeeDetail {
    /** Amount of the fee, in cents. */
    amount?: number;
    /** ID of the Connect application that earned the fee. */
    application?: string | undefined;
    /** Three-letter ISO currency
code, in lowercase. Must be a supported
currency. */
    currency?: string | undefined;
    /** An arbitrary string attached to the object. Often useful for displaying to users. */
    description?: string | undefined;
    /** Type of the fee, one of: application_fee, stripe_fee or tax. */
    type?: string | undefined;
}

/** Resources that implement this interface can appear as sources in balance transactions. Possible concrete classes: */
export abstract class IBalanceTransactionSource implements IIBalanceTransactionSource {

    constructor(data?: IIBalanceTransactionSource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): IBalanceTransactionSource {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'IBalanceTransactionSource' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

/** Resources that implement this interface can appear as sources in balance transactions. Possible concrete classes: */
export interface IIBalanceTransactionSource {
}

/** Represents a generic expandable field. */
export class ExpandableFieldOfIBalanceTransactionSource implements IExpandableFieldOfIBalanceTransactionSource {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: IBalanceTransactionSource | undefined;

    constructor(data?: IExpandableFieldOfIBalanceTransactionSource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.expandedObject = _data["expandedObject"] ? IBalanceTransactionSource.fromJS(_data["expandedObject"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExpandableFieldOfIBalanceTransactionSource {
        data = typeof data === 'object' ? data : {};
        let result = new ExpandableFieldOfIBalanceTransactionSource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["expandedObject"] = this.expandedObject ? this.expandedObject.toJSON() : <any>undefined;
        return data;
    }
}

/** Represents a generic expandable field. */
export interface IExpandableFieldOfIBalanceTransactionSource {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: IBalanceTransactionSource | undefined;
}

/** Represents a generic expandable field. */
export class ExpandableFieldOfBalanceTransaction implements IExpandableFieldOfBalanceTransaction {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: BalanceTransaction | undefined;

    constructor(data?: IExpandableFieldOfBalanceTransaction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.expandedObject = _data["expandedObject"] ? BalanceTransaction.fromJS(_data["expandedObject"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExpandableFieldOfBalanceTransaction {
        data = typeof data === 'object' ? data : {};
        let result = new ExpandableFieldOfBalanceTransaction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["expandedObject"] = this.expandedObject ? this.expandedObject.toJSON() : <any>undefined;
        return data;
    }
}

/** Represents a generic expandable field. */
export interface IExpandableFieldOfBalanceTransaction {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: BalanceTransaction | undefined;
}

/** Represents a generic expandable field. */
export class ExpandableFieldOfCharge implements IExpandableFieldOfCharge {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: Charge | undefined;

    constructor(data?: IExpandableFieldOfCharge) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.expandedObject = _data["expandedObject"] ? Charge.fromJS(_data["expandedObject"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExpandableFieldOfCharge {
        data = typeof data === 'object' ? data : {};
        let result = new ExpandableFieldOfCharge();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["expandedObject"] = this.expandedObject ? this.expandedObject.toJSON() : <any>undefined;
        return data;
    }
}

/** Represents a generic expandable field. */
export interface IExpandableFieldOfCharge {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: Charge | undefined;
}

export abstract class StripeEntityOfStripeListOfApplicationFeeRefund extends StripeEntity implements IStripeEntityOfStripeListOfApplicationFeeRefund {

    constructor(data?: IStripeEntityOfStripeListOfApplicationFeeRefund) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfStripeListOfApplicationFeeRefund {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfStripeListOfApplicationFeeRefund' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfStripeListOfApplicationFeeRefund extends IStripeEntity {
}

export class StripeListOfApplicationFeeRefund extends StripeEntityOfStripeListOfApplicationFeeRefund implements IStripeListOfApplicationFeeRefund {
    /** A string describing the object type returned. */
    object?: string | undefined;
    /** A list containing the actual response elements, paginated by any request parameters. */
    data?: ApplicationFeeRefund[] | undefined;
    /** Whether or not there are more elements available after this set. If false,
this set comprises the end of the list. */
    hasMore?: boolean;
    /** The URL for accessing this list. */
    url?: string | undefined;

    constructor(data?: IStripeListOfApplicationFeeRefund) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.object = _data["object"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ApplicationFeeRefund.fromJS(item));
            }
            this.hasMore = _data["hasMore"];
            this.url = _data["url"];
        }
    }

    static override fromJS(data: any): StripeListOfApplicationFeeRefund {
        data = typeof data === 'object' ? data : {};
        let result = new StripeListOfApplicationFeeRefund();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["object"] = this.object;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["hasMore"] = this.hasMore;
        data["url"] = this.url;
        super.toJSON(data);
        return data;
    }
}

export interface IStripeListOfApplicationFeeRefund extends IStripeEntityOfStripeListOfApplicationFeeRefund {
    /** A string describing the object type returned. */
    object?: string | undefined;
    /** A list containing the actual response elements, paginated by any request parameters. */
    data?: ApplicationFeeRefund[] | undefined;
    /** Whether or not there are more elements available after this set. If false,
this set comprises the end of the list. */
    hasMore?: boolean;
    /** The URL for accessing this list. */
    url?: string | undefined;
}

export abstract class StripeEntityOfApplicationFeeRefund extends StripeEntity implements IStripeEntityOfApplicationFeeRefund {

    constructor(data?: IStripeEntityOfApplicationFeeRefund) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfApplicationFeeRefund {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfApplicationFeeRefund' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfApplicationFeeRefund extends IStripeEntity {
}

/** Application Fee Refund objects allow you to refund an application fee that has previously been created but not yet refunded. Funds will be refunded to the Stripe account from which the fee was originally collected.            Related guide: Refunding application fees. */
export class ApplicationFeeRefund extends StripeEntityOfApplicationFeeRefund implements IApplicationFeeRefund {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** Amount, in %s. */
    amount?: number;
    /** (ID of the BalanceTransaction)
Balance transaction that describes the impact on your account balance. */
    balanceTransactionId?: string | undefined;
    /** (Expanded)
Balance transaction that describes the impact on your account balance.
            
For more information, see the expand documentation. */
    balanceTransaction?: BalanceTransaction | undefined;
    internalBalanceTransaction?: ExpandableFieldOfBalanceTransaction | undefined;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** Three-letter ISO currency
code, in lowercase. Must be a supported
currency. */
    currency?: string | undefined;
    /** (ID of the ApplicationFee)
ID of the application fee that was refunded. */
    feeId?: string | undefined;
    /** (Expanded)
ID of the application fee that was refunded.
            
For more information, see the expand documentation. */
    fee?: ApplicationFee | undefined;
    internalFee?: ExpandableFieldOfApplicationFee | undefined;
    /** Set of key-value pairs that you can
attach to an object. This can be useful for storing additional information about the
object in a structured format. */
    metadata?: { [key: string]: string; } | undefined;

    constructor(data?: IApplicationFeeRefund) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.object = _data["object"];
            this.amount = _data["amount"];
            this.balanceTransactionId = _data["balanceTransactionId"];
            this.balanceTransaction = _data["balanceTransaction"] ? BalanceTransaction.fromJS(_data["balanceTransaction"]) : <any>undefined;
            this.internalBalanceTransaction = _data["internalBalanceTransaction"] ? ExpandableFieldOfBalanceTransaction.fromJS(_data["internalBalanceTransaction"]) : <any>undefined;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.currency = _data["currency"];
            this.feeId = _data["feeId"];
            this.fee = _data["fee"] ? ApplicationFee.fromJS(_data["fee"]) : <any>undefined;
            this.internalFee = _data["internalFee"] ? ExpandableFieldOfApplicationFee.fromJS(_data["internalFee"]) : <any>undefined;
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
        }
    }

    static override fromJS(data: any): ApplicationFeeRefund {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationFeeRefund();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["object"] = this.object;
        data["amount"] = this.amount;
        data["balanceTransactionId"] = this.balanceTransactionId;
        data["balanceTransaction"] = this.balanceTransaction ? this.balanceTransaction.toJSON() : <any>undefined;
        data["internalBalanceTransaction"] = this.internalBalanceTransaction ? this.internalBalanceTransaction.toJSON() : <any>undefined;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["currency"] = this.currency;
        data["feeId"] = this.feeId;
        data["fee"] = this.fee ? this.fee.toJSON() : <any>undefined;
        data["internalFee"] = this.internalFee ? this.internalFee.toJSON() : <any>undefined;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        super.toJSON(data);
        return data;
    }
}

/** Application Fee Refund objects allow you to refund an application fee that has previously been created but not yet refunded. Funds will be refunded to the Stripe account from which the fee was originally collected.            Related guide: Refunding application fees. */
export interface IApplicationFeeRefund extends IStripeEntityOfApplicationFeeRefund {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** Amount, in %s. */
    amount?: number;
    /** (ID of the BalanceTransaction)
Balance transaction that describes the impact on your account balance. */
    balanceTransactionId?: string | undefined;
    /** (Expanded)
Balance transaction that describes the impact on your account balance.
            
For more information, see the expand documentation. */
    balanceTransaction?: BalanceTransaction | undefined;
    internalBalanceTransaction?: ExpandableFieldOfBalanceTransaction | undefined;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** Three-letter ISO currency
code, in lowercase. Must be a supported
currency. */
    currency?: string | undefined;
    /** (ID of the ApplicationFee)
ID of the application fee that was refunded. */
    feeId?: string | undefined;
    /** (Expanded)
ID of the application fee that was refunded.
            
For more information, see the expand documentation. */
    fee?: ApplicationFee | undefined;
    internalFee?: ExpandableFieldOfApplicationFee | undefined;
    /** Set of key-value pairs that you can
attach to an object. This can be useful for storing additional information about the
object in a structured format. */
    metadata?: { [key: string]: string; } | undefined;
}

/** Represents a generic expandable field. */
export class ExpandableFieldOfApplicationFee implements IExpandableFieldOfApplicationFee {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: ApplicationFee | undefined;

    constructor(data?: IExpandableFieldOfApplicationFee) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.expandedObject = _data["expandedObject"] ? ApplicationFee.fromJS(_data["expandedObject"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExpandableFieldOfApplicationFee {
        data = typeof data === 'object' ? data : {};
        let result = new ExpandableFieldOfApplicationFee();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["expandedObject"] = this.expandedObject ? this.expandedObject.toJSON() : <any>undefined;
        return data;
    }
}

/** Represents a generic expandable field. */
export interface IExpandableFieldOfApplicationFee {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: ApplicationFee | undefined;
}

export abstract class StripeEntityOfChargeBillingDetails extends StripeEntity implements IStripeEntityOfChargeBillingDetails {

    constructor(data?: IStripeEntityOfChargeBillingDetails) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargeBillingDetails {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargeBillingDetails' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargeBillingDetails extends IStripeEntity {
}

export class ChargeBillingDetails extends StripeEntityOfChargeBillingDetails implements IChargeBillingDetails {
    /** Billing address. */
    address?: Address | undefined;
    /** Email address. */
    email?: string | undefined;
    /** Full name. */
    name?: string | undefined;
    /** Billing phone number (including extension). */
    phone?: string | undefined;

    constructor(data?: IChargeBillingDetails) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.address = _data["address"] ? Address.fromJS(_data["address"]) : <any>undefined;
            this.email = _data["email"];
            this.name = _data["name"];
            this.phone = _data["phone"];
        }
    }

    static override fromJS(data: any): ChargeBillingDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ChargeBillingDetails();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["email"] = this.email;
        data["name"] = this.name;
        data["phone"] = this.phone;
        super.toJSON(data);
        return data;
    }
}

export interface IChargeBillingDetails extends IStripeEntityOfChargeBillingDetails {
    /** Billing address. */
    address?: Address | undefined;
    /** Email address. */
    email?: string | undefined;
    /** Full name. */
    name?: string | undefined;
    /** Billing phone number (including extension). */
    phone?: string | undefined;
}

export abstract class StripeEntityOfDispute extends StripeEntity implements IStripeEntityOfDispute {

    constructor(data?: IStripeEntityOfDispute) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfDispute {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfDispute' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfDispute extends IStripeEntity {
}

/** A dispute occurs when a customer questions your charge with their card issuer. When this happens, you're given the opportunity to respond to the dispute with evidence that shows that the charge is legitimate. You can find more information about the dispute process in our Disputes and Fraud documentation.            Related guide: Disputes and fraud. */
export class Dispute extends StripeEntityOfDispute implements IDispute {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** Disputed amount. Usually the amount of the charge, but can differ (usually because of
currency fluctuation or because only part of the order is disputed). */
    amount?: number;
    /** List of zero, one, or two balance transactions that show funds withdrawn and reinstated
to your Stripe account as a result of this dispute. */
    balanceTransactions?: BalanceTransaction[] | undefined;
    /** (ID of the Charge)
ID of the charge that was disputed. */
    chargeId?: string | undefined;
    /** (Expanded)
ID of the charge that was disputed.
            
For more information, see the expand documentation. */
    charge?: Charge | undefined;
    internalCharge?: ExpandableFieldOfCharge | undefined;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** Three-letter ISO currency
code, in lowercase. Must be a supported
currency. */
    currency?: string | undefined;
    evidence?: DisputeEvidence | undefined;
    evidenceDetails?: DisputeEvidenceDetails | undefined;
    /** If true, it is still possible to refund the disputed payment. Once the payment has been
fully refunded, no further funds will be withdrawn from your Stripe account as a result
of this dispute. */
    isChargeRefundable?: boolean;
    /** Has the value true if the object exists in live mode or the value false if
the object exists in test mode. */
    livemode?: boolean;
    /** Set of key-value pairs that you can
attach to an object. This can be useful for storing additional information about the
object in a structured format. */
    metadata?: { [key: string]: string; } | undefined;
    /** Network-dependent reason code for the dispute. */
    networkReasonCode?: string | undefined;
    /** (ID of the PaymentIntent)
ID of the PaymentIntent that was disputed. */
    paymentIntentId?: string | undefined;
    /** (Expanded)
ID of the PaymentIntent that was disputed.
            
For more information, see the expand documentation. */
    paymentIntent?: PaymentIntent | undefined;
    internalPaymentIntent?: ExpandableFieldOfPaymentIntent | undefined;
    /** Reason given by cardholder for dispute. Possible values are bank_cannot_process,
check_returned, credit_not_processed, customer_initiated,
debit_not_authorized, duplicate, fraudulent, general,
incorrect_account_details, insufficient_funds,
product_not_received, product_unacceptable, subscription_canceled,
or unrecognized. Read more about dispute reasons. */
    reason?: string | undefined;
    /** Current status of dispute. Possible values are warning_needs_response,
warning_under_review, warning_closed, needs_response,
under_review, charge_refunded, won, or lost.
One of: charge_refunded, lost, needs_response, under_review,
warning_closed, warning_needs_response, warning_under_review, or
won. */
    status?: string | undefined;

    constructor(data?: IDispute) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.object = _data["object"];
            this.amount = _data["amount"];
            if (Array.isArray(_data["balanceTransactions"])) {
                this.balanceTransactions = [] as any;
                for (let item of _data["balanceTransactions"])
                    this.balanceTransactions!.push(BalanceTransaction.fromJS(item));
            }
            this.chargeId = _data["chargeId"];
            this.charge = _data["charge"] ? Charge.fromJS(_data["charge"]) : <any>undefined;
            this.internalCharge = _data["internalCharge"] ? ExpandableFieldOfCharge.fromJS(_data["internalCharge"]) : <any>undefined;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.currency = _data["currency"];
            this.evidence = _data["evidence"] ? DisputeEvidence.fromJS(_data["evidence"]) : <any>undefined;
            this.evidenceDetails = _data["evidenceDetails"] ? DisputeEvidenceDetails.fromJS(_data["evidenceDetails"]) : <any>undefined;
            this.isChargeRefundable = _data["isChargeRefundable"];
            this.livemode = _data["livemode"];
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
            this.networkReasonCode = _data["networkReasonCode"];
            this.paymentIntentId = _data["paymentIntentId"];
            this.paymentIntent = _data["paymentIntent"] ? PaymentIntent.fromJS(_data["paymentIntent"]) : <any>undefined;
            this.internalPaymentIntent = _data["internalPaymentIntent"] ? ExpandableFieldOfPaymentIntent.fromJS(_data["internalPaymentIntent"]) : <any>undefined;
            this.reason = _data["reason"];
            this.status = _data["status"];
        }
    }

    static override fromJS(data: any): Dispute {
        data = typeof data === 'object' ? data : {};
        let result = new Dispute();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["object"] = this.object;
        data["amount"] = this.amount;
        if (Array.isArray(this.balanceTransactions)) {
            data["balanceTransactions"] = [];
            for (let item of this.balanceTransactions)
                data["balanceTransactions"].push(item.toJSON());
        }
        data["chargeId"] = this.chargeId;
        data["charge"] = this.charge ? this.charge.toJSON() : <any>undefined;
        data["internalCharge"] = this.internalCharge ? this.internalCharge.toJSON() : <any>undefined;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["currency"] = this.currency;
        data["evidence"] = this.evidence ? this.evidence.toJSON() : <any>undefined;
        data["evidenceDetails"] = this.evidenceDetails ? this.evidenceDetails.toJSON() : <any>undefined;
        data["isChargeRefundable"] = this.isChargeRefundable;
        data["livemode"] = this.livemode;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        data["networkReasonCode"] = this.networkReasonCode;
        data["paymentIntentId"] = this.paymentIntentId;
        data["paymentIntent"] = this.paymentIntent ? this.paymentIntent.toJSON() : <any>undefined;
        data["internalPaymentIntent"] = this.internalPaymentIntent ? this.internalPaymentIntent.toJSON() : <any>undefined;
        data["reason"] = this.reason;
        data["status"] = this.status;
        super.toJSON(data);
        return data;
    }
}

/** A dispute occurs when a customer questions your charge with their card issuer. When this happens, you're given the opportunity to respond to the dispute with evidence that shows that the charge is legitimate. You can find more information about the dispute process in our Disputes and Fraud documentation.            Related guide: Disputes and fraud. */
export interface IDispute extends IStripeEntityOfDispute {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** Disputed amount. Usually the amount of the charge, but can differ (usually because of
currency fluctuation or because only part of the order is disputed). */
    amount?: number;
    /** List of zero, one, or two balance transactions that show funds withdrawn and reinstated
to your Stripe account as a result of this dispute. */
    balanceTransactions?: BalanceTransaction[] | undefined;
    /** (ID of the Charge)
ID of the charge that was disputed. */
    chargeId?: string | undefined;
    /** (Expanded)
ID of the charge that was disputed.
            
For more information, see the expand documentation. */
    charge?: Charge | undefined;
    internalCharge?: ExpandableFieldOfCharge | undefined;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** Three-letter ISO currency
code, in lowercase. Must be a supported
currency. */
    currency?: string | undefined;
    evidence?: DisputeEvidence | undefined;
    evidenceDetails?: DisputeEvidenceDetails | undefined;
    /** If true, it is still possible to refund the disputed payment. Once the payment has been
fully refunded, no further funds will be withdrawn from your Stripe account as a result
of this dispute. */
    isChargeRefundable?: boolean;
    /** Has the value true if the object exists in live mode or the value false if
the object exists in test mode. */
    livemode?: boolean;
    /** Set of key-value pairs that you can
attach to an object. This can be useful for storing additional information about the
object in a structured format. */
    metadata?: { [key: string]: string; } | undefined;
    /** Network-dependent reason code for the dispute. */
    networkReasonCode?: string | undefined;
    /** (ID of the PaymentIntent)
ID of the PaymentIntent that was disputed. */
    paymentIntentId?: string | undefined;
    /** (Expanded)
ID of the PaymentIntent that was disputed.
            
For more information, see the expand documentation. */
    paymentIntent?: PaymentIntent | undefined;
    internalPaymentIntent?: ExpandableFieldOfPaymentIntent | undefined;
    /** Reason given by cardholder for dispute. Possible values are bank_cannot_process,
check_returned, credit_not_processed, customer_initiated,
debit_not_authorized, duplicate, fraudulent, general,
incorrect_account_details, insufficient_funds,
product_not_received, product_unacceptable, subscription_canceled,
or unrecognized. Read more about dispute reasons. */
    reason?: string | undefined;
    /** Current status of dispute. Possible values are warning_needs_response,
warning_under_review, warning_closed, needs_response,
under_review, charge_refunded, won, or lost.
One of: charge_refunded, lost, needs_response, under_review,
warning_closed, warning_needs_response, warning_under_review, or
won. */
    status?: string | undefined;
}

export abstract class StripeEntityOfDisputeEvidence extends StripeEntity implements IStripeEntityOfDisputeEvidence {

    constructor(data?: IStripeEntityOfDisputeEvidence) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfDisputeEvidence {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfDisputeEvidence' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfDisputeEvidence extends IStripeEntity {
}

export class DisputeEvidence extends StripeEntityOfDisputeEvidence implements IDisputeEvidence {
    /** Any server or activity logs showing proof that the customer accessed or downloaded the
purchased digital product. This information should include IP addresses, corresponding
timestamps, and any detailed recorded activity. */
    accessActivityLog?: string | undefined;
    /** The billing address provided by the customer. */
    billingAddress?: string | undefined;
    /** (ID of the File)
(ID of a file upload) Your
subscription cancellation policy, as shown to the customer. */
    cancellationPolicyId?: string | undefined;
    /** (Expanded)
(ID of a file upload) Your
subscription cancellation policy, as shown to the customer.
            
For more information, see the expand documentation. */
    cancellationPolicy?: File | undefined;
    internalCancellationPolicy?: ExpandableFieldOfFile | undefined;
    /** An explanation of how and when the customer was shown your refund policy prior to
purchase. */
    cancellationPolicyDisclosure?: string | undefined;
    /** A justification for why the customer's subscription was not canceled. */
    cancellationRebuttal?: string | undefined;
    /** (ID of the File)
(ID of a file upload) Any
communication with the customer that you feel is relevant to your case. Examples include
emails proving that the customer received the product or service, or demonstrating their
use of or satisfaction with the product or service. */
    customerCommunicationId?: string | undefined;
    /** (Expanded)
(ID of a file upload) Any
communication with the customer that you feel is relevant to your case. Examples include
emails proving that the customer received the product or service, or demonstrating their
use of or satisfaction with the product or service.
            
For more information, see the expand documentation. */
    customerCommunication?: File | undefined;
    internalCustomerCommunication?: ExpandableFieldOfFile | undefined;
    /** The email address of the customer. */
    customerEmailAddress?: string | undefined;
    /** The name of the customer. */
    customerName?: string | undefined;
    /** The IP address that the customer used when making the purchase. */
    customerPurchaseIp?: string | undefined;
    /** (ID of the File)
(ID of a file upload) A
relevant document or contract showing the customer's signature. */
    customerSignatureId?: string | undefined;
    /** (Expanded)
(ID of a file upload) A
relevant document or contract showing the customer's signature.
            
For more information, see the expand documentation. */
    customerSignature?: File | undefined;
    internalCustomerSignature?: ExpandableFieldOfFile | undefined;
    /** (ID of the File)
(ID of a file upload)
Documentation for the prior charge that can uniquely identify the charge, such as a
receipt, shipping label, work order, etc. This document should be paired with a similar
document from the disputed payment that proves the two payments are separate. */
    duplicateChargeDocumentationId?: string | undefined;
    /** (Expanded)
(ID of a file upload)
Documentation for the prior charge that can uniquely identify the charge, such as a
receipt, shipping label, work order, etc. This document should be paired with a similar
document from the disputed payment that proves the two payments are separate.
            
For more information, see the expand documentation. */
    duplicateChargeDocumentation?: File | undefined;
    internalDuplicateChargeDocumentation?: ExpandableFieldOfFile | undefined;
    /** An explanation of the difference between the disputed charge versus the prior charge
that appears to be a duplicate. */
    duplicateChargeExplanation?: string | undefined;
    /** The Stripe ID for the prior charge which appears to be a duplicate of the disputed
charge. */
    duplicateChargeId?: string | undefined;
    /** A description of the product or service that was sold. */
    productDescription?: string | undefined;
    /** (ID of the File)
(ID of a file upload) Any
receipt or message sent to the customer notifying them of the charge. */
    receiptId?: string | undefined;
    /** (Expanded)
(ID of a file upload) Any
receipt or message sent to the customer notifying them of the charge.
            
For more information, see the expand documentation. */
    receipt?: File | undefined;
    internalReceipt?: ExpandableFieldOfFile | undefined;
    /** (ID of the File)
(ID of a file upload) Your
refund policy, as shown to the customer. */
    refundPolicyId?: string | undefined;
    /** (Expanded)
(ID of a file upload) Your
refund policy, as shown to the customer.
            
For more information, see the expand documentation. */
    refundPolicy?: File | undefined;
    internalRefundPolicy?: ExpandableFieldOfFile | undefined;
    /** Documentation demonstrating that the customer was shown your refund policy prior to
purchase. */
    refundPolicyDisclosure?: string | undefined;
    /** A justification for why the customer is not entitled to a refund. */
    refundRefusalExplanation?: string | undefined;
    /** The date on which the customer received or began receiving the purchased service, in a
clear human-readable format. */
    serviceDate?: string | undefined;
    /** (ID of the File)
(ID of a file upload)
Documentation showing proof that a service was provided to the customer. This could
include a copy of a signed contract, work order, or other form of written agreement. */
    serviceDocumentationId?: string | undefined;
    /** (Expanded)
(ID of a file upload)
Documentation showing proof that a service was provided to the customer. This could
include a copy of a signed contract, work order, or other form of written agreement.
            
For more information, see the expand documentation. */
    serviceDocumentation?: File | undefined;
    internalServiceDocumentation?: ExpandableFieldOfFile | undefined;
    /** The address to which a physical product was shipped. You should try to include as
complete address information as possible. */
    shippingAddress?: string | undefined;
    /** The delivery service that shipped a physical product, such as Fedex, UPS, USPS, etc. If
multiple carriers were used for this purchase, please separate them with commas. */
    shippingCarrier?: string | undefined;
    /** The date on which a physical product began its route to the shipping address, in a clear
human-readable format. */
    shippingDate?: string | undefined;
    /** (ID of the File)
(ID of a file upload)
Documentation showing proof that a product was shipped to the customer at the same
address the customer provided to you. This could include a copy of the shipment receipt,
shipping label, etc. It should show the customer's full shipping address, if possible. */
    shippingDocumentationId?: string | undefined;
    /** (Expanded)
(ID of a file upload)
Documentation showing proof that a product was shipped to the customer at the same
address the customer provided to you. This could include a copy of the shipment receipt,
shipping label, etc. It should show the customer's full shipping address, if possible.
            
For more information, see the expand documentation. */
    shippingDocumentation?: File | undefined;
    internalShippingDocumentation?: ExpandableFieldOfFile | undefined;
    /** The tracking number for a physical product, obtained from the delivery service. If
multiple tracking numbers were generated for this purchase, please separate them with
commas. */
    shippingTrackingNumber?: string | undefined;
    /** (ID of the File)
(ID of a file upload) Any
additional evidence or statements. */
    uncategorizedFileId?: string | undefined;
    /** (Expanded)
(ID of a file upload) Any
additional evidence or statements.
            
For more information, see the expand documentation. */
    uncategorizedFile?: File | undefined;
    internalUncategorizedFile?: ExpandableFieldOfFile | undefined;
    /** Any additional evidence or statements. */
    uncategorizedText?: string | undefined;

    constructor(data?: IDisputeEvidence) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.accessActivityLog = _data["accessActivityLog"];
            this.billingAddress = _data["billingAddress"];
            this.cancellationPolicyId = _data["cancellationPolicyId"];
            this.cancellationPolicy = _data["cancellationPolicy"] ? File.fromJS(_data["cancellationPolicy"]) : <any>undefined;
            this.internalCancellationPolicy = _data["internalCancellationPolicy"] ? ExpandableFieldOfFile.fromJS(_data["internalCancellationPolicy"]) : <any>undefined;
            this.cancellationPolicyDisclosure = _data["cancellationPolicyDisclosure"];
            this.cancellationRebuttal = _data["cancellationRebuttal"];
            this.customerCommunicationId = _data["customerCommunicationId"];
            this.customerCommunication = _data["customerCommunication"] ? File.fromJS(_data["customerCommunication"]) : <any>undefined;
            this.internalCustomerCommunication = _data["internalCustomerCommunication"] ? ExpandableFieldOfFile.fromJS(_data["internalCustomerCommunication"]) : <any>undefined;
            this.customerEmailAddress = _data["customerEmailAddress"];
            this.customerName = _data["customerName"];
            this.customerPurchaseIp = _data["customerPurchaseIp"];
            this.customerSignatureId = _data["customerSignatureId"];
            this.customerSignature = _data["customerSignature"] ? File.fromJS(_data["customerSignature"]) : <any>undefined;
            this.internalCustomerSignature = _data["internalCustomerSignature"] ? ExpandableFieldOfFile.fromJS(_data["internalCustomerSignature"]) : <any>undefined;
            this.duplicateChargeDocumentationId = _data["duplicateChargeDocumentationId"];
            this.duplicateChargeDocumentation = _data["duplicateChargeDocumentation"] ? File.fromJS(_data["duplicateChargeDocumentation"]) : <any>undefined;
            this.internalDuplicateChargeDocumentation = _data["internalDuplicateChargeDocumentation"] ? ExpandableFieldOfFile.fromJS(_data["internalDuplicateChargeDocumentation"]) : <any>undefined;
            this.duplicateChargeExplanation = _data["duplicateChargeExplanation"];
            this.duplicateChargeId = _data["duplicateChargeId"];
            this.productDescription = _data["productDescription"];
            this.receiptId = _data["receiptId"];
            this.receipt = _data["receipt"] ? File.fromJS(_data["receipt"]) : <any>undefined;
            this.internalReceipt = _data["internalReceipt"] ? ExpandableFieldOfFile.fromJS(_data["internalReceipt"]) : <any>undefined;
            this.refundPolicyId = _data["refundPolicyId"];
            this.refundPolicy = _data["refundPolicy"] ? File.fromJS(_data["refundPolicy"]) : <any>undefined;
            this.internalRefundPolicy = _data["internalRefundPolicy"] ? ExpandableFieldOfFile.fromJS(_data["internalRefundPolicy"]) : <any>undefined;
            this.refundPolicyDisclosure = _data["refundPolicyDisclosure"];
            this.refundRefusalExplanation = _data["refundRefusalExplanation"];
            this.serviceDate = _data["serviceDate"];
            this.serviceDocumentationId = _data["serviceDocumentationId"];
            this.serviceDocumentation = _data["serviceDocumentation"] ? File.fromJS(_data["serviceDocumentation"]) : <any>undefined;
            this.internalServiceDocumentation = _data["internalServiceDocumentation"] ? ExpandableFieldOfFile.fromJS(_data["internalServiceDocumentation"]) : <any>undefined;
            this.shippingAddress = _data["shippingAddress"];
            this.shippingCarrier = _data["shippingCarrier"];
            this.shippingDate = _data["shippingDate"];
            this.shippingDocumentationId = _data["shippingDocumentationId"];
            this.shippingDocumentation = _data["shippingDocumentation"] ? File.fromJS(_data["shippingDocumentation"]) : <any>undefined;
            this.internalShippingDocumentation = _data["internalShippingDocumentation"] ? ExpandableFieldOfFile.fromJS(_data["internalShippingDocumentation"]) : <any>undefined;
            this.shippingTrackingNumber = _data["shippingTrackingNumber"];
            this.uncategorizedFileId = _data["uncategorizedFileId"];
            this.uncategorizedFile = _data["uncategorizedFile"] ? File.fromJS(_data["uncategorizedFile"]) : <any>undefined;
            this.internalUncategorizedFile = _data["internalUncategorizedFile"] ? ExpandableFieldOfFile.fromJS(_data["internalUncategorizedFile"]) : <any>undefined;
            this.uncategorizedText = _data["uncategorizedText"];
        }
    }

    static override fromJS(data: any): DisputeEvidence {
        data = typeof data === 'object' ? data : {};
        let result = new DisputeEvidence();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessActivityLog"] = this.accessActivityLog;
        data["billingAddress"] = this.billingAddress;
        data["cancellationPolicyId"] = this.cancellationPolicyId;
        data["cancellationPolicy"] = this.cancellationPolicy ? this.cancellationPolicy.toJSON() : <any>undefined;
        data["internalCancellationPolicy"] = this.internalCancellationPolicy ? this.internalCancellationPolicy.toJSON() : <any>undefined;
        data["cancellationPolicyDisclosure"] = this.cancellationPolicyDisclosure;
        data["cancellationRebuttal"] = this.cancellationRebuttal;
        data["customerCommunicationId"] = this.customerCommunicationId;
        data["customerCommunication"] = this.customerCommunication ? this.customerCommunication.toJSON() : <any>undefined;
        data["internalCustomerCommunication"] = this.internalCustomerCommunication ? this.internalCustomerCommunication.toJSON() : <any>undefined;
        data["customerEmailAddress"] = this.customerEmailAddress;
        data["customerName"] = this.customerName;
        data["customerPurchaseIp"] = this.customerPurchaseIp;
        data["customerSignatureId"] = this.customerSignatureId;
        data["customerSignature"] = this.customerSignature ? this.customerSignature.toJSON() : <any>undefined;
        data["internalCustomerSignature"] = this.internalCustomerSignature ? this.internalCustomerSignature.toJSON() : <any>undefined;
        data["duplicateChargeDocumentationId"] = this.duplicateChargeDocumentationId;
        data["duplicateChargeDocumentation"] = this.duplicateChargeDocumentation ? this.duplicateChargeDocumentation.toJSON() : <any>undefined;
        data["internalDuplicateChargeDocumentation"] = this.internalDuplicateChargeDocumentation ? this.internalDuplicateChargeDocumentation.toJSON() : <any>undefined;
        data["duplicateChargeExplanation"] = this.duplicateChargeExplanation;
        data["duplicateChargeId"] = this.duplicateChargeId;
        data["productDescription"] = this.productDescription;
        data["receiptId"] = this.receiptId;
        data["receipt"] = this.receipt ? this.receipt.toJSON() : <any>undefined;
        data["internalReceipt"] = this.internalReceipt ? this.internalReceipt.toJSON() : <any>undefined;
        data["refundPolicyId"] = this.refundPolicyId;
        data["refundPolicy"] = this.refundPolicy ? this.refundPolicy.toJSON() : <any>undefined;
        data["internalRefundPolicy"] = this.internalRefundPolicy ? this.internalRefundPolicy.toJSON() : <any>undefined;
        data["refundPolicyDisclosure"] = this.refundPolicyDisclosure;
        data["refundRefusalExplanation"] = this.refundRefusalExplanation;
        data["serviceDate"] = this.serviceDate;
        data["serviceDocumentationId"] = this.serviceDocumentationId;
        data["serviceDocumentation"] = this.serviceDocumentation ? this.serviceDocumentation.toJSON() : <any>undefined;
        data["internalServiceDocumentation"] = this.internalServiceDocumentation ? this.internalServiceDocumentation.toJSON() : <any>undefined;
        data["shippingAddress"] = this.shippingAddress;
        data["shippingCarrier"] = this.shippingCarrier;
        data["shippingDate"] = this.shippingDate;
        data["shippingDocumentationId"] = this.shippingDocumentationId;
        data["shippingDocumentation"] = this.shippingDocumentation ? this.shippingDocumentation.toJSON() : <any>undefined;
        data["internalShippingDocumentation"] = this.internalShippingDocumentation ? this.internalShippingDocumentation.toJSON() : <any>undefined;
        data["shippingTrackingNumber"] = this.shippingTrackingNumber;
        data["uncategorizedFileId"] = this.uncategorizedFileId;
        data["uncategorizedFile"] = this.uncategorizedFile ? this.uncategorizedFile.toJSON() : <any>undefined;
        data["internalUncategorizedFile"] = this.internalUncategorizedFile ? this.internalUncategorizedFile.toJSON() : <any>undefined;
        data["uncategorizedText"] = this.uncategorizedText;
        super.toJSON(data);
        return data;
    }
}

export interface IDisputeEvidence extends IStripeEntityOfDisputeEvidence {
    /** Any server or activity logs showing proof that the customer accessed or downloaded the
purchased digital product. This information should include IP addresses, corresponding
timestamps, and any detailed recorded activity. */
    accessActivityLog?: string | undefined;
    /** The billing address provided by the customer. */
    billingAddress?: string | undefined;
    /** (ID of the File)
(ID of a file upload) Your
subscription cancellation policy, as shown to the customer. */
    cancellationPolicyId?: string | undefined;
    /** (Expanded)
(ID of a file upload) Your
subscription cancellation policy, as shown to the customer.
            
For more information, see the expand documentation. */
    cancellationPolicy?: File | undefined;
    internalCancellationPolicy?: ExpandableFieldOfFile | undefined;
    /** An explanation of how and when the customer was shown your refund policy prior to
purchase. */
    cancellationPolicyDisclosure?: string | undefined;
    /** A justification for why the customer's subscription was not canceled. */
    cancellationRebuttal?: string | undefined;
    /** (ID of the File)
(ID of a file upload) Any
communication with the customer that you feel is relevant to your case. Examples include
emails proving that the customer received the product or service, or demonstrating their
use of or satisfaction with the product or service. */
    customerCommunicationId?: string | undefined;
    /** (Expanded)
(ID of a file upload) Any
communication with the customer that you feel is relevant to your case. Examples include
emails proving that the customer received the product or service, or demonstrating their
use of or satisfaction with the product or service.
            
For more information, see the expand documentation. */
    customerCommunication?: File | undefined;
    internalCustomerCommunication?: ExpandableFieldOfFile | undefined;
    /** The email address of the customer. */
    customerEmailAddress?: string | undefined;
    /** The name of the customer. */
    customerName?: string | undefined;
    /** The IP address that the customer used when making the purchase. */
    customerPurchaseIp?: string | undefined;
    /** (ID of the File)
(ID of a file upload) A
relevant document or contract showing the customer's signature. */
    customerSignatureId?: string | undefined;
    /** (Expanded)
(ID of a file upload) A
relevant document or contract showing the customer's signature.
            
For more information, see the expand documentation. */
    customerSignature?: File | undefined;
    internalCustomerSignature?: ExpandableFieldOfFile | undefined;
    /** (ID of the File)
(ID of a file upload)
Documentation for the prior charge that can uniquely identify the charge, such as a
receipt, shipping label, work order, etc. This document should be paired with a similar
document from the disputed payment that proves the two payments are separate. */
    duplicateChargeDocumentationId?: string | undefined;
    /** (Expanded)
(ID of a file upload)
Documentation for the prior charge that can uniquely identify the charge, such as a
receipt, shipping label, work order, etc. This document should be paired with a similar
document from the disputed payment that proves the two payments are separate.
            
For more information, see the expand documentation. */
    duplicateChargeDocumentation?: File | undefined;
    internalDuplicateChargeDocumentation?: ExpandableFieldOfFile | undefined;
    /** An explanation of the difference between the disputed charge versus the prior charge
that appears to be a duplicate. */
    duplicateChargeExplanation?: string | undefined;
    /** The Stripe ID for the prior charge which appears to be a duplicate of the disputed
charge. */
    duplicateChargeId?: string | undefined;
    /** A description of the product or service that was sold. */
    productDescription?: string | undefined;
    /** (ID of the File)
(ID of a file upload) Any
receipt or message sent to the customer notifying them of the charge. */
    receiptId?: string | undefined;
    /** (Expanded)
(ID of a file upload) Any
receipt or message sent to the customer notifying them of the charge.
            
For more information, see the expand documentation. */
    receipt?: File | undefined;
    internalReceipt?: ExpandableFieldOfFile | undefined;
    /** (ID of the File)
(ID of a file upload) Your
refund policy, as shown to the customer. */
    refundPolicyId?: string | undefined;
    /** (Expanded)
(ID of a file upload) Your
refund policy, as shown to the customer.
            
For more information, see the expand documentation. */
    refundPolicy?: File | undefined;
    internalRefundPolicy?: ExpandableFieldOfFile | undefined;
    /** Documentation demonstrating that the customer was shown your refund policy prior to
purchase. */
    refundPolicyDisclosure?: string | undefined;
    /** A justification for why the customer is not entitled to a refund. */
    refundRefusalExplanation?: string | undefined;
    /** The date on which the customer received or began receiving the purchased service, in a
clear human-readable format. */
    serviceDate?: string | undefined;
    /** (ID of the File)
(ID of a file upload)
Documentation showing proof that a service was provided to the customer. This could
include a copy of a signed contract, work order, or other form of written agreement. */
    serviceDocumentationId?: string | undefined;
    /** (Expanded)
(ID of a file upload)
Documentation showing proof that a service was provided to the customer. This could
include a copy of a signed contract, work order, or other form of written agreement.
            
For more information, see the expand documentation. */
    serviceDocumentation?: File | undefined;
    internalServiceDocumentation?: ExpandableFieldOfFile | undefined;
    /** The address to which a physical product was shipped. You should try to include as
complete address information as possible. */
    shippingAddress?: string | undefined;
    /** The delivery service that shipped a physical product, such as Fedex, UPS, USPS, etc. If
multiple carriers were used for this purchase, please separate them with commas. */
    shippingCarrier?: string | undefined;
    /** The date on which a physical product began its route to the shipping address, in a clear
human-readable format. */
    shippingDate?: string | undefined;
    /** (ID of the File)
(ID of a file upload)
Documentation showing proof that a product was shipped to the customer at the same
address the customer provided to you. This could include a copy of the shipment receipt,
shipping label, etc. It should show the customer's full shipping address, if possible. */
    shippingDocumentationId?: string | undefined;
    /** (Expanded)
(ID of a file upload)
Documentation showing proof that a product was shipped to the customer at the same
address the customer provided to you. This could include a copy of the shipment receipt,
shipping label, etc. It should show the customer's full shipping address, if possible.
            
For more information, see the expand documentation. */
    shippingDocumentation?: File | undefined;
    internalShippingDocumentation?: ExpandableFieldOfFile | undefined;
    /** The tracking number for a physical product, obtained from the delivery service. If
multiple tracking numbers were generated for this purchase, please separate them with
commas. */
    shippingTrackingNumber?: string | undefined;
    /** (ID of the File)
(ID of a file upload) Any
additional evidence or statements. */
    uncategorizedFileId?: string | undefined;
    /** (Expanded)
(ID of a file upload) Any
additional evidence or statements.
            
For more information, see the expand documentation. */
    uncategorizedFile?: File | undefined;
    internalUncategorizedFile?: ExpandableFieldOfFile | undefined;
    /** Any additional evidence or statements. */
    uncategorizedText?: string | undefined;
}

export abstract class StripeEntityOfDisputeEvidenceDetails extends StripeEntity implements IStripeEntityOfDisputeEvidenceDetails {

    constructor(data?: IStripeEntityOfDisputeEvidenceDetails) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfDisputeEvidenceDetails {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfDisputeEvidenceDetails' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfDisputeEvidenceDetails extends IStripeEntity {
}

export class DisputeEvidenceDetails extends StripeEntityOfDisputeEvidenceDetails implements IDisputeEvidenceDetails {
    /** Date by which evidence must be submitted in order to successfully challenge dispute.
Will be 0 if the customer's bank or credit card company doesn't allow a response for
this particular dispute. */
    dueBy?: Date | undefined;
    /** Whether evidence has been staged for this dispute. */
    hasEvidence?: boolean;
    /** Whether the last evidence submission was submitted past the due date. Defaults to
false if no evidence submissions have occurred. If true, then delivery of
the latest evidence is not guaranteed. */
    pastDue?: boolean;
    /** The number of times evidence has been submitted. Typically, you may only submit evidence
once. */
    submissionCount?: number;

    constructor(data?: IDisputeEvidenceDetails) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.dueBy = _data["dueBy"] ? new Date(_data["dueBy"].toString()) : <any>undefined;
            this.hasEvidence = _data["hasEvidence"];
            this.pastDue = _data["pastDue"];
            this.submissionCount = _data["submissionCount"];
        }
    }

    static override fromJS(data: any): DisputeEvidenceDetails {
        data = typeof data === 'object' ? data : {};
        let result = new DisputeEvidenceDetails();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dueBy"] = this.dueBy ? this.dueBy.toISOString() : <any>undefined;
        data["hasEvidence"] = this.hasEvidence;
        data["pastDue"] = this.pastDue;
        data["submissionCount"] = this.submissionCount;
        super.toJSON(data);
        return data;
    }
}

export interface IDisputeEvidenceDetails extends IStripeEntityOfDisputeEvidenceDetails {
    /** Date by which evidence must be submitted in order to successfully challenge dispute.
Will be 0 if the customer's bank or credit card company doesn't allow a response for
this particular dispute. */
    dueBy?: Date | undefined;
    /** Whether evidence has been staged for this dispute. */
    hasEvidence?: boolean;
    /** Whether the last evidence submission was submitted past the due date. Defaults to
false if no evidence submissions have occurred. If true, then delivery of
the latest evidence is not guaranteed. */
    pastDue?: boolean;
    /** The number of times evidence has been submitted. Typically, you may only submit evidence
once. */
    submissionCount?: number;
}

export abstract class StripeEntityOfPaymentIntent extends StripeEntity implements IStripeEntityOfPaymentIntent {

    constructor(data?: IStripeEntityOfPaymentIntent) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntent {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntent' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntent extends IStripeEntity {
}

/** A PaymentIntent guides you through the process of collecting a payment from your customer. We recommend that you create exactly one PaymentIntent for each order or customer session in your system. You can reference the PaymentIntent later to see the history of payment attempts for a particular session.            A PaymentIntent transitions through multiple statuses throughout its lifetime as it interfaces with Stripe.js to perform authentication flows and ultimately creates at most one successful charge.            Related guide: Payment Intents API. */
export class PaymentIntent extends StripeEntityOfPaymentIntent implements IPaymentIntent {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** Amount intended to be collected by this PaymentIntent. A positive integer representing
how much to charge in the smallest currency unit (e.g.,
100 cents to charge $1.00 or 100 to charge ¥100, a zero-decimal currency). The minimum
amount is $0.50 US or equivalent
in charge currency. The amount value supports up to eight digits (e.g., a value of
99999999 for a USD charge of $999,999.99). */
    amount?: number;
    /** Amount that can be captured from this PaymentIntent. */
    amountCapturable?: number;
    amountDetails?: PaymentIntentAmountDetails | undefined;
    /** Amount that was collected by this PaymentIntent. */
    amountReceived?: number;
    /** (ID of the Application)
ID of the Connect application that created the PaymentIntent. */
    applicationId?: string | undefined;
    /** (Expanded)
ID of the Connect application that created the PaymentIntent.
            
For more information, see the expand documentation. */
    application?: Application | undefined;
    internalApplication?: ExpandableFieldOfApplication | undefined;
    /** The amount of the application fee (if any) that will be requested to be applied to the
payment and transferred to the application owner's Stripe account. The amount of the
application fee collected will be capped at the total payment amount. For more
information, see the PaymentIntents use case for connected
accounts. */
    applicationFeeAmount?: number | undefined;
    /** Settings to configure compatible payment methods from the Stripe Dashboard. */
    automaticPaymentMethods?: PaymentIntentAutomaticPaymentMethods | undefined;
    /** Populated when status is canceled, this is the time at which the
PaymentIntent was canceled. Measured in seconds since the Unix epoch. */
    canceledAt?: Date | undefined;
    /** Reason for cancellation of this PaymentIntent, either user-provided (duplicate,
fraudulent, requested_by_customer, or abandoned) or generated by
Stripe internally (failed_invoice, void_invoice, or automatic).
One of: abandoned, automatic, duplicate, failed_invoice,
fraudulent, requested_by_customer, or void_invoice. */
    cancellationReason?: string | undefined;
    /** Controls when the funds will be captured from the customer's account.
One of: automatic, automatic_async, or manual. */
    captureMethod?: string | undefined;
    /** The client secret of this PaymentIntent. Used for client-side retrieval using a
publishable key.
            
The client secret can be used to complete a payment from your frontend. It should not be
stored, logged, or exposed to anyone other than the customer. Make sure that you have
TLS enabled on any page that includes the client secret.
            
Refer to our docs to accept a
payment and learn about how client_secret should be handled. */
    clientSecret?: string | undefined;
    confirmationMethod?: string | undefined;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** Three-letter ISO currency
code, in lowercase. Must be a supported
currency. */
    currency?: string | undefined;
    /** (ID of the Customer)
ID of the Customer this PaymentIntent belongs to, if one exists.
            
Payment methods attached to other Customers cannot be used with this PaymentIntent.
            
If present in combination with setup_future_usage,
this PaymentIntent's payment method will be attached to the Customer after the
PaymentIntent has been confirmed and any required actions from the user are complete. */
    customerId?: string | undefined;
    /** (Expanded)
ID of the Customer this PaymentIntent belongs to, if one exists.
            
Payment methods attached to other Customers cannot be used with this PaymentIntent.
            
If present in combination with setup_future_usage,
this PaymentIntent's payment method will be attached to the Customer after the
PaymentIntent has been confirmed and any required actions from the user are complete.
            
For more information, see the expand documentation. */
    customer?: Customer2 | undefined;
    internalCustomer?: ExpandableFieldOfCustomer | undefined;
    /** An arbitrary string attached to the object. Often useful for displaying to users. */
    description?: string | undefined;
    /** (ID of the Invoice)
ID of the invoice that created this PaymentIntent, if it exists. */
    invoiceId?: string | undefined;
    /** (Expanded)
ID of the invoice that created this PaymentIntent, if it exists.
            
For more information, see the expand documentation. */
    invoice?: Invoice | undefined;
    internalInvoice?: ExpandableFieldOfInvoice | undefined;
    /** The payment error encountered in the previous PaymentIntent confirmation. It will be
cleared if the PaymentIntent is later updated for any reason. */
    lastPaymentError?: StripeError | undefined;
    /** (ID of the Charge)
The latest charge created by this payment intent. */
    latestChargeId?: string | undefined;
    /** (Expanded)
The latest charge created by this payment intent.
            
For more information, see the expand documentation. */
    latestCharge?: Charge | undefined;
    internalLatestCharge?: ExpandableFieldOfCharge | undefined;
    /** Has the value true if the object exists in live mode or the value false if
the object exists in test mode. */
    livemode?: boolean;
    /** Set of key-value pairs that you can
attach to an object. This can be useful for storing additional information about the
object in a structured format. For more information, see the documentation. */
    metadata?: { [key: string]: string; } | undefined;
    /** If present, this property tells you what actions you need to take in order for your
customer to fulfill a payment using the provided source. */
    nextAction?: PaymentIntentNextAction | undefined;
    /** (ID of the Account)
The account (if any) for which the funds of the PaymentIntent are intended. See the
PaymentIntents use case
for connected accounts for details. */
    onBehalfOfId?: string | undefined;
    /** (Expanded)
The account (if any) for which the funds of the PaymentIntent are intended. See the
PaymentIntents use case
for connected accounts for details.
            
For more information, see the expand documentation. */
    onBehalfOf?: Account | undefined;
    internalOnBehalfOf?: ExpandableFieldOfAccount | undefined;
    /** (ID of the PaymentMethod)
ID of the payment method used in this PaymentIntent. */
    paymentMethodId?: string | undefined;
    /** (Expanded)
ID of the payment method used in this PaymentIntent.
            
For more information, see the expand documentation. */
    paymentMethod?: PaymentMethod | undefined;
    internalPaymentMethod?: ExpandableFieldOfPaymentMethod | undefined;
    /** Payment-method-specific configuration for this PaymentIntent. */
    paymentMethodOptions?: PaymentIntentPaymentMethodOptions | undefined;
    /** The list of payment method types (e.g. card) that this PaymentIntent is allowed to use. */
    paymentMethodTypes?: string[] | undefined;
    /** If present, this property tells you about the processing state of the payment. */
    processing?: PaymentIntentProcessing | undefined;
    /** Email address that the receipt for the resulting payment will be sent to. If
receipt_email is specified for a payment in live mode, a receipt will be sent
regardless of your email
settings. */
    receiptEmail?: string | undefined;
    /** (ID of the Review)
ID of the review associated with this PaymentIntent, if any. */
    reviewId?: string | undefined;
    /** (Expanded)
ID of the review associated with this PaymentIntent, if any.
            
For more information, see the expand documentation. */
    review?: Review2 | undefined;
    internalReview?: ExpandableFieldOfReview | undefined;
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA.
One of: off_session, or on_session. */
    setupFutureUsage?: string | undefined;
    /** Shipping information for this PaymentIntent. */
    shipping?: Shipping | undefined;
    /** (ID of the IPaymentSource)
This is a legacy field that will be removed in the future. It is the ID of the Source
object that is associated with this PaymentIntent, if one was supplied. */
    sourceId?: string | undefined;
    /** (Expanded)
This is a legacy field that will be removed in the future. It is the ID of the Source
object that is associated with this PaymentIntent, if one was supplied.
            
For more information, see the expand documentation. */
    source?: IPaymentSource | undefined;
    internalSource?: ExpandableFieldOfIPaymentSource | undefined;
    /** For non-card charges, you can use this value as the complete description that appears on
your customers’ statements. Must contain at least one letter, maximum 22 characters. */
    statementDescriptor?: string | undefined;
    /** Provides information about a card payment that customers see on their statements.
Concatenated with the prefix (shortened descriptor) or statement descriptor that’s set
on the account to form the complete statement descriptor. Maximum 22 characters for the
concatenated descriptor. */
    statementDescriptorSuffix?: string | undefined;
    /** Status of this PaymentIntent, one of requires_payment_method,
requires_confirmation, requires_action, processing,
requires_capture, canceled, or succeeded. Read more about each
PaymentIntent status.
One of: canceled, processing, requires_action,
requires_capture, requires_confirmation, requires_payment_method,
or succeeded. */
    status?: string | undefined;
    /** The data with which to automatically create a Transfer when the payment is finalized.
See the PaymentIntents use
case for connected accounts for details. */
    transferData?: PaymentIntentTransferData | undefined;
    /** A string that identifies the resulting payment as part of a group. See the
PaymentIntents use case
for connected accounts for details. */
    transferGroup?: string | undefined;

    constructor(data?: IPaymentIntent) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.object = _data["object"];
            this.amount = _data["amount"];
            this.amountCapturable = _data["amountCapturable"];
            this.amountDetails = _data["amountDetails"] ? PaymentIntentAmountDetails.fromJS(_data["amountDetails"]) : <any>undefined;
            this.amountReceived = _data["amountReceived"];
            this.applicationId = _data["applicationId"];
            this.application = _data["application"] ? Application.fromJS(_data["application"]) : <any>undefined;
            this.internalApplication = _data["internalApplication"] ? ExpandableFieldOfApplication.fromJS(_data["internalApplication"]) : <any>undefined;
            this.applicationFeeAmount = _data["applicationFeeAmount"];
            this.automaticPaymentMethods = _data["automaticPaymentMethods"] ? PaymentIntentAutomaticPaymentMethods.fromJS(_data["automaticPaymentMethods"]) : <any>undefined;
            this.canceledAt = _data["canceledAt"] ? new Date(_data["canceledAt"].toString()) : <any>undefined;
            this.cancellationReason = _data["cancellationReason"];
            this.captureMethod = _data["captureMethod"];
            this.clientSecret = _data["clientSecret"];
            this.confirmationMethod = _data["confirmationMethod"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.currency = _data["currency"];
            this.customerId = _data["customerId"];
            this.customer = _data["customer"] ? Customer2.fromJS(_data["customer"]) : <any>undefined;
            this.internalCustomer = _data["internalCustomer"] ? ExpandableFieldOfCustomer.fromJS(_data["internalCustomer"]) : <any>undefined;
            this.description = _data["description"];
            this.invoiceId = _data["invoiceId"];
            this.invoice = _data["invoice"] ? Invoice.fromJS(_data["invoice"]) : <any>undefined;
            this.internalInvoice = _data["internalInvoice"] ? ExpandableFieldOfInvoice.fromJS(_data["internalInvoice"]) : <any>undefined;
            this.lastPaymentError = _data["lastPaymentError"] ? StripeError.fromJS(_data["lastPaymentError"]) : <any>undefined;
            this.latestChargeId = _data["latestChargeId"];
            this.latestCharge = _data["latestCharge"] ? Charge.fromJS(_data["latestCharge"]) : <any>undefined;
            this.internalLatestCharge = _data["internalLatestCharge"] ? ExpandableFieldOfCharge.fromJS(_data["internalLatestCharge"]) : <any>undefined;
            this.livemode = _data["livemode"];
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
            this.nextAction = _data["nextAction"] ? PaymentIntentNextAction.fromJS(_data["nextAction"]) : <any>undefined;
            this.onBehalfOfId = _data["onBehalfOfId"];
            this.onBehalfOf = _data["onBehalfOf"] ? Account.fromJS(_data["onBehalfOf"]) : <any>undefined;
            this.internalOnBehalfOf = _data["internalOnBehalfOf"] ? ExpandableFieldOfAccount.fromJS(_data["internalOnBehalfOf"]) : <any>undefined;
            this.paymentMethodId = _data["paymentMethodId"];
            this.paymentMethod = _data["paymentMethod"] ? PaymentMethod.fromJS(_data["paymentMethod"]) : <any>undefined;
            this.internalPaymentMethod = _data["internalPaymentMethod"] ? ExpandableFieldOfPaymentMethod.fromJS(_data["internalPaymentMethod"]) : <any>undefined;
            this.paymentMethodOptions = _data["paymentMethodOptions"] ? PaymentIntentPaymentMethodOptions.fromJS(_data["paymentMethodOptions"]) : <any>undefined;
            if (Array.isArray(_data["paymentMethodTypes"])) {
                this.paymentMethodTypes = [] as any;
                for (let item of _data["paymentMethodTypes"])
                    this.paymentMethodTypes!.push(item);
            }
            this.processing = _data["processing"] ? PaymentIntentProcessing.fromJS(_data["processing"]) : <any>undefined;
            this.receiptEmail = _data["receiptEmail"];
            this.reviewId = _data["reviewId"];
            this.review = _data["review"] ? Review2.fromJS(_data["review"]) : <any>undefined;
            this.internalReview = _data["internalReview"] ? ExpandableFieldOfReview.fromJS(_data["internalReview"]) : <any>undefined;
            this.setupFutureUsage = _data["setupFutureUsage"];
            this.shipping = _data["shipping"] ? Shipping.fromJS(_data["shipping"]) : <any>undefined;
            this.sourceId = _data["sourceId"];
            this.source = _data["source"] ? IPaymentSource.fromJS(_data["source"]) : <any>undefined;
            this.internalSource = _data["internalSource"] ? ExpandableFieldOfIPaymentSource.fromJS(_data["internalSource"]) : <any>undefined;
            this.statementDescriptor = _data["statementDescriptor"];
            this.statementDescriptorSuffix = _data["statementDescriptorSuffix"];
            this.status = _data["status"];
            this.transferData = _data["transferData"] ? PaymentIntentTransferData.fromJS(_data["transferData"]) : <any>undefined;
            this.transferGroup = _data["transferGroup"];
        }
    }

    static override fromJS(data: any): PaymentIntent {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntent();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["object"] = this.object;
        data["amount"] = this.amount;
        data["amountCapturable"] = this.amountCapturable;
        data["amountDetails"] = this.amountDetails ? this.amountDetails.toJSON() : <any>undefined;
        data["amountReceived"] = this.amountReceived;
        data["applicationId"] = this.applicationId;
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["internalApplication"] = this.internalApplication ? this.internalApplication.toJSON() : <any>undefined;
        data["applicationFeeAmount"] = this.applicationFeeAmount;
        data["automaticPaymentMethods"] = this.automaticPaymentMethods ? this.automaticPaymentMethods.toJSON() : <any>undefined;
        data["canceledAt"] = this.canceledAt ? this.canceledAt.toISOString() : <any>undefined;
        data["cancellationReason"] = this.cancellationReason;
        data["captureMethod"] = this.captureMethod;
        data["clientSecret"] = this.clientSecret;
        data["confirmationMethod"] = this.confirmationMethod;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["currency"] = this.currency;
        data["customerId"] = this.customerId;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["internalCustomer"] = this.internalCustomer ? this.internalCustomer.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["invoiceId"] = this.invoiceId;
        data["invoice"] = this.invoice ? this.invoice.toJSON() : <any>undefined;
        data["internalInvoice"] = this.internalInvoice ? this.internalInvoice.toJSON() : <any>undefined;
        data["lastPaymentError"] = this.lastPaymentError ? this.lastPaymentError.toJSON() : <any>undefined;
        data["latestChargeId"] = this.latestChargeId;
        data["latestCharge"] = this.latestCharge ? this.latestCharge.toJSON() : <any>undefined;
        data["internalLatestCharge"] = this.internalLatestCharge ? this.internalLatestCharge.toJSON() : <any>undefined;
        data["livemode"] = this.livemode;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        data["nextAction"] = this.nextAction ? this.nextAction.toJSON() : <any>undefined;
        data["onBehalfOfId"] = this.onBehalfOfId;
        data["onBehalfOf"] = this.onBehalfOf ? this.onBehalfOf.toJSON() : <any>undefined;
        data["internalOnBehalfOf"] = this.internalOnBehalfOf ? this.internalOnBehalfOf.toJSON() : <any>undefined;
        data["paymentMethodId"] = this.paymentMethodId;
        data["paymentMethod"] = this.paymentMethod ? this.paymentMethod.toJSON() : <any>undefined;
        data["internalPaymentMethod"] = this.internalPaymentMethod ? this.internalPaymentMethod.toJSON() : <any>undefined;
        data["paymentMethodOptions"] = this.paymentMethodOptions ? this.paymentMethodOptions.toJSON() : <any>undefined;
        if (Array.isArray(this.paymentMethodTypes)) {
            data["paymentMethodTypes"] = [];
            for (let item of this.paymentMethodTypes)
                data["paymentMethodTypes"].push(item);
        }
        data["processing"] = this.processing ? this.processing.toJSON() : <any>undefined;
        data["receiptEmail"] = this.receiptEmail;
        data["reviewId"] = this.reviewId;
        data["review"] = this.review ? this.review.toJSON() : <any>undefined;
        data["internalReview"] = this.internalReview ? this.internalReview.toJSON() : <any>undefined;
        data["setupFutureUsage"] = this.setupFutureUsage;
        data["shipping"] = this.shipping ? this.shipping.toJSON() : <any>undefined;
        data["sourceId"] = this.sourceId;
        data["source"] = this.source ? this.source.toJSON() : <any>undefined;
        data["internalSource"] = this.internalSource ? this.internalSource.toJSON() : <any>undefined;
        data["statementDescriptor"] = this.statementDescriptor;
        data["statementDescriptorSuffix"] = this.statementDescriptorSuffix;
        data["status"] = this.status;
        data["transferData"] = this.transferData ? this.transferData.toJSON() : <any>undefined;
        data["transferGroup"] = this.transferGroup;
        super.toJSON(data);
        return data;
    }
}

/** A PaymentIntent guides you through the process of collecting a payment from your customer. We recommend that you create exactly one PaymentIntent for each order or customer session in your system. You can reference the PaymentIntent later to see the history of payment attempts for a particular session.            A PaymentIntent transitions through multiple statuses throughout its lifetime as it interfaces with Stripe.js to perform authentication flows and ultimately creates at most one successful charge.            Related guide: Payment Intents API. */
export interface IPaymentIntent extends IStripeEntityOfPaymentIntent {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** Amount intended to be collected by this PaymentIntent. A positive integer representing
how much to charge in the smallest currency unit (e.g.,
100 cents to charge $1.00 or 100 to charge ¥100, a zero-decimal currency). The minimum
amount is $0.50 US or equivalent
in charge currency. The amount value supports up to eight digits (e.g., a value of
99999999 for a USD charge of $999,999.99). */
    amount?: number;
    /** Amount that can be captured from this PaymentIntent. */
    amountCapturable?: number;
    amountDetails?: PaymentIntentAmountDetails | undefined;
    /** Amount that was collected by this PaymentIntent. */
    amountReceived?: number;
    /** (ID of the Application)
ID of the Connect application that created the PaymentIntent. */
    applicationId?: string | undefined;
    /** (Expanded)
ID of the Connect application that created the PaymentIntent.
            
For more information, see the expand documentation. */
    application?: Application | undefined;
    internalApplication?: ExpandableFieldOfApplication | undefined;
    /** The amount of the application fee (if any) that will be requested to be applied to the
payment and transferred to the application owner's Stripe account. The amount of the
application fee collected will be capped at the total payment amount. For more
information, see the PaymentIntents use case for connected
accounts. */
    applicationFeeAmount?: number | undefined;
    /** Settings to configure compatible payment methods from the Stripe Dashboard. */
    automaticPaymentMethods?: PaymentIntentAutomaticPaymentMethods | undefined;
    /** Populated when status is canceled, this is the time at which the
PaymentIntent was canceled. Measured in seconds since the Unix epoch. */
    canceledAt?: Date | undefined;
    /** Reason for cancellation of this PaymentIntent, either user-provided (duplicate,
fraudulent, requested_by_customer, or abandoned) or generated by
Stripe internally (failed_invoice, void_invoice, or automatic).
One of: abandoned, automatic, duplicate, failed_invoice,
fraudulent, requested_by_customer, or void_invoice. */
    cancellationReason?: string | undefined;
    /** Controls when the funds will be captured from the customer's account.
One of: automatic, automatic_async, or manual. */
    captureMethod?: string | undefined;
    /** The client secret of this PaymentIntent. Used for client-side retrieval using a
publishable key.
            
The client secret can be used to complete a payment from your frontend. It should not be
stored, logged, or exposed to anyone other than the customer. Make sure that you have
TLS enabled on any page that includes the client secret.
            
Refer to our docs to accept a
payment and learn about how client_secret should be handled. */
    clientSecret?: string | undefined;
    confirmationMethod?: string | undefined;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** Three-letter ISO currency
code, in lowercase. Must be a supported
currency. */
    currency?: string | undefined;
    /** (ID of the Customer)
ID of the Customer this PaymentIntent belongs to, if one exists.
            
Payment methods attached to other Customers cannot be used with this PaymentIntent.
            
If present in combination with setup_future_usage,
this PaymentIntent's payment method will be attached to the Customer after the
PaymentIntent has been confirmed and any required actions from the user are complete. */
    customerId?: string | undefined;
    /** (Expanded)
ID of the Customer this PaymentIntent belongs to, if one exists.
            
Payment methods attached to other Customers cannot be used with this PaymentIntent.
            
If present in combination with setup_future_usage,
this PaymentIntent's payment method will be attached to the Customer after the
PaymentIntent has been confirmed and any required actions from the user are complete.
            
For more information, see the expand documentation. */
    customer?: Customer2 | undefined;
    internalCustomer?: ExpandableFieldOfCustomer | undefined;
    /** An arbitrary string attached to the object. Often useful for displaying to users. */
    description?: string | undefined;
    /** (ID of the Invoice)
ID of the invoice that created this PaymentIntent, if it exists. */
    invoiceId?: string | undefined;
    /** (Expanded)
ID of the invoice that created this PaymentIntent, if it exists.
            
For more information, see the expand documentation. */
    invoice?: Invoice | undefined;
    internalInvoice?: ExpandableFieldOfInvoice | undefined;
    /** The payment error encountered in the previous PaymentIntent confirmation. It will be
cleared if the PaymentIntent is later updated for any reason. */
    lastPaymentError?: StripeError | undefined;
    /** (ID of the Charge)
The latest charge created by this payment intent. */
    latestChargeId?: string | undefined;
    /** (Expanded)
The latest charge created by this payment intent.
            
For more information, see the expand documentation. */
    latestCharge?: Charge | undefined;
    internalLatestCharge?: ExpandableFieldOfCharge | undefined;
    /** Has the value true if the object exists in live mode or the value false if
the object exists in test mode. */
    livemode?: boolean;
    /** Set of key-value pairs that you can
attach to an object. This can be useful for storing additional information about the
object in a structured format. For more information, see the documentation. */
    metadata?: { [key: string]: string; } | undefined;
    /** If present, this property tells you what actions you need to take in order for your
customer to fulfill a payment using the provided source. */
    nextAction?: PaymentIntentNextAction | undefined;
    /** (ID of the Account)
The account (if any) for which the funds of the PaymentIntent are intended. See the
PaymentIntents use case
for connected accounts for details. */
    onBehalfOfId?: string | undefined;
    /** (Expanded)
The account (if any) for which the funds of the PaymentIntent are intended. See the
PaymentIntents use case
for connected accounts for details.
            
For more information, see the expand documentation. */
    onBehalfOf?: Account | undefined;
    internalOnBehalfOf?: ExpandableFieldOfAccount | undefined;
    /** (ID of the PaymentMethod)
ID of the payment method used in this PaymentIntent. */
    paymentMethodId?: string | undefined;
    /** (Expanded)
ID of the payment method used in this PaymentIntent.
            
For more information, see the expand documentation. */
    paymentMethod?: PaymentMethod | undefined;
    internalPaymentMethod?: ExpandableFieldOfPaymentMethod | undefined;
    /** Payment-method-specific configuration for this PaymentIntent. */
    paymentMethodOptions?: PaymentIntentPaymentMethodOptions | undefined;
    /** The list of payment method types (e.g. card) that this PaymentIntent is allowed to use. */
    paymentMethodTypes?: string[] | undefined;
    /** If present, this property tells you about the processing state of the payment. */
    processing?: PaymentIntentProcessing | undefined;
    /** Email address that the receipt for the resulting payment will be sent to. If
receipt_email is specified for a payment in live mode, a receipt will be sent
regardless of your email
settings. */
    receiptEmail?: string | undefined;
    /** (ID of the Review)
ID of the review associated with this PaymentIntent, if any. */
    reviewId?: string | undefined;
    /** (Expanded)
ID of the review associated with this PaymentIntent, if any.
            
For more information, see the expand documentation. */
    review?: Review2 | undefined;
    internalReview?: ExpandableFieldOfReview | undefined;
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA.
One of: off_session, or on_session. */
    setupFutureUsage?: string | undefined;
    /** Shipping information for this PaymentIntent. */
    shipping?: Shipping | undefined;
    /** (ID of the IPaymentSource)
This is a legacy field that will be removed in the future. It is the ID of the Source
object that is associated with this PaymentIntent, if one was supplied. */
    sourceId?: string | undefined;
    /** (Expanded)
This is a legacy field that will be removed in the future. It is the ID of the Source
object that is associated with this PaymentIntent, if one was supplied.
            
For more information, see the expand documentation. */
    source?: IPaymentSource | undefined;
    internalSource?: ExpandableFieldOfIPaymentSource | undefined;
    /** For non-card charges, you can use this value as the complete description that appears on
your customers’ statements. Must contain at least one letter, maximum 22 characters. */
    statementDescriptor?: string | undefined;
    /** Provides information about a card payment that customers see on their statements.
Concatenated with the prefix (shortened descriptor) or statement descriptor that’s set
on the account to form the complete statement descriptor. Maximum 22 characters for the
concatenated descriptor. */
    statementDescriptorSuffix?: string | undefined;
    /** Status of this PaymentIntent, one of requires_payment_method,
requires_confirmation, requires_action, processing,
requires_capture, canceled, or succeeded. Read more about each
PaymentIntent status.
One of: canceled, processing, requires_action,
requires_capture, requires_confirmation, requires_payment_method,
or succeeded. */
    status?: string | undefined;
    /** The data with which to automatically create a Transfer when the payment is finalized.
See the PaymentIntents use
case for connected accounts for details. */
    transferData?: PaymentIntentTransferData | undefined;
    /** A string that identifies the resulting payment as part of a group. See the
PaymentIntents use case
for connected accounts for details. */
    transferGroup?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentAmountDetails extends StripeEntity implements IStripeEntityOfPaymentIntentAmountDetails {

    constructor(data?: IStripeEntityOfPaymentIntentAmountDetails) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentAmountDetails {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentAmountDetails' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentAmountDetails extends IStripeEntity {
}

export class PaymentIntentAmountDetails extends StripeEntityOfPaymentIntentAmountDetails implements IPaymentIntentAmountDetails {
    tip?: PaymentIntentAmountDetailsTip | undefined;

    constructor(data?: IPaymentIntentAmountDetails) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.tip = _data["tip"] ? PaymentIntentAmountDetailsTip.fromJS(_data["tip"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): PaymentIntentAmountDetails {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentAmountDetails();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tip"] = this.tip ? this.tip.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentAmountDetails extends IStripeEntityOfPaymentIntentAmountDetails {
    tip?: PaymentIntentAmountDetailsTip | undefined;
}

export abstract class StripeEntityOfPaymentIntentAmountDetailsTip extends StripeEntity implements IStripeEntityOfPaymentIntentAmountDetailsTip {

    constructor(data?: IStripeEntityOfPaymentIntentAmountDetailsTip) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentAmountDetailsTip {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentAmountDetailsTip' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentAmountDetailsTip extends IStripeEntity {
}

export class PaymentIntentAmountDetailsTip extends StripeEntityOfPaymentIntentAmountDetailsTip implements IPaymentIntentAmountDetailsTip {
    /** Portion of the amount that corresponds to a tip. */
    amount?: number;

    constructor(data?: IPaymentIntentAmountDetailsTip) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.amount = _data["amount"];
        }
    }

    static override fromJS(data: any): PaymentIntentAmountDetailsTip {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentAmountDetailsTip();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentAmountDetailsTip extends IStripeEntityOfPaymentIntentAmountDetailsTip {
    /** Portion of the amount that corresponds to a tip. */
    amount?: number;
}

export abstract class StripeEntityOfPaymentIntentAutomaticPaymentMethods extends StripeEntity implements IStripeEntityOfPaymentIntentAutomaticPaymentMethods {

    constructor(data?: IStripeEntityOfPaymentIntentAutomaticPaymentMethods) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentAutomaticPaymentMethods {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentAutomaticPaymentMethods' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentAutomaticPaymentMethods extends IStripeEntity {
}

export class PaymentIntentAutomaticPaymentMethods extends StripeEntityOfPaymentIntentAutomaticPaymentMethods implements IPaymentIntentAutomaticPaymentMethods {
    /** Automatically calculates compatible payment methods. */
    enabled?: boolean;

    constructor(data?: IPaymentIntentAutomaticPaymentMethods) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.enabled = _data["enabled"];
        }
    }

    static override fromJS(data: any): PaymentIntentAutomaticPaymentMethods {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentAutomaticPaymentMethods();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enabled"] = this.enabled;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentAutomaticPaymentMethods extends IStripeEntityOfPaymentIntentAutomaticPaymentMethods {
    /** Automatically calculates compatible payment methods. */
    enabled?: boolean;
}

export abstract class StripeEntityOfInvoice extends StripeEntity implements IStripeEntityOfInvoice {

    constructor(data?: IStripeEntityOfInvoice) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfInvoice {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfInvoice' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfInvoice extends IStripeEntity {
}

/** Invoices are statements of amounts owed by a customer, and are either generated one-off, or generated periodically from a subscription.            They contain invoice items, and proration adjustments that may be caused by subscription upgrades/downgrades (if necessary).            If your invoice is configured to be billed through automatic charges, Stripe automatically finalizes your invoice and attempts payment. Note that finalizing the invoice, when automatic, does not happen immediately as the invoice is created. Stripe waits until one hour after the last webhook was successfully sent (or the last webhook timed out after failing). If you (and the platforms you may have connected to) have no webhooks configured, Stripe waits one hour after creation to finalize the invoice.            If your invoice is configured to be billed by sending an email, then based on your email settings, Stripe will email the invoice to your customer and await payment. These emails can contain a link to a hosted page to pay the invoice.            Stripe applies any customer credit on the account before determining the amount due for the invoice (i.e., the amount that will be actually charged). If the amount due for the invoice is less than Stripe's minimum allowed charge per currency, the invoice is automatically marked paid, and we add the amount due to the customer's credit balance which is applied to the next invoice.            More details on the customer's credit balance are here.            Related guide: Send invoices to customers. */
export class Invoice extends StripeEntityOfInvoice implements IInvoice {
    /** Unique identifier for the object. This property is always present unless the invoice is
an upcoming invoice. See Retrieve an upcoming invoice
for more details. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** The country of the business associated with this invoice, most often the business
creating the invoice. */
    accountCountry?: string | undefined;
    /** The public name of the business associated with this invoice, most often the business
creating the invoice. */
    accountName?: string | undefined;
    /** (IDs of the AccountTaxIds)
The account tax IDs associated with the invoice. Only editable when the invoice is a
draft. */
    accountTaxIdIds?: string[] | undefined;
    /** (Expanded)
The account tax IDs associated with the invoice. Only editable when the invoice is a
draft.
            
For more information, see the expand documentation. */
    accountTaxIds?: TaxId[] | undefined;
    internalAccountTaxIds?: ExpandableFieldOfTaxId[] | undefined;
    /** Final amount due at this time for this invoice. If the invoice's total is smaller than
the minimum charge amount, for example, or if there is account credit that can be
applied to the invoice, the amount_due may be 0. If there is a positive
starting_balance for the invoice (the customer owes money), the amount_due
will also take that into account. The charge that gets generated for the invoice will be
for the amount specified in amount_due. */
    amountDue?: number;
    /** The amount, in %s, that was paid. */
    amountPaid?: number;
    /** The difference between amount_due and amount_paid, in %s. */
    amountRemaining?: number;
    /** This is the sum of all the shipping amounts. */
    amountShipping?: number;
    /** (ID of the Application)
ID of the Connect Application that created the invoice. */
    applicationId?: string | undefined;
    /** (Expanded)
ID of the Connect Application that created the invoice.
            
For more information, see the expand documentation. */
    application?: Application | undefined;
    internalApplication?: ExpandableFieldOfApplication | undefined;
    /** The fee in %s that will be applied to the invoice and transferred to the application
owner's Stripe account when the invoice is paid. */
    applicationFeeAmount?: number | undefined;
    /** Number of payment attempts made for this invoice, from the perspective of the payment
retry schedule. Any payment attempt counts as the first attempt, and subsequently only
automatic retries increment the attempt count. In other words, manual payment attempts
after the first attempt do not affect the retry schedule. */
    attemptCount?: number;
    /** Whether an attempt has been made to pay the invoice. An invoice is not attempted until 1
hour after the invoice.created webhook, for example, so you might not want to
display that invoice as unpaid to your users. */
    attempted?: boolean;
    /** Controls whether Stripe will perform automatic
collection of the invoice. When false, the invoice's state will not
automatically advance without an explicit action. */
    autoAdvance?: boolean;
    automaticTax?: InvoiceAutomaticTax | undefined;
    /** Indicates the reason why the invoice was created. subscription_cycle indicates an
invoice created by a subscription advancing into a new period.
subscription_create indicates an invoice created due to creating a subscription.
subscription_update indicates an invoice created due to updating a subscription.
subscription is set for all old invoices to indicate either a change to a
subscription or a period advancement. manual is set for all invoices unrelated to
a subscription (for example: created via the invoice editor). The upcoming value
is reserved for simulated invoices per the upcoming invoice endpoint.
subscription_threshold indicates an invoice created due to a billing threshold
being reached.
One of: automatic_pending_invoice_item_invoice, manual,
quote_accept, subscription, subscription_create,
subscription_cycle, subscription_threshold, subscription_update, or
upcoming. */
    billingReason?: string | undefined;
    /** (ID of the Charge)
ID of the latest charge generated for this invoice, if any. */
    chargeId?: string | undefined;
    /** (Expanded)
ID of the latest charge generated for this invoice, if any.
            
For more information, see the expand documentation. */
    charge?: Charge | undefined;
    internalCharge?: ExpandableFieldOfCharge | undefined;
    /** Either charge_automatically, or send_invoice. When charging automatically,
Stripe will attempt to pay this invoice using the default source attached to the
customer. When sending an invoice, Stripe will email this invoice to the customer with
payment instructions.
One of: charge_automatically, or send_invoice. */
    collectionMethod?: string | undefined;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** Three-letter ISO currency
code, in lowercase. Must be a supported
currency. */
    currency?: string | undefined;
    /** Custom fields displayed on the invoice. */
    customFields?: InvoiceCustomField[] | undefined;
    /** (ID of the Customer)
The ID of the customer who will be billed. */
    customerId?: string | undefined;
    /** (Expanded)
The ID of the customer who will be billed.
            
For more information, see the expand documentation. */
    customer?: Customer2 | undefined;
    internalCustomer?: ExpandableFieldOfCustomer | undefined;
    /** The customer's address. Until the invoice is finalized, this field will equal
customer.address. Once the invoice is finalized, this field will no longer be
updated. */
    customerAddress?: Address | undefined;
    /** The customer's email. Until the invoice is finalized, this field will equal
customer.email. Once the invoice is finalized, this field will no longer be
updated. */
    customerEmail?: string | undefined;
    /** The customer's name. Until the invoice is finalized, this field will equal
customer.name. Once the invoice is finalized, this field will no longer be
updated. */
    customerName?: string | undefined;
    /** The customer's phone number. Until the invoice is finalized, this field will equal
customer.phone. Once the invoice is finalized, this field will no longer be
updated. */
    customerPhone?: string | undefined;
    /** The customer's shipping information. Until the invoice is finalized, this field will
equal customer.shipping. Once the invoice is finalized, this field will no longer
be updated. */
    customerShipping?: Shipping | undefined;
    /** The customer's tax exempt status. Until the invoice is finalized, this field will equal
customer.tax_exempt. Once the invoice is finalized, this field will no longer be
updated.
One of: exempt, none, or reverse. */
    customerTaxExempt?: string | undefined;
    /** The customer's tax IDs. Until the invoice is finalized, this field will contain the same
tax IDs as customer.tax_ids. Once the invoice is finalized, this field will no
longer be updated. */
    customerTaxIds?: InvoiceCustomerTaxId[] | undefined;
    /** (ID of the PaymentMethod)
ID of the default payment method for the invoice. It must belong to the customer
associated with the invoice. If not set, defaults to the subscription's default payment
method, if any, or to the default payment method in the customer's invoice settings. */
    defaultPaymentMethodId?: string | undefined;
    /** (Expanded)
ID of the default payment method for the invoice. It must belong to the customer
associated with the invoice. If not set, defaults to the subscription's default payment
method, if any, or to the default payment method in the customer's invoice settings.
            
For more information, see the expand documentation. */
    defaultPaymentMethod?: PaymentMethod | undefined;
    internalDefaultPaymentMethod?: ExpandableFieldOfPaymentMethod | undefined;
    /** (ID of the IPaymentSource)
ID of the default payment source for the invoice. It must belong to the customer
associated with the invoice and be in a chargeable state. If not set, defaults to the
subscription's default source, if any, or to the customer's default source. */
    defaultSourceId?: string | undefined;
    /** (Expanded)
ID of the default payment source for the invoice. It must belong to the customer
associated with the invoice and be in a chargeable state. If not set, defaults to the
subscription's default source, if any, or to the customer's default source.
            
For more information, see the expand documentation. */
    defaultSource?: IPaymentSource | undefined;
    internalDefaultSource?: ExpandableFieldOfIPaymentSource | undefined;
    /** The tax rates applied to this invoice, if any. */
    defaultTaxRates?: TaxRate[] | undefined;
    /** Whether this object is deleted or not. */
    deleted?: boolean | undefined;
    /** An arbitrary string attached to the object. Often useful for displaying to users.
Referenced as 'memo' in the Dashboard. */
    description?: string | undefined;
    /** Describes the current discount applied to this invoice, if there is one. Not populated
if there are multiple discounts. */
    discount?: Discount | undefined;
    /** (IDs of the Discounts)
The discounts applied to the invoice. Line item discounts are applied before invoice
discounts. Use expand[]=discounts to expand each discount. */
    discountIds?: string[] | undefined;
    /** (Expanded)
The discounts applied to the invoice. Line item discounts are applied before invoice
discounts. Use expand[]=discounts to expand each discount.
            
For more information, see the expand documentation. */
    discounts?: Discount[] | undefined;
    internalDiscounts?: ExpandableFieldOfDiscount[] | undefined;
    /** The date on which payment for this invoice is due. This value will be null for
invoices where collection_method=charge_automatically. */
    dueDate?: Date | undefined;
    /** Ending customer balance after the invoice is finalized. Invoices are finalized
approximately an hour after successful webhook delivery or when payment collection is
attempted for the invoice. If the invoice has not been finalized yet, this will be null. */
    endingBalance?: number | undefined;
    /** Footer displayed on the invoice. */
    footer?: string | undefined;
    /** Details of the invoice that was cloned. See the revision documentation
for more details. */
    fromInvoice?: InvoiceFromInvoice | undefined;
    /** The URL for the hosted invoice page, which allows customers to view and pay an invoice.
If the invoice has not been finalized yet, this will be null. */
    hostedInvoiceUrl?: string | undefined;
    /** The link to download the PDF for the invoice. If the invoice has not been finalized yet,
this will be null. */
    invoicePdf?: string | undefined;
    /** The error encountered during the previous attempt to finalize the invoice. This field is
cleared when the invoice is successfully finalized. */
    lastFinalizationError?: StripeError | undefined;
    /** (ID of the Invoice)
The ID of the most recent non-draft revision of this invoice. */
    latestRevisionId?: string | undefined;
    /** (Expanded)
The ID of the most recent non-draft revision of this invoice.
            
For more information, see the expand documentation. */
    latestRevision?: Invoice | undefined;
    internalLatestRevision?: ExpandableFieldOfInvoice | undefined;
    /** The individual line items that make up the invoice. lines is sorted as follows:
(1) pending invoice items (including prorations) in reverse chronological order, (2)
subscription items in reverse chronological order, and (3) invoice items added after
invoice creation in chronological order. */
    lines?: StripeListOfInvoiceLineItem | undefined;
    /** Has the value true if the object exists in live mode or the value false if
the object exists in test mode. */
    livemode?: boolean;
    /** Set of key-value pairs that you can
attach to an object. This can be useful for storing additional information about the
object in a structured format. */
    metadata?: { [key: string]: string; } | undefined;
    /** The time at which payment will next be attempted. This value will be null for
invoices where collection_method=send_invoice. */
    nextPaymentAttempt?: Date | undefined;
    /** A unique, identifying string that appears on emails sent to the customer for this
invoice. This starts with the customer's unique invoice_prefix if it is specified. */
    number?: string | undefined;
    /** (ID of the Account)
The account (if any) for which the funds of the invoice payment are intended. If set,
the invoice will be presented with the branding and support information of the specified
account. See the Invoices
with Connect documentation for details. */
    onBehalfOfId?: string | undefined;
    /** (Expanded)
The account (if any) for which the funds of the invoice payment are intended. If set,
the invoice will be presented with the branding and support information of the specified
account. See the Invoices
with Connect documentation for details.
            
For more information, see the expand documentation. */
    onBehalfOf?: Account | undefined;
    internalOnBehalfOf?: ExpandableFieldOfAccount | undefined;
    /** Whether payment was successfully collected for this invoice. An invoice can be paid
(most commonly) with a charge or with credit from the customer's account balance. */
    paid?: boolean;
    /** Returns true if the invoice was manually marked paid, returns false if the invoice
hasn't been paid yet or was paid on Stripe. */
    paidOutOfBand?: boolean;
    /** (ID of the PaymentIntent)
The PaymentIntent associated with this invoice. The PaymentIntent is generated when the
invoice is finalized, and can then be used to pay the invoice. Note that voiding an
invoice will cancel the PaymentIntent. */
    paymentIntentId?: string | undefined;
    /** (Expanded)
The PaymentIntent associated with this invoice. The PaymentIntent is generated when the
invoice is finalized, and can then be used to pay the invoice. Note that voiding an
invoice will cancel the PaymentIntent.
            
For more information, see the expand documentation. */
    paymentIntent?: PaymentIntent | undefined;
    internalPaymentIntent?: ExpandableFieldOfPaymentIntent | undefined;
    paymentSettings?: InvoicePaymentSettings | undefined;
    /** End of the usage period during which invoice items were added to this invoice. */
    periodEnd?: Date;
    /** Start of the usage period during which invoice items were added to this invoice. */
    periodStart?: Date;
    /** Total amount of all post-payment credit notes issued for this invoice. */
    postPaymentCreditNotesAmount?: number;
    /** Total amount of all pre-payment credit notes issued for this invoice. */
    prePaymentCreditNotesAmount?: number;
    /** (ID of the Quote)
The quote this invoice was generated from. */
    quoteId?: string | undefined;
    /** (Expanded)
The quote this invoice was generated from.
            
For more information, see the expand documentation. */
    quote?: Quote | undefined;
    internalQuote?: ExpandableFieldOfQuote | undefined;
    /** This is the transaction number that appears on email receipts sent for this invoice. */
    receiptNumber?: string | undefined;
    /** Options for invoice PDF rendering. */
    renderingOptions?: InvoiceRenderingOptions | undefined;
    /** The details of the cost of shipping, including the ShippingRate applied on the invoice. */
    shippingCost?: InvoiceShippingCost | undefined;
    /** Shipping details for the invoice. The Invoice PDF will use the shipping_details
value if it is set, otherwise the PDF will render the shipping address from the
customer. */
    shippingDetails?: InvoiceShippingDetails | undefined;
    /** Starting customer balance before the invoice is finalized. If the invoice has not been
finalized yet, this will be the current customer balance. For revision invoices, this
also includes any customer balance that was applied to the original invoice. */
    startingBalance?: number;
    /** Extra information about an invoice for the customer's credit card statement. */
    statementDescriptor?: string | undefined;
    /** The status of the invoice, one of draft, open, paid,
uncollectible, or void. Learn
more.
One of: draft, open, paid, uncollectible, or void. */
    status?: string | undefined;
    statusTransitions?: InvoiceStatusTransitions | undefined;
    /** (ID of the Subscription)
The subscription that this invoice was prepared for, if any. */
    subscriptionId?: string | undefined;
    /** (Expanded)
The subscription that this invoice was prepared for, if any.
            
For more information, see the expand documentation. */
    subscription?: Subscription | undefined;
    internalSubscription?: ExpandableFieldOfSubscription | undefined;
    /** Only set for upcoming invoices that preview prorations. The time used to calculate
prorations. */
    subscriptionProrationDate?: Date;
    /** Total of all subscriptions, invoice items, and prorations on the invoice before any
invoice level discount or exclusive tax is applied. Item discounts are already
incorporated. */
    subtotal?: number;
    /** The integer amount in %s representing the subtotal of the invoice before any invoice
level discount or tax is applied. Item discounts are already incorporated. */
    subtotalExcludingTax?: number | undefined;
    /** The amount of tax on this invoice. This is the sum of all the tax amounts on this
invoice. */
    tax?: number | undefined;
    /** (ID of the TestHelpers.TestClock)
ID of the test clock this invoice belongs to. */
    testClockId?: string | undefined;
    /** (Expanded)
ID of the test clock this invoice belongs to.
            
For more information, see the expand documentation. */
    testClock?: TestClock | undefined;
    internalTestClock?: ExpandableFieldOfTestClock | undefined;
    thresholdReason?: InvoiceThresholdReason | undefined;
    /** Total after discounts and taxes. */
    total?: number;
    /** The aggregate amounts calculated per discount across all line items. */
    totalDiscountAmounts?: InvoiceDiscountAmount[] | undefined;
    /** The integer amount in %s representing the total amount of the invoice including all
discounts but excluding all tax. */
    totalExcludingTax?: number | undefined;
    /** The aggregate amounts calculated per tax rate for all line items. */
    totalTaxAmounts?: InvoiceTaxAmount[] | undefined;
    /** The account (if any) the payment will be attributed to for tax reporting, and where
funds from the payment will be transferred to for the invoice. */
    transferData?: InvoiceTransferData | undefined;
    /** Invoices are automatically paid or sent 1 hour after webhooks are delivered, or until
all webhook delivery attempts have been exhausted. This
field tracks the time when webhooks for this invoice were successfully delivered. If the
invoice had no webhooks to deliver, this will be set while the invoice is being created. */
    webhooksDeliveredAt?: Date | undefined;

    constructor(data?: IInvoice) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.object = _data["object"];
            this.accountCountry = _data["accountCountry"];
            this.accountName = _data["accountName"];
            if (Array.isArray(_data["accountTaxIdIds"])) {
                this.accountTaxIdIds = [] as any;
                for (let item of _data["accountTaxIdIds"])
                    this.accountTaxIdIds!.push(item);
            }
            if (Array.isArray(_data["accountTaxIds"])) {
                this.accountTaxIds = [] as any;
                for (let item of _data["accountTaxIds"])
                    this.accountTaxIds!.push(TaxId.fromJS(item));
            }
            if (Array.isArray(_data["internalAccountTaxIds"])) {
                this.internalAccountTaxIds = [] as any;
                for (let item of _data["internalAccountTaxIds"])
                    this.internalAccountTaxIds!.push(ExpandableFieldOfTaxId.fromJS(item));
            }
            this.amountDue = _data["amountDue"];
            this.amountPaid = _data["amountPaid"];
            this.amountRemaining = _data["amountRemaining"];
            this.amountShipping = _data["amountShipping"];
            this.applicationId = _data["applicationId"];
            this.application = _data["application"] ? Application.fromJS(_data["application"]) : <any>undefined;
            this.internalApplication = _data["internalApplication"] ? ExpandableFieldOfApplication.fromJS(_data["internalApplication"]) : <any>undefined;
            this.applicationFeeAmount = _data["applicationFeeAmount"];
            this.attemptCount = _data["attemptCount"];
            this.attempted = _data["attempted"];
            this.autoAdvance = _data["autoAdvance"];
            this.automaticTax = _data["automaticTax"] ? InvoiceAutomaticTax.fromJS(_data["automaticTax"]) : <any>undefined;
            this.billingReason = _data["billingReason"];
            this.chargeId = _data["chargeId"];
            this.charge = _data["charge"] ? Charge.fromJS(_data["charge"]) : <any>undefined;
            this.internalCharge = _data["internalCharge"] ? ExpandableFieldOfCharge.fromJS(_data["internalCharge"]) : <any>undefined;
            this.collectionMethod = _data["collectionMethod"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.currency = _data["currency"];
            if (Array.isArray(_data["customFields"])) {
                this.customFields = [] as any;
                for (let item of _data["customFields"])
                    this.customFields!.push(InvoiceCustomField.fromJS(item));
            }
            this.customerId = _data["customerId"];
            this.customer = _data["customer"] ? Customer2.fromJS(_data["customer"]) : <any>undefined;
            this.internalCustomer = _data["internalCustomer"] ? ExpandableFieldOfCustomer.fromJS(_data["internalCustomer"]) : <any>undefined;
            this.customerAddress = _data["customerAddress"] ? Address.fromJS(_data["customerAddress"]) : <any>undefined;
            this.customerEmail = _data["customerEmail"];
            this.customerName = _data["customerName"];
            this.customerPhone = _data["customerPhone"];
            this.customerShipping = _data["customerShipping"] ? Shipping.fromJS(_data["customerShipping"]) : <any>undefined;
            this.customerTaxExempt = _data["customerTaxExempt"];
            if (Array.isArray(_data["customerTaxIds"])) {
                this.customerTaxIds = [] as any;
                for (let item of _data["customerTaxIds"])
                    this.customerTaxIds!.push(InvoiceCustomerTaxId.fromJS(item));
            }
            this.defaultPaymentMethodId = _data["defaultPaymentMethodId"];
            this.defaultPaymentMethod = _data["defaultPaymentMethod"] ? PaymentMethod.fromJS(_data["defaultPaymentMethod"]) : <any>undefined;
            this.internalDefaultPaymentMethod = _data["internalDefaultPaymentMethod"] ? ExpandableFieldOfPaymentMethod.fromJS(_data["internalDefaultPaymentMethod"]) : <any>undefined;
            this.defaultSourceId = _data["defaultSourceId"];
            this.defaultSource = _data["defaultSource"] ? IPaymentSource.fromJS(_data["defaultSource"]) : <any>undefined;
            this.internalDefaultSource = _data["internalDefaultSource"] ? ExpandableFieldOfIPaymentSource.fromJS(_data["internalDefaultSource"]) : <any>undefined;
            if (Array.isArray(_data["defaultTaxRates"])) {
                this.defaultTaxRates = [] as any;
                for (let item of _data["defaultTaxRates"])
                    this.defaultTaxRates!.push(TaxRate.fromJS(item));
            }
            this.deleted = _data["deleted"];
            this.description = _data["description"];
            this.discount = _data["discount"] ? Discount.fromJS(_data["discount"]) : <any>undefined;
            if (Array.isArray(_data["discountIds"])) {
                this.discountIds = [] as any;
                for (let item of _data["discountIds"])
                    this.discountIds!.push(item);
            }
            if (Array.isArray(_data["discounts"])) {
                this.discounts = [] as any;
                for (let item of _data["discounts"])
                    this.discounts!.push(Discount.fromJS(item));
            }
            if (Array.isArray(_data["internalDiscounts"])) {
                this.internalDiscounts = [] as any;
                for (let item of _data["internalDiscounts"])
                    this.internalDiscounts!.push(ExpandableFieldOfDiscount.fromJS(item));
            }
            this.dueDate = _data["dueDate"] ? new Date(_data["dueDate"].toString()) : <any>undefined;
            this.endingBalance = _data["endingBalance"];
            this.footer = _data["footer"];
            this.fromInvoice = _data["fromInvoice"] ? InvoiceFromInvoice.fromJS(_data["fromInvoice"]) : <any>undefined;
            this.hostedInvoiceUrl = _data["hostedInvoiceUrl"];
            this.invoicePdf = _data["invoicePdf"];
            this.lastFinalizationError = _data["lastFinalizationError"] ? StripeError.fromJS(_data["lastFinalizationError"]) : <any>undefined;
            this.latestRevisionId = _data["latestRevisionId"];
            this.latestRevision = _data["latestRevision"] ? Invoice.fromJS(_data["latestRevision"]) : <any>undefined;
            this.internalLatestRevision = _data["internalLatestRevision"] ? ExpandableFieldOfInvoice.fromJS(_data["internalLatestRevision"]) : <any>undefined;
            this.lines = _data["lines"] ? StripeListOfInvoiceLineItem.fromJS(_data["lines"]) : <any>undefined;
            this.livemode = _data["livemode"];
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
            this.nextPaymentAttempt = _data["nextPaymentAttempt"] ? new Date(_data["nextPaymentAttempt"].toString()) : <any>undefined;
            this.number = _data["number"];
            this.onBehalfOfId = _data["onBehalfOfId"];
            this.onBehalfOf = _data["onBehalfOf"] ? Account.fromJS(_data["onBehalfOf"]) : <any>undefined;
            this.internalOnBehalfOf = _data["internalOnBehalfOf"] ? ExpandableFieldOfAccount.fromJS(_data["internalOnBehalfOf"]) : <any>undefined;
            this.paid = _data["paid"];
            this.paidOutOfBand = _data["paidOutOfBand"];
            this.paymentIntentId = _data["paymentIntentId"];
            this.paymentIntent = _data["paymentIntent"] ? PaymentIntent.fromJS(_data["paymentIntent"]) : <any>undefined;
            this.internalPaymentIntent = _data["internalPaymentIntent"] ? ExpandableFieldOfPaymentIntent.fromJS(_data["internalPaymentIntent"]) : <any>undefined;
            this.paymentSettings = _data["paymentSettings"] ? InvoicePaymentSettings.fromJS(_data["paymentSettings"]) : <any>undefined;
            this.periodEnd = _data["periodEnd"] ? new Date(_data["periodEnd"].toString()) : <any>undefined;
            this.periodStart = _data["periodStart"] ? new Date(_data["periodStart"].toString()) : <any>undefined;
            this.postPaymentCreditNotesAmount = _data["postPaymentCreditNotesAmount"];
            this.prePaymentCreditNotesAmount = _data["prePaymentCreditNotesAmount"];
            this.quoteId = _data["quoteId"];
            this.quote = _data["quote"] ? Quote.fromJS(_data["quote"]) : <any>undefined;
            this.internalQuote = _data["internalQuote"] ? ExpandableFieldOfQuote.fromJS(_data["internalQuote"]) : <any>undefined;
            this.receiptNumber = _data["receiptNumber"];
            this.renderingOptions = _data["renderingOptions"] ? InvoiceRenderingOptions.fromJS(_data["renderingOptions"]) : <any>undefined;
            this.shippingCost = _data["shippingCost"] ? InvoiceShippingCost.fromJS(_data["shippingCost"]) : <any>undefined;
            this.shippingDetails = _data["shippingDetails"] ? InvoiceShippingDetails.fromJS(_data["shippingDetails"]) : <any>undefined;
            this.startingBalance = _data["startingBalance"];
            this.statementDescriptor = _data["statementDescriptor"];
            this.status = _data["status"];
            this.statusTransitions = _data["statusTransitions"] ? InvoiceStatusTransitions.fromJS(_data["statusTransitions"]) : <any>undefined;
            this.subscriptionId = _data["subscriptionId"];
            this.subscription = _data["subscription"] ? Subscription.fromJS(_data["subscription"]) : <any>undefined;
            this.internalSubscription = _data["internalSubscription"] ? ExpandableFieldOfSubscription.fromJS(_data["internalSubscription"]) : <any>undefined;
            this.subscriptionProrationDate = _data["subscriptionProrationDate"] ? new Date(_data["subscriptionProrationDate"].toString()) : <any>undefined;
            this.subtotal = _data["subtotal"];
            this.subtotalExcludingTax = _data["subtotalExcludingTax"];
            this.tax = _data["tax"];
            this.testClockId = _data["testClockId"];
            this.testClock = _data["testClock"] ? TestClock.fromJS(_data["testClock"]) : <any>undefined;
            this.internalTestClock = _data["internalTestClock"] ? ExpandableFieldOfTestClock.fromJS(_data["internalTestClock"]) : <any>undefined;
            this.thresholdReason = _data["thresholdReason"] ? InvoiceThresholdReason.fromJS(_data["thresholdReason"]) : <any>undefined;
            this.total = _data["total"];
            if (Array.isArray(_data["totalDiscountAmounts"])) {
                this.totalDiscountAmounts = [] as any;
                for (let item of _data["totalDiscountAmounts"])
                    this.totalDiscountAmounts!.push(InvoiceDiscountAmount.fromJS(item));
            }
            this.totalExcludingTax = _data["totalExcludingTax"];
            if (Array.isArray(_data["totalTaxAmounts"])) {
                this.totalTaxAmounts = [] as any;
                for (let item of _data["totalTaxAmounts"])
                    this.totalTaxAmounts!.push(InvoiceTaxAmount.fromJS(item));
            }
            this.transferData = _data["transferData"] ? InvoiceTransferData.fromJS(_data["transferData"]) : <any>undefined;
            this.webhooksDeliveredAt = _data["webhooksDeliveredAt"] ? new Date(_data["webhooksDeliveredAt"].toString()) : <any>undefined;
        }
    }

    static override fromJS(data: any): Invoice {
        data = typeof data === 'object' ? data : {};
        let result = new Invoice();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["object"] = this.object;
        data["accountCountry"] = this.accountCountry;
        data["accountName"] = this.accountName;
        if (Array.isArray(this.accountTaxIdIds)) {
            data["accountTaxIdIds"] = [];
            for (let item of this.accountTaxIdIds)
                data["accountTaxIdIds"].push(item);
        }
        if (Array.isArray(this.accountTaxIds)) {
            data["accountTaxIds"] = [];
            for (let item of this.accountTaxIds)
                data["accountTaxIds"].push(item.toJSON());
        }
        if (Array.isArray(this.internalAccountTaxIds)) {
            data["internalAccountTaxIds"] = [];
            for (let item of this.internalAccountTaxIds)
                data["internalAccountTaxIds"].push(item.toJSON());
        }
        data["amountDue"] = this.amountDue;
        data["amountPaid"] = this.amountPaid;
        data["amountRemaining"] = this.amountRemaining;
        data["amountShipping"] = this.amountShipping;
        data["applicationId"] = this.applicationId;
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["internalApplication"] = this.internalApplication ? this.internalApplication.toJSON() : <any>undefined;
        data["applicationFeeAmount"] = this.applicationFeeAmount;
        data["attemptCount"] = this.attemptCount;
        data["attempted"] = this.attempted;
        data["autoAdvance"] = this.autoAdvance;
        data["automaticTax"] = this.automaticTax ? this.automaticTax.toJSON() : <any>undefined;
        data["billingReason"] = this.billingReason;
        data["chargeId"] = this.chargeId;
        data["charge"] = this.charge ? this.charge.toJSON() : <any>undefined;
        data["internalCharge"] = this.internalCharge ? this.internalCharge.toJSON() : <any>undefined;
        data["collectionMethod"] = this.collectionMethod;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["currency"] = this.currency;
        if (Array.isArray(this.customFields)) {
            data["customFields"] = [];
            for (let item of this.customFields)
                data["customFields"].push(item.toJSON());
        }
        data["customerId"] = this.customerId;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["internalCustomer"] = this.internalCustomer ? this.internalCustomer.toJSON() : <any>undefined;
        data["customerAddress"] = this.customerAddress ? this.customerAddress.toJSON() : <any>undefined;
        data["customerEmail"] = this.customerEmail;
        data["customerName"] = this.customerName;
        data["customerPhone"] = this.customerPhone;
        data["customerShipping"] = this.customerShipping ? this.customerShipping.toJSON() : <any>undefined;
        data["customerTaxExempt"] = this.customerTaxExempt;
        if (Array.isArray(this.customerTaxIds)) {
            data["customerTaxIds"] = [];
            for (let item of this.customerTaxIds)
                data["customerTaxIds"].push(item.toJSON());
        }
        data["defaultPaymentMethodId"] = this.defaultPaymentMethodId;
        data["defaultPaymentMethod"] = this.defaultPaymentMethod ? this.defaultPaymentMethod.toJSON() : <any>undefined;
        data["internalDefaultPaymentMethod"] = this.internalDefaultPaymentMethod ? this.internalDefaultPaymentMethod.toJSON() : <any>undefined;
        data["defaultSourceId"] = this.defaultSourceId;
        data["defaultSource"] = this.defaultSource ? this.defaultSource.toJSON() : <any>undefined;
        data["internalDefaultSource"] = this.internalDefaultSource ? this.internalDefaultSource.toJSON() : <any>undefined;
        if (Array.isArray(this.defaultTaxRates)) {
            data["defaultTaxRates"] = [];
            for (let item of this.defaultTaxRates)
                data["defaultTaxRates"].push(item.toJSON());
        }
        data["deleted"] = this.deleted;
        data["description"] = this.description;
        data["discount"] = this.discount ? this.discount.toJSON() : <any>undefined;
        if (Array.isArray(this.discountIds)) {
            data["discountIds"] = [];
            for (let item of this.discountIds)
                data["discountIds"].push(item);
        }
        if (Array.isArray(this.discounts)) {
            data["discounts"] = [];
            for (let item of this.discounts)
                data["discounts"].push(item.toJSON());
        }
        if (Array.isArray(this.internalDiscounts)) {
            data["internalDiscounts"] = [];
            for (let item of this.internalDiscounts)
                data["internalDiscounts"].push(item.toJSON());
        }
        data["dueDate"] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
        data["endingBalance"] = this.endingBalance;
        data["footer"] = this.footer;
        data["fromInvoice"] = this.fromInvoice ? this.fromInvoice.toJSON() : <any>undefined;
        data["hostedInvoiceUrl"] = this.hostedInvoiceUrl;
        data["invoicePdf"] = this.invoicePdf;
        data["lastFinalizationError"] = this.lastFinalizationError ? this.lastFinalizationError.toJSON() : <any>undefined;
        data["latestRevisionId"] = this.latestRevisionId;
        data["latestRevision"] = this.latestRevision ? this.latestRevision.toJSON() : <any>undefined;
        data["internalLatestRevision"] = this.internalLatestRevision ? this.internalLatestRevision.toJSON() : <any>undefined;
        data["lines"] = this.lines ? this.lines.toJSON() : <any>undefined;
        data["livemode"] = this.livemode;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        data["nextPaymentAttempt"] = this.nextPaymentAttempt ? this.nextPaymentAttempt.toISOString() : <any>undefined;
        data["number"] = this.number;
        data["onBehalfOfId"] = this.onBehalfOfId;
        data["onBehalfOf"] = this.onBehalfOf ? this.onBehalfOf.toJSON() : <any>undefined;
        data["internalOnBehalfOf"] = this.internalOnBehalfOf ? this.internalOnBehalfOf.toJSON() : <any>undefined;
        data["paid"] = this.paid;
        data["paidOutOfBand"] = this.paidOutOfBand;
        data["paymentIntentId"] = this.paymentIntentId;
        data["paymentIntent"] = this.paymentIntent ? this.paymentIntent.toJSON() : <any>undefined;
        data["internalPaymentIntent"] = this.internalPaymentIntent ? this.internalPaymentIntent.toJSON() : <any>undefined;
        data["paymentSettings"] = this.paymentSettings ? this.paymentSettings.toJSON() : <any>undefined;
        data["periodEnd"] = this.periodEnd ? this.periodEnd.toISOString() : <any>undefined;
        data["periodStart"] = this.periodStart ? this.periodStart.toISOString() : <any>undefined;
        data["postPaymentCreditNotesAmount"] = this.postPaymentCreditNotesAmount;
        data["prePaymentCreditNotesAmount"] = this.prePaymentCreditNotesAmount;
        data["quoteId"] = this.quoteId;
        data["quote"] = this.quote ? this.quote.toJSON() : <any>undefined;
        data["internalQuote"] = this.internalQuote ? this.internalQuote.toJSON() : <any>undefined;
        data["receiptNumber"] = this.receiptNumber;
        data["renderingOptions"] = this.renderingOptions ? this.renderingOptions.toJSON() : <any>undefined;
        data["shippingCost"] = this.shippingCost ? this.shippingCost.toJSON() : <any>undefined;
        data["shippingDetails"] = this.shippingDetails ? this.shippingDetails.toJSON() : <any>undefined;
        data["startingBalance"] = this.startingBalance;
        data["statementDescriptor"] = this.statementDescriptor;
        data["status"] = this.status;
        data["statusTransitions"] = this.statusTransitions ? this.statusTransitions.toJSON() : <any>undefined;
        data["subscriptionId"] = this.subscriptionId;
        data["subscription"] = this.subscription ? this.subscription.toJSON() : <any>undefined;
        data["internalSubscription"] = this.internalSubscription ? this.internalSubscription.toJSON() : <any>undefined;
        data["subscriptionProrationDate"] = this.subscriptionProrationDate ? this.subscriptionProrationDate.toISOString() : <any>undefined;
        data["subtotal"] = this.subtotal;
        data["subtotalExcludingTax"] = this.subtotalExcludingTax;
        data["tax"] = this.tax;
        data["testClockId"] = this.testClockId;
        data["testClock"] = this.testClock ? this.testClock.toJSON() : <any>undefined;
        data["internalTestClock"] = this.internalTestClock ? this.internalTestClock.toJSON() : <any>undefined;
        data["thresholdReason"] = this.thresholdReason ? this.thresholdReason.toJSON() : <any>undefined;
        data["total"] = this.total;
        if (Array.isArray(this.totalDiscountAmounts)) {
            data["totalDiscountAmounts"] = [];
            for (let item of this.totalDiscountAmounts)
                data["totalDiscountAmounts"].push(item.toJSON());
        }
        data["totalExcludingTax"] = this.totalExcludingTax;
        if (Array.isArray(this.totalTaxAmounts)) {
            data["totalTaxAmounts"] = [];
            for (let item of this.totalTaxAmounts)
                data["totalTaxAmounts"].push(item.toJSON());
        }
        data["transferData"] = this.transferData ? this.transferData.toJSON() : <any>undefined;
        data["webhooksDeliveredAt"] = this.webhooksDeliveredAt ? this.webhooksDeliveredAt.toISOString() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** Invoices are statements of amounts owed by a customer, and are either generated one-off, or generated periodically from a subscription.            They contain invoice items, and proration adjustments that may be caused by subscription upgrades/downgrades (if necessary).            If your invoice is configured to be billed through automatic charges, Stripe automatically finalizes your invoice and attempts payment. Note that finalizing the invoice, when automatic, does not happen immediately as the invoice is created. Stripe waits until one hour after the last webhook was successfully sent (or the last webhook timed out after failing). If you (and the platforms you may have connected to) have no webhooks configured, Stripe waits one hour after creation to finalize the invoice.            If your invoice is configured to be billed by sending an email, then based on your email settings, Stripe will email the invoice to your customer and await payment. These emails can contain a link to a hosted page to pay the invoice.            Stripe applies any customer credit on the account before determining the amount due for the invoice (i.e., the amount that will be actually charged). If the amount due for the invoice is less than Stripe's minimum allowed charge per currency, the invoice is automatically marked paid, and we add the amount due to the customer's credit balance which is applied to the next invoice.            More details on the customer's credit balance are here.            Related guide: Send invoices to customers. */
export interface IInvoice extends IStripeEntityOfInvoice {
    /** Unique identifier for the object. This property is always present unless the invoice is
an upcoming invoice. See Retrieve an upcoming invoice
for more details. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** The country of the business associated with this invoice, most often the business
creating the invoice. */
    accountCountry?: string | undefined;
    /** The public name of the business associated with this invoice, most often the business
creating the invoice. */
    accountName?: string | undefined;
    /** (IDs of the AccountTaxIds)
The account tax IDs associated with the invoice. Only editable when the invoice is a
draft. */
    accountTaxIdIds?: string[] | undefined;
    /** (Expanded)
The account tax IDs associated with the invoice. Only editable when the invoice is a
draft.
            
For more information, see the expand documentation. */
    accountTaxIds?: TaxId[] | undefined;
    internalAccountTaxIds?: ExpandableFieldOfTaxId[] | undefined;
    /** Final amount due at this time for this invoice. If the invoice's total is smaller than
the minimum charge amount, for example, or if there is account credit that can be
applied to the invoice, the amount_due may be 0. If there is a positive
starting_balance for the invoice (the customer owes money), the amount_due
will also take that into account. The charge that gets generated for the invoice will be
for the amount specified in amount_due. */
    amountDue?: number;
    /** The amount, in %s, that was paid. */
    amountPaid?: number;
    /** The difference between amount_due and amount_paid, in %s. */
    amountRemaining?: number;
    /** This is the sum of all the shipping amounts. */
    amountShipping?: number;
    /** (ID of the Application)
ID of the Connect Application that created the invoice. */
    applicationId?: string | undefined;
    /** (Expanded)
ID of the Connect Application that created the invoice.
            
For more information, see the expand documentation. */
    application?: Application | undefined;
    internalApplication?: ExpandableFieldOfApplication | undefined;
    /** The fee in %s that will be applied to the invoice and transferred to the application
owner's Stripe account when the invoice is paid. */
    applicationFeeAmount?: number | undefined;
    /** Number of payment attempts made for this invoice, from the perspective of the payment
retry schedule. Any payment attempt counts as the first attempt, and subsequently only
automatic retries increment the attempt count. In other words, manual payment attempts
after the first attempt do not affect the retry schedule. */
    attemptCount?: number;
    /** Whether an attempt has been made to pay the invoice. An invoice is not attempted until 1
hour after the invoice.created webhook, for example, so you might not want to
display that invoice as unpaid to your users. */
    attempted?: boolean;
    /** Controls whether Stripe will perform automatic
collection of the invoice. When false, the invoice's state will not
automatically advance without an explicit action. */
    autoAdvance?: boolean;
    automaticTax?: InvoiceAutomaticTax | undefined;
    /** Indicates the reason why the invoice was created. subscription_cycle indicates an
invoice created by a subscription advancing into a new period.
subscription_create indicates an invoice created due to creating a subscription.
subscription_update indicates an invoice created due to updating a subscription.
subscription is set for all old invoices to indicate either a change to a
subscription or a period advancement. manual is set for all invoices unrelated to
a subscription (for example: created via the invoice editor). The upcoming value
is reserved for simulated invoices per the upcoming invoice endpoint.
subscription_threshold indicates an invoice created due to a billing threshold
being reached.
One of: automatic_pending_invoice_item_invoice, manual,
quote_accept, subscription, subscription_create,
subscription_cycle, subscription_threshold, subscription_update, or
upcoming. */
    billingReason?: string | undefined;
    /** (ID of the Charge)
ID of the latest charge generated for this invoice, if any. */
    chargeId?: string | undefined;
    /** (Expanded)
ID of the latest charge generated for this invoice, if any.
            
For more information, see the expand documentation. */
    charge?: Charge | undefined;
    internalCharge?: ExpandableFieldOfCharge | undefined;
    /** Either charge_automatically, or send_invoice. When charging automatically,
Stripe will attempt to pay this invoice using the default source attached to the
customer. When sending an invoice, Stripe will email this invoice to the customer with
payment instructions.
One of: charge_automatically, or send_invoice. */
    collectionMethod?: string | undefined;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** Three-letter ISO currency
code, in lowercase. Must be a supported
currency. */
    currency?: string | undefined;
    /** Custom fields displayed on the invoice. */
    customFields?: InvoiceCustomField[] | undefined;
    /** (ID of the Customer)
The ID of the customer who will be billed. */
    customerId?: string | undefined;
    /** (Expanded)
The ID of the customer who will be billed.
            
For more information, see the expand documentation. */
    customer?: Customer2 | undefined;
    internalCustomer?: ExpandableFieldOfCustomer | undefined;
    /** The customer's address. Until the invoice is finalized, this field will equal
customer.address. Once the invoice is finalized, this field will no longer be
updated. */
    customerAddress?: Address | undefined;
    /** The customer's email. Until the invoice is finalized, this field will equal
customer.email. Once the invoice is finalized, this field will no longer be
updated. */
    customerEmail?: string | undefined;
    /** The customer's name. Until the invoice is finalized, this field will equal
customer.name. Once the invoice is finalized, this field will no longer be
updated. */
    customerName?: string | undefined;
    /** The customer's phone number. Until the invoice is finalized, this field will equal
customer.phone. Once the invoice is finalized, this field will no longer be
updated. */
    customerPhone?: string | undefined;
    /** The customer's shipping information. Until the invoice is finalized, this field will
equal customer.shipping. Once the invoice is finalized, this field will no longer
be updated. */
    customerShipping?: Shipping | undefined;
    /** The customer's tax exempt status. Until the invoice is finalized, this field will equal
customer.tax_exempt. Once the invoice is finalized, this field will no longer be
updated.
One of: exempt, none, or reverse. */
    customerTaxExempt?: string | undefined;
    /** The customer's tax IDs. Until the invoice is finalized, this field will contain the same
tax IDs as customer.tax_ids. Once the invoice is finalized, this field will no
longer be updated. */
    customerTaxIds?: InvoiceCustomerTaxId[] | undefined;
    /** (ID of the PaymentMethod)
ID of the default payment method for the invoice. It must belong to the customer
associated with the invoice. If not set, defaults to the subscription's default payment
method, if any, or to the default payment method in the customer's invoice settings. */
    defaultPaymentMethodId?: string | undefined;
    /** (Expanded)
ID of the default payment method for the invoice. It must belong to the customer
associated with the invoice. If not set, defaults to the subscription's default payment
method, if any, or to the default payment method in the customer's invoice settings.
            
For more information, see the expand documentation. */
    defaultPaymentMethod?: PaymentMethod | undefined;
    internalDefaultPaymentMethod?: ExpandableFieldOfPaymentMethod | undefined;
    /** (ID of the IPaymentSource)
ID of the default payment source for the invoice. It must belong to the customer
associated with the invoice and be in a chargeable state. If not set, defaults to the
subscription's default source, if any, or to the customer's default source. */
    defaultSourceId?: string | undefined;
    /** (Expanded)
ID of the default payment source for the invoice. It must belong to the customer
associated with the invoice and be in a chargeable state. If not set, defaults to the
subscription's default source, if any, or to the customer's default source.
            
For more information, see the expand documentation. */
    defaultSource?: IPaymentSource | undefined;
    internalDefaultSource?: ExpandableFieldOfIPaymentSource | undefined;
    /** The tax rates applied to this invoice, if any. */
    defaultTaxRates?: TaxRate[] | undefined;
    /** Whether this object is deleted or not. */
    deleted?: boolean | undefined;
    /** An arbitrary string attached to the object. Often useful for displaying to users.
Referenced as 'memo' in the Dashboard. */
    description?: string | undefined;
    /** Describes the current discount applied to this invoice, if there is one. Not populated
if there are multiple discounts. */
    discount?: Discount | undefined;
    /** (IDs of the Discounts)
The discounts applied to the invoice. Line item discounts are applied before invoice
discounts. Use expand[]=discounts to expand each discount. */
    discountIds?: string[] | undefined;
    /** (Expanded)
The discounts applied to the invoice. Line item discounts are applied before invoice
discounts. Use expand[]=discounts to expand each discount.
            
For more information, see the expand documentation. */
    discounts?: Discount[] | undefined;
    internalDiscounts?: ExpandableFieldOfDiscount[] | undefined;
    /** The date on which payment for this invoice is due. This value will be null for
invoices where collection_method=charge_automatically. */
    dueDate?: Date | undefined;
    /** Ending customer balance after the invoice is finalized. Invoices are finalized
approximately an hour after successful webhook delivery or when payment collection is
attempted for the invoice. If the invoice has not been finalized yet, this will be null. */
    endingBalance?: number | undefined;
    /** Footer displayed on the invoice. */
    footer?: string | undefined;
    /** Details of the invoice that was cloned. See the revision documentation
for more details. */
    fromInvoice?: InvoiceFromInvoice | undefined;
    /** The URL for the hosted invoice page, which allows customers to view and pay an invoice.
If the invoice has not been finalized yet, this will be null. */
    hostedInvoiceUrl?: string | undefined;
    /** The link to download the PDF for the invoice. If the invoice has not been finalized yet,
this will be null. */
    invoicePdf?: string | undefined;
    /** The error encountered during the previous attempt to finalize the invoice. This field is
cleared when the invoice is successfully finalized. */
    lastFinalizationError?: StripeError | undefined;
    /** (ID of the Invoice)
The ID of the most recent non-draft revision of this invoice. */
    latestRevisionId?: string | undefined;
    /** (Expanded)
The ID of the most recent non-draft revision of this invoice.
            
For more information, see the expand documentation. */
    latestRevision?: Invoice | undefined;
    internalLatestRevision?: ExpandableFieldOfInvoice | undefined;
    /** The individual line items that make up the invoice. lines is sorted as follows:
(1) pending invoice items (including prorations) in reverse chronological order, (2)
subscription items in reverse chronological order, and (3) invoice items added after
invoice creation in chronological order. */
    lines?: StripeListOfInvoiceLineItem | undefined;
    /** Has the value true if the object exists in live mode or the value false if
the object exists in test mode. */
    livemode?: boolean;
    /** Set of key-value pairs that you can
attach to an object. This can be useful for storing additional information about the
object in a structured format. */
    metadata?: { [key: string]: string; } | undefined;
    /** The time at which payment will next be attempted. This value will be null for
invoices where collection_method=send_invoice. */
    nextPaymentAttempt?: Date | undefined;
    /** A unique, identifying string that appears on emails sent to the customer for this
invoice. This starts with the customer's unique invoice_prefix if it is specified. */
    number?: string | undefined;
    /** (ID of the Account)
The account (if any) for which the funds of the invoice payment are intended. If set,
the invoice will be presented with the branding and support information of the specified
account. See the Invoices
with Connect documentation for details. */
    onBehalfOfId?: string | undefined;
    /** (Expanded)
The account (if any) for which the funds of the invoice payment are intended. If set,
the invoice will be presented with the branding and support information of the specified
account. See the Invoices
with Connect documentation for details.
            
For more information, see the expand documentation. */
    onBehalfOf?: Account | undefined;
    internalOnBehalfOf?: ExpandableFieldOfAccount | undefined;
    /** Whether payment was successfully collected for this invoice. An invoice can be paid
(most commonly) with a charge or with credit from the customer's account balance. */
    paid?: boolean;
    /** Returns true if the invoice was manually marked paid, returns false if the invoice
hasn't been paid yet or was paid on Stripe. */
    paidOutOfBand?: boolean;
    /** (ID of the PaymentIntent)
The PaymentIntent associated with this invoice. The PaymentIntent is generated when the
invoice is finalized, and can then be used to pay the invoice. Note that voiding an
invoice will cancel the PaymentIntent. */
    paymentIntentId?: string | undefined;
    /** (Expanded)
The PaymentIntent associated with this invoice. The PaymentIntent is generated when the
invoice is finalized, and can then be used to pay the invoice. Note that voiding an
invoice will cancel the PaymentIntent.
            
For more information, see the expand documentation. */
    paymentIntent?: PaymentIntent | undefined;
    internalPaymentIntent?: ExpandableFieldOfPaymentIntent | undefined;
    paymentSettings?: InvoicePaymentSettings | undefined;
    /** End of the usage period during which invoice items were added to this invoice. */
    periodEnd?: Date;
    /** Start of the usage period during which invoice items were added to this invoice. */
    periodStart?: Date;
    /** Total amount of all post-payment credit notes issued for this invoice. */
    postPaymentCreditNotesAmount?: number;
    /** Total amount of all pre-payment credit notes issued for this invoice. */
    prePaymentCreditNotesAmount?: number;
    /** (ID of the Quote)
The quote this invoice was generated from. */
    quoteId?: string | undefined;
    /** (Expanded)
The quote this invoice was generated from.
            
For more information, see the expand documentation. */
    quote?: Quote | undefined;
    internalQuote?: ExpandableFieldOfQuote | undefined;
    /** This is the transaction number that appears on email receipts sent for this invoice. */
    receiptNumber?: string | undefined;
    /** Options for invoice PDF rendering. */
    renderingOptions?: InvoiceRenderingOptions | undefined;
    /** The details of the cost of shipping, including the ShippingRate applied on the invoice. */
    shippingCost?: InvoiceShippingCost | undefined;
    /** Shipping details for the invoice. The Invoice PDF will use the shipping_details
value if it is set, otherwise the PDF will render the shipping address from the
customer. */
    shippingDetails?: InvoiceShippingDetails | undefined;
    /** Starting customer balance before the invoice is finalized. If the invoice has not been
finalized yet, this will be the current customer balance. For revision invoices, this
also includes any customer balance that was applied to the original invoice. */
    startingBalance?: number;
    /** Extra information about an invoice for the customer's credit card statement. */
    statementDescriptor?: string | undefined;
    /** The status of the invoice, one of draft, open, paid,
uncollectible, or void. Learn
more.
One of: draft, open, paid, uncollectible, or void. */
    status?: string | undefined;
    statusTransitions?: InvoiceStatusTransitions | undefined;
    /** (ID of the Subscription)
The subscription that this invoice was prepared for, if any. */
    subscriptionId?: string | undefined;
    /** (Expanded)
The subscription that this invoice was prepared for, if any.
            
For more information, see the expand documentation. */
    subscription?: Subscription | undefined;
    internalSubscription?: ExpandableFieldOfSubscription | undefined;
    /** Only set for upcoming invoices that preview prorations. The time used to calculate
prorations. */
    subscriptionProrationDate?: Date;
    /** Total of all subscriptions, invoice items, and prorations on the invoice before any
invoice level discount or exclusive tax is applied. Item discounts are already
incorporated. */
    subtotal?: number;
    /** The integer amount in %s representing the subtotal of the invoice before any invoice
level discount or tax is applied. Item discounts are already incorporated. */
    subtotalExcludingTax?: number | undefined;
    /** The amount of tax on this invoice. This is the sum of all the tax amounts on this
invoice. */
    tax?: number | undefined;
    /** (ID of the TestHelpers.TestClock)
ID of the test clock this invoice belongs to. */
    testClockId?: string | undefined;
    /** (Expanded)
ID of the test clock this invoice belongs to.
            
For more information, see the expand documentation. */
    testClock?: TestClock | undefined;
    internalTestClock?: ExpandableFieldOfTestClock | undefined;
    thresholdReason?: InvoiceThresholdReason | undefined;
    /** Total after discounts and taxes. */
    total?: number;
    /** The aggregate amounts calculated per discount across all line items. */
    totalDiscountAmounts?: InvoiceDiscountAmount[] | undefined;
    /** The integer amount in %s representing the total amount of the invoice including all
discounts but excluding all tax. */
    totalExcludingTax?: number | undefined;
    /** The aggregate amounts calculated per tax rate for all line items. */
    totalTaxAmounts?: InvoiceTaxAmount[] | undefined;
    /** The account (if any) the payment will be attributed to for tax reporting, and where
funds from the payment will be transferred to for the invoice. */
    transferData?: InvoiceTransferData | undefined;
    /** Invoices are automatically paid or sent 1 hour after webhooks are delivered, or until
all webhook delivery attempts have been exhausted. This
field tracks the time when webhooks for this invoice were successfully delivered. If the
invoice had no webhooks to deliver, this will be set while the invoice is being created. */
    webhooksDeliveredAt?: Date | undefined;
}

export abstract class StripeEntityOfTaxId extends StripeEntity implements IStripeEntityOfTaxId {

    constructor(data?: IStripeEntityOfTaxId) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfTaxId {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfTaxId' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfTaxId extends IStripeEntity {
}

/** You can add one or multiple tax IDs to a customer. A customer's tax IDs are displayed on invoices and credit notes issued for the customer.            Related guide: Customer tax identification numbers. */
export class TaxId extends StripeEntityOfTaxId implements ITaxId {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** Two-letter ISO code representing the country of the tax ID. */
    country?: string | undefined;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** (ID of the Customer)
ID of the customer. */
    customerId?: string | undefined;
    /** (Expanded)
ID of the customer.
            
For more information, see the expand documentation. */
    customer?: Customer2 | undefined;
    internalCustomer?: ExpandableFieldOfCustomer | undefined;
    /** Whether this object is deleted or not. */
    deleted?: boolean | undefined;
    /** Has the value true if the object exists in live mode or the value false if
the object exists in test mode. */
    livemode?: boolean;
    /** Type of the tax ID, one of ae_trn, au_abn, au_arn, bg_uic,
br_cnpj, br_cpf, ca_bn, ca_gst_hst, ca_pst_bc,
ca_pst_mb, ca_pst_sk, ca_qst, ch_vat, cl_tin,
eg_tin, es_cif, eu_oss_vat, eu_vat, gb_vat,
ge_vat, hk_br, hu_tin, id_npwp, il_vat,
in_gst, is_vat, jp_cn, jp_rn, jp_trn, ke_pin,
kr_brn, li_uid, mx_rfc, my_frp, my_itn,
my_sst, no_vat, nz_gst, ph_tin, ru_inn,
ru_kpp, sa_vat, sg_gst, sg_uen, si_tin,
th_vat, tr_tin, tw_vat, ua_vat, us_ein, or
za_vat. Note that some legacy tax IDs have type unknown.
One of: ae_trn, au_abn, au_arn, bg_uic, br_cnpj,
br_cpf, ca_bn, ca_gst_hst, ca_pst_bc, ca_pst_mb,
ca_pst_sk, ca_qst, ch_vat, cl_tin, eg_tin,
es_cif, eu_oss_vat, eu_vat, gb_vat, ge_vat,
hk_br, hu_tin, id_npwp, il_vat, in_gst,
is_vat, jp_cn, jp_rn, jp_trn, ke_pin, kr_brn,
li_uid, mx_rfc, my_frp, my_itn, my_sst,
no_vat, nz_gst, ph_tin, ru_inn, ru_kpp,
sa_vat, sg_gst, sg_uen, si_tin, th_vat,
tr_tin, tw_vat, ua_vat, unknown, us_ein, or
za_vat. */
    type?: string | undefined;
    /** Value of the tax ID. */
    value?: string | undefined;
    /** Tax ID verification information. */
    verification?: TaxIdVerification | undefined;

    constructor(data?: ITaxId) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.object = _data["object"];
            this.country = _data["country"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.customerId = _data["customerId"];
            this.customer = _data["customer"] ? Customer2.fromJS(_data["customer"]) : <any>undefined;
            this.internalCustomer = _data["internalCustomer"] ? ExpandableFieldOfCustomer.fromJS(_data["internalCustomer"]) : <any>undefined;
            this.deleted = _data["deleted"];
            this.livemode = _data["livemode"];
            this.type = _data["type"];
            this.value = _data["value"];
            this.verification = _data["verification"] ? TaxIdVerification.fromJS(_data["verification"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): TaxId {
        data = typeof data === 'object' ? data : {};
        let result = new TaxId();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["object"] = this.object;
        data["country"] = this.country;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["customerId"] = this.customerId;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["internalCustomer"] = this.internalCustomer ? this.internalCustomer.toJSON() : <any>undefined;
        data["deleted"] = this.deleted;
        data["livemode"] = this.livemode;
        data["type"] = this.type;
        data["value"] = this.value;
        data["verification"] = this.verification ? this.verification.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** You can add one or multiple tax IDs to a customer. A customer's tax IDs are displayed on invoices and credit notes issued for the customer.            Related guide: Customer tax identification numbers. */
export interface ITaxId extends IStripeEntityOfTaxId {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** Two-letter ISO code representing the country of the tax ID. */
    country?: string | undefined;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** (ID of the Customer)
ID of the customer. */
    customerId?: string | undefined;
    /** (Expanded)
ID of the customer.
            
For more information, see the expand documentation. */
    customer?: Customer2 | undefined;
    internalCustomer?: ExpandableFieldOfCustomer | undefined;
    /** Whether this object is deleted or not. */
    deleted?: boolean | undefined;
    /** Has the value true if the object exists in live mode or the value false if
the object exists in test mode. */
    livemode?: boolean;
    /** Type of the tax ID, one of ae_trn, au_abn, au_arn, bg_uic,
br_cnpj, br_cpf, ca_bn, ca_gst_hst, ca_pst_bc,
ca_pst_mb, ca_pst_sk, ca_qst, ch_vat, cl_tin,
eg_tin, es_cif, eu_oss_vat, eu_vat, gb_vat,
ge_vat, hk_br, hu_tin, id_npwp, il_vat,
in_gst, is_vat, jp_cn, jp_rn, jp_trn, ke_pin,
kr_brn, li_uid, mx_rfc, my_frp, my_itn,
my_sst, no_vat, nz_gst, ph_tin, ru_inn,
ru_kpp, sa_vat, sg_gst, sg_uen, si_tin,
th_vat, tr_tin, tw_vat, ua_vat, us_ein, or
za_vat. Note that some legacy tax IDs have type unknown.
One of: ae_trn, au_abn, au_arn, bg_uic, br_cnpj,
br_cpf, ca_bn, ca_gst_hst, ca_pst_bc, ca_pst_mb,
ca_pst_sk, ca_qst, ch_vat, cl_tin, eg_tin,
es_cif, eu_oss_vat, eu_vat, gb_vat, ge_vat,
hk_br, hu_tin, id_npwp, il_vat, in_gst,
is_vat, jp_cn, jp_rn, jp_trn, ke_pin, kr_brn,
li_uid, mx_rfc, my_frp, my_itn, my_sst,
no_vat, nz_gst, ph_tin, ru_inn, ru_kpp,
sa_vat, sg_gst, sg_uen, si_tin, th_vat,
tr_tin, tw_vat, ua_vat, unknown, us_ein, or
za_vat. */
    type?: string | undefined;
    /** Value of the tax ID. */
    value?: string | undefined;
    /** Tax ID verification information. */
    verification?: TaxIdVerification | undefined;
}

export abstract class StripeEntityOfTaxIdVerification extends StripeEntity implements IStripeEntityOfTaxIdVerification {

    constructor(data?: IStripeEntityOfTaxIdVerification) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfTaxIdVerification {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfTaxIdVerification' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfTaxIdVerification extends IStripeEntity {
}

export class TaxIdVerification extends StripeEntityOfTaxIdVerification implements ITaxIdVerification {
    /** Verification status, one of pending, verified, unverified, or
unavailable.
One of: pending, unavailable, unverified, or verified. */
    status?: string | undefined;
    /** Verified address. */
    verifiedAddress?: string | undefined;
    /** Verified name. */
    verifiedName?: string | undefined;

    constructor(data?: ITaxIdVerification) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.status = _data["status"];
            this.verifiedAddress = _data["verifiedAddress"];
            this.verifiedName = _data["verifiedName"];
        }
    }

    static override fromJS(data: any): TaxIdVerification {
        data = typeof data === 'object' ? data : {};
        let result = new TaxIdVerification();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["verifiedAddress"] = this.verifiedAddress;
        data["verifiedName"] = this.verifiedName;
        super.toJSON(data);
        return data;
    }
}

export interface ITaxIdVerification extends IStripeEntityOfTaxIdVerification {
    /** Verification status, one of pending, verified, unverified, or
unavailable.
One of: pending, unavailable, unverified, or verified. */
    status?: string | undefined;
    /** Verified address. */
    verifiedAddress?: string | undefined;
    /** Verified name. */
    verifiedName?: string | undefined;
}

/** Represents a generic expandable field. */
export class ExpandableFieldOfTaxId implements IExpandableFieldOfTaxId {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: TaxId | undefined;

    constructor(data?: IExpandableFieldOfTaxId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.expandedObject = _data["expandedObject"] ? TaxId.fromJS(_data["expandedObject"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExpandableFieldOfTaxId {
        data = typeof data === 'object' ? data : {};
        let result = new ExpandableFieldOfTaxId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["expandedObject"] = this.expandedObject ? this.expandedObject.toJSON() : <any>undefined;
        return data;
    }
}

/** Represents a generic expandable field. */
export interface IExpandableFieldOfTaxId {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: TaxId | undefined;
}

export abstract class StripeEntityOfInvoiceAutomaticTax extends StripeEntity implements IStripeEntityOfInvoiceAutomaticTax {

    constructor(data?: IStripeEntityOfInvoiceAutomaticTax) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfInvoiceAutomaticTax {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfInvoiceAutomaticTax' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfInvoiceAutomaticTax extends IStripeEntity {
}

export class InvoiceAutomaticTax extends StripeEntityOfInvoiceAutomaticTax implements IInvoiceAutomaticTax {
    /** Whether Stripe automatically computes tax on this invoice. Note that incompatible
invoice items (invoice items with manually specified tax rates, negative amounts, or
tax_behavior=unspecified) cannot be added to automatic tax invoices. */
    enabled?: boolean;
    /** The status of the most recent automated tax calculation for this invoice.
One of: complete, failed, or requires_location_inputs. */
    status?: string | undefined;

    constructor(data?: IInvoiceAutomaticTax) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.enabled = _data["enabled"];
            this.status = _data["status"];
        }
    }

    static override fromJS(data: any): InvoiceAutomaticTax {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceAutomaticTax();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enabled"] = this.enabled;
        data["status"] = this.status;
        super.toJSON(data);
        return data;
    }
}

export interface IInvoiceAutomaticTax extends IStripeEntityOfInvoiceAutomaticTax {
    /** Whether Stripe automatically computes tax on this invoice. Note that incompatible
invoice items (invoice items with manually specified tax rates, negative amounts, or
tax_behavior=unspecified) cannot be added to automatic tax invoices. */
    enabled?: boolean;
    /** The status of the most recent automated tax calculation for this invoice.
One of: complete, failed, or requires_location_inputs. */
    status?: string | undefined;
}

export abstract class StripeEntityOfInvoiceCustomField extends StripeEntity implements IStripeEntityOfInvoiceCustomField {

    constructor(data?: IStripeEntityOfInvoiceCustomField) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfInvoiceCustomField {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfInvoiceCustomField' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfInvoiceCustomField extends IStripeEntity {
}

export class InvoiceCustomField extends StripeEntityOfInvoiceCustomField implements IInvoiceCustomField {
    /** The name of the custom field. */
    name?: string | undefined;
    /** The value of the custom field. */
    value?: string | undefined;

    constructor(data?: IInvoiceCustomField) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static override fromJS(data: any): InvoiceCustomField {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceCustomField();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        super.toJSON(data);
        return data;
    }
}

export interface IInvoiceCustomField extends IStripeEntityOfInvoiceCustomField {
    /** The name of the custom field. */
    name?: string | undefined;
    /** The value of the custom field. */
    value?: string | undefined;
}

export abstract class StripeEntityOfShipping extends StripeEntity implements IStripeEntityOfShipping {

    constructor(data?: IStripeEntityOfShipping) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfShipping {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfShipping' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfShipping extends IStripeEntity {
}

export class Shipping extends StripeEntityOfShipping implements IShipping {
    address?: Address | undefined;
    carrier?: string | undefined;
    name?: string | undefined;
    phone?: string | undefined;
    trackingNumber?: string | undefined;

    constructor(data?: IShipping) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.address = _data["address"] ? Address.fromJS(_data["address"]) : <any>undefined;
            this.carrier = _data["carrier"];
            this.name = _data["name"];
            this.phone = _data["phone"];
            this.trackingNumber = _data["trackingNumber"];
        }
    }

    static override fromJS(data: any): Shipping {
        data = typeof data === 'object' ? data : {};
        let result = new Shipping();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["carrier"] = this.carrier;
        data["name"] = this.name;
        data["phone"] = this.phone;
        data["trackingNumber"] = this.trackingNumber;
        super.toJSON(data);
        return data;
    }
}

export interface IShipping extends IStripeEntityOfShipping {
    address?: Address | undefined;
    carrier?: string | undefined;
    name?: string | undefined;
    phone?: string | undefined;
    trackingNumber?: string | undefined;
}

export abstract class StripeEntityOfInvoiceCustomerTaxId extends StripeEntity implements IStripeEntityOfInvoiceCustomerTaxId {

    constructor(data?: IStripeEntityOfInvoiceCustomerTaxId) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfInvoiceCustomerTaxId {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfInvoiceCustomerTaxId' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfInvoiceCustomerTaxId extends IStripeEntity {
}

export class InvoiceCustomerTaxId extends StripeEntityOfInvoiceCustomerTaxId implements IInvoiceCustomerTaxId {
    /** The type of the tax ID, one of eu_vat, br_cnpj, br_cpf,
eu_oss_vat, gb_vat, nz_gst, au_abn, au_arn,
in_gst, no_vat, za_vat, ch_vat, mx_rfc,
sg_uen, ru_inn, ru_kpp, ca_bn, hk_br, es_cif,
tw_vat, th_vat, jp_cn, jp_rn, jp_trn, li_uid,
my_itn, us_ein, kr_brn, ca_qst, ca_gst_hst,
ca_pst_bc, ca_pst_mb, ca_pst_sk, my_sst, sg_gst,
ae_trn, cl_tin, sa_vat, id_npwp, my_frp,
il_vat, ge_vat, ua_vat, is_vat, bg_uic,
hu_tin, si_tin, ke_pin, tr_tin, eg_tin,
ph_tin, or unknown.
One of: ae_trn, au_abn, au_arn, bg_uic, br_cnpj,
br_cpf, ca_bn, ca_gst_hst, ca_pst_bc, ca_pst_mb,
ca_pst_sk, ca_qst, ch_vat, cl_tin, eg_tin,
es_cif, eu_oss_vat, eu_vat, gb_vat, ge_vat,
hk_br, hu_tin, id_npwp, il_vat, in_gst,
is_vat, jp_cn, jp_rn, jp_trn, ke_pin, kr_brn,
li_uid, mx_rfc, my_frp, my_itn, my_sst,
no_vat, nz_gst, ph_tin, ru_inn, ru_kpp,
sa_vat, sg_gst, sg_uen, si_tin, th_vat,
tr_tin, tw_vat, ua_vat, unknown, us_ein, or
za_vat. */
    type?: string | undefined;
    /** The value of the tax ID. */
    value?: string | undefined;

    constructor(data?: IInvoiceCustomerTaxId) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.type = _data["type"];
            this.value = _data["value"];
        }
    }

    static override fromJS(data: any): InvoiceCustomerTaxId {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceCustomerTaxId();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["value"] = this.value;
        super.toJSON(data);
        return data;
    }
}

export interface IInvoiceCustomerTaxId extends IStripeEntityOfInvoiceCustomerTaxId {
    /** The type of the tax ID, one of eu_vat, br_cnpj, br_cpf,
eu_oss_vat, gb_vat, nz_gst, au_abn, au_arn,
in_gst, no_vat, za_vat, ch_vat, mx_rfc,
sg_uen, ru_inn, ru_kpp, ca_bn, hk_br, es_cif,
tw_vat, th_vat, jp_cn, jp_rn, jp_trn, li_uid,
my_itn, us_ein, kr_brn, ca_qst, ca_gst_hst,
ca_pst_bc, ca_pst_mb, ca_pst_sk, my_sst, sg_gst,
ae_trn, cl_tin, sa_vat, id_npwp, my_frp,
il_vat, ge_vat, ua_vat, is_vat, bg_uic,
hu_tin, si_tin, ke_pin, tr_tin, eg_tin,
ph_tin, or unknown.
One of: ae_trn, au_abn, au_arn, bg_uic, br_cnpj,
br_cpf, ca_bn, ca_gst_hst, ca_pst_bc, ca_pst_mb,
ca_pst_sk, ca_qst, ch_vat, cl_tin, eg_tin,
es_cif, eu_oss_vat, eu_vat, gb_vat, ge_vat,
hk_br, hu_tin, id_npwp, il_vat, in_gst,
is_vat, jp_cn, jp_rn, jp_trn, ke_pin, kr_brn,
li_uid, mx_rfc, my_frp, my_itn, my_sst,
no_vat, nz_gst, ph_tin, ru_inn, ru_kpp,
sa_vat, sg_gst, sg_uen, si_tin, th_vat,
tr_tin, tw_vat, ua_vat, unknown, us_ein, or
za_vat. */
    type?: string | undefined;
    /** The value of the tax ID. */
    value?: string | undefined;
}

/** Represents a generic expandable field. */
export class ExpandableFieldOfPaymentMethod implements IExpandableFieldOfPaymentMethod {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: PaymentMethod | undefined;

    constructor(data?: IExpandableFieldOfPaymentMethod) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.expandedObject = _data["expandedObject"] ? PaymentMethod.fromJS(_data["expandedObject"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExpandableFieldOfPaymentMethod {
        data = typeof data === 'object' ? data : {};
        let result = new ExpandableFieldOfPaymentMethod();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["expandedObject"] = this.expandedObject ? this.expandedObject.toJSON() : <any>undefined;
        return data;
    }
}

/** Represents a generic expandable field. */
export interface IExpandableFieldOfPaymentMethod {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: PaymentMethod | undefined;
}

export abstract class StripeEntityOfTaxRate extends StripeEntity implements IStripeEntityOfTaxRate {

    constructor(data?: IStripeEntityOfTaxRate) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfTaxRate {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfTaxRate' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfTaxRate extends IStripeEntity {
}

/** Tax rates can be applied to invoices, subscriptions and Checkout Sessions to collect tax.            Related guide: Tax rates. */
export class TaxRate extends StripeEntityOfTaxRate implements ITaxRate {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** Defaults to true. When set to false, this tax rate cannot be used with new
applications or Checkout Sessions, but will still work for subscriptions and invoices
that already have it set. */
    active?: boolean;
    /** Two-letter country code (ISO
3166-1 alpha-2). */
    country?: string | undefined;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** An arbitrary string attached to the tax rate for your internal use only. It will not be
visible to your customers. */
    description?: string | undefined;
    /** The display name of the tax rates as it will appear to your customer on their receipt
email, PDF, and the hosted invoice page. */
    displayName?: string | undefined;
    /** Actual/effective tax rate percentage out of 100. For tax calculations with
automatic_tax[enabled]=true, this percentage does not include the statutory tax rate of
non-taxable jurisdictions. */
    effectivePercentage?: number | undefined;
    /** This specifies if the tax rate is inclusive or exclusive. */
    inclusive?: boolean;
    /** The jurisdiction for the tax rate. You can use this label field for tax reporting
purposes. It also appears on your customer’s invoice. */
    jurisdiction?: string | undefined;
    /** Has the value true if the object exists in live mode or the value false if
the object exists in test mode. */
    livemode?: boolean;
    /** Set of key-value pairs that you can
attach to an object. This can be useful for storing additional information about the
object in a structured format. */
    metadata?: { [key: string]: string; } | undefined;
    /** Tax rate percentage out of 100. For tax calculations with automatic_tax[enabled]=true,
this percentage includes the statutory tax rate of non-taxable jurisdictions. */
    percentage?: number;
    /** ISO 3166-2 subdivision code,
without country prefix. For example, "NY" for New York, United States. */
    state?: string | undefined;
    /** The high-level tax type, such as vat or sales_tax.
One of: amusement_tax, communications_tax, gst, hst,
igst, jct, lease_tax, pst, qst, rst,
sales_tax, or vat. */
    taxType?: string | undefined;

    constructor(data?: ITaxRate) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.object = _data["object"];
            this.active = _data["active"];
            this.country = _data["country"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.description = _data["description"];
            this.displayName = _data["displayName"];
            this.effectivePercentage = _data["effectivePercentage"];
            this.inclusive = _data["inclusive"];
            this.jurisdiction = _data["jurisdiction"];
            this.livemode = _data["livemode"];
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
            this.percentage = _data["percentage"];
            this.state = _data["state"];
            this.taxType = _data["taxType"];
        }
    }

    static override fromJS(data: any): TaxRate {
        data = typeof data === 'object' ? data : {};
        let result = new TaxRate();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["object"] = this.object;
        data["active"] = this.active;
        data["country"] = this.country;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["description"] = this.description;
        data["displayName"] = this.displayName;
        data["effectivePercentage"] = this.effectivePercentage;
        data["inclusive"] = this.inclusive;
        data["jurisdiction"] = this.jurisdiction;
        data["livemode"] = this.livemode;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        data["percentage"] = this.percentage;
        data["state"] = this.state;
        data["taxType"] = this.taxType;
        super.toJSON(data);
        return data;
    }
}

/** Tax rates can be applied to invoices, subscriptions and Checkout Sessions to collect tax.            Related guide: Tax rates. */
export interface ITaxRate extends IStripeEntityOfTaxRate {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** Defaults to true. When set to false, this tax rate cannot be used with new
applications or Checkout Sessions, but will still work for subscriptions and invoices
that already have it set. */
    active?: boolean;
    /** Two-letter country code (ISO
3166-1 alpha-2). */
    country?: string | undefined;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** An arbitrary string attached to the tax rate for your internal use only. It will not be
visible to your customers. */
    description?: string | undefined;
    /** The display name of the tax rates as it will appear to your customer on their receipt
email, PDF, and the hosted invoice page. */
    displayName?: string | undefined;
    /** Actual/effective tax rate percentage out of 100. For tax calculations with
automatic_tax[enabled]=true, this percentage does not include the statutory tax rate of
non-taxable jurisdictions. */
    effectivePercentage?: number | undefined;
    /** This specifies if the tax rate is inclusive or exclusive. */
    inclusive?: boolean;
    /** The jurisdiction for the tax rate. You can use this label field for tax reporting
purposes. It also appears on your customer’s invoice. */
    jurisdiction?: string | undefined;
    /** Has the value true if the object exists in live mode or the value false if
the object exists in test mode. */
    livemode?: boolean;
    /** Set of key-value pairs that you can
attach to an object. This can be useful for storing additional information about the
object in a structured format. */
    metadata?: { [key: string]: string; } | undefined;
    /** Tax rate percentage out of 100. For tax calculations with automatic_tax[enabled]=true,
this percentage includes the statutory tax rate of non-taxable jurisdictions. */
    percentage?: number;
    /** ISO 3166-2 subdivision code,
without country prefix. For example, "NY" for New York, United States. */
    state?: string | undefined;
    /** The high-level tax type, such as vat or sales_tax.
One of: amusement_tax, communications_tax, gst, hst,
igst, jct, lease_tax, pst, qst, rst,
sales_tax, or vat. */
    taxType?: string | undefined;
}

/** Represents a generic expandable field. */
export class ExpandableFieldOfDiscount implements IExpandableFieldOfDiscount {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: Discount | undefined;

    constructor(data?: IExpandableFieldOfDiscount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.expandedObject = _data["expandedObject"] ? Discount.fromJS(_data["expandedObject"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExpandableFieldOfDiscount {
        data = typeof data === 'object' ? data : {};
        let result = new ExpandableFieldOfDiscount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["expandedObject"] = this.expandedObject ? this.expandedObject.toJSON() : <any>undefined;
        return data;
    }
}

/** Represents a generic expandable field. */
export interface IExpandableFieldOfDiscount {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: Discount | undefined;
}

export abstract class StripeEntityOfInvoiceFromInvoice extends StripeEntity implements IStripeEntityOfInvoiceFromInvoice {

    constructor(data?: IStripeEntityOfInvoiceFromInvoice) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfInvoiceFromInvoice {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfInvoiceFromInvoice' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfInvoiceFromInvoice extends IStripeEntity {
}

export class InvoiceFromInvoice extends StripeEntityOfInvoiceFromInvoice implements IInvoiceFromInvoice {
    /** The relation between this invoice and the cloned invoice. */
    action?: string | undefined;
    /** (ID of the Invoice)
The invoice that was cloned. */
    invoiceId?: string | undefined;
    /** (Expanded)
The invoice that was cloned.
            
For more information, see the expand documentation. */
    invoice?: Invoice | undefined;
    internalInvoice?: ExpandableFieldOfInvoice | undefined;

    constructor(data?: IInvoiceFromInvoice) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.action = _data["action"];
            this.invoiceId = _data["invoiceId"];
            this.invoice = _data["invoice"] ? Invoice.fromJS(_data["invoice"]) : <any>undefined;
            this.internalInvoice = _data["internalInvoice"] ? ExpandableFieldOfInvoice.fromJS(_data["internalInvoice"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): InvoiceFromInvoice {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceFromInvoice();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["action"] = this.action;
        data["invoiceId"] = this.invoiceId;
        data["invoice"] = this.invoice ? this.invoice.toJSON() : <any>undefined;
        data["internalInvoice"] = this.internalInvoice ? this.internalInvoice.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IInvoiceFromInvoice extends IStripeEntityOfInvoiceFromInvoice {
    /** The relation between this invoice and the cloned invoice. */
    action?: string | undefined;
    /** (ID of the Invoice)
The invoice that was cloned. */
    invoiceId?: string | undefined;
    /** (Expanded)
The invoice that was cloned.
            
For more information, see the expand documentation. */
    invoice?: Invoice | undefined;
    internalInvoice?: ExpandableFieldOfInvoice | undefined;
}

/** Represents a generic expandable field. */
export class ExpandableFieldOfInvoice implements IExpandableFieldOfInvoice {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: Invoice | undefined;

    constructor(data?: IExpandableFieldOfInvoice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.expandedObject = _data["expandedObject"] ? Invoice.fromJS(_data["expandedObject"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExpandableFieldOfInvoice {
        data = typeof data === 'object' ? data : {};
        let result = new ExpandableFieldOfInvoice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["expandedObject"] = this.expandedObject ? this.expandedObject.toJSON() : <any>undefined;
        return data;
    }
}

/** Represents a generic expandable field. */
export interface IExpandableFieldOfInvoice {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: Invoice | undefined;
}

export abstract class StripeEntityOfStripeError extends StripeEntity implements IStripeEntityOfStripeError {

    constructor(data?: IStripeEntityOfStripeError) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfStripeError {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfStripeError' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfStripeError extends IStripeEntity {
}

export class StripeError extends StripeEntityOfStripeError implements IStripeError {
    /** For card errors, the ID of the failed charge. */
    charge?: string | undefined;
    /** For some errors that could be handled programmatically, a short string indicating the
error code reported. */
    code?: string | undefined;
    /** For card errors resulting from a card issuer decline, a short string indicating the
card issuer's reason for the
decline. */
    declineCode?: string | undefined;
    /** A URL to more information about the error
code reported. */
    docUrl?: string | undefined;
    /** A human-readable message providing more details about the error. For card errors, these
messages can be shown to your users. */
    message?: string | undefined;
    /** If the error is parameter-specific, the parameter related to the error. For example,
you can use this to display a message near the correct form field. */
    param?: string | undefined;
    /** The PaymentIntent object for errors returned on a request
involving a PaymentIntent. */
    paymentIntent?: PaymentIntent | undefined;
    /** The PaymentMethod object for errors returned on a request
involving a PaymentMethod. */
    paymentMethod?: PaymentMethod | undefined;
    /** If the error is specific to the type of payment method, the payment method type that had
a problem. This field is only populated for invoice-related errors. */
    paymentMethodType?: string | undefined;
    /** A URL to the request log entry in your dashboard. */
    requestLogUrl?: string | undefined;
    /** The SetupIntent object for errors returned on a request
involving a SetupIntent. */
    setupIntent?: SetupIntent | undefined;
    /** The source object for errors returned on a request involving a source. */
    source?: IPaymentSource | undefined;
    /** The type of error returned. One of api_error, card_error,
idempotency_error, or invalid_request_error. */
    type?: string | undefined;
    error?: string | undefined;
    errorDescription?: string | undefined;

    constructor(data?: IStripeError) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.charge = _data["charge"];
            this.code = _data["code"];
            this.declineCode = _data["declineCode"];
            this.docUrl = _data["docUrl"];
            this.message = _data["message"];
            this.param = _data["param"];
            this.paymentIntent = _data["paymentIntent"] ? PaymentIntent.fromJS(_data["paymentIntent"]) : <any>undefined;
            this.paymentMethod = _data["paymentMethod"] ? PaymentMethod.fromJS(_data["paymentMethod"]) : <any>undefined;
            this.paymentMethodType = _data["paymentMethodType"];
            this.requestLogUrl = _data["requestLogUrl"];
            this.setupIntent = _data["setupIntent"] ? SetupIntent.fromJS(_data["setupIntent"]) : <any>undefined;
            this.source = _data["source"] ? IPaymentSource.fromJS(_data["source"]) : <any>undefined;
            this.type = _data["type"];
            this.error = _data["error"];
            this.errorDescription = _data["errorDescription"];
        }
    }

    static override fromJS(data: any): StripeError {
        data = typeof data === 'object' ? data : {};
        let result = new StripeError();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["charge"] = this.charge;
        data["code"] = this.code;
        data["declineCode"] = this.declineCode;
        data["docUrl"] = this.docUrl;
        data["message"] = this.message;
        data["param"] = this.param;
        data["paymentIntent"] = this.paymentIntent ? this.paymentIntent.toJSON() : <any>undefined;
        data["paymentMethod"] = this.paymentMethod ? this.paymentMethod.toJSON() : <any>undefined;
        data["paymentMethodType"] = this.paymentMethodType;
        data["requestLogUrl"] = this.requestLogUrl;
        data["setupIntent"] = this.setupIntent ? this.setupIntent.toJSON() : <any>undefined;
        data["source"] = this.source ? this.source.toJSON() : <any>undefined;
        data["type"] = this.type;
        data["error"] = this.error;
        data["errorDescription"] = this.errorDescription;
        super.toJSON(data);
        return data;
    }
}

export interface IStripeError extends IStripeEntityOfStripeError {
    /** For card errors, the ID of the failed charge. */
    charge?: string | undefined;
    /** For some errors that could be handled programmatically, a short string indicating the
error code reported. */
    code?: string | undefined;
    /** For card errors resulting from a card issuer decline, a short string indicating the
card issuer's reason for the
decline. */
    declineCode?: string | undefined;
    /** A URL to more information about the error
code reported. */
    docUrl?: string | undefined;
    /** A human-readable message providing more details about the error. For card errors, these
messages can be shown to your users. */
    message?: string | undefined;
    /** If the error is parameter-specific, the parameter related to the error. For example,
you can use this to display a message near the correct form field. */
    param?: string | undefined;
    /** The PaymentIntent object for errors returned on a request
involving a PaymentIntent. */
    paymentIntent?: PaymentIntent | undefined;
    /** The PaymentMethod object for errors returned on a request
involving a PaymentMethod. */
    paymentMethod?: PaymentMethod | undefined;
    /** If the error is specific to the type of payment method, the payment method type that had
a problem. This field is only populated for invoice-related errors. */
    paymentMethodType?: string | undefined;
    /** A URL to the request log entry in your dashboard. */
    requestLogUrl?: string | undefined;
    /** The SetupIntent object for errors returned on a request
involving a SetupIntent. */
    setupIntent?: SetupIntent | undefined;
    /** The source object for errors returned on a request involving a source. */
    source?: IPaymentSource | undefined;
    /** The type of error returned. One of api_error, card_error,
idempotency_error, or invalid_request_error. */
    type?: string | undefined;
    error?: string | undefined;
    errorDescription?: string | undefined;
}

export abstract class StripeEntityOfSetupIntent extends StripeEntity implements IStripeEntityOfSetupIntent {

    constructor(data?: IStripeEntityOfSetupIntent) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSetupIntent {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSetupIntent' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSetupIntent extends IStripeEntity {
}

/** A SetupIntent guides you through the process of setting up and saving a customer's payment credentials for future payments. For example, you could use a SetupIntent to set up and save your customer's card without immediately collecting a payment. Later, you can use PaymentIntents to drive the payment flow.            Create a SetupIntent as soon as you're ready to collect your customer's payment credentials. Do not maintain long-lived, unconfirmed SetupIntents as they may no longer be valid. The SetupIntent then transitions through multiple statuses as it guides you through the setup process.            Successful SetupIntents result in payment credentials that are optimized for future payments. For example, cardholders in certain regions may need to be run through Strong Customer Authentication at the time of payment method collection in order to streamline later off-session payments. If the SetupIntent is used with a Customer, upon success, it will automatically attach the resulting payment method to that Customer. We recommend using SetupIntents or setup_future_usage on PaymentIntents to save payment methods in order to prevent saving invalid or unoptimized payment methods.            By using SetupIntents, you ensure that your customers experience the minimum set of required friction, even as regulations change over time.            Related guide: Setup Intents API. */
export class SetupIntent extends StripeEntityOfSetupIntent implements ISetupIntent {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** (ID of the Application)
ID of the Connect application that created the SetupIntent. */
    applicationId?: string | undefined;
    /** (Expanded)
ID of the Connect application that created the SetupIntent.
            
For more information, see the expand documentation. */
    application?: Application | undefined;
    internalApplication?: ExpandableFieldOfApplication | undefined;
    /** If present, the SetupIntent's payment method will be attached to the in-context Stripe
Account.
            
It can only be used for this Stripe Account’s own money movement flows like
InboundTransfer and OutboundTransfers. It cannot be set to true when setting up a
PaymentMethod for a Customer, and defaults to false when attaching a PaymentMethod to a
Customer. */
    attachToSelf?: boolean;
    /** Settings for automatic payment methods compatible with this Setup Intent. */
    automaticPaymentMethods?: SetupIntentAutomaticPaymentMethods | undefined;
    /** Reason for cancellation of this SetupIntent, one of abandoned,
requested_by_customer, or duplicate.
One of: abandoned, duplicate, or requested_by_customer. */
    cancellationReason?: string | undefined;
    /** The client secret of this SetupIntent. Used for client-side retrieval using a
publishable key.
            
The client secret can be used to complete payment setup from your frontend. It should
not be stored, logged, or exposed to anyone other than the customer. Make sure that you
have TLS enabled on any page that includes the client secret. */
    clientSecret?: string | undefined;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** (ID of the Customer)
ID of the Customer this SetupIntent belongs to, if one exists.
            
If present, the SetupIntent's payment method will be attached to the Customer on
successful setup. Payment methods attached to other Customers cannot be used with this
SetupIntent. */
    customerId?: string | undefined;
    /** (Expanded)
ID of the Customer this SetupIntent belongs to, if one exists.
            
If present, the SetupIntent's payment method will be attached to the Customer on
successful setup. Payment methods attached to other Customers cannot be used with this
SetupIntent.
            
For more information, see the expand documentation. */
    customer?: Customer2 | undefined;
    internalCustomer?: ExpandableFieldOfCustomer | undefined;
    /** An arbitrary string attached to the object. Often useful for displaying to users. */
    description?: string | undefined;
    /** Indicates the directions of money movement for which this payment method is intended to
be used.
            
Include inbound if you intend to use the payment method as the origin to pull
funds from. Include outbound if you intend to use the payment method as the
destination to send funds to. You can include both if you intend to use the payment
method for both purposes. */
    flowDirections?: string[] | undefined;
    /** The error encountered in the previous SetupIntent confirmation. */
    lastSetupError?: StripeError | undefined;
    /** (ID of the SetupAttempt)
The most recent SetupAttempt for this SetupIntent. */
    latestAttemptId?: string | undefined;
    /** (Expanded)
The most recent SetupAttempt for this SetupIntent.
            
For more information, see the expand documentation. */
    latestAttempt?: SetupAttempt | undefined;
    internalLatestAttempt?: ExpandableFieldOfSetupAttempt | undefined;
    /** Has the value true if the object exists in live mode or the value false if
the object exists in test mode. */
    livemode?: boolean;
    /** (ID of the Mandate)
ID of the multi use Mandate generated by the SetupIntent. */
    mandateId?: string | undefined;
    /** (Expanded)
ID of the multi use Mandate generated by the SetupIntent.
            
For more information, see the expand documentation. */
    mandate?: Mandate | undefined;
    internalMandate?: ExpandableFieldOfMandate | undefined;
    /** Set of key-value pairs that you can
attach to an object. This can be useful for storing additional information about the
object in a structured format. */
    metadata?: { [key: string]: string; } | undefined;
    /** If present, this property tells you what actions you need to take in order for your
customer to continue payment setup. */
    nextAction?: SetupIntentNextAction | undefined;
    /** (ID of the Account)
The account (if any) for which the setup is intended. */
    onBehalfOfId?: string | undefined;
    /** (Expanded)
The account (if any) for which the setup is intended.
            
For more information, see the expand documentation. */
    onBehalfOf?: Account | undefined;
    internalOnBehalfOf?: ExpandableFieldOfAccount | undefined;
    /** (ID of the PaymentMethod)
ID of the payment method used with this SetupIntent. */
    paymentMethodId?: string | undefined;
    /** (Expanded)
ID of the payment method used with this SetupIntent.
            
For more information, see the expand documentation. */
    paymentMethod?: PaymentMethod | undefined;
    internalPaymentMethod?: ExpandableFieldOfPaymentMethod | undefined;
    /** Payment-method-specific configuration for this SetupIntent. */
    paymentMethodOptions?: SetupIntentPaymentMethodOptions | undefined;
    /** The list of payment method types (e.g. card) that this SetupIntent is allowed to set up. */
    paymentMethodTypes?: string[] | undefined;
    /** (ID of the Mandate)
ID of the single_use Mandate generated by the SetupIntent. */
    singleUseMandateId?: string | undefined;
    /** (Expanded)
ID of the single_use Mandate generated by the SetupIntent.
            
For more information, see the expand documentation. */
    singleUseMandate?: Mandate | undefined;
    internalSingleUseMandate?: ExpandableFieldOfMandate | undefined;
    /** Status of this
SetupIntent, one of requires_payment_method, requires_confirmation,
requires_action, processing, canceled, or succeeded.
One of: canceled, processing, requires_action,
requires_confirmation, requires_payment_method, or succeeded. */
    status?: string | undefined;
    /** Indicates how the payment method is intended to be used in the future.
            
Use on_session if you intend to only reuse the payment method when the customer
is in your checkout flow. Use off_session if your customer may or may not be in
your checkout flow. If not provided, this value defaults to off_session. */
    usage?: string | undefined;

    constructor(data?: ISetupIntent) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.object = _data["object"];
            this.applicationId = _data["applicationId"];
            this.application = _data["application"] ? Application.fromJS(_data["application"]) : <any>undefined;
            this.internalApplication = _data["internalApplication"] ? ExpandableFieldOfApplication.fromJS(_data["internalApplication"]) : <any>undefined;
            this.attachToSelf = _data["attachToSelf"];
            this.automaticPaymentMethods = _data["automaticPaymentMethods"] ? SetupIntentAutomaticPaymentMethods.fromJS(_data["automaticPaymentMethods"]) : <any>undefined;
            this.cancellationReason = _data["cancellationReason"];
            this.clientSecret = _data["clientSecret"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.customerId = _data["customerId"];
            this.customer = _data["customer"] ? Customer2.fromJS(_data["customer"]) : <any>undefined;
            this.internalCustomer = _data["internalCustomer"] ? ExpandableFieldOfCustomer.fromJS(_data["internalCustomer"]) : <any>undefined;
            this.description = _data["description"];
            if (Array.isArray(_data["flowDirections"])) {
                this.flowDirections = [] as any;
                for (let item of _data["flowDirections"])
                    this.flowDirections!.push(item);
            }
            this.lastSetupError = _data["lastSetupError"] ? StripeError.fromJS(_data["lastSetupError"]) : <any>undefined;
            this.latestAttemptId = _data["latestAttemptId"];
            this.latestAttempt = _data["latestAttempt"] ? SetupAttempt.fromJS(_data["latestAttempt"]) : <any>undefined;
            this.internalLatestAttempt = _data["internalLatestAttempt"] ? ExpandableFieldOfSetupAttempt.fromJS(_data["internalLatestAttempt"]) : <any>undefined;
            this.livemode = _data["livemode"];
            this.mandateId = _data["mandateId"];
            this.mandate = _data["mandate"] ? Mandate.fromJS(_data["mandate"]) : <any>undefined;
            this.internalMandate = _data["internalMandate"] ? ExpandableFieldOfMandate.fromJS(_data["internalMandate"]) : <any>undefined;
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
            this.nextAction = _data["nextAction"] ? SetupIntentNextAction.fromJS(_data["nextAction"]) : <any>undefined;
            this.onBehalfOfId = _data["onBehalfOfId"];
            this.onBehalfOf = _data["onBehalfOf"] ? Account.fromJS(_data["onBehalfOf"]) : <any>undefined;
            this.internalOnBehalfOf = _data["internalOnBehalfOf"] ? ExpandableFieldOfAccount.fromJS(_data["internalOnBehalfOf"]) : <any>undefined;
            this.paymentMethodId = _data["paymentMethodId"];
            this.paymentMethod = _data["paymentMethod"] ? PaymentMethod.fromJS(_data["paymentMethod"]) : <any>undefined;
            this.internalPaymentMethod = _data["internalPaymentMethod"] ? ExpandableFieldOfPaymentMethod.fromJS(_data["internalPaymentMethod"]) : <any>undefined;
            this.paymentMethodOptions = _data["paymentMethodOptions"] ? SetupIntentPaymentMethodOptions.fromJS(_data["paymentMethodOptions"]) : <any>undefined;
            if (Array.isArray(_data["paymentMethodTypes"])) {
                this.paymentMethodTypes = [] as any;
                for (let item of _data["paymentMethodTypes"])
                    this.paymentMethodTypes!.push(item);
            }
            this.singleUseMandateId = _data["singleUseMandateId"];
            this.singleUseMandate = _data["singleUseMandate"] ? Mandate.fromJS(_data["singleUseMandate"]) : <any>undefined;
            this.internalSingleUseMandate = _data["internalSingleUseMandate"] ? ExpandableFieldOfMandate.fromJS(_data["internalSingleUseMandate"]) : <any>undefined;
            this.status = _data["status"];
            this.usage = _data["usage"];
        }
    }

    static override fromJS(data: any): SetupIntent {
        data = typeof data === 'object' ? data : {};
        let result = new SetupIntent();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["object"] = this.object;
        data["applicationId"] = this.applicationId;
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["internalApplication"] = this.internalApplication ? this.internalApplication.toJSON() : <any>undefined;
        data["attachToSelf"] = this.attachToSelf;
        data["automaticPaymentMethods"] = this.automaticPaymentMethods ? this.automaticPaymentMethods.toJSON() : <any>undefined;
        data["cancellationReason"] = this.cancellationReason;
        data["clientSecret"] = this.clientSecret;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["customerId"] = this.customerId;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["internalCustomer"] = this.internalCustomer ? this.internalCustomer.toJSON() : <any>undefined;
        data["description"] = this.description;
        if (Array.isArray(this.flowDirections)) {
            data["flowDirections"] = [];
            for (let item of this.flowDirections)
                data["flowDirections"].push(item);
        }
        data["lastSetupError"] = this.lastSetupError ? this.lastSetupError.toJSON() : <any>undefined;
        data["latestAttemptId"] = this.latestAttemptId;
        data["latestAttempt"] = this.latestAttempt ? this.latestAttempt.toJSON() : <any>undefined;
        data["internalLatestAttempt"] = this.internalLatestAttempt ? this.internalLatestAttempt.toJSON() : <any>undefined;
        data["livemode"] = this.livemode;
        data["mandateId"] = this.mandateId;
        data["mandate"] = this.mandate ? this.mandate.toJSON() : <any>undefined;
        data["internalMandate"] = this.internalMandate ? this.internalMandate.toJSON() : <any>undefined;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        data["nextAction"] = this.nextAction ? this.nextAction.toJSON() : <any>undefined;
        data["onBehalfOfId"] = this.onBehalfOfId;
        data["onBehalfOf"] = this.onBehalfOf ? this.onBehalfOf.toJSON() : <any>undefined;
        data["internalOnBehalfOf"] = this.internalOnBehalfOf ? this.internalOnBehalfOf.toJSON() : <any>undefined;
        data["paymentMethodId"] = this.paymentMethodId;
        data["paymentMethod"] = this.paymentMethod ? this.paymentMethod.toJSON() : <any>undefined;
        data["internalPaymentMethod"] = this.internalPaymentMethod ? this.internalPaymentMethod.toJSON() : <any>undefined;
        data["paymentMethodOptions"] = this.paymentMethodOptions ? this.paymentMethodOptions.toJSON() : <any>undefined;
        if (Array.isArray(this.paymentMethodTypes)) {
            data["paymentMethodTypes"] = [];
            for (let item of this.paymentMethodTypes)
                data["paymentMethodTypes"].push(item);
        }
        data["singleUseMandateId"] = this.singleUseMandateId;
        data["singleUseMandate"] = this.singleUseMandate ? this.singleUseMandate.toJSON() : <any>undefined;
        data["internalSingleUseMandate"] = this.internalSingleUseMandate ? this.internalSingleUseMandate.toJSON() : <any>undefined;
        data["status"] = this.status;
        data["usage"] = this.usage;
        super.toJSON(data);
        return data;
    }
}

/** A SetupIntent guides you through the process of setting up and saving a customer's payment credentials for future payments. For example, you could use a SetupIntent to set up and save your customer's card without immediately collecting a payment. Later, you can use PaymentIntents to drive the payment flow.            Create a SetupIntent as soon as you're ready to collect your customer's payment credentials. Do not maintain long-lived, unconfirmed SetupIntents as they may no longer be valid. The SetupIntent then transitions through multiple statuses as it guides you through the setup process.            Successful SetupIntents result in payment credentials that are optimized for future payments. For example, cardholders in certain regions may need to be run through Strong Customer Authentication at the time of payment method collection in order to streamline later off-session payments. If the SetupIntent is used with a Customer, upon success, it will automatically attach the resulting payment method to that Customer. We recommend using SetupIntents or setup_future_usage on PaymentIntents to save payment methods in order to prevent saving invalid or unoptimized payment methods.            By using SetupIntents, you ensure that your customers experience the minimum set of required friction, even as regulations change over time.            Related guide: Setup Intents API. */
export interface ISetupIntent extends IStripeEntityOfSetupIntent {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** (ID of the Application)
ID of the Connect application that created the SetupIntent. */
    applicationId?: string | undefined;
    /** (Expanded)
ID of the Connect application that created the SetupIntent.
            
For more information, see the expand documentation. */
    application?: Application | undefined;
    internalApplication?: ExpandableFieldOfApplication | undefined;
    /** If present, the SetupIntent's payment method will be attached to the in-context Stripe
Account.
            
It can only be used for this Stripe Account’s own money movement flows like
InboundTransfer and OutboundTransfers. It cannot be set to true when setting up a
PaymentMethod for a Customer, and defaults to false when attaching a PaymentMethod to a
Customer. */
    attachToSelf?: boolean;
    /** Settings for automatic payment methods compatible with this Setup Intent. */
    automaticPaymentMethods?: SetupIntentAutomaticPaymentMethods | undefined;
    /** Reason for cancellation of this SetupIntent, one of abandoned,
requested_by_customer, or duplicate.
One of: abandoned, duplicate, or requested_by_customer. */
    cancellationReason?: string | undefined;
    /** The client secret of this SetupIntent. Used for client-side retrieval using a
publishable key.
            
The client secret can be used to complete payment setup from your frontend. It should
not be stored, logged, or exposed to anyone other than the customer. Make sure that you
have TLS enabled on any page that includes the client secret. */
    clientSecret?: string | undefined;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** (ID of the Customer)
ID of the Customer this SetupIntent belongs to, if one exists.
            
If present, the SetupIntent's payment method will be attached to the Customer on
successful setup. Payment methods attached to other Customers cannot be used with this
SetupIntent. */
    customerId?: string | undefined;
    /** (Expanded)
ID of the Customer this SetupIntent belongs to, if one exists.
            
If present, the SetupIntent's payment method will be attached to the Customer on
successful setup. Payment methods attached to other Customers cannot be used with this
SetupIntent.
            
For more information, see the expand documentation. */
    customer?: Customer2 | undefined;
    internalCustomer?: ExpandableFieldOfCustomer | undefined;
    /** An arbitrary string attached to the object. Often useful for displaying to users. */
    description?: string | undefined;
    /** Indicates the directions of money movement for which this payment method is intended to
be used.
            
Include inbound if you intend to use the payment method as the origin to pull
funds from. Include outbound if you intend to use the payment method as the
destination to send funds to. You can include both if you intend to use the payment
method for both purposes. */
    flowDirections?: string[] | undefined;
    /** The error encountered in the previous SetupIntent confirmation. */
    lastSetupError?: StripeError | undefined;
    /** (ID of the SetupAttempt)
The most recent SetupAttempt for this SetupIntent. */
    latestAttemptId?: string | undefined;
    /** (Expanded)
The most recent SetupAttempt for this SetupIntent.
            
For more information, see the expand documentation. */
    latestAttempt?: SetupAttempt | undefined;
    internalLatestAttempt?: ExpandableFieldOfSetupAttempt | undefined;
    /** Has the value true if the object exists in live mode or the value false if
the object exists in test mode. */
    livemode?: boolean;
    /** (ID of the Mandate)
ID of the multi use Mandate generated by the SetupIntent. */
    mandateId?: string | undefined;
    /** (Expanded)
ID of the multi use Mandate generated by the SetupIntent.
            
For more information, see the expand documentation. */
    mandate?: Mandate | undefined;
    internalMandate?: ExpandableFieldOfMandate | undefined;
    /** Set of key-value pairs that you can
attach to an object. This can be useful for storing additional information about the
object in a structured format. */
    metadata?: { [key: string]: string; } | undefined;
    /** If present, this property tells you what actions you need to take in order for your
customer to continue payment setup. */
    nextAction?: SetupIntentNextAction | undefined;
    /** (ID of the Account)
The account (if any) for which the setup is intended. */
    onBehalfOfId?: string | undefined;
    /** (Expanded)
The account (if any) for which the setup is intended.
            
For more information, see the expand documentation. */
    onBehalfOf?: Account | undefined;
    internalOnBehalfOf?: ExpandableFieldOfAccount | undefined;
    /** (ID of the PaymentMethod)
ID of the payment method used with this SetupIntent. */
    paymentMethodId?: string | undefined;
    /** (Expanded)
ID of the payment method used with this SetupIntent.
            
For more information, see the expand documentation. */
    paymentMethod?: PaymentMethod | undefined;
    internalPaymentMethod?: ExpandableFieldOfPaymentMethod | undefined;
    /** Payment-method-specific configuration for this SetupIntent. */
    paymentMethodOptions?: SetupIntentPaymentMethodOptions | undefined;
    /** The list of payment method types (e.g. card) that this SetupIntent is allowed to set up. */
    paymentMethodTypes?: string[] | undefined;
    /** (ID of the Mandate)
ID of the single_use Mandate generated by the SetupIntent. */
    singleUseMandateId?: string | undefined;
    /** (Expanded)
ID of the single_use Mandate generated by the SetupIntent.
            
For more information, see the expand documentation. */
    singleUseMandate?: Mandate | undefined;
    internalSingleUseMandate?: ExpandableFieldOfMandate | undefined;
    /** Status of this
SetupIntent, one of requires_payment_method, requires_confirmation,
requires_action, processing, canceled, or succeeded.
One of: canceled, processing, requires_action,
requires_confirmation, requires_payment_method, or succeeded. */
    status?: string | undefined;
    /** Indicates how the payment method is intended to be used in the future.
            
Use on_session if you intend to only reuse the payment method when the customer
is in your checkout flow. Use off_session if your customer may or may not be in
your checkout flow. If not provided, this value defaults to off_session. */
    usage?: string | undefined;
}

export abstract class StripeEntityOfSetupIntentAutomaticPaymentMethods extends StripeEntity implements IStripeEntityOfSetupIntentAutomaticPaymentMethods {

    constructor(data?: IStripeEntityOfSetupIntentAutomaticPaymentMethods) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSetupIntentAutomaticPaymentMethods {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSetupIntentAutomaticPaymentMethods' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSetupIntentAutomaticPaymentMethods extends IStripeEntity {
}

export class SetupIntentAutomaticPaymentMethods extends StripeEntityOfSetupIntentAutomaticPaymentMethods implements ISetupIntentAutomaticPaymentMethods {
    /** Automatically calculates compatible payment methods. */
    enabled?: boolean | undefined;

    constructor(data?: ISetupIntentAutomaticPaymentMethods) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.enabled = _data["enabled"];
        }
    }

    static override fromJS(data: any): SetupIntentAutomaticPaymentMethods {
        data = typeof data === 'object' ? data : {};
        let result = new SetupIntentAutomaticPaymentMethods();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enabled"] = this.enabled;
        super.toJSON(data);
        return data;
    }
}

export interface ISetupIntentAutomaticPaymentMethods extends IStripeEntityOfSetupIntentAutomaticPaymentMethods {
    /** Automatically calculates compatible payment methods. */
    enabled?: boolean | undefined;
}

export abstract class StripeEntityOfSetupAttempt extends StripeEntity implements IStripeEntityOfSetupAttempt {

    constructor(data?: IStripeEntityOfSetupAttempt) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSetupAttempt {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSetupAttempt' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSetupAttempt extends IStripeEntity {
}

/** A SetupAttempt describes one attempted confirmation of a SetupIntent, whether that confirmation was successful or unsuccessful. You can use SetupAttempts to inspect details of a specific attempt at setting up a payment method using a SetupIntent. */
export class SetupAttempt extends StripeEntityOfSetupAttempt implements ISetupAttempt {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** (ID of the Application)
The value of application
on the SetupIntent at the time of this confirmation. */
    applicationId?: string | undefined;
    /** (Expanded)
The value of application
on the SetupIntent at the time of this confirmation.
            
For more information, see the expand documentation. */
    application?: Application | undefined;
    internalApplication?: ExpandableFieldOfApplication | undefined;
    /** If present, the SetupIntent's payment method will be attached to the in-context Stripe
Account.
            
It can only be used for this Stripe Account’s own money movement flows like
InboundTransfer and OutboundTransfers. It cannot be set to true when setting up a
PaymentMethod for a Customer, and defaults to false when attaching a PaymentMethod to a
Customer. */
    attachToSelf?: boolean;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** (ID of the Customer)
The value of customer
on the SetupIntent at the time of this confirmation. */
    customerId?: string | undefined;
    /** (Expanded)
The value of customer
on the SetupIntent at the time of this confirmation.
            
For more information, see the expand documentation. */
    customer?: Customer2 | undefined;
    internalCustomer?: ExpandableFieldOfCustomer | undefined;
    /** Indicates the directions of money movement for which this payment method is intended to
be used.
            
Include inbound if you intend to use the payment method as the origin to pull
funds from. Include outbound if you intend to use the payment method as the
destination to send funds to. You can include both if you intend to use the payment
method for both purposes. */
    flowDirections?: string[] | undefined;
    /** Has the value true if the object exists in live mode or the value false if
the object exists in test mode. */
    livemode?: boolean;
    /** (ID of the Account)
The value of on_behalf_of
on the SetupIntent at the time of this confirmation. */
    onBehalfOfId?: string | undefined;
    /** (Expanded)
The value of on_behalf_of
on the SetupIntent at the time of this confirmation.
            
For more information, see the expand documentation. */
    onBehalfOf?: Account | undefined;
    internalOnBehalfOf?: ExpandableFieldOfAccount | undefined;
    /** (ID of the PaymentMethod)
ID of the payment method used with this SetupAttempt. */
    paymentMethodId?: string | undefined;
    /** (Expanded)
ID of the payment method used with this SetupAttempt.
            
For more information, see the expand documentation. */
    paymentMethod?: PaymentMethod | undefined;
    internalPaymentMethod?: ExpandableFieldOfPaymentMethod | undefined;
    paymentMethodDetails?: SetupAttemptPaymentMethodDetails | undefined;
    /** The error encountered during this attempt to confirm the SetupIntent, if any. */
    setupError?: StripeError | undefined;
    /** (ID of the SetupIntent)
ID of the SetupIntent that this attempt belongs to. */
    setupIntentId?: string | undefined;
    /** (Expanded)
ID of the SetupIntent that this attempt belongs to.
            
For more information, see the expand documentation. */
    setupIntent?: SetupIntent | undefined;
    internalSetupIntent?: ExpandableFieldOfSetupIntent | undefined;
    /** Status of this SetupAttempt, one of requires_confirmation,
requires_action, processing, succeeded, failed, or
abandoned. */
    status?: string | undefined;
    /** The value of usage
on the SetupIntent at the time of this confirmation, one of off_session or
on_session. */
    usage?: string | undefined;

    constructor(data?: ISetupAttempt) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.object = _data["object"];
            this.applicationId = _data["applicationId"];
            this.application = _data["application"] ? Application.fromJS(_data["application"]) : <any>undefined;
            this.internalApplication = _data["internalApplication"] ? ExpandableFieldOfApplication.fromJS(_data["internalApplication"]) : <any>undefined;
            this.attachToSelf = _data["attachToSelf"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.customerId = _data["customerId"];
            this.customer = _data["customer"] ? Customer2.fromJS(_data["customer"]) : <any>undefined;
            this.internalCustomer = _data["internalCustomer"] ? ExpandableFieldOfCustomer.fromJS(_data["internalCustomer"]) : <any>undefined;
            if (Array.isArray(_data["flowDirections"])) {
                this.flowDirections = [] as any;
                for (let item of _data["flowDirections"])
                    this.flowDirections!.push(item);
            }
            this.livemode = _data["livemode"];
            this.onBehalfOfId = _data["onBehalfOfId"];
            this.onBehalfOf = _data["onBehalfOf"] ? Account.fromJS(_data["onBehalfOf"]) : <any>undefined;
            this.internalOnBehalfOf = _data["internalOnBehalfOf"] ? ExpandableFieldOfAccount.fromJS(_data["internalOnBehalfOf"]) : <any>undefined;
            this.paymentMethodId = _data["paymentMethodId"];
            this.paymentMethod = _data["paymentMethod"] ? PaymentMethod.fromJS(_data["paymentMethod"]) : <any>undefined;
            this.internalPaymentMethod = _data["internalPaymentMethod"] ? ExpandableFieldOfPaymentMethod.fromJS(_data["internalPaymentMethod"]) : <any>undefined;
            this.paymentMethodDetails = _data["paymentMethodDetails"] ? SetupAttemptPaymentMethodDetails.fromJS(_data["paymentMethodDetails"]) : <any>undefined;
            this.setupError = _data["setupError"] ? StripeError.fromJS(_data["setupError"]) : <any>undefined;
            this.setupIntentId = _data["setupIntentId"];
            this.setupIntent = _data["setupIntent"] ? SetupIntent.fromJS(_data["setupIntent"]) : <any>undefined;
            this.internalSetupIntent = _data["internalSetupIntent"] ? ExpandableFieldOfSetupIntent.fromJS(_data["internalSetupIntent"]) : <any>undefined;
            this.status = _data["status"];
            this.usage = _data["usage"];
        }
    }

    static override fromJS(data: any): SetupAttempt {
        data = typeof data === 'object' ? data : {};
        let result = new SetupAttempt();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["object"] = this.object;
        data["applicationId"] = this.applicationId;
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["internalApplication"] = this.internalApplication ? this.internalApplication.toJSON() : <any>undefined;
        data["attachToSelf"] = this.attachToSelf;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["customerId"] = this.customerId;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["internalCustomer"] = this.internalCustomer ? this.internalCustomer.toJSON() : <any>undefined;
        if (Array.isArray(this.flowDirections)) {
            data["flowDirections"] = [];
            for (let item of this.flowDirections)
                data["flowDirections"].push(item);
        }
        data["livemode"] = this.livemode;
        data["onBehalfOfId"] = this.onBehalfOfId;
        data["onBehalfOf"] = this.onBehalfOf ? this.onBehalfOf.toJSON() : <any>undefined;
        data["internalOnBehalfOf"] = this.internalOnBehalfOf ? this.internalOnBehalfOf.toJSON() : <any>undefined;
        data["paymentMethodId"] = this.paymentMethodId;
        data["paymentMethod"] = this.paymentMethod ? this.paymentMethod.toJSON() : <any>undefined;
        data["internalPaymentMethod"] = this.internalPaymentMethod ? this.internalPaymentMethod.toJSON() : <any>undefined;
        data["paymentMethodDetails"] = this.paymentMethodDetails ? this.paymentMethodDetails.toJSON() : <any>undefined;
        data["setupError"] = this.setupError ? this.setupError.toJSON() : <any>undefined;
        data["setupIntentId"] = this.setupIntentId;
        data["setupIntent"] = this.setupIntent ? this.setupIntent.toJSON() : <any>undefined;
        data["internalSetupIntent"] = this.internalSetupIntent ? this.internalSetupIntent.toJSON() : <any>undefined;
        data["status"] = this.status;
        data["usage"] = this.usage;
        super.toJSON(data);
        return data;
    }
}

/** A SetupAttempt describes one attempted confirmation of a SetupIntent, whether that confirmation was successful or unsuccessful. You can use SetupAttempts to inspect details of a specific attempt at setting up a payment method using a SetupIntent. */
export interface ISetupAttempt extends IStripeEntityOfSetupAttempt {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** (ID of the Application)
The value of application
on the SetupIntent at the time of this confirmation. */
    applicationId?: string | undefined;
    /** (Expanded)
The value of application
on the SetupIntent at the time of this confirmation.
            
For more information, see the expand documentation. */
    application?: Application | undefined;
    internalApplication?: ExpandableFieldOfApplication | undefined;
    /** If present, the SetupIntent's payment method will be attached to the in-context Stripe
Account.
            
It can only be used for this Stripe Account’s own money movement flows like
InboundTransfer and OutboundTransfers. It cannot be set to true when setting up a
PaymentMethod for a Customer, and defaults to false when attaching a PaymentMethod to a
Customer. */
    attachToSelf?: boolean;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** (ID of the Customer)
The value of customer
on the SetupIntent at the time of this confirmation. */
    customerId?: string | undefined;
    /** (Expanded)
The value of customer
on the SetupIntent at the time of this confirmation.
            
For more information, see the expand documentation. */
    customer?: Customer2 | undefined;
    internalCustomer?: ExpandableFieldOfCustomer | undefined;
    /** Indicates the directions of money movement for which this payment method is intended to
be used.
            
Include inbound if you intend to use the payment method as the origin to pull
funds from. Include outbound if you intend to use the payment method as the
destination to send funds to. You can include both if you intend to use the payment
method for both purposes. */
    flowDirections?: string[] | undefined;
    /** Has the value true if the object exists in live mode or the value false if
the object exists in test mode. */
    livemode?: boolean;
    /** (ID of the Account)
The value of on_behalf_of
on the SetupIntent at the time of this confirmation. */
    onBehalfOfId?: string | undefined;
    /** (Expanded)
The value of on_behalf_of
on the SetupIntent at the time of this confirmation.
            
For more information, see the expand documentation. */
    onBehalfOf?: Account | undefined;
    internalOnBehalfOf?: ExpandableFieldOfAccount | undefined;
    /** (ID of the PaymentMethod)
ID of the payment method used with this SetupAttempt. */
    paymentMethodId?: string | undefined;
    /** (Expanded)
ID of the payment method used with this SetupAttempt.
            
For more information, see the expand documentation. */
    paymentMethod?: PaymentMethod | undefined;
    internalPaymentMethod?: ExpandableFieldOfPaymentMethod | undefined;
    paymentMethodDetails?: SetupAttemptPaymentMethodDetails | undefined;
    /** The error encountered during this attempt to confirm the SetupIntent, if any. */
    setupError?: StripeError | undefined;
    /** (ID of the SetupIntent)
ID of the SetupIntent that this attempt belongs to. */
    setupIntentId?: string | undefined;
    /** (Expanded)
ID of the SetupIntent that this attempt belongs to.
            
For more information, see the expand documentation. */
    setupIntent?: SetupIntent | undefined;
    internalSetupIntent?: ExpandableFieldOfSetupIntent | undefined;
    /** Status of this SetupAttempt, one of requires_confirmation,
requires_action, processing, succeeded, failed, or
abandoned. */
    status?: string | undefined;
    /** The value of usage
on the SetupIntent at the time of this confirmation, one of off_session or
on_session. */
    usage?: string | undefined;
}

export abstract class StripeEntityOfSetupAttemptPaymentMethodDetails extends StripeEntity implements IStripeEntityOfSetupAttemptPaymentMethodDetails {

    constructor(data?: IStripeEntityOfSetupAttemptPaymentMethodDetails) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSetupAttemptPaymentMethodDetails {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSetupAttemptPaymentMethodDetails' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSetupAttemptPaymentMethodDetails extends IStripeEntity {
}

export class SetupAttemptPaymentMethodDetails extends StripeEntityOfSetupAttemptPaymentMethodDetails implements ISetupAttemptPaymentMethodDetails {
    acssDebit?: SetupAttemptPaymentMethodDetailsAcssDebit | undefined;
    auBecsDebit?: SetupAttemptPaymentMethodDetailsAuBecsDebit | undefined;
    bacsDebit?: SetupAttemptPaymentMethodDetailsBacsDebit | undefined;
    bancontact?: SetupAttemptPaymentMethodDetailsBancontact | undefined;
    blik?: SetupAttemptPaymentMethodDetailsBlik | undefined;
    boleto?: SetupAttemptPaymentMethodDetailsBoleto | undefined;
    card?: SetupAttemptPaymentMethodDetailsCard | undefined;
    cardPresent?: SetupAttemptPaymentMethodDetailsCardPresent | undefined;
    cashapp?: SetupAttemptPaymentMethodDetailsCashapp | undefined;
    ideal?: SetupAttemptPaymentMethodDetailsIdeal | undefined;
    klarna?: SetupAttemptPaymentMethodDetailsKlarna | undefined;
    link?: SetupAttemptPaymentMethodDetailsLink | undefined;
    paypal?: SetupAttemptPaymentMethodDetailsPaypal | undefined;
    sepaDebit?: SetupAttemptPaymentMethodDetailsSepaDebit | undefined;
    sofort?: SetupAttemptPaymentMethodDetailsSofort | undefined;
    /** The type of the payment method used in the SetupIntent (e.g., card). An
additional hash is included on payment_method_details with a name matching this
value. It contains confirmation-specific information for the payment method. */
    type?: string | undefined;
    usBankAccount?: SetupAttemptPaymentMethodDetailsUsBankAccount | undefined;

    constructor(data?: ISetupAttemptPaymentMethodDetails) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.acssDebit = _data["acssDebit"] ? SetupAttemptPaymentMethodDetailsAcssDebit.fromJS(_data["acssDebit"]) : <any>undefined;
            this.auBecsDebit = _data["auBecsDebit"] ? SetupAttemptPaymentMethodDetailsAuBecsDebit.fromJS(_data["auBecsDebit"]) : <any>undefined;
            this.bacsDebit = _data["bacsDebit"] ? SetupAttemptPaymentMethodDetailsBacsDebit.fromJS(_data["bacsDebit"]) : <any>undefined;
            this.bancontact = _data["bancontact"] ? SetupAttemptPaymentMethodDetailsBancontact.fromJS(_data["bancontact"]) : <any>undefined;
            this.blik = _data["blik"] ? SetupAttemptPaymentMethodDetailsBlik.fromJS(_data["blik"]) : <any>undefined;
            this.boleto = _data["boleto"] ? SetupAttemptPaymentMethodDetailsBoleto.fromJS(_data["boleto"]) : <any>undefined;
            this.card = _data["card"] ? SetupAttemptPaymentMethodDetailsCard.fromJS(_data["card"]) : <any>undefined;
            this.cardPresent = _data["cardPresent"] ? SetupAttemptPaymentMethodDetailsCardPresent.fromJS(_data["cardPresent"]) : <any>undefined;
            this.cashapp = _data["cashapp"] ? SetupAttemptPaymentMethodDetailsCashapp.fromJS(_data["cashapp"]) : <any>undefined;
            this.ideal = _data["ideal"] ? SetupAttemptPaymentMethodDetailsIdeal.fromJS(_data["ideal"]) : <any>undefined;
            this.klarna = _data["klarna"] ? SetupAttemptPaymentMethodDetailsKlarna.fromJS(_data["klarna"]) : <any>undefined;
            this.link = _data["link"] ? SetupAttemptPaymentMethodDetailsLink.fromJS(_data["link"]) : <any>undefined;
            this.paypal = _data["paypal"] ? SetupAttemptPaymentMethodDetailsPaypal.fromJS(_data["paypal"]) : <any>undefined;
            this.sepaDebit = _data["sepaDebit"] ? SetupAttemptPaymentMethodDetailsSepaDebit.fromJS(_data["sepaDebit"]) : <any>undefined;
            this.sofort = _data["sofort"] ? SetupAttemptPaymentMethodDetailsSofort.fromJS(_data["sofort"]) : <any>undefined;
            this.type = _data["type"];
            this.usBankAccount = _data["usBankAccount"] ? SetupAttemptPaymentMethodDetailsUsBankAccount.fromJS(_data["usBankAccount"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): SetupAttemptPaymentMethodDetails {
        data = typeof data === 'object' ? data : {};
        let result = new SetupAttemptPaymentMethodDetails();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["acssDebit"] = this.acssDebit ? this.acssDebit.toJSON() : <any>undefined;
        data["auBecsDebit"] = this.auBecsDebit ? this.auBecsDebit.toJSON() : <any>undefined;
        data["bacsDebit"] = this.bacsDebit ? this.bacsDebit.toJSON() : <any>undefined;
        data["bancontact"] = this.bancontact ? this.bancontact.toJSON() : <any>undefined;
        data["blik"] = this.blik ? this.blik.toJSON() : <any>undefined;
        data["boleto"] = this.boleto ? this.boleto.toJSON() : <any>undefined;
        data["card"] = this.card ? this.card.toJSON() : <any>undefined;
        data["cardPresent"] = this.cardPresent ? this.cardPresent.toJSON() : <any>undefined;
        data["cashapp"] = this.cashapp ? this.cashapp.toJSON() : <any>undefined;
        data["ideal"] = this.ideal ? this.ideal.toJSON() : <any>undefined;
        data["klarna"] = this.klarna ? this.klarna.toJSON() : <any>undefined;
        data["link"] = this.link ? this.link.toJSON() : <any>undefined;
        data["paypal"] = this.paypal ? this.paypal.toJSON() : <any>undefined;
        data["sepaDebit"] = this.sepaDebit ? this.sepaDebit.toJSON() : <any>undefined;
        data["sofort"] = this.sofort ? this.sofort.toJSON() : <any>undefined;
        data["type"] = this.type;
        data["usBankAccount"] = this.usBankAccount ? this.usBankAccount.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface ISetupAttemptPaymentMethodDetails extends IStripeEntityOfSetupAttemptPaymentMethodDetails {
    acssDebit?: SetupAttemptPaymentMethodDetailsAcssDebit | undefined;
    auBecsDebit?: SetupAttemptPaymentMethodDetailsAuBecsDebit | undefined;
    bacsDebit?: SetupAttemptPaymentMethodDetailsBacsDebit | undefined;
    bancontact?: SetupAttemptPaymentMethodDetailsBancontact | undefined;
    blik?: SetupAttemptPaymentMethodDetailsBlik | undefined;
    boleto?: SetupAttemptPaymentMethodDetailsBoleto | undefined;
    card?: SetupAttemptPaymentMethodDetailsCard | undefined;
    cardPresent?: SetupAttemptPaymentMethodDetailsCardPresent | undefined;
    cashapp?: SetupAttemptPaymentMethodDetailsCashapp | undefined;
    ideal?: SetupAttemptPaymentMethodDetailsIdeal | undefined;
    klarna?: SetupAttemptPaymentMethodDetailsKlarna | undefined;
    link?: SetupAttemptPaymentMethodDetailsLink | undefined;
    paypal?: SetupAttemptPaymentMethodDetailsPaypal | undefined;
    sepaDebit?: SetupAttemptPaymentMethodDetailsSepaDebit | undefined;
    sofort?: SetupAttemptPaymentMethodDetailsSofort | undefined;
    /** The type of the payment method used in the SetupIntent (e.g., card). An
additional hash is included on payment_method_details with a name matching this
value. It contains confirmation-specific information for the payment method. */
    type?: string | undefined;
    usBankAccount?: SetupAttemptPaymentMethodDetailsUsBankAccount | undefined;
}

export abstract class StripeEntityOfSetupAttemptPaymentMethodDetailsAcssDebit extends StripeEntity implements IStripeEntityOfSetupAttemptPaymentMethodDetailsAcssDebit {

    constructor(data?: IStripeEntityOfSetupAttemptPaymentMethodDetailsAcssDebit) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSetupAttemptPaymentMethodDetailsAcssDebit {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSetupAttemptPaymentMethodDetailsAcssDebit' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSetupAttemptPaymentMethodDetailsAcssDebit extends IStripeEntity {
}

export class SetupAttemptPaymentMethodDetailsAcssDebit extends StripeEntityOfSetupAttemptPaymentMethodDetailsAcssDebit implements ISetupAttemptPaymentMethodDetailsAcssDebit {

    constructor(data?: ISetupAttemptPaymentMethodDetailsAcssDebit) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): SetupAttemptPaymentMethodDetailsAcssDebit {
        data = typeof data === 'object' ? data : {};
        let result = new SetupAttemptPaymentMethodDetailsAcssDebit();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ISetupAttemptPaymentMethodDetailsAcssDebit extends IStripeEntityOfSetupAttemptPaymentMethodDetailsAcssDebit {
}

export abstract class StripeEntityOfSetupAttemptPaymentMethodDetailsAuBecsDebit extends StripeEntity implements IStripeEntityOfSetupAttemptPaymentMethodDetailsAuBecsDebit {

    constructor(data?: IStripeEntityOfSetupAttemptPaymentMethodDetailsAuBecsDebit) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSetupAttemptPaymentMethodDetailsAuBecsDebit {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSetupAttemptPaymentMethodDetailsAuBecsDebit' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSetupAttemptPaymentMethodDetailsAuBecsDebit extends IStripeEntity {
}

export class SetupAttemptPaymentMethodDetailsAuBecsDebit extends StripeEntityOfSetupAttemptPaymentMethodDetailsAuBecsDebit implements ISetupAttemptPaymentMethodDetailsAuBecsDebit {

    constructor(data?: ISetupAttemptPaymentMethodDetailsAuBecsDebit) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): SetupAttemptPaymentMethodDetailsAuBecsDebit {
        data = typeof data === 'object' ? data : {};
        let result = new SetupAttemptPaymentMethodDetailsAuBecsDebit();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ISetupAttemptPaymentMethodDetailsAuBecsDebit extends IStripeEntityOfSetupAttemptPaymentMethodDetailsAuBecsDebit {
}

export abstract class StripeEntityOfSetupAttemptPaymentMethodDetailsBacsDebit extends StripeEntity implements IStripeEntityOfSetupAttemptPaymentMethodDetailsBacsDebit {

    constructor(data?: IStripeEntityOfSetupAttemptPaymentMethodDetailsBacsDebit) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSetupAttemptPaymentMethodDetailsBacsDebit {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSetupAttemptPaymentMethodDetailsBacsDebit' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSetupAttemptPaymentMethodDetailsBacsDebit extends IStripeEntity {
}

export class SetupAttemptPaymentMethodDetailsBacsDebit extends StripeEntityOfSetupAttemptPaymentMethodDetailsBacsDebit implements ISetupAttemptPaymentMethodDetailsBacsDebit {

    constructor(data?: ISetupAttemptPaymentMethodDetailsBacsDebit) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): SetupAttemptPaymentMethodDetailsBacsDebit {
        data = typeof data === 'object' ? data : {};
        let result = new SetupAttemptPaymentMethodDetailsBacsDebit();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ISetupAttemptPaymentMethodDetailsBacsDebit extends IStripeEntityOfSetupAttemptPaymentMethodDetailsBacsDebit {
}

export abstract class StripeEntityOfSetupAttemptPaymentMethodDetailsBancontact extends StripeEntity implements IStripeEntityOfSetupAttemptPaymentMethodDetailsBancontact {

    constructor(data?: IStripeEntityOfSetupAttemptPaymentMethodDetailsBancontact) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSetupAttemptPaymentMethodDetailsBancontact {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSetupAttemptPaymentMethodDetailsBancontact' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSetupAttemptPaymentMethodDetailsBancontact extends IStripeEntity {
}

export class SetupAttemptPaymentMethodDetailsBancontact extends StripeEntityOfSetupAttemptPaymentMethodDetailsBancontact implements ISetupAttemptPaymentMethodDetailsBancontact {
    /** Bank code of bank associated with the bank account. */
    bankCode?: string | undefined;
    /** Name of the bank associated with the bank account. */
    bankName?: string | undefined;
    /** Bank Identifier Code of the bank associated with the bank account. */
    bic?: string | undefined;
    /** (ID of the PaymentMethod)
The ID of the SEPA Direct Debit PaymentMethod which was generated by this SetupAttempt. */
    generatedSepaDebitId?: string | undefined;
    /** (Expanded)
The ID of the SEPA Direct Debit PaymentMethod which was generated by this SetupAttempt.
            
For more information, see the expand documentation. */
    generatedSepaDebit?: PaymentMethod | undefined;
    internalGeneratedSepaDebit?: ExpandableFieldOfPaymentMethod | undefined;
    /** (ID of the Mandate)
The mandate for the SEPA Direct Debit PaymentMethod which was generated by this
SetupAttempt. */
    generatedSepaDebitMandateId?: string | undefined;
    /** (Expanded)
The mandate for the SEPA Direct Debit PaymentMethod which was generated by this
SetupAttempt.
            
For more information, see the expand documentation. */
    generatedSepaDebitMandate?: Mandate | undefined;
    internalGeneratedSepaDebitMandate?: ExpandableFieldOfMandate | undefined;
    /** Last four characters of the IBAN. */
    ibanLast4?: string | undefined;
    /** Preferred language of the Bancontact authorization page that the customer is redirected
to. Can be one of en, de, fr, or nl.
One of: de, en, fr, or nl. */
    preferredLanguage?: string | undefined;
    /** Owner's verified full name. Values are verified or provided by Bancontact directly (if
supported) at the time of authorization or settlement. They cannot be set or mutated. */
    verifiedName?: string | undefined;

    constructor(data?: ISetupAttemptPaymentMethodDetailsBancontact) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.bankCode = _data["bankCode"];
            this.bankName = _data["bankName"];
            this.bic = _data["bic"];
            this.generatedSepaDebitId = _data["generatedSepaDebitId"];
            this.generatedSepaDebit = _data["generatedSepaDebit"] ? PaymentMethod.fromJS(_data["generatedSepaDebit"]) : <any>undefined;
            this.internalGeneratedSepaDebit = _data["internalGeneratedSepaDebit"] ? ExpandableFieldOfPaymentMethod.fromJS(_data["internalGeneratedSepaDebit"]) : <any>undefined;
            this.generatedSepaDebitMandateId = _data["generatedSepaDebitMandateId"];
            this.generatedSepaDebitMandate = _data["generatedSepaDebitMandate"] ? Mandate.fromJS(_data["generatedSepaDebitMandate"]) : <any>undefined;
            this.internalGeneratedSepaDebitMandate = _data["internalGeneratedSepaDebitMandate"] ? ExpandableFieldOfMandate.fromJS(_data["internalGeneratedSepaDebitMandate"]) : <any>undefined;
            this.ibanLast4 = _data["ibanLast4"];
            this.preferredLanguage = _data["preferredLanguage"];
            this.verifiedName = _data["verifiedName"];
        }
    }

    static override fromJS(data: any): SetupAttemptPaymentMethodDetailsBancontact {
        data = typeof data === 'object' ? data : {};
        let result = new SetupAttemptPaymentMethodDetailsBancontact();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankCode"] = this.bankCode;
        data["bankName"] = this.bankName;
        data["bic"] = this.bic;
        data["generatedSepaDebitId"] = this.generatedSepaDebitId;
        data["generatedSepaDebit"] = this.generatedSepaDebit ? this.generatedSepaDebit.toJSON() : <any>undefined;
        data["internalGeneratedSepaDebit"] = this.internalGeneratedSepaDebit ? this.internalGeneratedSepaDebit.toJSON() : <any>undefined;
        data["generatedSepaDebitMandateId"] = this.generatedSepaDebitMandateId;
        data["generatedSepaDebitMandate"] = this.generatedSepaDebitMandate ? this.generatedSepaDebitMandate.toJSON() : <any>undefined;
        data["internalGeneratedSepaDebitMandate"] = this.internalGeneratedSepaDebitMandate ? this.internalGeneratedSepaDebitMandate.toJSON() : <any>undefined;
        data["ibanLast4"] = this.ibanLast4;
        data["preferredLanguage"] = this.preferredLanguage;
        data["verifiedName"] = this.verifiedName;
        super.toJSON(data);
        return data;
    }
}

export interface ISetupAttemptPaymentMethodDetailsBancontact extends IStripeEntityOfSetupAttemptPaymentMethodDetailsBancontact {
    /** Bank code of bank associated with the bank account. */
    bankCode?: string | undefined;
    /** Name of the bank associated with the bank account. */
    bankName?: string | undefined;
    /** Bank Identifier Code of the bank associated with the bank account. */
    bic?: string | undefined;
    /** (ID of the PaymentMethod)
The ID of the SEPA Direct Debit PaymentMethod which was generated by this SetupAttempt. */
    generatedSepaDebitId?: string | undefined;
    /** (Expanded)
The ID of the SEPA Direct Debit PaymentMethod which was generated by this SetupAttempt.
            
For more information, see the expand documentation. */
    generatedSepaDebit?: PaymentMethod | undefined;
    internalGeneratedSepaDebit?: ExpandableFieldOfPaymentMethod | undefined;
    /** (ID of the Mandate)
The mandate for the SEPA Direct Debit PaymentMethod which was generated by this
SetupAttempt. */
    generatedSepaDebitMandateId?: string | undefined;
    /** (Expanded)
The mandate for the SEPA Direct Debit PaymentMethod which was generated by this
SetupAttempt.
            
For more information, see the expand documentation. */
    generatedSepaDebitMandate?: Mandate | undefined;
    internalGeneratedSepaDebitMandate?: ExpandableFieldOfMandate | undefined;
    /** Last four characters of the IBAN. */
    ibanLast4?: string | undefined;
    /** Preferred language of the Bancontact authorization page that the customer is redirected
to. Can be one of en, de, fr, or nl.
One of: de, en, fr, or nl. */
    preferredLanguage?: string | undefined;
    /** Owner's verified full name. Values are verified or provided by Bancontact directly (if
supported) at the time of authorization or settlement. They cannot be set or mutated. */
    verifiedName?: string | undefined;
}

export abstract class StripeEntityOfMandate extends StripeEntity implements IStripeEntityOfMandate {

    constructor(data?: IStripeEntityOfMandate) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfMandate {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfMandate' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfMandate extends IStripeEntity {
}

/** A Mandate is a record of the permission a customer has given you to debit their payment method. */
export class Mandate extends StripeEntityOfMandate implements IMandate {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    customerAcceptance?: MandateCustomerAcceptance | undefined;
    /** Has the value true if the object exists in live mode or the value false if
the object exists in test mode. */
    livemode?: boolean;
    multiUse?: MandateMultiUse | undefined;
    /** (ID of the PaymentMethod)
ID of the payment method associated with this mandate. */
    paymentMethodId?: string | undefined;
    /** (Expanded)
ID of the payment method associated with this mandate.
            
For more information, see the expand documentation. */
    paymentMethod?: PaymentMethod | undefined;
    internalPaymentMethod?: ExpandableFieldOfPaymentMethod | undefined;
    paymentMethodDetails?: MandatePaymentMethodDetails | undefined;
    singleUse?: MandateSingleUse | undefined;
    /** The status of the mandate, which indicates whether it can be used to initiate a payment.
One of: active, inactive, or pending. */
    status?: string | undefined;
    /** The type of the mandate.
One of: multi_use, or single_use. */
    type?: string | undefined;

    constructor(data?: IMandate) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.object = _data["object"];
            this.customerAcceptance = _data["customerAcceptance"] ? MandateCustomerAcceptance.fromJS(_data["customerAcceptance"]) : <any>undefined;
            this.livemode = _data["livemode"];
            this.multiUse = _data["multiUse"] ? MandateMultiUse.fromJS(_data["multiUse"]) : <any>undefined;
            this.paymentMethodId = _data["paymentMethodId"];
            this.paymentMethod = _data["paymentMethod"] ? PaymentMethod.fromJS(_data["paymentMethod"]) : <any>undefined;
            this.internalPaymentMethod = _data["internalPaymentMethod"] ? ExpandableFieldOfPaymentMethod.fromJS(_data["internalPaymentMethod"]) : <any>undefined;
            this.paymentMethodDetails = _data["paymentMethodDetails"] ? MandatePaymentMethodDetails.fromJS(_data["paymentMethodDetails"]) : <any>undefined;
            this.singleUse = _data["singleUse"] ? MandateSingleUse.fromJS(_data["singleUse"]) : <any>undefined;
            this.status = _data["status"];
            this.type = _data["type"];
        }
    }

    static override fromJS(data: any): Mandate {
        data = typeof data === 'object' ? data : {};
        let result = new Mandate();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["object"] = this.object;
        data["customerAcceptance"] = this.customerAcceptance ? this.customerAcceptance.toJSON() : <any>undefined;
        data["livemode"] = this.livemode;
        data["multiUse"] = this.multiUse ? this.multiUse.toJSON() : <any>undefined;
        data["paymentMethodId"] = this.paymentMethodId;
        data["paymentMethod"] = this.paymentMethod ? this.paymentMethod.toJSON() : <any>undefined;
        data["internalPaymentMethod"] = this.internalPaymentMethod ? this.internalPaymentMethod.toJSON() : <any>undefined;
        data["paymentMethodDetails"] = this.paymentMethodDetails ? this.paymentMethodDetails.toJSON() : <any>undefined;
        data["singleUse"] = this.singleUse ? this.singleUse.toJSON() : <any>undefined;
        data["status"] = this.status;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** A Mandate is a record of the permission a customer has given you to debit their payment method. */
export interface IMandate extends IStripeEntityOfMandate {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    customerAcceptance?: MandateCustomerAcceptance | undefined;
    /** Has the value true if the object exists in live mode or the value false if
the object exists in test mode. */
    livemode?: boolean;
    multiUse?: MandateMultiUse | undefined;
    /** (ID of the PaymentMethod)
ID of the payment method associated with this mandate. */
    paymentMethodId?: string | undefined;
    /** (Expanded)
ID of the payment method associated with this mandate.
            
For more information, see the expand documentation. */
    paymentMethod?: PaymentMethod | undefined;
    internalPaymentMethod?: ExpandableFieldOfPaymentMethod | undefined;
    paymentMethodDetails?: MandatePaymentMethodDetails | undefined;
    singleUse?: MandateSingleUse | undefined;
    /** The status of the mandate, which indicates whether it can be used to initiate a payment.
One of: active, inactive, or pending. */
    status?: string | undefined;
    /** The type of the mandate.
One of: multi_use, or single_use. */
    type?: string | undefined;
}

export abstract class StripeEntityOfMandateCustomerAcceptance extends StripeEntity implements IStripeEntityOfMandateCustomerAcceptance {

    constructor(data?: IStripeEntityOfMandateCustomerAcceptance) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfMandateCustomerAcceptance {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfMandateCustomerAcceptance' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfMandateCustomerAcceptance extends IStripeEntity {
}

export class MandateCustomerAcceptance extends StripeEntityOfMandateCustomerAcceptance implements IMandateCustomerAcceptance {
    /** The time at which the customer accepted the Mandate. */
    acceptedAt?: Date | undefined;
    offline?: MandateCustomerAcceptanceOffline | undefined;
    online?: MandateCustomerAcceptanceOnline | undefined;
    /** The type of customer acceptance information included with the Mandate. One of
online or offline.
One of: offline, or online. */
    type?: string | undefined;

    constructor(data?: IMandateCustomerAcceptance) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.acceptedAt = _data["acceptedAt"] ? new Date(_data["acceptedAt"].toString()) : <any>undefined;
            this.offline = _data["offline"] ? MandateCustomerAcceptanceOffline.fromJS(_data["offline"]) : <any>undefined;
            this.online = _data["online"] ? MandateCustomerAcceptanceOnline.fromJS(_data["online"]) : <any>undefined;
            this.type = _data["type"];
        }
    }

    static override fromJS(data: any): MandateCustomerAcceptance {
        data = typeof data === 'object' ? data : {};
        let result = new MandateCustomerAcceptance();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["acceptedAt"] = this.acceptedAt ? this.acceptedAt.toISOString() : <any>undefined;
        data["offline"] = this.offline ? this.offline.toJSON() : <any>undefined;
        data["online"] = this.online ? this.online.toJSON() : <any>undefined;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

export interface IMandateCustomerAcceptance extends IStripeEntityOfMandateCustomerAcceptance {
    /** The time at which the customer accepted the Mandate. */
    acceptedAt?: Date | undefined;
    offline?: MandateCustomerAcceptanceOffline | undefined;
    online?: MandateCustomerAcceptanceOnline | undefined;
    /** The type of customer acceptance information included with the Mandate. One of
online or offline.
One of: offline, or online. */
    type?: string | undefined;
}

export abstract class StripeEntityOfMandateCustomerAcceptanceOffline extends StripeEntity implements IStripeEntityOfMandateCustomerAcceptanceOffline {

    constructor(data?: IStripeEntityOfMandateCustomerAcceptanceOffline) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfMandateCustomerAcceptanceOffline {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfMandateCustomerAcceptanceOffline' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfMandateCustomerAcceptanceOffline extends IStripeEntity {
}

export class MandateCustomerAcceptanceOffline extends StripeEntityOfMandateCustomerAcceptanceOffline implements IMandateCustomerAcceptanceOffline {

    constructor(data?: IMandateCustomerAcceptanceOffline) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): MandateCustomerAcceptanceOffline {
        data = typeof data === 'object' ? data : {};
        let result = new MandateCustomerAcceptanceOffline();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IMandateCustomerAcceptanceOffline extends IStripeEntityOfMandateCustomerAcceptanceOffline {
}

export abstract class StripeEntityOfMandateCustomerAcceptanceOnline extends StripeEntity implements IStripeEntityOfMandateCustomerAcceptanceOnline {

    constructor(data?: IStripeEntityOfMandateCustomerAcceptanceOnline) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfMandateCustomerAcceptanceOnline {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfMandateCustomerAcceptanceOnline' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfMandateCustomerAcceptanceOnline extends IStripeEntity {
}

export class MandateCustomerAcceptanceOnline extends StripeEntityOfMandateCustomerAcceptanceOnline implements IMandateCustomerAcceptanceOnline {
    /** The IP address from which the Mandate was accepted by the customer. */
    ipAddress?: string | undefined;
    /** The user agent of the browser from which the Mandate was accepted by the customer. */
    userAgent?: string | undefined;

    constructor(data?: IMandateCustomerAcceptanceOnline) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.ipAddress = _data["ipAddress"];
            this.userAgent = _data["userAgent"];
        }
    }

    static override fromJS(data: any): MandateCustomerAcceptanceOnline {
        data = typeof data === 'object' ? data : {};
        let result = new MandateCustomerAcceptanceOnline();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ipAddress"] = this.ipAddress;
        data["userAgent"] = this.userAgent;
        super.toJSON(data);
        return data;
    }
}

export interface IMandateCustomerAcceptanceOnline extends IStripeEntityOfMandateCustomerAcceptanceOnline {
    /** The IP address from which the Mandate was accepted by the customer. */
    ipAddress?: string | undefined;
    /** The user agent of the browser from which the Mandate was accepted by the customer. */
    userAgent?: string | undefined;
}

export abstract class StripeEntityOfMandateMultiUse extends StripeEntity implements IStripeEntityOfMandateMultiUse {

    constructor(data?: IStripeEntityOfMandateMultiUse) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfMandateMultiUse {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfMandateMultiUse' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfMandateMultiUse extends IStripeEntity {
}

export class MandateMultiUse extends StripeEntityOfMandateMultiUse implements IMandateMultiUse {

    constructor(data?: IMandateMultiUse) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): MandateMultiUse {
        data = typeof data === 'object' ? data : {};
        let result = new MandateMultiUse();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IMandateMultiUse extends IStripeEntityOfMandateMultiUse {
}

export abstract class StripeEntityOfMandatePaymentMethodDetails extends StripeEntity implements IStripeEntityOfMandatePaymentMethodDetails {

    constructor(data?: IStripeEntityOfMandatePaymentMethodDetails) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfMandatePaymentMethodDetails {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfMandatePaymentMethodDetails' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfMandatePaymentMethodDetails extends IStripeEntity {
}

export class MandatePaymentMethodDetails extends StripeEntityOfMandatePaymentMethodDetails implements IMandatePaymentMethodDetails {
    acssDebit?: MandatePaymentMethodDetailsAcssDebit | undefined;
    auBecsDebit?: MandatePaymentMethodDetailsAuBecsDebit | undefined;
    bacsDebit?: MandatePaymentMethodDetailsBacsDebit | undefined;
    blik?: MandatePaymentMethodDetailsBlik | undefined;
    card?: MandatePaymentMethodDetailsCard | undefined;
    cashapp?: MandatePaymentMethodDetailsCashapp | undefined;
    link?: MandatePaymentMethodDetailsLink | undefined;
    paypal?: MandatePaymentMethodDetailsPaypal | undefined;
    sepaDebit?: MandatePaymentMethodDetailsSepaDebit | undefined;
    /** The type of the payment method associated with this mandate. An additional hash is
included on payment_method_details with a name matching this value. It contains
mandate information specific to the payment method. */
    type?: string | undefined;
    usBankAccount?: MandatePaymentMethodDetailsUsBankAccount | undefined;

    constructor(data?: IMandatePaymentMethodDetails) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.acssDebit = _data["acssDebit"] ? MandatePaymentMethodDetailsAcssDebit.fromJS(_data["acssDebit"]) : <any>undefined;
            this.auBecsDebit = _data["auBecsDebit"] ? MandatePaymentMethodDetailsAuBecsDebit.fromJS(_data["auBecsDebit"]) : <any>undefined;
            this.bacsDebit = _data["bacsDebit"] ? MandatePaymentMethodDetailsBacsDebit.fromJS(_data["bacsDebit"]) : <any>undefined;
            this.blik = _data["blik"] ? MandatePaymentMethodDetailsBlik.fromJS(_data["blik"]) : <any>undefined;
            this.card = _data["card"] ? MandatePaymentMethodDetailsCard.fromJS(_data["card"]) : <any>undefined;
            this.cashapp = _data["cashapp"] ? MandatePaymentMethodDetailsCashapp.fromJS(_data["cashapp"]) : <any>undefined;
            this.link = _data["link"] ? MandatePaymentMethodDetailsLink.fromJS(_data["link"]) : <any>undefined;
            this.paypal = _data["paypal"] ? MandatePaymentMethodDetailsPaypal.fromJS(_data["paypal"]) : <any>undefined;
            this.sepaDebit = _data["sepaDebit"] ? MandatePaymentMethodDetailsSepaDebit.fromJS(_data["sepaDebit"]) : <any>undefined;
            this.type = _data["type"];
            this.usBankAccount = _data["usBankAccount"] ? MandatePaymentMethodDetailsUsBankAccount.fromJS(_data["usBankAccount"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): MandatePaymentMethodDetails {
        data = typeof data === 'object' ? data : {};
        let result = new MandatePaymentMethodDetails();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["acssDebit"] = this.acssDebit ? this.acssDebit.toJSON() : <any>undefined;
        data["auBecsDebit"] = this.auBecsDebit ? this.auBecsDebit.toJSON() : <any>undefined;
        data["bacsDebit"] = this.bacsDebit ? this.bacsDebit.toJSON() : <any>undefined;
        data["blik"] = this.blik ? this.blik.toJSON() : <any>undefined;
        data["card"] = this.card ? this.card.toJSON() : <any>undefined;
        data["cashapp"] = this.cashapp ? this.cashapp.toJSON() : <any>undefined;
        data["link"] = this.link ? this.link.toJSON() : <any>undefined;
        data["paypal"] = this.paypal ? this.paypal.toJSON() : <any>undefined;
        data["sepaDebit"] = this.sepaDebit ? this.sepaDebit.toJSON() : <any>undefined;
        data["type"] = this.type;
        data["usBankAccount"] = this.usBankAccount ? this.usBankAccount.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IMandatePaymentMethodDetails extends IStripeEntityOfMandatePaymentMethodDetails {
    acssDebit?: MandatePaymentMethodDetailsAcssDebit | undefined;
    auBecsDebit?: MandatePaymentMethodDetailsAuBecsDebit | undefined;
    bacsDebit?: MandatePaymentMethodDetailsBacsDebit | undefined;
    blik?: MandatePaymentMethodDetailsBlik | undefined;
    card?: MandatePaymentMethodDetailsCard | undefined;
    cashapp?: MandatePaymentMethodDetailsCashapp | undefined;
    link?: MandatePaymentMethodDetailsLink | undefined;
    paypal?: MandatePaymentMethodDetailsPaypal | undefined;
    sepaDebit?: MandatePaymentMethodDetailsSepaDebit | undefined;
    /** The type of the payment method associated with this mandate. An additional hash is
included on payment_method_details with a name matching this value. It contains
mandate information specific to the payment method. */
    type?: string | undefined;
    usBankAccount?: MandatePaymentMethodDetailsUsBankAccount | undefined;
}

export abstract class StripeEntityOfMandatePaymentMethodDetailsAcssDebit extends StripeEntity implements IStripeEntityOfMandatePaymentMethodDetailsAcssDebit {

    constructor(data?: IStripeEntityOfMandatePaymentMethodDetailsAcssDebit) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfMandatePaymentMethodDetailsAcssDebit {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfMandatePaymentMethodDetailsAcssDebit' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfMandatePaymentMethodDetailsAcssDebit extends IStripeEntity {
}

export class MandatePaymentMethodDetailsAcssDebit extends StripeEntityOfMandatePaymentMethodDetailsAcssDebit implements IMandatePaymentMethodDetailsAcssDebit {
    /** List of Stripe products where this mandate can be selected automatically. */
    defaultFor?: string[] | undefined;
    /** Description of the interval. Only required if the 'payment_schedule' parameter is
'interval' or 'combined'. */
    intervalDescription?: string | undefined;
    /** Payment schedule for the mandate.
One of: combined, interval, or sporadic. */
    paymentSchedule?: string | undefined;
    /** Transaction type of the mandate.
One of: business, or personal. */
    transactionType?: string | undefined;

    constructor(data?: IMandatePaymentMethodDetailsAcssDebit) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["defaultFor"])) {
                this.defaultFor = [] as any;
                for (let item of _data["defaultFor"])
                    this.defaultFor!.push(item);
            }
            this.intervalDescription = _data["intervalDescription"];
            this.paymentSchedule = _data["paymentSchedule"];
            this.transactionType = _data["transactionType"];
        }
    }

    static override fromJS(data: any): MandatePaymentMethodDetailsAcssDebit {
        data = typeof data === 'object' ? data : {};
        let result = new MandatePaymentMethodDetailsAcssDebit();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.defaultFor)) {
            data["defaultFor"] = [];
            for (let item of this.defaultFor)
                data["defaultFor"].push(item);
        }
        data["intervalDescription"] = this.intervalDescription;
        data["paymentSchedule"] = this.paymentSchedule;
        data["transactionType"] = this.transactionType;
        super.toJSON(data);
        return data;
    }
}

export interface IMandatePaymentMethodDetailsAcssDebit extends IStripeEntityOfMandatePaymentMethodDetailsAcssDebit {
    /** List of Stripe products where this mandate can be selected automatically. */
    defaultFor?: string[] | undefined;
    /** Description of the interval. Only required if the 'payment_schedule' parameter is
'interval' or 'combined'. */
    intervalDescription?: string | undefined;
    /** Payment schedule for the mandate.
One of: combined, interval, or sporadic. */
    paymentSchedule?: string | undefined;
    /** Transaction type of the mandate.
One of: business, or personal. */
    transactionType?: string | undefined;
}

export abstract class StripeEntityOfMandatePaymentMethodDetailsAuBecsDebit extends StripeEntity implements IStripeEntityOfMandatePaymentMethodDetailsAuBecsDebit {

    constructor(data?: IStripeEntityOfMandatePaymentMethodDetailsAuBecsDebit) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfMandatePaymentMethodDetailsAuBecsDebit {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfMandatePaymentMethodDetailsAuBecsDebit' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfMandatePaymentMethodDetailsAuBecsDebit extends IStripeEntity {
}

export class MandatePaymentMethodDetailsAuBecsDebit extends StripeEntityOfMandatePaymentMethodDetailsAuBecsDebit implements IMandatePaymentMethodDetailsAuBecsDebit {
    /** The URL of the mandate. This URL generally contains sensitive information about the
customer and should be shared with them exclusively. */
    url?: string | undefined;

    constructor(data?: IMandatePaymentMethodDetailsAuBecsDebit) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.url = _data["url"];
        }
    }

    static override fromJS(data: any): MandatePaymentMethodDetailsAuBecsDebit {
        data = typeof data === 'object' ? data : {};
        let result = new MandatePaymentMethodDetailsAuBecsDebit();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        super.toJSON(data);
        return data;
    }
}

export interface IMandatePaymentMethodDetailsAuBecsDebit extends IStripeEntityOfMandatePaymentMethodDetailsAuBecsDebit {
    /** The URL of the mandate. This URL generally contains sensitive information about the
customer and should be shared with them exclusively. */
    url?: string | undefined;
}

export abstract class StripeEntityOfMandatePaymentMethodDetailsBacsDebit extends StripeEntity implements IStripeEntityOfMandatePaymentMethodDetailsBacsDebit {

    constructor(data?: IStripeEntityOfMandatePaymentMethodDetailsBacsDebit) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfMandatePaymentMethodDetailsBacsDebit {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfMandatePaymentMethodDetailsBacsDebit' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfMandatePaymentMethodDetailsBacsDebit extends IStripeEntity {
}

export class MandatePaymentMethodDetailsBacsDebit extends StripeEntityOfMandatePaymentMethodDetailsBacsDebit implements IMandatePaymentMethodDetailsBacsDebit {
    /** The status of the mandate on the Bacs network. Can be one of pending,
revoked, refused, or accepted.
One of: accepted, pending, refused, or revoked. */
    networkStatus?: string | undefined;
    /** The unique reference identifying the mandate on the Bacs network. */
    reference?: string | undefined;
    /** The URL that will contain the mandate that the customer has signed. */
    url?: string | undefined;

    constructor(data?: IMandatePaymentMethodDetailsBacsDebit) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.networkStatus = _data["networkStatus"];
            this.reference = _data["reference"];
            this.url = _data["url"];
        }
    }

    static override fromJS(data: any): MandatePaymentMethodDetailsBacsDebit {
        data = typeof data === 'object' ? data : {};
        let result = new MandatePaymentMethodDetailsBacsDebit();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["networkStatus"] = this.networkStatus;
        data["reference"] = this.reference;
        data["url"] = this.url;
        super.toJSON(data);
        return data;
    }
}

export interface IMandatePaymentMethodDetailsBacsDebit extends IStripeEntityOfMandatePaymentMethodDetailsBacsDebit {
    /** The status of the mandate on the Bacs network. Can be one of pending,
revoked, refused, or accepted.
One of: accepted, pending, refused, or revoked. */
    networkStatus?: string | undefined;
    /** The unique reference identifying the mandate on the Bacs network. */
    reference?: string | undefined;
    /** The URL that will contain the mandate that the customer has signed. */
    url?: string | undefined;
}

export abstract class StripeEntityOfMandatePaymentMethodDetailsBlik extends StripeEntity implements IStripeEntityOfMandatePaymentMethodDetailsBlik {

    constructor(data?: IStripeEntityOfMandatePaymentMethodDetailsBlik) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfMandatePaymentMethodDetailsBlik {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfMandatePaymentMethodDetailsBlik' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfMandatePaymentMethodDetailsBlik extends IStripeEntity {
}

export class MandatePaymentMethodDetailsBlik extends StripeEntityOfMandatePaymentMethodDetailsBlik implements IMandatePaymentMethodDetailsBlik {
    /** Date at which the mandate expires. */
    expiresAfter?: Date | undefined;
    offSession?: MandatePaymentMethodDetailsBlikOffSession | undefined;
    /** Type of the mandate.
One of: off_session, or on_session. */
    type?: string | undefined;

    constructor(data?: IMandatePaymentMethodDetailsBlik) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.expiresAfter = _data["expiresAfter"] ? new Date(_data["expiresAfter"].toString()) : <any>undefined;
            this.offSession = _data["offSession"] ? MandatePaymentMethodDetailsBlikOffSession.fromJS(_data["offSession"]) : <any>undefined;
            this.type = _data["type"];
        }
    }

    static override fromJS(data: any): MandatePaymentMethodDetailsBlik {
        data = typeof data === 'object' ? data : {};
        let result = new MandatePaymentMethodDetailsBlik();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expiresAfter"] = this.expiresAfter ? this.expiresAfter.toISOString() : <any>undefined;
        data["offSession"] = this.offSession ? this.offSession.toJSON() : <any>undefined;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

export interface IMandatePaymentMethodDetailsBlik extends IStripeEntityOfMandatePaymentMethodDetailsBlik {
    /** Date at which the mandate expires. */
    expiresAfter?: Date | undefined;
    offSession?: MandatePaymentMethodDetailsBlikOffSession | undefined;
    /** Type of the mandate.
One of: off_session, or on_session. */
    type?: string | undefined;
}

export abstract class StripeEntityOfMandatePaymentMethodDetailsBlikOffSession extends StripeEntity implements IStripeEntityOfMandatePaymentMethodDetailsBlikOffSession {

    constructor(data?: IStripeEntityOfMandatePaymentMethodDetailsBlikOffSession) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfMandatePaymentMethodDetailsBlikOffSession {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfMandatePaymentMethodDetailsBlikOffSession' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfMandatePaymentMethodDetailsBlikOffSession extends IStripeEntity {
}

export class MandatePaymentMethodDetailsBlikOffSession extends StripeEntityOfMandatePaymentMethodDetailsBlikOffSession implements IMandatePaymentMethodDetailsBlikOffSession {
    /** Amount of each recurring payment. */
    amount?: number | undefined;
    /** Currency of each recurring payment. */
    currency?: string | undefined;
    /** Frequency interval of each recurring payment.
One of: day, month, week, or year. */
    interval?: string | undefined;
    /** Frequency indicator of each recurring payment. */
    intervalCount?: number | undefined;

    constructor(data?: IMandatePaymentMethodDetailsBlikOffSession) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.amount = _data["amount"];
            this.currency = _data["currency"];
            this.interval = _data["interval"];
            this.intervalCount = _data["intervalCount"];
        }
    }

    static override fromJS(data: any): MandatePaymentMethodDetailsBlikOffSession {
        data = typeof data === 'object' ? data : {};
        let result = new MandatePaymentMethodDetailsBlikOffSession();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["currency"] = this.currency;
        data["interval"] = this.interval;
        data["intervalCount"] = this.intervalCount;
        super.toJSON(data);
        return data;
    }
}

export interface IMandatePaymentMethodDetailsBlikOffSession extends IStripeEntityOfMandatePaymentMethodDetailsBlikOffSession {
    /** Amount of each recurring payment. */
    amount?: number | undefined;
    /** Currency of each recurring payment. */
    currency?: string | undefined;
    /** Frequency interval of each recurring payment.
One of: day, month, week, or year. */
    interval?: string | undefined;
    /** Frequency indicator of each recurring payment. */
    intervalCount?: number | undefined;
}

export abstract class StripeEntityOfMandatePaymentMethodDetailsCard extends StripeEntity implements IStripeEntityOfMandatePaymentMethodDetailsCard {

    constructor(data?: IStripeEntityOfMandatePaymentMethodDetailsCard) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfMandatePaymentMethodDetailsCard {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfMandatePaymentMethodDetailsCard' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfMandatePaymentMethodDetailsCard extends IStripeEntity {
}

export class MandatePaymentMethodDetailsCard extends StripeEntityOfMandatePaymentMethodDetailsCard implements IMandatePaymentMethodDetailsCard {

    constructor(data?: IMandatePaymentMethodDetailsCard) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): MandatePaymentMethodDetailsCard {
        data = typeof data === 'object' ? data : {};
        let result = new MandatePaymentMethodDetailsCard();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IMandatePaymentMethodDetailsCard extends IStripeEntityOfMandatePaymentMethodDetailsCard {
}

export abstract class StripeEntityOfMandatePaymentMethodDetailsCashapp extends StripeEntity implements IStripeEntityOfMandatePaymentMethodDetailsCashapp {

    constructor(data?: IStripeEntityOfMandatePaymentMethodDetailsCashapp) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfMandatePaymentMethodDetailsCashapp {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfMandatePaymentMethodDetailsCashapp' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfMandatePaymentMethodDetailsCashapp extends IStripeEntity {
}

export class MandatePaymentMethodDetailsCashapp extends StripeEntityOfMandatePaymentMethodDetailsCashapp implements IMandatePaymentMethodDetailsCashapp {

    constructor(data?: IMandatePaymentMethodDetailsCashapp) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): MandatePaymentMethodDetailsCashapp {
        data = typeof data === 'object' ? data : {};
        let result = new MandatePaymentMethodDetailsCashapp();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IMandatePaymentMethodDetailsCashapp extends IStripeEntityOfMandatePaymentMethodDetailsCashapp {
}

export abstract class StripeEntityOfMandatePaymentMethodDetailsLink extends StripeEntity implements IStripeEntityOfMandatePaymentMethodDetailsLink {

    constructor(data?: IStripeEntityOfMandatePaymentMethodDetailsLink) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfMandatePaymentMethodDetailsLink {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfMandatePaymentMethodDetailsLink' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfMandatePaymentMethodDetailsLink extends IStripeEntity {
}

export class MandatePaymentMethodDetailsLink extends StripeEntityOfMandatePaymentMethodDetailsLink implements IMandatePaymentMethodDetailsLink {

    constructor(data?: IMandatePaymentMethodDetailsLink) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): MandatePaymentMethodDetailsLink {
        data = typeof data === 'object' ? data : {};
        let result = new MandatePaymentMethodDetailsLink();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IMandatePaymentMethodDetailsLink extends IStripeEntityOfMandatePaymentMethodDetailsLink {
}

export abstract class StripeEntityOfMandatePaymentMethodDetailsPaypal extends StripeEntity implements IStripeEntityOfMandatePaymentMethodDetailsPaypal {

    constructor(data?: IStripeEntityOfMandatePaymentMethodDetailsPaypal) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfMandatePaymentMethodDetailsPaypal {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfMandatePaymentMethodDetailsPaypal' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfMandatePaymentMethodDetailsPaypal extends IStripeEntity {
}

export class MandatePaymentMethodDetailsPaypal extends StripeEntityOfMandatePaymentMethodDetailsPaypal implements IMandatePaymentMethodDetailsPaypal {
    /** The PayPal Billing Agreement ID (BAID). This is an ID generated by PayPal which
represents the mandate between the merchant and the customer. */
    billingAgreementId?: string | undefined;
    /** PayPal account PayerID. This identifier uniquely identifies the PayPal customer. */
    payerId?: string | undefined;

    constructor(data?: IMandatePaymentMethodDetailsPaypal) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.billingAgreementId = _data["billingAgreementId"];
            this.payerId = _data["payerId"];
        }
    }

    static override fromJS(data: any): MandatePaymentMethodDetailsPaypal {
        data = typeof data === 'object' ? data : {};
        let result = new MandatePaymentMethodDetailsPaypal();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["billingAgreementId"] = this.billingAgreementId;
        data["payerId"] = this.payerId;
        super.toJSON(data);
        return data;
    }
}

export interface IMandatePaymentMethodDetailsPaypal extends IStripeEntityOfMandatePaymentMethodDetailsPaypal {
    /** The PayPal Billing Agreement ID (BAID). This is an ID generated by PayPal which
represents the mandate between the merchant and the customer. */
    billingAgreementId?: string | undefined;
    /** PayPal account PayerID. This identifier uniquely identifies the PayPal customer. */
    payerId?: string | undefined;
}

export abstract class StripeEntityOfMandatePaymentMethodDetailsSepaDebit extends StripeEntity implements IStripeEntityOfMandatePaymentMethodDetailsSepaDebit {

    constructor(data?: IStripeEntityOfMandatePaymentMethodDetailsSepaDebit) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfMandatePaymentMethodDetailsSepaDebit {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfMandatePaymentMethodDetailsSepaDebit' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfMandatePaymentMethodDetailsSepaDebit extends IStripeEntity {
}

export class MandatePaymentMethodDetailsSepaDebit extends StripeEntityOfMandatePaymentMethodDetailsSepaDebit implements IMandatePaymentMethodDetailsSepaDebit {
    /** The unique reference of the mandate. */
    reference?: string | undefined;
    /** The URL of the mandate. This URL generally contains sensitive information about the
customer and should be shared with them exclusively. */
    url?: string | undefined;

    constructor(data?: IMandatePaymentMethodDetailsSepaDebit) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.reference = _data["reference"];
            this.url = _data["url"];
        }
    }

    static override fromJS(data: any): MandatePaymentMethodDetailsSepaDebit {
        data = typeof data === 'object' ? data : {};
        let result = new MandatePaymentMethodDetailsSepaDebit();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reference"] = this.reference;
        data["url"] = this.url;
        super.toJSON(data);
        return data;
    }
}

export interface IMandatePaymentMethodDetailsSepaDebit extends IStripeEntityOfMandatePaymentMethodDetailsSepaDebit {
    /** The unique reference of the mandate. */
    reference?: string | undefined;
    /** The URL of the mandate. This URL generally contains sensitive information about the
customer and should be shared with them exclusively. */
    url?: string | undefined;
}

export abstract class StripeEntityOfMandatePaymentMethodDetailsUsBankAccount extends StripeEntity implements IStripeEntityOfMandatePaymentMethodDetailsUsBankAccount {

    constructor(data?: IStripeEntityOfMandatePaymentMethodDetailsUsBankAccount) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfMandatePaymentMethodDetailsUsBankAccount {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfMandatePaymentMethodDetailsUsBankAccount' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfMandatePaymentMethodDetailsUsBankAccount extends IStripeEntity {
}

export class MandatePaymentMethodDetailsUsBankAccount extends StripeEntityOfMandatePaymentMethodDetailsUsBankAccount implements IMandatePaymentMethodDetailsUsBankAccount {

    constructor(data?: IMandatePaymentMethodDetailsUsBankAccount) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): MandatePaymentMethodDetailsUsBankAccount {
        data = typeof data === 'object' ? data : {};
        let result = new MandatePaymentMethodDetailsUsBankAccount();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IMandatePaymentMethodDetailsUsBankAccount extends IStripeEntityOfMandatePaymentMethodDetailsUsBankAccount {
}

export abstract class StripeEntityOfMandateSingleUse extends StripeEntity implements IStripeEntityOfMandateSingleUse {

    constructor(data?: IStripeEntityOfMandateSingleUse) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfMandateSingleUse {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfMandateSingleUse' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfMandateSingleUse extends IStripeEntity {
}

export class MandateSingleUse extends StripeEntityOfMandateSingleUse implements IMandateSingleUse {
    /** On a single use mandate, the amount of the payment. */
    amount?: number;
    /** On a single use mandate, the currency of the payment. */
    currency?: string | undefined;

    constructor(data?: IMandateSingleUse) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.amount = _data["amount"];
            this.currency = _data["currency"];
        }
    }

    static override fromJS(data: any): MandateSingleUse {
        data = typeof data === 'object' ? data : {};
        let result = new MandateSingleUse();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["currency"] = this.currency;
        super.toJSON(data);
        return data;
    }
}

export interface IMandateSingleUse extends IStripeEntityOfMandateSingleUse {
    /** On a single use mandate, the amount of the payment. */
    amount?: number;
    /** On a single use mandate, the currency of the payment. */
    currency?: string | undefined;
}

/** Represents a generic expandable field. */
export class ExpandableFieldOfMandate implements IExpandableFieldOfMandate {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: Mandate | undefined;

    constructor(data?: IExpandableFieldOfMandate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.expandedObject = _data["expandedObject"] ? Mandate.fromJS(_data["expandedObject"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExpandableFieldOfMandate {
        data = typeof data === 'object' ? data : {};
        let result = new ExpandableFieldOfMandate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["expandedObject"] = this.expandedObject ? this.expandedObject.toJSON() : <any>undefined;
        return data;
    }
}

/** Represents a generic expandable field. */
export interface IExpandableFieldOfMandate {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: Mandate | undefined;
}

export abstract class StripeEntityOfSetupAttemptPaymentMethodDetailsBlik extends StripeEntity implements IStripeEntityOfSetupAttemptPaymentMethodDetailsBlik {

    constructor(data?: IStripeEntityOfSetupAttemptPaymentMethodDetailsBlik) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSetupAttemptPaymentMethodDetailsBlik {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSetupAttemptPaymentMethodDetailsBlik' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSetupAttemptPaymentMethodDetailsBlik extends IStripeEntity {
}

export class SetupAttemptPaymentMethodDetailsBlik extends StripeEntityOfSetupAttemptPaymentMethodDetailsBlik implements ISetupAttemptPaymentMethodDetailsBlik {

    constructor(data?: ISetupAttemptPaymentMethodDetailsBlik) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): SetupAttemptPaymentMethodDetailsBlik {
        data = typeof data === 'object' ? data : {};
        let result = new SetupAttemptPaymentMethodDetailsBlik();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ISetupAttemptPaymentMethodDetailsBlik extends IStripeEntityOfSetupAttemptPaymentMethodDetailsBlik {
}

export abstract class StripeEntityOfSetupAttemptPaymentMethodDetailsBoleto extends StripeEntity implements IStripeEntityOfSetupAttemptPaymentMethodDetailsBoleto {

    constructor(data?: IStripeEntityOfSetupAttemptPaymentMethodDetailsBoleto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSetupAttemptPaymentMethodDetailsBoleto {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSetupAttemptPaymentMethodDetailsBoleto' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSetupAttemptPaymentMethodDetailsBoleto extends IStripeEntity {
}

export class SetupAttemptPaymentMethodDetailsBoleto extends StripeEntityOfSetupAttemptPaymentMethodDetailsBoleto implements ISetupAttemptPaymentMethodDetailsBoleto {

    constructor(data?: ISetupAttemptPaymentMethodDetailsBoleto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): SetupAttemptPaymentMethodDetailsBoleto {
        data = typeof data === 'object' ? data : {};
        let result = new SetupAttemptPaymentMethodDetailsBoleto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ISetupAttemptPaymentMethodDetailsBoleto extends IStripeEntityOfSetupAttemptPaymentMethodDetailsBoleto {
}

export abstract class StripeEntityOfSetupAttemptPaymentMethodDetailsCard extends StripeEntity implements IStripeEntityOfSetupAttemptPaymentMethodDetailsCard {

    constructor(data?: IStripeEntityOfSetupAttemptPaymentMethodDetailsCard) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSetupAttemptPaymentMethodDetailsCard {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSetupAttemptPaymentMethodDetailsCard' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSetupAttemptPaymentMethodDetailsCard extends IStripeEntity {
}

export class SetupAttemptPaymentMethodDetailsCard extends StripeEntityOfSetupAttemptPaymentMethodDetailsCard implements ISetupAttemptPaymentMethodDetailsCard {
    /** Card brand. Can be amex, diners, discover, eftpos_au,
jcb, mastercard, unionpay, visa, or unknown. */
    brand?: string | undefined;
    /** Check results by Card networks on Card address and CVC at the time of authorization. */
    checks?: SetupAttemptPaymentMethodDetailsCardChecks | undefined;
    /** Two-letter ISO code representing the country of the card. You could use this attribute
to get a sense of the international breakdown of cards you've collected. */
    country?: string | undefined;
    /** A high-level description of the type of cards issued in this range. (For internal use
only and not typically available in standard API requests.). */
    description?: string | undefined;
    /** Two-digit number representing the card's expiration month. */
    expMonth?: number | undefined;
    /** Four-digit number representing the card's expiration year. */
    expYear?: number | undefined;
    /** Uniquely identifies this particular card number. You can use this attribute to check
whether two customers who’ve signed up with you are using the same card number, for
example. For payment methods that tokenize card information (Apple Pay, Google Pay), the
tokenized number might be provided instead of the underlying card number.
            
Starting May 1, 2021, card fingerprint in India for Connect will change to allow two
fingerprints for the same card --- one for India and one for the rest of the world.. */
    fingerprint?: string | undefined;
    /** Card funding type. Can be credit, debit, prepaid, or
unknown. */
    funding?: string | undefined;
    /** Issuer identification number of the card. (For internal use only and not typically
available in standard API requests.). */
    iin?: string | undefined;
    /** The name of the card's issuing bank. (For internal use only and not typically available
in standard API requests.). */
    issuer?: string | undefined;
    /** The last four digits of the card. */
    last4?: string | undefined;
    /** Identifies which network this charge was processed on. Can be amex,
cartes_bancaires, diners, discover, eftpos_au,
interac, jcb, mastercard, unionpay, visa, or
unknown. */
    network?: string | undefined;
    /** Populated if this authorization used 3D Secure authentication. */
    threeDSecure?: SetupAttemptPaymentMethodDetailsCardThreeDSecure | undefined;
    /** If this Card is part of a card wallet, this contains the details of the card wallet. */
    wallet?: SetupAttemptPaymentMethodDetailsCardWallet | undefined;

    constructor(data?: ISetupAttemptPaymentMethodDetailsCard) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.brand = _data["brand"];
            this.checks = _data["checks"] ? SetupAttemptPaymentMethodDetailsCardChecks.fromJS(_data["checks"]) : <any>undefined;
            this.country = _data["country"];
            this.description = _data["description"];
            this.expMonth = _data["expMonth"];
            this.expYear = _data["expYear"];
            this.fingerprint = _data["fingerprint"];
            this.funding = _data["funding"];
            this.iin = _data["iin"];
            this.issuer = _data["issuer"];
            this.last4 = _data["last4"];
            this.network = _data["network"];
            this.threeDSecure = _data["threeDSecure"] ? SetupAttemptPaymentMethodDetailsCardThreeDSecure.fromJS(_data["threeDSecure"]) : <any>undefined;
            this.wallet = _data["wallet"] ? SetupAttemptPaymentMethodDetailsCardWallet.fromJS(_data["wallet"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): SetupAttemptPaymentMethodDetailsCard {
        data = typeof data === 'object' ? data : {};
        let result = new SetupAttemptPaymentMethodDetailsCard();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brand"] = this.brand;
        data["checks"] = this.checks ? this.checks.toJSON() : <any>undefined;
        data["country"] = this.country;
        data["description"] = this.description;
        data["expMonth"] = this.expMonth;
        data["expYear"] = this.expYear;
        data["fingerprint"] = this.fingerprint;
        data["funding"] = this.funding;
        data["iin"] = this.iin;
        data["issuer"] = this.issuer;
        data["last4"] = this.last4;
        data["network"] = this.network;
        data["threeDSecure"] = this.threeDSecure ? this.threeDSecure.toJSON() : <any>undefined;
        data["wallet"] = this.wallet ? this.wallet.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface ISetupAttemptPaymentMethodDetailsCard extends IStripeEntityOfSetupAttemptPaymentMethodDetailsCard {
    /** Card brand. Can be amex, diners, discover, eftpos_au,
jcb, mastercard, unionpay, visa, or unknown. */
    brand?: string | undefined;
    /** Check results by Card networks on Card address and CVC at the time of authorization. */
    checks?: SetupAttemptPaymentMethodDetailsCardChecks | undefined;
    /** Two-letter ISO code representing the country of the card. You could use this attribute
to get a sense of the international breakdown of cards you've collected. */
    country?: string | undefined;
    /** A high-level description of the type of cards issued in this range. (For internal use
only and not typically available in standard API requests.). */
    description?: string | undefined;
    /** Two-digit number representing the card's expiration month. */
    expMonth?: number | undefined;
    /** Four-digit number representing the card's expiration year. */
    expYear?: number | undefined;
    /** Uniquely identifies this particular card number. You can use this attribute to check
whether two customers who’ve signed up with you are using the same card number, for
example. For payment methods that tokenize card information (Apple Pay, Google Pay), the
tokenized number might be provided instead of the underlying card number.
            
Starting May 1, 2021, card fingerprint in India for Connect will change to allow two
fingerprints for the same card --- one for India and one for the rest of the world.. */
    fingerprint?: string | undefined;
    /** Card funding type. Can be credit, debit, prepaid, or
unknown. */
    funding?: string | undefined;
    /** Issuer identification number of the card. (For internal use only and not typically
available in standard API requests.). */
    iin?: string | undefined;
    /** The name of the card's issuing bank. (For internal use only and not typically available
in standard API requests.). */
    issuer?: string | undefined;
    /** The last four digits of the card. */
    last4?: string | undefined;
    /** Identifies which network this charge was processed on. Can be amex,
cartes_bancaires, diners, discover, eftpos_au,
interac, jcb, mastercard, unionpay, visa, or
unknown. */
    network?: string | undefined;
    /** Populated if this authorization used 3D Secure authentication. */
    threeDSecure?: SetupAttemptPaymentMethodDetailsCardThreeDSecure | undefined;
    /** If this Card is part of a card wallet, this contains the details of the card wallet. */
    wallet?: SetupAttemptPaymentMethodDetailsCardWallet | undefined;
}

export abstract class StripeEntityOfSetupAttemptPaymentMethodDetailsCardChecks extends StripeEntity implements IStripeEntityOfSetupAttemptPaymentMethodDetailsCardChecks {

    constructor(data?: IStripeEntityOfSetupAttemptPaymentMethodDetailsCardChecks) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSetupAttemptPaymentMethodDetailsCardChecks {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSetupAttemptPaymentMethodDetailsCardChecks' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSetupAttemptPaymentMethodDetailsCardChecks extends IStripeEntity {
}

export class SetupAttemptPaymentMethodDetailsCardChecks extends StripeEntityOfSetupAttemptPaymentMethodDetailsCardChecks implements ISetupAttemptPaymentMethodDetailsCardChecks {
    /** If a address line1 was provided, results of the check, one of pass, fail,
unavailable, or unchecked. */
    addressLine1Check?: string | undefined;
    /** If a address postal code was provided, results of the check, one of pass,
fail, unavailable, or unchecked. */
    addressPostalCodeCheck?: string | undefined;
    /** If a CVC was provided, results of the check, one of pass, fail,
unavailable, or unchecked. */
    cvcCheck?: string | undefined;

    constructor(data?: ISetupAttemptPaymentMethodDetailsCardChecks) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.addressLine1Check = _data["addressLine1Check"];
            this.addressPostalCodeCheck = _data["addressPostalCodeCheck"];
            this.cvcCheck = _data["cvcCheck"];
        }
    }

    static override fromJS(data: any): SetupAttemptPaymentMethodDetailsCardChecks {
        data = typeof data === 'object' ? data : {};
        let result = new SetupAttemptPaymentMethodDetailsCardChecks();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["addressLine1Check"] = this.addressLine1Check;
        data["addressPostalCodeCheck"] = this.addressPostalCodeCheck;
        data["cvcCheck"] = this.cvcCheck;
        super.toJSON(data);
        return data;
    }
}

export interface ISetupAttemptPaymentMethodDetailsCardChecks extends IStripeEntityOfSetupAttemptPaymentMethodDetailsCardChecks {
    /** If a address line1 was provided, results of the check, one of pass, fail,
unavailable, or unchecked. */
    addressLine1Check?: string | undefined;
    /** If a address postal code was provided, results of the check, one of pass,
fail, unavailable, or unchecked. */
    addressPostalCodeCheck?: string | undefined;
    /** If a CVC was provided, results of the check, one of pass, fail,
unavailable, or unchecked. */
    cvcCheck?: string | undefined;
}

export abstract class StripeEntityOfSetupAttemptPaymentMethodDetailsCardThreeDSecure extends StripeEntity implements IStripeEntityOfSetupAttemptPaymentMethodDetailsCardThreeDSecure {

    constructor(data?: IStripeEntityOfSetupAttemptPaymentMethodDetailsCardThreeDSecure) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSetupAttemptPaymentMethodDetailsCardThreeDSecure {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSetupAttemptPaymentMethodDetailsCardThreeDSecure' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSetupAttemptPaymentMethodDetailsCardThreeDSecure extends IStripeEntity {
}

export class SetupAttemptPaymentMethodDetailsCardThreeDSecure extends StripeEntityOfSetupAttemptPaymentMethodDetailsCardThreeDSecure implements ISetupAttemptPaymentMethodDetailsCardThreeDSecure {
    /** For authenticated transactions: how the customer was authenticated by the issuing bank.
One of: challenge, or frictionless. */
    authenticationFlow?: string | undefined;
    /** Indicates the outcome of 3D Secure authentication.
One of: attempt_acknowledged, authenticated, exempted,
failed, not_supported, or processing_error. */
    result?: string | undefined;
    /** Additional information about why 3D Secure succeeded or failed based on the
result.
One of: abandoned, bypassed, canceled, card_not_enrolled,
network_not_supported, protocol_error, or rejected. */
    resultReason?: string | undefined;
    /** The version of 3D Secure that was used.
One of: 1.0.2, 2.1.0, or 2.2.0. */
    version?: string | undefined;

    constructor(data?: ISetupAttemptPaymentMethodDetailsCardThreeDSecure) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.authenticationFlow = _data["authenticationFlow"];
            this.result = _data["result"];
            this.resultReason = _data["resultReason"];
            this.version = _data["version"];
        }
    }

    static override fromJS(data: any): SetupAttemptPaymentMethodDetailsCardThreeDSecure {
        data = typeof data === 'object' ? data : {};
        let result = new SetupAttemptPaymentMethodDetailsCardThreeDSecure();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authenticationFlow"] = this.authenticationFlow;
        data["result"] = this.result;
        data["resultReason"] = this.resultReason;
        data["version"] = this.version;
        super.toJSON(data);
        return data;
    }
}

export interface ISetupAttemptPaymentMethodDetailsCardThreeDSecure extends IStripeEntityOfSetupAttemptPaymentMethodDetailsCardThreeDSecure {
    /** For authenticated transactions: how the customer was authenticated by the issuing bank.
One of: challenge, or frictionless. */
    authenticationFlow?: string | undefined;
    /** Indicates the outcome of 3D Secure authentication.
One of: attempt_acknowledged, authenticated, exempted,
failed, not_supported, or processing_error. */
    result?: string | undefined;
    /** Additional information about why 3D Secure succeeded or failed based on the
result.
One of: abandoned, bypassed, canceled, card_not_enrolled,
network_not_supported, protocol_error, or rejected. */
    resultReason?: string | undefined;
    /** The version of 3D Secure that was used.
One of: 1.0.2, 2.1.0, or 2.2.0. */
    version?: string | undefined;
}

export abstract class StripeEntityOfSetupAttemptPaymentMethodDetailsCardWallet extends StripeEntity implements IStripeEntityOfSetupAttemptPaymentMethodDetailsCardWallet {

    constructor(data?: IStripeEntityOfSetupAttemptPaymentMethodDetailsCardWallet) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSetupAttemptPaymentMethodDetailsCardWallet {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSetupAttemptPaymentMethodDetailsCardWallet' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSetupAttemptPaymentMethodDetailsCardWallet extends IStripeEntity {
}

export class SetupAttemptPaymentMethodDetailsCardWallet extends StripeEntityOfSetupAttemptPaymentMethodDetailsCardWallet implements ISetupAttemptPaymentMethodDetailsCardWallet {
    applePay?: SetupAttemptPaymentMethodDetailsCardWalletApplePay | undefined;
    googlePay?: SetupAttemptPaymentMethodDetailsCardWalletGooglePay | undefined;
    /** The type of the card wallet, one of apple_pay, google_pay, or link.
An additional hash is included on the Wallet subhash with a name matching this value. It
contains additional information specific to the card wallet type.
One of: apple_pay, google_pay, or link. */
    type?: string | undefined;

    constructor(data?: ISetupAttemptPaymentMethodDetailsCardWallet) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.applePay = _data["applePay"] ? SetupAttemptPaymentMethodDetailsCardWalletApplePay.fromJS(_data["applePay"]) : <any>undefined;
            this.googlePay = _data["googlePay"] ? SetupAttemptPaymentMethodDetailsCardWalletGooglePay.fromJS(_data["googlePay"]) : <any>undefined;
            this.type = _data["type"];
        }
    }

    static override fromJS(data: any): SetupAttemptPaymentMethodDetailsCardWallet {
        data = typeof data === 'object' ? data : {};
        let result = new SetupAttemptPaymentMethodDetailsCardWallet();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["applePay"] = this.applePay ? this.applePay.toJSON() : <any>undefined;
        data["googlePay"] = this.googlePay ? this.googlePay.toJSON() : <any>undefined;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

export interface ISetupAttemptPaymentMethodDetailsCardWallet extends IStripeEntityOfSetupAttemptPaymentMethodDetailsCardWallet {
    applePay?: SetupAttemptPaymentMethodDetailsCardWalletApplePay | undefined;
    googlePay?: SetupAttemptPaymentMethodDetailsCardWalletGooglePay | undefined;
    /** The type of the card wallet, one of apple_pay, google_pay, or link.
An additional hash is included on the Wallet subhash with a name matching this value. It
contains additional information specific to the card wallet type.
One of: apple_pay, google_pay, or link. */
    type?: string | undefined;
}

export abstract class StripeEntityOfSetupAttemptPaymentMethodDetailsCardWalletApplePay extends StripeEntity implements IStripeEntityOfSetupAttemptPaymentMethodDetailsCardWalletApplePay {

    constructor(data?: IStripeEntityOfSetupAttemptPaymentMethodDetailsCardWalletApplePay) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSetupAttemptPaymentMethodDetailsCardWalletApplePay {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSetupAttemptPaymentMethodDetailsCardWalletApplePay' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSetupAttemptPaymentMethodDetailsCardWalletApplePay extends IStripeEntity {
}

export class SetupAttemptPaymentMethodDetailsCardWalletApplePay extends StripeEntityOfSetupAttemptPaymentMethodDetailsCardWalletApplePay implements ISetupAttemptPaymentMethodDetailsCardWalletApplePay {

    constructor(data?: ISetupAttemptPaymentMethodDetailsCardWalletApplePay) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): SetupAttemptPaymentMethodDetailsCardWalletApplePay {
        data = typeof data === 'object' ? data : {};
        let result = new SetupAttemptPaymentMethodDetailsCardWalletApplePay();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ISetupAttemptPaymentMethodDetailsCardWalletApplePay extends IStripeEntityOfSetupAttemptPaymentMethodDetailsCardWalletApplePay {
}

export abstract class StripeEntityOfSetupAttemptPaymentMethodDetailsCardWalletGooglePay extends StripeEntity implements IStripeEntityOfSetupAttemptPaymentMethodDetailsCardWalletGooglePay {

    constructor(data?: IStripeEntityOfSetupAttemptPaymentMethodDetailsCardWalletGooglePay) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSetupAttemptPaymentMethodDetailsCardWalletGooglePay {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSetupAttemptPaymentMethodDetailsCardWalletGooglePay' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSetupAttemptPaymentMethodDetailsCardWalletGooglePay extends IStripeEntity {
}

export class SetupAttemptPaymentMethodDetailsCardWalletGooglePay extends StripeEntityOfSetupAttemptPaymentMethodDetailsCardWalletGooglePay implements ISetupAttemptPaymentMethodDetailsCardWalletGooglePay {

    constructor(data?: ISetupAttemptPaymentMethodDetailsCardWalletGooglePay) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): SetupAttemptPaymentMethodDetailsCardWalletGooglePay {
        data = typeof data === 'object' ? data : {};
        let result = new SetupAttemptPaymentMethodDetailsCardWalletGooglePay();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ISetupAttemptPaymentMethodDetailsCardWalletGooglePay extends IStripeEntityOfSetupAttemptPaymentMethodDetailsCardWalletGooglePay {
}

export abstract class StripeEntityOfSetupAttemptPaymentMethodDetailsCardPresent extends StripeEntity implements IStripeEntityOfSetupAttemptPaymentMethodDetailsCardPresent {

    constructor(data?: IStripeEntityOfSetupAttemptPaymentMethodDetailsCardPresent) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSetupAttemptPaymentMethodDetailsCardPresent {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSetupAttemptPaymentMethodDetailsCardPresent' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSetupAttemptPaymentMethodDetailsCardPresent extends IStripeEntity {
}

export class SetupAttemptPaymentMethodDetailsCardPresent extends StripeEntityOfSetupAttemptPaymentMethodDetailsCardPresent implements ISetupAttemptPaymentMethodDetailsCardPresent {
    /** (ID of the PaymentMethod)
The ID of the Card PaymentMethod which was generated by this SetupAttempt. */
    generatedCardId?: string | undefined;
    /** (Expanded)
The ID of the Card PaymentMethod which was generated by this SetupAttempt.
            
For more information, see the expand documentation. */
    generatedCard?: PaymentMethod | undefined;
    internalGeneratedCard?: ExpandableFieldOfPaymentMethod | undefined;

    constructor(data?: ISetupAttemptPaymentMethodDetailsCardPresent) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.generatedCardId = _data["generatedCardId"];
            this.generatedCard = _data["generatedCard"] ? PaymentMethod.fromJS(_data["generatedCard"]) : <any>undefined;
            this.internalGeneratedCard = _data["internalGeneratedCard"] ? ExpandableFieldOfPaymentMethod.fromJS(_data["internalGeneratedCard"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): SetupAttemptPaymentMethodDetailsCardPresent {
        data = typeof data === 'object' ? data : {};
        let result = new SetupAttemptPaymentMethodDetailsCardPresent();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["generatedCardId"] = this.generatedCardId;
        data["generatedCard"] = this.generatedCard ? this.generatedCard.toJSON() : <any>undefined;
        data["internalGeneratedCard"] = this.internalGeneratedCard ? this.internalGeneratedCard.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface ISetupAttemptPaymentMethodDetailsCardPresent extends IStripeEntityOfSetupAttemptPaymentMethodDetailsCardPresent {
    /** (ID of the PaymentMethod)
The ID of the Card PaymentMethod which was generated by this SetupAttempt. */
    generatedCardId?: string | undefined;
    /** (Expanded)
The ID of the Card PaymentMethod which was generated by this SetupAttempt.
            
For more information, see the expand documentation. */
    generatedCard?: PaymentMethod | undefined;
    internalGeneratedCard?: ExpandableFieldOfPaymentMethod | undefined;
}

export abstract class StripeEntityOfSetupAttemptPaymentMethodDetailsCashapp extends StripeEntity implements IStripeEntityOfSetupAttemptPaymentMethodDetailsCashapp {

    constructor(data?: IStripeEntityOfSetupAttemptPaymentMethodDetailsCashapp) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSetupAttemptPaymentMethodDetailsCashapp {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSetupAttemptPaymentMethodDetailsCashapp' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSetupAttemptPaymentMethodDetailsCashapp extends IStripeEntity {
}

export class SetupAttemptPaymentMethodDetailsCashapp extends StripeEntityOfSetupAttemptPaymentMethodDetailsCashapp implements ISetupAttemptPaymentMethodDetailsCashapp {

    constructor(data?: ISetupAttemptPaymentMethodDetailsCashapp) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): SetupAttemptPaymentMethodDetailsCashapp {
        data = typeof data === 'object' ? data : {};
        let result = new SetupAttemptPaymentMethodDetailsCashapp();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ISetupAttemptPaymentMethodDetailsCashapp extends IStripeEntityOfSetupAttemptPaymentMethodDetailsCashapp {
}

export abstract class StripeEntityOfSetupAttemptPaymentMethodDetailsIdeal extends StripeEntity implements IStripeEntityOfSetupAttemptPaymentMethodDetailsIdeal {

    constructor(data?: IStripeEntityOfSetupAttemptPaymentMethodDetailsIdeal) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSetupAttemptPaymentMethodDetailsIdeal {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSetupAttemptPaymentMethodDetailsIdeal' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSetupAttemptPaymentMethodDetailsIdeal extends IStripeEntity {
}

export class SetupAttemptPaymentMethodDetailsIdeal extends StripeEntityOfSetupAttemptPaymentMethodDetailsIdeal implements ISetupAttemptPaymentMethodDetailsIdeal {
    /** The customer's bank. Can be one of abn_amro, asn_bank, bunq,
handelsbanken, ing, knab, moneyou, rabobank,
regiobank, revolut, sns_bank, triodos_bank,
van_lanschot, or yoursafe.
One of: abn_amro, asn_bank, bunq, handelsbanken, ing,
knab, moneyou, rabobank, regiobank, revolut,
sns_bank, triodos_bank, van_lanschot, or yoursafe. */
    bank?: string | undefined;
    /** The Bank Identifier Code of the customer's bank.
One of: ABNANL2A, ASNBNL21, BITSNL2A, BUNQNL2A,
FVLBNL22, HANDNL2A, INGBNL2A, KNABNL2H, MOYONL21,
RABONL2U, RBRBNL21, REVOIE23, REVOLT21, SNSBNL2A, or
TRIONL2U. */
    bic?: string | undefined;
    /** (ID of the PaymentMethod)
The ID of the SEPA Direct Debit PaymentMethod which was generated by this SetupAttempt. */
    generatedSepaDebitId?: string | undefined;
    /** (Expanded)
The ID of the SEPA Direct Debit PaymentMethod which was generated by this SetupAttempt.
            
For more information, see the expand documentation. */
    generatedSepaDebit?: PaymentMethod | undefined;
    internalGeneratedSepaDebit?: ExpandableFieldOfPaymentMethod | undefined;
    /** (ID of the Mandate)
The mandate for the SEPA Direct Debit PaymentMethod which was generated by this
SetupAttempt. */
    generatedSepaDebitMandateId?: string | undefined;
    /** (Expanded)
The mandate for the SEPA Direct Debit PaymentMethod which was generated by this
SetupAttempt.
            
For more information, see the expand documentation. */
    generatedSepaDebitMandate?: Mandate | undefined;
    internalGeneratedSepaDebitMandate?: ExpandableFieldOfMandate | undefined;
    /** Last four characters of the IBAN. */
    ibanLast4?: string | undefined;
    /** Owner's verified full name. Values are verified or provided by iDEAL directly (if
supported) at the time of authorization or settlement. They cannot be set or mutated. */
    verifiedName?: string | undefined;

    constructor(data?: ISetupAttemptPaymentMethodDetailsIdeal) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.bank = _data["bank"];
            this.bic = _data["bic"];
            this.generatedSepaDebitId = _data["generatedSepaDebitId"];
            this.generatedSepaDebit = _data["generatedSepaDebit"] ? PaymentMethod.fromJS(_data["generatedSepaDebit"]) : <any>undefined;
            this.internalGeneratedSepaDebit = _data["internalGeneratedSepaDebit"] ? ExpandableFieldOfPaymentMethod.fromJS(_data["internalGeneratedSepaDebit"]) : <any>undefined;
            this.generatedSepaDebitMandateId = _data["generatedSepaDebitMandateId"];
            this.generatedSepaDebitMandate = _data["generatedSepaDebitMandate"] ? Mandate.fromJS(_data["generatedSepaDebitMandate"]) : <any>undefined;
            this.internalGeneratedSepaDebitMandate = _data["internalGeneratedSepaDebitMandate"] ? ExpandableFieldOfMandate.fromJS(_data["internalGeneratedSepaDebitMandate"]) : <any>undefined;
            this.ibanLast4 = _data["ibanLast4"];
            this.verifiedName = _data["verifiedName"];
        }
    }

    static override fromJS(data: any): SetupAttemptPaymentMethodDetailsIdeal {
        data = typeof data === 'object' ? data : {};
        let result = new SetupAttemptPaymentMethodDetailsIdeal();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bank"] = this.bank;
        data["bic"] = this.bic;
        data["generatedSepaDebitId"] = this.generatedSepaDebitId;
        data["generatedSepaDebit"] = this.generatedSepaDebit ? this.generatedSepaDebit.toJSON() : <any>undefined;
        data["internalGeneratedSepaDebit"] = this.internalGeneratedSepaDebit ? this.internalGeneratedSepaDebit.toJSON() : <any>undefined;
        data["generatedSepaDebitMandateId"] = this.generatedSepaDebitMandateId;
        data["generatedSepaDebitMandate"] = this.generatedSepaDebitMandate ? this.generatedSepaDebitMandate.toJSON() : <any>undefined;
        data["internalGeneratedSepaDebitMandate"] = this.internalGeneratedSepaDebitMandate ? this.internalGeneratedSepaDebitMandate.toJSON() : <any>undefined;
        data["ibanLast4"] = this.ibanLast4;
        data["verifiedName"] = this.verifiedName;
        super.toJSON(data);
        return data;
    }
}

export interface ISetupAttemptPaymentMethodDetailsIdeal extends IStripeEntityOfSetupAttemptPaymentMethodDetailsIdeal {
    /** The customer's bank. Can be one of abn_amro, asn_bank, bunq,
handelsbanken, ing, knab, moneyou, rabobank,
regiobank, revolut, sns_bank, triodos_bank,
van_lanschot, or yoursafe.
One of: abn_amro, asn_bank, bunq, handelsbanken, ing,
knab, moneyou, rabobank, regiobank, revolut,
sns_bank, triodos_bank, van_lanschot, or yoursafe. */
    bank?: string | undefined;
    /** The Bank Identifier Code of the customer's bank.
One of: ABNANL2A, ASNBNL21, BITSNL2A, BUNQNL2A,
FVLBNL22, HANDNL2A, INGBNL2A, KNABNL2H, MOYONL21,
RABONL2U, RBRBNL21, REVOIE23, REVOLT21, SNSBNL2A, or
TRIONL2U. */
    bic?: string | undefined;
    /** (ID of the PaymentMethod)
The ID of the SEPA Direct Debit PaymentMethod which was generated by this SetupAttempt. */
    generatedSepaDebitId?: string | undefined;
    /** (Expanded)
The ID of the SEPA Direct Debit PaymentMethod which was generated by this SetupAttempt.
            
For more information, see the expand documentation. */
    generatedSepaDebit?: PaymentMethod | undefined;
    internalGeneratedSepaDebit?: ExpandableFieldOfPaymentMethod | undefined;
    /** (ID of the Mandate)
The mandate for the SEPA Direct Debit PaymentMethod which was generated by this
SetupAttempt. */
    generatedSepaDebitMandateId?: string | undefined;
    /** (Expanded)
The mandate for the SEPA Direct Debit PaymentMethod which was generated by this
SetupAttempt.
            
For more information, see the expand documentation. */
    generatedSepaDebitMandate?: Mandate | undefined;
    internalGeneratedSepaDebitMandate?: ExpandableFieldOfMandate | undefined;
    /** Last four characters of the IBAN. */
    ibanLast4?: string | undefined;
    /** Owner's verified full name. Values are verified or provided by iDEAL directly (if
supported) at the time of authorization or settlement. They cannot be set or mutated. */
    verifiedName?: string | undefined;
}

export abstract class StripeEntityOfSetupAttemptPaymentMethodDetailsKlarna extends StripeEntity implements IStripeEntityOfSetupAttemptPaymentMethodDetailsKlarna {

    constructor(data?: IStripeEntityOfSetupAttemptPaymentMethodDetailsKlarna) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSetupAttemptPaymentMethodDetailsKlarna {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSetupAttemptPaymentMethodDetailsKlarna' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSetupAttemptPaymentMethodDetailsKlarna extends IStripeEntity {
}

export class SetupAttemptPaymentMethodDetailsKlarna extends StripeEntityOfSetupAttemptPaymentMethodDetailsKlarna implements ISetupAttemptPaymentMethodDetailsKlarna {

    constructor(data?: ISetupAttemptPaymentMethodDetailsKlarna) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): SetupAttemptPaymentMethodDetailsKlarna {
        data = typeof data === 'object' ? data : {};
        let result = new SetupAttemptPaymentMethodDetailsKlarna();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ISetupAttemptPaymentMethodDetailsKlarna extends IStripeEntityOfSetupAttemptPaymentMethodDetailsKlarna {
}

export abstract class StripeEntityOfSetupAttemptPaymentMethodDetailsLink extends StripeEntity implements IStripeEntityOfSetupAttemptPaymentMethodDetailsLink {

    constructor(data?: IStripeEntityOfSetupAttemptPaymentMethodDetailsLink) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSetupAttemptPaymentMethodDetailsLink {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSetupAttemptPaymentMethodDetailsLink' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSetupAttemptPaymentMethodDetailsLink extends IStripeEntity {
}

export class SetupAttemptPaymentMethodDetailsLink extends StripeEntityOfSetupAttemptPaymentMethodDetailsLink implements ISetupAttemptPaymentMethodDetailsLink {

    constructor(data?: ISetupAttemptPaymentMethodDetailsLink) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): SetupAttemptPaymentMethodDetailsLink {
        data = typeof data === 'object' ? data : {};
        let result = new SetupAttemptPaymentMethodDetailsLink();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ISetupAttemptPaymentMethodDetailsLink extends IStripeEntityOfSetupAttemptPaymentMethodDetailsLink {
}

export abstract class StripeEntityOfSetupAttemptPaymentMethodDetailsPaypal extends StripeEntity implements IStripeEntityOfSetupAttemptPaymentMethodDetailsPaypal {

    constructor(data?: IStripeEntityOfSetupAttemptPaymentMethodDetailsPaypal) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSetupAttemptPaymentMethodDetailsPaypal {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSetupAttemptPaymentMethodDetailsPaypal' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSetupAttemptPaymentMethodDetailsPaypal extends IStripeEntity {
}

export class SetupAttemptPaymentMethodDetailsPaypal extends StripeEntityOfSetupAttemptPaymentMethodDetailsPaypal implements ISetupAttemptPaymentMethodDetailsPaypal {

    constructor(data?: ISetupAttemptPaymentMethodDetailsPaypal) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): SetupAttemptPaymentMethodDetailsPaypal {
        data = typeof data === 'object' ? data : {};
        let result = new SetupAttemptPaymentMethodDetailsPaypal();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ISetupAttemptPaymentMethodDetailsPaypal extends IStripeEntityOfSetupAttemptPaymentMethodDetailsPaypal {
}

export abstract class StripeEntityOfSetupAttemptPaymentMethodDetailsSepaDebit extends StripeEntity implements IStripeEntityOfSetupAttemptPaymentMethodDetailsSepaDebit {

    constructor(data?: IStripeEntityOfSetupAttemptPaymentMethodDetailsSepaDebit) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSetupAttemptPaymentMethodDetailsSepaDebit {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSetupAttemptPaymentMethodDetailsSepaDebit' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSetupAttemptPaymentMethodDetailsSepaDebit extends IStripeEntity {
}

export class SetupAttemptPaymentMethodDetailsSepaDebit extends StripeEntityOfSetupAttemptPaymentMethodDetailsSepaDebit implements ISetupAttemptPaymentMethodDetailsSepaDebit {

    constructor(data?: ISetupAttemptPaymentMethodDetailsSepaDebit) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): SetupAttemptPaymentMethodDetailsSepaDebit {
        data = typeof data === 'object' ? data : {};
        let result = new SetupAttemptPaymentMethodDetailsSepaDebit();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ISetupAttemptPaymentMethodDetailsSepaDebit extends IStripeEntityOfSetupAttemptPaymentMethodDetailsSepaDebit {
}

export abstract class StripeEntityOfSetupAttemptPaymentMethodDetailsSofort extends StripeEntity implements IStripeEntityOfSetupAttemptPaymentMethodDetailsSofort {

    constructor(data?: IStripeEntityOfSetupAttemptPaymentMethodDetailsSofort) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSetupAttemptPaymentMethodDetailsSofort {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSetupAttemptPaymentMethodDetailsSofort' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSetupAttemptPaymentMethodDetailsSofort extends IStripeEntity {
}

export class SetupAttemptPaymentMethodDetailsSofort extends StripeEntityOfSetupAttemptPaymentMethodDetailsSofort implements ISetupAttemptPaymentMethodDetailsSofort {
    /** Bank code of bank associated with the bank account. */
    bankCode?: string | undefined;
    /** Name of the bank associated with the bank account. */
    bankName?: string | undefined;
    /** Bank Identifier Code of the bank associated with the bank account. */
    bic?: string | undefined;
    /** (ID of the PaymentMethod)
The ID of the SEPA Direct Debit PaymentMethod which was generated by this SetupAttempt. */
    generatedSepaDebitId?: string | undefined;
    /** (Expanded)
The ID of the SEPA Direct Debit PaymentMethod which was generated by this SetupAttempt.
            
For more information, see the expand documentation. */
    generatedSepaDebit?: PaymentMethod | undefined;
    internalGeneratedSepaDebit?: ExpandableFieldOfPaymentMethod | undefined;
    /** (ID of the Mandate)
The mandate for the SEPA Direct Debit PaymentMethod which was generated by this
SetupAttempt. */
    generatedSepaDebitMandateId?: string | undefined;
    /** (Expanded)
The mandate for the SEPA Direct Debit PaymentMethod which was generated by this
SetupAttempt.
            
For more information, see the expand documentation. */
    generatedSepaDebitMandate?: Mandate | undefined;
    internalGeneratedSepaDebitMandate?: ExpandableFieldOfMandate | undefined;
    /** Last four characters of the IBAN. */
    ibanLast4?: string | undefined;
    /** Preferred language of the Sofort authorization page that the customer is redirected to.
Can be one of en, de, fr, or nl.
One of: de, en, fr, or nl. */
    preferredLanguage?: string | undefined;
    /** Owner's verified full name. Values are verified or provided by Sofort directly (if
supported) at the time of authorization or settlement. They cannot be set or mutated. */
    verifiedName?: string | undefined;

    constructor(data?: ISetupAttemptPaymentMethodDetailsSofort) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.bankCode = _data["bankCode"];
            this.bankName = _data["bankName"];
            this.bic = _data["bic"];
            this.generatedSepaDebitId = _data["generatedSepaDebitId"];
            this.generatedSepaDebit = _data["generatedSepaDebit"] ? PaymentMethod.fromJS(_data["generatedSepaDebit"]) : <any>undefined;
            this.internalGeneratedSepaDebit = _data["internalGeneratedSepaDebit"] ? ExpandableFieldOfPaymentMethod.fromJS(_data["internalGeneratedSepaDebit"]) : <any>undefined;
            this.generatedSepaDebitMandateId = _data["generatedSepaDebitMandateId"];
            this.generatedSepaDebitMandate = _data["generatedSepaDebitMandate"] ? Mandate.fromJS(_data["generatedSepaDebitMandate"]) : <any>undefined;
            this.internalGeneratedSepaDebitMandate = _data["internalGeneratedSepaDebitMandate"] ? ExpandableFieldOfMandate.fromJS(_data["internalGeneratedSepaDebitMandate"]) : <any>undefined;
            this.ibanLast4 = _data["ibanLast4"];
            this.preferredLanguage = _data["preferredLanguage"];
            this.verifiedName = _data["verifiedName"];
        }
    }

    static override fromJS(data: any): SetupAttemptPaymentMethodDetailsSofort {
        data = typeof data === 'object' ? data : {};
        let result = new SetupAttemptPaymentMethodDetailsSofort();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankCode"] = this.bankCode;
        data["bankName"] = this.bankName;
        data["bic"] = this.bic;
        data["generatedSepaDebitId"] = this.generatedSepaDebitId;
        data["generatedSepaDebit"] = this.generatedSepaDebit ? this.generatedSepaDebit.toJSON() : <any>undefined;
        data["internalGeneratedSepaDebit"] = this.internalGeneratedSepaDebit ? this.internalGeneratedSepaDebit.toJSON() : <any>undefined;
        data["generatedSepaDebitMandateId"] = this.generatedSepaDebitMandateId;
        data["generatedSepaDebitMandate"] = this.generatedSepaDebitMandate ? this.generatedSepaDebitMandate.toJSON() : <any>undefined;
        data["internalGeneratedSepaDebitMandate"] = this.internalGeneratedSepaDebitMandate ? this.internalGeneratedSepaDebitMandate.toJSON() : <any>undefined;
        data["ibanLast4"] = this.ibanLast4;
        data["preferredLanguage"] = this.preferredLanguage;
        data["verifiedName"] = this.verifiedName;
        super.toJSON(data);
        return data;
    }
}

export interface ISetupAttemptPaymentMethodDetailsSofort extends IStripeEntityOfSetupAttemptPaymentMethodDetailsSofort {
    /** Bank code of bank associated with the bank account. */
    bankCode?: string | undefined;
    /** Name of the bank associated with the bank account. */
    bankName?: string | undefined;
    /** Bank Identifier Code of the bank associated with the bank account. */
    bic?: string | undefined;
    /** (ID of the PaymentMethod)
The ID of the SEPA Direct Debit PaymentMethod which was generated by this SetupAttempt. */
    generatedSepaDebitId?: string | undefined;
    /** (Expanded)
The ID of the SEPA Direct Debit PaymentMethod which was generated by this SetupAttempt.
            
For more information, see the expand documentation. */
    generatedSepaDebit?: PaymentMethod | undefined;
    internalGeneratedSepaDebit?: ExpandableFieldOfPaymentMethod | undefined;
    /** (ID of the Mandate)
The mandate for the SEPA Direct Debit PaymentMethod which was generated by this
SetupAttempt. */
    generatedSepaDebitMandateId?: string | undefined;
    /** (Expanded)
The mandate for the SEPA Direct Debit PaymentMethod which was generated by this
SetupAttempt.
            
For more information, see the expand documentation. */
    generatedSepaDebitMandate?: Mandate | undefined;
    internalGeneratedSepaDebitMandate?: ExpandableFieldOfMandate | undefined;
    /** Last four characters of the IBAN. */
    ibanLast4?: string | undefined;
    /** Preferred language of the Sofort authorization page that the customer is redirected to.
Can be one of en, de, fr, or nl.
One of: de, en, fr, or nl. */
    preferredLanguage?: string | undefined;
    /** Owner's verified full name. Values are verified or provided by Sofort directly (if
supported) at the time of authorization or settlement. They cannot be set or mutated. */
    verifiedName?: string | undefined;
}

export abstract class StripeEntityOfSetupAttemptPaymentMethodDetailsUsBankAccount extends StripeEntity implements IStripeEntityOfSetupAttemptPaymentMethodDetailsUsBankAccount {

    constructor(data?: IStripeEntityOfSetupAttemptPaymentMethodDetailsUsBankAccount) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSetupAttemptPaymentMethodDetailsUsBankAccount {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSetupAttemptPaymentMethodDetailsUsBankAccount' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSetupAttemptPaymentMethodDetailsUsBankAccount extends IStripeEntity {
}

export class SetupAttemptPaymentMethodDetailsUsBankAccount extends StripeEntityOfSetupAttemptPaymentMethodDetailsUsBankAccount implements ISetupAttemptPaymentMethodDetailsUsBankAccount {

    constructor(data?: ISetupAttemptPaymentMethodDetailsUsBankAccount) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): SetupAttemptPaymentMethodDetailsUsBankAccount {
        data = typeof data === 'object' ? data : {};
        let result = new SetupAttemptPaymentMethodDetailsUsBankAccount();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ISetupAttemptPaymentMethodDetailsUsBankAccount extends IStripeEntityOfSetupAttemptPaymentMethodDetailsUsBankAccount {
}

/** Represents a generic expandable field. */
export class ExpandableFieldOfSetupIntent implements IExpandableFieldOfSetupIntent {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: SetupIntent | undefined;

    constructor(data?: IExpandableFieldOfSetupIntent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.expandedObject = _data["expandedObject"] ? SetupIntent.fromJS(_data["expandedObject"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExpandableFieldOfSetupIntent {
        data = typeof data === 'object' ? data : {};
        let result = new ExpandableFieldOfSetupIntent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["expandedObject"] = this.expandedObject ? this.expandedObject.toJSON() : <any>undefined;
        return data;
    }
}

/** Represents a generic expandable field. */
export interface IExpandableFieldOfSetupIntent {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: SetupIntent | undefined;
}

/** Represents a generic expandable field. */
export class ExpandableFieldOfSetupAttempt implements IExpandableFieldOfSetupAttempt {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: SetupAttempt | undefined;

    constructor(data?: IExpandableFieldOfSetupAttempt) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.expandedObject = _data["expandedObject"] ? SetupAttempt.fromJS(_data["expandedObject"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExpandableFieldOfSetupAttempt {
        data = typeof data === 'object' ? data : {};
        let result = new ExpandableFieldOfSetupAttempt();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["expandedObject"] = this.expandedObject ? this.expandedObject.toJSON() : <any>undefined;
        return data;
    }
}

/** Represents a generic expandable field. */
export interface IExpandableFieldOfSetupAttempt {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: SetupAttempt | undefined;
}

export abstract class StripeEntityOfSetupIntentNextAction extends StripeEntity implements IStripeEntityOfSetupIntentNextAction {

    constructor(data?: IStripeEntityOfSetupIntentNextAction) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSetupIntentNextAction {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSetupIntentNextAction' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSetupIntentNextAction extends IStripeEntity {
}

export class SetupIntentNextAction extends StripeEntityOfSetupIntentNextAction implements ISetupIntentNextAction {
    cashappHandleRedirectOrDisplayQrCode?: SetupIntentNextActionCashappHandleRedirectOrDisplayQrCode | undefined;
    redirectToUrl?: SetupIntentNextActionRedirectToUrl | undefined;
    /** Type of the next action to perform, one of redirect_to_url,
use_stripe_sdk, alipay_handle_redirect, oxxo_display_details, or
verify_with_microdeposits. */
    type?: string | undefined;
    verifyWithMicrodeposits?: SetupIntentNextActionVerifyWithMicrodeposits | undefined;

    constructor(data?: ISetupIntentNextAction) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.cashappHandleRedirectOrDisplayQrCode = _data["cashappHandleRedirectOrDisplayQrCode"] ? SetupIntentNextActionCashappHandleRedirectOrDisplayQrCode.fromJS(_data["cashappHandleRedirectOrDisplayQrCode"]) : <any>undefined;
            this.redirectToUrl = _data["redirectToUrl"] ? SetupIntentNextActionRedirectToUrl.fromJS(_data["redirectToUrl"]) : <any>undefined;
            this.type = _data["type"];
            this.verifyWithMicrodeposits = _data["verifyWithMicrodeposits"] ? SetupIntentNextActionVerifyWithMicrodeposits.fromJS(_data["verifyWithMicrodeposits"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): SetupIntentNextAction {
        data = typeof data === 'object' ? data : {};
        let result = new SetupIntentNextAction();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cashappHandleRedirectOrDisplayQrCode"] = this.cashappHandleRedirectOrDisplayQrCode ? this.cashappHandleRedirectOrDisplayQrCode.toJSON() : <any>undefined;
        data["redirectToUrl"] = this.redirectToUrl ? this.redirectToUrl.toJSON() : <any>undefined;
        data["type"] = this.type;
        data["verifyWithMicrodeposits"] = this.verifyWithMicrodeposits ? this.verifyWithMicrodeposits.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface ISetupIntentNextAction extends IStripeEntityOfSetupIntentNextAction {
    cashappHandleRedirectOrDisplayQrCode?: SetupIntentNextActionCashappHandleRedirectOrDisplayQrCode | undefined;
    redirectToUrl?: SetupIntentNextActionRedirectToUrl | undefined;
    /** Type of the next action to perform, one of redirect_to_url,
use_stripe_sdk, alipay_handle_redirect, oxxo_display_details, or
verify_with_microdeposits. */
    type?: string | undefined;
    verifyWithMicrodeposits?: SetupIntentNextActionVerifyWithMicrodeposits | undefined;
}

export abstract class StripeEntityOfSetupIntentNextActionCashappHandleRedirectOrDisplayQrCode extends StripeEntity implements IStripeEntityOfSetupIntentNextActionCashappHandleRedirectOrDisplayQrCode {

    constructor(data?: IStripeEntityOfSetupIntentNextActionCashappHandleRedirectOrDisplayQrCode) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSetupIntentNextActionCashappHandleRedirectOrDisplayQrCode {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSetupIntentNextActionCashappHandleRedirectOrDisplayQrCode' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSetupIntentNextActionCashappHandleRedirectOrDisplayQrCode extends IStripeEntity {
}

export class SetupIntentNextActionCashappHandleRedirectOrDisplayQrCode extends StripeEntityOfSetupIntentNextActionCashappHandleRedirectOrDisplayQrCode implements ISetupIntentNextActionCashappHandleRedirectOrDisplayQrCode {
    /** The URL to the hosted Cash App Pay instructions page, which allows customers to view the
QR code, and supports QR code refreshing on expiration. */
    hostedInstructionsUrl?: string | undefined;
    /** The url for mobile redirect based auth. */
    mobileAuthUrl?: string | undefined;
    qrCode?: SetupIntentNextActionCashappHandleRedirectOrDisplayQrCodeQrCode | undefined;

    constructor(data?: ISetupIntentNextActionCashappHandleRedirectOrDisplayQrCode) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.hostedInstructionsUrl = _data["hostedInstructionsUrl"];
            this.mobileAuthUrl = _data["mobileAuthUrl"];
            this.qrCode = _data["qrCode"] ? SetupIntentNextActionCashappHandleRedirectOrDisplayQrCodeQrCode.fromJS(_data["qrCode"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): SetupIntentNextActionCashappHandleRedirectOrDisplayQrCode {
        data = typeof data === 'object' ? data : {};
        let result = new SetupIntentNextActionCashappHandleRedirectOrDisplayQrCode();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hostedInstructionsUrl"] = this.hostedInstructionsUrl;
        data["mobileAuthUrl"] = this.mobileAuthUrl;
        data["qrCode"] = this.qrCode ? this.qrCode.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface ISetupIntentNextActionCashappHandleRedirectOrDisplayQrCode extends IStripeEntityOfSetupIntentNextActionCashappHandleRedirectOrDisplayQrCode {
    /** The URL to the hosted Cash App Pay instructions page, which allows customers to view the
QR code, and supports QR code refreshing on expiration. */
    hostedInstructionsUrl?: string | undefined;
    /** The url for mobile redirect based auth. */
    mobileAuthUrl?: string | undefined;
    qrCode?: SetupIntentNextActionCashappHandleRedirectOrDisplayQrCodeQrCode | undefined;
}

export abstract class StripeEntityOfSetupIntentNextActionCashappHandleRedirectOrDisplayQrCodeQrCode extends StripeEntity implements IStripeEntityOfSetupIntentNextActionCashappHandleRedirectOrDisplayQrCodeQrCode {

    constructor(data?: IStripeEntityOfSetupIntentNextActionCashappHandleRedirectOrDisplayQrCodeQrCode) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSetupIntentNextActionCashappHandleRedirectOrDisplayQrCodeQrCode {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSetupIntentNextActionCashappHandleRedirectOrDisplayQrCodeQrCode' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSetupIntentNextActionCashappHandleRedirectOrDisplayQrCodeQrCode extends IStripeEntity {
}

export class SetupIntentNextActionCashappHandleRedirectOrDisplayQrCodeQrCode extends StripeEntityOfSetupIntentNextActionCashappHandleRedirectOrDisplayQrCodeQrCode implements ISetupIntentNextActionCashappHandleRedirectOrDisplayQrCodeQrCode {
    /** The date (unix timestamp) when the QR code expires. */
    expiresAt?: Date;
    /** The image_url_png string used to render QR code. */
    imageUrlPng?: string | undefined;
    /** The image_url_svg string used to render QR code. */
    imageUrlSvg?: string | undefined;

    constructor(data?: ISetupIntentNextActionCashappHandleRedirectOrDisplayQrCodeQrCode) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.expiresAt = _data["expiresAt"] ? new Date(_data["expiresAt"].toString()) : <any>undefined;
            this.imageUrlPng = _data["imageUrlPng"];
            this.imageUrlSvg = _data["imageUrlSvg"];
        }
    }

    static override fromJS(data: any): SetupIntentNextActionCashappHandleRedirectOrDisplayQrCodeQrCode {
        data = typeof data === 'object' ? data : {};
        let result = new SetupIntentNextActionCashappHandleRedirectOrDisplayQrCodeQrCode();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expiresAt"] = this.expiresAt ? this.expiresAt.toISOString() : <any>undefined;
        data["imageUrlPng"] = this.imageUrlPng;
        data["imageUrlSvg"] = this.imageUrlSvg;
        super.toJSON(data);
        return data;
    }
}

export interface ISetupIntentNextActionCashappHandleRedirectOrDisplayQrCodeQrCode extends IStripeEntityOfSetupIntentNextActionCashappHandleRedirectOrDisplayQrCodeQrCode {
    /** The date (unix timestamp) when the QR code expires. */
    expiresAt?: Date;
    /** The image_url_png string used to render QR code. */
    imageUrlPng?: string | undefined;
    /** The image_url_svg string used to render QR code. */
    imageUrlSvg?: string | undefined;
}

export abstract class StripeEntityOfSetupIntentNextActionRedirectToUrl extends StripeEntity implements IStripeEntityOfSetupIntentNextActionRedirectToUrl {

    constructor(data?: IStripeEntityOfSetupIntentNextActionRedirectToUrl) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSetupIntentNextActionRedirectToUrl {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSetupIntentNextActionRedirectToUrl' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSetupIntentNextActionRedirectToUrl extends IStripeEntity {
}

export class SetupIntentNextActionRedirectToUrl extends StripeEntityOfSetupIntentNextActionRedirectToUrl implements ISetupIntentNextActionRedirectToUrl {
    /** If the customer does not exit their browser while authenticating, they will be
redirected to this specified URL after completion. */
    returnUrl?: string | undefined;
    /** The URL you must redirect your customer to in order to authenticate. */
    url?: string | undefined;

    constructor(data?: ISetupIntentNextActionRedirectToUrl) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.returnUrl = _data["returnUrl"];
            this.url = _data["url"];
        }
    }

    static override fromJS(data: any): SetupIntentNextActionRedirectToUrl {
        data = typeof data === 'object' ? data : {};
        let result = new SetupIntentNextActionRedirectToUrl();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["returnUrl"] = this.returnUrl;
        data["url"] = this.url;
        super.toJSON(data);
        return data;
    }
}

export interface ISetupIntentNextActionRedirectToUrl extends IStripeEntityOfSetupIntentNextActionRedirectToUrl {
    /** If the customer does not exit their browser while authenticating, they will be
redirected to this specified URL after completion. */
    returnUrl?: string | undefined;
    /** The URL you must redirect your customer to in order to authenticate. */
    url?: string | undefined;
}

export abstract class StripeEntityOfSetupIntentNextActionVerifyWithMicrodeposits extends StripeEntity implements IStripeEntityOfSetupIntentNextActionVerifyWithMicrodeposits {

    constructor(data?: IStripeEntityOfSetupIntentNextActionVerifyWithMicrodeposits) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSetupIntentNextActionVerifyWithMicrodeposits {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSetupIntentNextActionVerifyWithMicrodeposits' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSetupIntentNextActionVerifyWithMicrodeposits extends IStripeEntity {
}

export class SetupIntentNextActionVerifyWithMicrodeposits extends StripeEntityOfSetupIntentNextActionVerifyWithMicrodeposits implements ISetupIntentNextActionVerifyWithMicrodeposits {
    /** The timestamp when the microdeposits are expected to land. */
    arrivalDate?: Date;
    /** The URL for the hosted verification page, which allows customers to verify their bank
account. */
    hostedVerificationUrl?: string | undefined;
    /** The type of the microdeposit sent to the customer. Used to distinguish between different
verification methods.
One of: amounts, or descriptor_code. */
    microdepositType?: string | undefined;

    constructor(data?: ISetupIntentNextActionVerifyWithMicrodeposits) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.arrivalDate = _data["arrivalDate"] ? new Date(_data["arrivalDate"].toString()) : <any>undefined;
            this.hostedVerificationUrl = _data["hostedVerificationUrl"];
            this.microdepositType = _data["microdepositType"];
        }
    }

    static override fromJS(data: any): SetupIntentNextActionVerifyWithMicrodeposits {
        data = typeof data === 'object' ? data : {};
        let result = new SetupIntentNextActionVerifyWithMicrodeposits();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["arrivalDate"] = this.arrivalDate ? this.arrivalDate.toISOString() : <any>undefined;
        data["hostedVerificationUrl"] = this.hostedVerificationUrl;
        data["microdepositType"] = this.microdepositType;
        super.toJSON(data);
        return data;
    }
}

export interface ISetupIntentNextActionVerifyWithMicrodeposits extends IStripeEntityOfSetupIntentNextActionVerifyWithMicrodeposits {
    /** The timestamp when the microdeposits are expected to land. */
    arrivalDate?: Date;
    /** The URL for the hosted verification page, which allows customers to verify their bank
account. */
    hostedVerificationUrl?: string | undefined;
    /** The type of the microdeposit sent to the customer. Used to distinguish between different
verification methods.
One of: amounts, or descriptor_code. */
    microdepositType?: string | undefined;
}

export abstract class StripeEntityOfSetupIntentPaymentMethodOptions extends StripeEntity implements IStripeEntityOfSetupIntentPaymentMethodOptions {

    constructor(data?: IStripeEntityOfSetupIntentPaymentMethodOptions) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSetupIntentPaymentMethodOptions {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSetupIntentPaymentMethodOptions' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSetupIntentPaymentMethodOptions extends IStripeEntity {
}

export class SetupIntentPaymentMethodOptions extends StripeEntityOfSetupIntentPaymentMethodOptions implements ISetupIntentPaymentMethodOptions {
    acssDebit?: SetupIntentPaymentMethodOptionsAcssDebit | undefined;
    blik?: SetupIntentPaymentMethodOptionsBlik | undefined;
    card?: SetupIntentPaymentMethodOptionsCard | undefined;
    link?: SetupIntentPaymentMethodOptionsLink | undefined;
    paypal?: SetupIntentPaymentMethodOptionsPaypal | undefined;
    sepaDebit?: SetupIntentPaymentMethodOptionsSepaDebit | undefined;
    usBankAccount?: SetupIntentPaymentMethodOptionsUsBankAccount | undefined;

    constructor(data?: ISetupIntentPaymentMethodOptions) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.acssDebit = _data["acssDebit"] ? SetupIntentPaymentMethodOptionsAcssDebit.fromJS(_data["acssDebit"]) : <any>undefined;
            this.blik = _data["blik"] ? SetupIntentPaymentMethodOptionsBlik.fromJS(_data["blik"]) : <any>undefined;
            this.card = _data["card"] ? SetupIntentPaymentMethodOptionsCard.fromJS(_data["card"]) : <any>undefined;
            this.link = _data["link"] ? SetupIntentPaymentMethodOptionsLink.fromJS(_data["link"]) : <any>undefined;
            this.paypal = _data["paypal"] ? SetupIntentPaymentMethodOptionsPaypal.fromJS(_data["paypal"]) : <any>undefined;
            this.sepaDebit = _data["sepaDebit"] ? SetupIntentPaymentMethodOptionsSepaDebit.fromJS(_data["sepaDebit"]) : <any>undefined;
            this.usBankAccount = _data["usBankAccount"] ? SetupIntentPaymentMethodOptionsUsBankAccount.fromJS(_data["usBankAccount"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): SetupIntentPaymentMethodOptions {
        data = typeof data === 'object' ? data : {};
        let result = new SetupIntentPaymentMethodOptions();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["acssDebit"] = this.acssDebit ? this.acssDebit.toJSON() : <any>undefined;
        data["blik"] = this.blik ? this.blik.toJSON() : <any>undefined;
        data["card"] = this.card ? this.card.toJSON() : <any>undefined;
        data["link"] = this.link ? this.link.toJSON() : <any>undefined;
        data["paypal"] = this.paypal ? this.paypal.toJSON() : <any>undefined;
        data["sepaDebit"] = this.sepaDebit ? this.sepaDebit.toJSON() : <any>undefined;
        data["usBankAccount"] = this.usBankAccount ? this.usBankAccount.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface ISetupIntentPaymentMethodOptions extends IStripeEntityOfSetupIntentPaymentMethodOptions {
    acssDebit?: SetupIntentPaymentMethodOptionsAcssDebit | undefined;
    blik?: SetupIntentPaymentMethodOptionsBlik | undefined;
    card?: SetupIntentPaymentMethodOptionsCard | undefined;
    link?: SetupIntentPaymentMethodOptionsLink | undefined;
    paypal?: SetupIntentPaymentMethodOptionsPaypal | undefined;
    sepaDebit?: SetupIntentPaymentMethodOptionsSepaDebit | undefined;
    usBankAccount?: SetupIntentPaymentMethodOptionsUsBankAccount | undefined;
}

export abstract class StripeEntityOfSetupIntentPaymentMethodOptionsAcssDebit extends StripeEntity implements IStripeEntityOfSetupIntentPaymentMethodOptionsAcssDebit {

    constructor(data?: IStripeEntityOfSetupIntentPaymentMethodOptionsAcssDebit) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSetupIntentPaymentMethodOptionsAcssDebit {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSetupIntentPaymentMethodOptionsAcssDebit' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSetupIntentPaymentMethodOptionsAcssDebit extends IStripeEntity {
}

export class SetupIntentPaymentMethodOptionsAcssDebit extends StripeEntityOfSetupIntentPaymentMethodOptionsAcssDebit implements ISetupIntentPaymentMethodOptionsAcssDebit {
    /** Currency supported by the bank account.
One of: cad, or usd. */
    currency?: string | undefined;
    mandateOptions?: SetupIntentPaymentMethodOptionsAcssDebitMandateOptions | undefined;
    /** Bank account verification method.
One of: automatic, instant, or microdeposits. */
    verificationMethod?: string | undefined;

    constructor(data?: ISetupIntentPaymentMethodOptionsAcssDebit) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.currency = _data["currency"];
            this.mandateOptions = _data["mandateOptions"] ? SetupIntentPaymentMethodOptionsAcssDebitMandateOptions.fromJS(_data["mandateOptions"]) : <any>undefined;
            this.verificationMethod = _data["verificationMethod"];
        }
    }

    static override fromJS(data: any): SetupIntentPaymentMethodOptionsAcssDebit {
        data = typeof data === 'object' ? data : {};
        let result = new SetupIntentPaymentMethodOptionsAcssDebit();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currency"] = this.currency;
        data["mandateOptions"] = this.mandateOptions ? this.mandateOptions.toJSON() : <any>undefined;
        data["verificationMethod"] = this.verificationMethod;
        super.toJSON(data);
        return data;
    }
}

export interface ISetupIntentPaymentMethodOptionsAcssDebit extends IStripeEntityOfSetupIntentPaymentMethodOptionsAcssDebit {
    /** Currency supported by the bank account.
One of: cad, or usd. */
    currency?: string | undefined;
    mandateOptions?: SetupIntentPaymentMethodOptionsAcssDebitMandateOptions | undefined;
    /** Bank account verification method.
One of: automatic, instant, or microdeposits. */
    verificationMethod?: string | undefined;
}

export abstract class StripeEntityOfSetupIntentPaymentMethodOptionsAcssDebitMandateOptions extends StripeEntity implements IStripeEntityOfSetupIntentPaymentMethodOptionsAcssDebitMandateOptions {

    constructor(data?: IStripeEntityOfSetupIntentPaymentMethodOptionsAcssDebitMandateOptions) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSetupIntentPaymentMethodOptionsAcssDebitMandateOptions {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSetupIntentPaymentMethodOptionsAcssDebitMandateOptions' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSetupIntentPaymentMethodOptionsAcssDebitMandateOptions extends IStripeEntity {
}

export class SetupIntentPaymentMethodOptionsAcssDebitMandateOptions extends StripeEntityOfSetupIntentPaymentMethodOptionsAcssDebitMandateOptions implements ISetupIntentPaymentMethodOptionsAcssDebitMandateOptions {
    /** A URL for custom mandate text. */
    customMandateUrl?: string | undefined;
    /** List of Stripe products where this mandate can be selected automatically. */
    defaultFor?: string[] | undefined;
    /** Description of the interval. Only required if the 'payment_schedule' parameter is
'interval' or 'combined'. */
    intervalDescription?: string | undefined;
    /** Payment schedule for the mandate.
One of: combined, interval, or sporadic. */
    paymentSchedule?: string | undefined;
    /** Transaction type of the mandate.
One of: business, or personal. */
    transactionType?: string | undefined;

    constructor(data?: ISetupIntentPaymentMethodOptionsAcssDebitMandateOptions) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.customMandateUrl = _data["customMandateUrl"];
            if (Array.isArray(_data["defaultFor"])) {
                this.defaultFor = [] as any;
                for (let item of _data["defaultFor"])
                    this.defaultFor!.push(item);
            }
            this.intervalDescription = _data["intervalDescription"];
            this.paymentSchedule = _data["paymentSchedule"];
            this.transactionType = _data["transactionType"];
        }
    }

    static override fromJS(data: any): SetupIntentPaymentMethodOptionsAcssDebitMandateOptions {
        data = typeof data === 'object' ? data : {};
        let result = new SetupIntentPaymentMethodOptionsAcssDebitMandateOptions();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customMandateUrl"] = this.customMandateUrl;
        if (Array.isArray(this.defaultFor)) {
            data["defaultFor"] = [];
            for (let item of this.defaultFor)
                data["defaultFor"].push(item);
        }
        data["intervalDescription"] = this.intervalDescription;
        data["paymentSchedule"] = this.paymentSchedule;
        data["transactionType"] = this.transactionType;
        super.toJSON(data);
        return data;
    }
}

export interface ISetupIntentPaymentMethodOptionsAcssDebitMandateOptions extends IStripeEntityOfSetupIntentPaymentMethodOptionsAcssDebitMandateOptions {
    /** A URL for custom mandate text. */
    customMandateUrl?: string | undefined;
    /** List of Stripe products where this mandate can be selected automatically. */
    defaultFor?: string[] | undefined;
    /** Description of the interval. Only required if the 'payment_schedule' parameter is
'interval' or 'combined'. */
    intervalDescription?: string | undefined;
    /** Payment schedule for the mandate.
One of: combined, interval, or sporadic. */
    paymentSchedule?: string | undefined;
    /** Transaction type of the mandate.
One of: business, or personal. */
    transactionType?: string | undefined;
}

export abstract class StripeEntityOfSetupIntentPaymentMethodOptionsBlik extends StripeEntity implements IStripeEntityOfSetupIntentPaymentMethodOptionsBlik {

    constructor(data?: IStripeEntityOfSetupIntentPaymentMethodOptionsBlik) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSetupIntentPaymentMethodOptionsBlik {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSetupIntentPaymentMethodOptionsBlik' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSetupIntentPaymentMethodOptionsBlik extends IStripeEntity {
}

export class SetupIntentPaymentMethodOptionsBlik extends StripeEntityOfSetupIntentPaymentMethodOptionsBlik implements ISetupIntentPaymentMethodOptionsBlik {
    mandateOptions?: SetupIntentPaymentMethodOptionsBlikMandateOptions | undefined;

    constructor(data?: ISetupIntentPaymentMethodOptionsBlik) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.mandateOptions = _data["mandateOptions"] ? SetupIntentPaymentMethodOptionsBlikMandateOptions.fromJS(_data["mandateOptions"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): SetupIntentPaymentMethodOptionsBlik {
        data = typeof data === 'object' ? data : {};
        let result = new SetupIntentPaymentMethodOptionsBlik();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mandateOptions"] = this.mandateOptions ? this.mandateOptions.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface ISetupIntentPaymentMethodOptionsBlik extends IStripeEntityOfSetupIntentPaymentMethodOptionsBlik {
    mandateOptions?: SetupIntentPaymentMethodOptionsBlikMandateOptions | undefined;
}

export abstract class StripeEntityOfSetupIntentPaymentMethodOptionsBlikMandateOptions extends StripeEntity implements IStripeEntityOfSetupIntentPaymentMethodOptionsBlikMandateOptions {

    constructor(data?: IStripeEntityOfSetupIntentPaymentMethodOptionsBlikMandateOptions) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSetupIntentPaymentMethodOptionsBlikMandateOptions {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSetupIntentPaymentMethodOptionsBlikMandateOptions' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSetupIntentPaymentMethodOptionsBlikMandateOptions extends IStripeEntity {
}

export class SetupIntentPaymentMethodOptionsBlikMandateOptions extends StripeEntityOfSetupIntentPaymentMethodOptionsBlikMandateOptions implements ISetupIntentPaymentMethodOptionsBlikMandateOptions {
    /** Date at which the mandate expires. */
    expiresAfter?: Date | undefined;
    offSession?: SetupIntentPaymentMethodOptionsBlikMandateOptionsOffSession | undefined;
    /** Type of the mandate.
One of: off_session, or on_session. */
    type?: string | undefined;

    constructor(data?: ISetupIntentPaymentMethodOptionsBlikMandateOptions) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.expiresAfter = _data["expiresAfter"] ? new Date(_data["expiresAfter"].toString()) : <any>undefined;
            this.offSession = _data["offSession"] ? SetupIntentPaymentMethodOptionsBlikMandateOptionsOffSession.fromJS(_data["offSession"]) : <any>undefined;
            this.type = _data["type"];
        }
    }

    static override fromJS(data: any): SetupIntentPaymentMethodOptionsBlikMandateOptions {
        data = typeof data === 'object' ? data : {};
        let result = new SetupIntentPaymentMethodOptionsBlikMandateOptions();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expiresAfter"] = this.expiresAfter ? this.expiresAfter.toISOString() : <any>undefined;
        data["offSession"] = this.offSession ? this.offSession.toJSON() : <any>undefined;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

export interface ISetupIntentPaymentMethodOptionsBlikMandateOptions extends IStripeEntityOfSetupIntentPaymentMethodOptionsBlikMandateOptions {
    /** Date at which the mandate expires. */
    expiresAfter?: Date | undefined;
    offSession?: SetupIntentPaymentMethodOptionsBlikMandateOptionsOffSession | undefined;
    /** Type of the mandate.
One of: off_session, or on_session. */
    type?: string | undefined;
}

export abstract class StripeEntityOfSetupIntentPaymentMethodOptionsBlikMandateOptionsOffSession extends StripeEntity implements IStripeEntityOfSetupIntentPaymentMethodOptionsBlikMandateOptionsOffSession {

    constructor(data?: IStripeEntityOfSetupIntentPaymentMethodOptionsBlikMandateOptionsOffSession) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSetupIntentPaymentMethodOptionsBlikMandateOptionsOffSession {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSetupIntentPaymentMethodOptionsBlikMandateOptionsOffSession' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSetupIntentPaymentMethodOptionsBlikMandateOptionsOffSession extends IStripeEntity {
}

export class SetupIntentPaymentMethodOptionsBlikMandateOptionsOffSession extends StripeEntityOfSetupIntentPaymentMethodOptionsBlikMandateOptionsOffSession implements ISetupIntentPaymentMethodOptionsBlikMandateOptionsOffSession {
    /** Amount of each recurring payment. */
    amount?: number | undefined;
    /** Currency of each recurring payment. */
    currency?: string | undefined;
    /** Frequency interval of each recurring payment.
One of: day, month, week, or year. */
    interval?: string | undefined;
    /** Frequency indicator of each recurring payment. */
    intervalCount?: number | undefined;

    constructor(data?: ISetupIntentPaymentMethodOptionsBlikMandateOptionsOffSession) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.amount = _data["amount"];
            this.currency = _data["currency"];
            this.interval = _data["interval"];
            this.intervalCount = _data["intervalCount"];
        }
    }

    static override fromJS(data: any): SetupIntentPaymentMethodOptionsBlikMandateOptionsOffSession {
        data = typeof data === 'object' ? data : {};
        let result = new SetupIntentPaymentMethodOptionsBlikMandateOptionsOffSession();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["currency"] = this.currency;
        data["interval"] = this.interval;
        data["intervalCount"] = this.intervalCount;
        super.toJSON(data);
        return data;
    }
}

export interface ISetupIntentPaymentMethodOptionsBlikMandateOptionsOffSession extends IStripeEntityOfSetupIntentPaymentMethodOptionsBlikMandateOptionsOffSession {
    /** Amount of each recurring payment. */
    amount?: number | undefined;
    /** Currency of each recurring payment. */
    currency?: string | undefined;
    /** Frequency interval of each recurring payment.
One of: day, month, week, or year. */
    interval?: string | undefined;
    /** Frequency indicator of each recurring payment. */
    intervalCount?: number | undefined;
}

export abstract class StripeEntityOfSetupIntentPaymentMethodOptionsCard extends StripeEntity implements IStripeEntityOfSetupIntentPaymentMethodOptionsCard {

    constructor(data?: IStripeEntityOfSetupIntentPaymentMethodOptionsCard) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSetupIntentPaymentMethodOptionsCard {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSetupIntentPaymentMethodOptionsCard' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSetupIntentPaymentMethodOptionsCard extends IStripeEntity {
}

export class SetupIntentPaymentMethodOptionsCard extends StripeEntityOfSetupIntentPaymentMethodOptionsCard implements ISetupIntentPaymentMethodOptionsCard {
    /** Configuration options for setting up an eMandate for cards issued in India. */
    mandateOptions?: SetupIntentPaymentMethodOptionsCardMandateOptions | undefined;
    /** Selected network to process this SetupIntent on. Depends on the available networks of
the card attached to the setup intent. Can be only set confirm-time.
One of: amex, cartes_bancaires, diners, discover,
eftpos_au, interac, jcb, mastercard, unionpay,
unknown, or visa. */
    network?: string | undefined;
    /** We strongly recommend that you rely on our SCA Engine to automatically prompt your
customers for authentication based on risk level and other requirements.
However, if you wish to request 3D Secure based on logic from your own fraud engine,
provide this option. Permitted values include: automatic or any. If not
provided, defaults to automatic. Read our guide on manually requesting 3D
Secure for more information on how this configuration interacts with Radar and our
SCA Engine.
One of: any, automatic, or challenge_only. */
    requestThreeDSecure?: string | undefined;

    constructor(data?: ISetupIntentPaymentMethodOptionsCard) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.mandateOptions = _data["mandateOptions"] ? SetupIntentPaymentMethodOptionsCardMandateOptions.fromJS(_data["mandateOptions"]) : <any>undefined;
            this.network = _data["network"];
            this.requestThreeDSecure = _data["requestThreeDSecure"];
        }
    }

    static override fromJS(data: any): SetupIntentPaymentMethodOptionsCard {
        data = typeof data === 'object' ? data : {};
        let result = new SetupIntentPaymentMethodOptionsCard();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mandateOptions"] = this.mandateOptions ? this.mandateOptions.toJSON() : <any>undefined;
        data["network"] = this.network;
        data["requestThreeDSecure"] = this.requestThreeDSecure;
        super.toJSON(data);
        return data;
    }
}

export interface ISetupIntentPaymentMethodOptionsCard extends IStripeEntityOfSetupIntentPaymentMethodOptionsCard {
    /** Configuration options for setting up an eMandate for cards issued in India. */
    mandateOptions?: SetupIntentPaymentMethodOptionsCardMandateOptions | undefined;
    /** Selected network to process this SetupIntent on. Depends on the available networks of
the card attached to the setup intent. Can be only set confirm-time.
One of: amex, cartes_bancaires, diners, discover,
eftpos_au, interac, jcb, mastercard, unionpay,
unknown, or visa. */
    network?: string | undefined;
    /** We strongly recommend that you rely on our SCA Engine to automatically prompt your
customers for authentication based on risk level and other requirements.
However, if you wish to request 3D Secure based on logic from your own fraud engine,
provide this option. Permitted values include: automatic or any. If not
provided, defaults to automatic. Read our guide on manually requesting 3D
Secure for more information on how this configuration interacts with Radar and our
SCA Engine.
One of: any, automatic, or challenge_only. */
    requestThreeDSecure?: string | undefined;
}

export abstract class StripeEntityOfSetupIntentPaymentMethodOptionsCardMandateOptions extends StripeEntity implements IStripeEntityOfSetupIntentPaymentMethodOptionsCardMandateOptions {

    constructor(data?: IStripeEntityOfSetupIntentPaymentMethodOptionsCardMandateOptions) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSetupIntentPaymentMethodOptionsCardMandateOptions {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSetupIntentPaymentMethodOptionsCardMandateOptions' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSetupIntentPaymentMethodOptionsCardMandateOptions extends IStripeEntity {
}

export class SetupIntentPaymentMethodOptionsCardMandateOptions extends StripeEntityOfSetupIntentPaymentMethodOptionsCardMandateOptions implements ISetupIntentPaymentMethodOptionsCardMandateOptions {
    /** Amount to be charged for future payments. */
    amount?: number;
    /** One of fixed or maximum. If fixed, the amount param refers
to the exact amount to be charged in future payments. If maximum, the amount
charged can be up to the value passed for the amount param.
One of: fixed, or maximum. */
    amountType?: string | undefined;
    /** Three-letter ISO currency
code, in lowercase. Must be a supported
currency. */
    currency?: string | undefined;
    /** A description of the mandate or subscription that is meant to be displayed to the
customer. */
    description?: string | undefined;
    /** End date of the mandate or subscription. If not provided, the mandate will be active
until canceled. If provided, end date should be after start date. */
    endDate?: Date | undefined;
    /** Specifies payment frequency. One of day, week, month, year,
or sporadic.
One of: day, month, sporadic, week, or year. */
    interval?: string | undefined;
    /** The number of intervals between payments. For example, interval=month and
interval_count=3 indicates one payment every three months. Maximum of one year
interval allowed (1 year, 12 months, or 52 weeks). This parameter is optional when
interval=sporadic. */
    intervalCount?: number | undefined;
    /** Unique identifier for the mandate or subscription. */
    reference?: string | undefined;
    /** Start date of the mandate or subscription. Start date should not be lesser than
yesterday. */
    startDate?: Date;
    /** Specifies the type of mandates supported. Possible values are india. */
    supportedTypes?: string[] | undefined;

    constructor(data?: ISetupIntentPaymentMethodOptionsCardMandateOptions) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.amount = _data["amount"];
            this.amountType = _data["amountType"];
            this.currency = _data["currency"];
            this.description = _data["description"];
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.interval = _data["interval"];
            this.intervalCount = _data["intervalCount"];
            this.reference = _data["reference"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["supportedTypes"])) {
                this.supportedTypes = [] as any;
                for (let item of _data["supportedTypes"])
                    this.supportedTypes!.push(item);
            }
        }
    }

    static override fromJS(data: any): SetupIntentPaymentMethodOptionsCardMandateOptions {
        data = typeof data === 'object' ? data : {};
        let result = new SetupIntentPaymentMethodOptionsCardMandateOptions();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["amountType"] = this.amountType;
        data["currency"] = this.currency;
        data["description"] = this.description;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["interval"] = this.interval;
        data["intervalCount"] = this.intervalCount;
        data["reference"] = this.reference;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        if (Array.isArray(this.supportedTypes)) {
            data["supportedTypes"] = [];
            for (let item of this.supportedTypes)
                data["supportedTypes"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface ISetupIntentPaymentMethodOptionsCardMandateOptions extends IStripeEntityOfSetupIntentPaymentMethodOptionsCardMandateOptions {
    /** Amount to be charged for future payments. */
    amount?: number;
    /** One of fixed or maximum. If fixed, the amount param refers
to the exact amount to be charged in future payments. If maximum, the amount
charged can be up to the value passed for the amount param.
One of: fixed, or maximum. */
    amountType?: string | undefined;
    /** Three-letter ISO currency
code, in lowercase. Must be a supported
currency. */
    currency?: string | undefined;
    /** A description of the mandate or subscription that is meant to be displayed to the
customer. */
    description?: string | undefined;
    /** End date of the mandate or subscription. If not provided, the mandate will be active
until canceled. If provided, end date should be after start date. */
    endDate?: Date | undefined;
    /** Specifies payment frequency. One of day, week, month, year,
or sporadic.
One of: day, month, sporadic, week, or year. */
    interval?: string | undefined;
    /** The number of intervals between payments. For example, interval=month and
interval_count=3 indicates one payment every three months. Maximum of one year
interval allowed (1 year, 12 months, or 52 weeks). This parameter is optional when
interval=sporadic. */
    intervalCount?: number | undefined;
    /** Unique identifier for the mandate or subscription. */
    reference?: string | undefined;
    /** Start date of the mandate or subscription. Start date should not be lesser than
yesterday. */
    startDate?: Date;
    /** Specifies the type of mandates supported. Possible values are india. */
    supportedTypes?: string[] | undefined;
}

export abstract class StripeEntityOfSetupIntentPaymentMethodOptionsLink extends StripeEntity implements IStripeEntityOfSetupIntentPaymentMethodOptionsLink {

    constructor(data?: IStripeEntityOfSetupIntentPaymentMethodOptionsLink) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSetupIntentPaymentMethodOptionsLink {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSetupIntentPaymentMethodOptionsLink' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSetupIntentPaymentMethodOptionsLink extends IStripeEntity {
}

export class SetupIntentPaymentMethodOptionsLink extends StripeEntityOfSetupIntentPaymentMethodOptionsLink implements ISetupIntentPaymentMethodOptionsLink {
    /** Token used for persistent Link logins. */
    persistentToken?: string | undefined;

    constructor(data?: ISetupIntentPaymentMethodOptionsLink) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.persistentToken = _data["persistentToken"];
        }
    }

    static override fromJS(data: any): SetupIntentPaymentMethodOptionsLink {
        data = typeof data === 'object' ? data : {};
        let result = new SetupIntentPaymentMethodOptionsLink();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["persistentToken"] = this.persistentToken;
        super.toJSON(data);
        return data;
    }
}

export interface ISetupIntentPaymentMethodOptionsLink extends IStripeEntityOfSetupIntentPaymentMethodOptionsLink {
    /** Token used for persistent Link logins. */
    persistentToken?: string | undefined;
}

export abstract class StripeEntityOfSetupIntentPaymentMethodOptionsPaypal extends StripeEntity implements IStripeEntityOfSetupIntentPaymentMethodOptionsPaypal {

    constructor(data?: IStripeEntityOfSetupIntentPaymentMethodOptionsPaypal) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSetupIntentPaymentMethodOptionsPaypal {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSetupIntentPaymentMethodOptionsPaypal' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSetupIntentPaymentMethodOptionsPaypal extends IStripeEntity {
}

export class SetupIntentPaymentMethodOptionsPaypal extends StripeEntityOfSetupIntentPaymentMethodOptionsPaypal implements ISetupIntentPaymentMethodOptionsPaypal {
    /** The PayPal Billing Agreement ID (BAID). This is an ID generated by PayPal which
represents the mandate between the merchant and the customer. */
    billingAgreementId?: string | undefined;

    constructor(data?: ISetupIntentPaymentMethodOptionsPaypal) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.billingAgreementId = _data["billingAgreementId"];
        }
    }

    static override fromJS(data: any): SetupIntentPaymentMethodOptionsPaypal {
        data = typeof data === 'object' ? data : {};
        let result = new SetupIntentPaymentMethodOptionsPaypal();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["billingAgreementId"] = this.billingAgreementId;
        super.toJSON(data);
        return data;
    }
}

export interface ISetupIntentPaymentMethodOptionsPaypal extends IStripeEntityOfSetupIntentPaymentMethodOptionsPaypal {
    /** The PayPal Billing Agreement ID (BAID). This is an ID generated by PayPal which
represents the mandate between the merchant and the customer. */
    billingAgreementId?: string | undefined;
}

export abstract class StripeEntityOfSetupIntentPaymentMethodOptionsSepaDebit extends StripeEntity implements IStripeEntityOfSetupIntentPaymentMethodOptionsSepaDebit {

    constructor(data?: IStripeEntityOfSetupIntentPaymentMethodOptionsSepaDebit) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSetupIntentPaymentMethodOptionsSepaDebit {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSetupIntentPaymentMethodOptionsSepaDebit' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSetupIntentPaymentMethodOptionsSepaDebit extends IStripeEntity {
}

export class SetupIntentPaymentMethodOptionsSepaDebit extends StripeEntityOfSetupIntentPaymentMethodOptionsSepaDebit implements ISetupIntentPaymentMethodOptionsSepaDebit {
    mandateOptions?: SetupIntentPaymentMethodOptionsSepaDebitMandateOptions | undefined;

    constructor(data?: ISetupIntentPaymentMethodOptionsSepaDebit) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.mandateOptions = _data["mandateOptions"] ? SetupIntentPaymentMethodOptionsSepaDebitMandateOptions.fromJS(_data["mandateOptions"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): SetupIntentPaymentMethodOptionsSepaDebit {
        data = typeof data === 'object' ? data : {};
        let result = new SetupIntentPaymentMethodOptionsSepaDebit();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mandateOptions"] = this.mandateOptions ? this.mandateOptions.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface ISetupIntentPaymentMethodOptionsSepaDebit extends IStripeEntityOfSetupIntentPaymentMethodOptionsSepaDebit {
    mandateOptions?: SetupIntentPaymentMethodOptionsSepaDebitMandateOptions | undefined;
}

export abstract class StripeEntityOfSetupIntentPaymentMethodOptionsSepaDebitMandateOptions extends StripeEntity implements IStripeEntityOfSetupIntentPaymentMethodOptionsSepaDebitMandateOptions {

    constructor(data?: IStripeEntityOfSetupIntentPaymentMethodOptionsSepaDebitMandateOptions) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSetupIntentPaymentMethodOptionsSepaDebitMandateOptions {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSetupIntentPaymentMethodOptionsSepaDebitMandateOptions' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSetupIntentPaymentMethodOptionsSepaDebitMandateOptions extends IStripeEntity {
}

export class SetupIntentPaymentMethodOptionsSepaDebitMandateOptions extends StripeEntityOfSetupIntentPaymentMethodOptionsSepaDebitMandateOptions implements ISetupIntentPaymentMethodOptionsSepaDebitMandateOptions {

    constructor(data?: ISetupIntentPaymentMethodOptionsSepaDebitMandateOptions) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): SetupIntentPaymentMethodOptionsSepaDebitMandateOptions {
        data = typeof data === 'object' ? data : {};
        let result = new SetupIntentPaymentMethodOptionsSepaDebitMandateOptions();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ISetupIntentPaymentMethodOptionsSepaDebitMandateOptions extends IStripeEntityOfSetupIntentPaymentMethodOptionsSepaDebitMandateOptions {
}

export abstract class StripeEntityOfSetupIntentPaymentMethodOptionsUsBankAccount extends StripeEntity implements IStripeEntityOfSetupIntentPaymentMethodOptionsUsBankAccount {

    constructor(data?: IStripeEntityOfSetupIntentPaymentMethodOptionsUsBankAccount) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSetupIntentPaymentMethodOptionsUsBankAccount {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSetupIntentPaymentMethodOptionsUsBankAccount' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSetupIntentPaymentMethodOptionsUsBankAccount extends IStripeEntity {
}

export class SetupIntentPaymentMethodOptionsUsBankAccount extends StripeEntityOfSetupIntentPaymentMethodOptionsUsBankAccount implements ISetupIntentPaymentMethodOptionsUsBankAccount {
    financialConnections?: SetupIntentPaymentMethodOptionsUsBankAccountFinancialConnections | undefined;
    /** Bank account verification method.
One of: automatic, instant, or microdeposits. */
    verificationMethod?: string | undefined;

    constructor(data?: ISetupIntentPaymentMethodOptionsUsBankAccount) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.financialConnections = _data["financialConnections"] ? SetupIntentPaymentMethodOptionsUsBankAccountFinancialConnections.fromJS(_data["financialConnections"]) : <any>undefined;
            this.verificationMethod = _data["verificationMethod"];
        }
    }

    static override fromJS(data: any): SetupIntentPaymentMethodOptionsUsBankAccount {
        data = typeof data === 'object' ? data : {};
        let result = new SetupIntentPaymentMethodOptionsUsBankAccount();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["financialConnections"] = this.financialConnections ? this.financialConnections.toJSON() : <any>undefined;
        data["verificationMethod"] = this.verificationMethod;
        super.toJSON(data);
        return data;
    }
}

export interface ISetupIntentPaymentMethodOptionsUsBankAccount extends IStripeEntityOfSetupIntentPaymentMethodOptionsUsBankAccount {
    financialConnections?: SetupIntentPaymentMethodOptionsUsBankAccountFinancialConnections | undefined;
    /** Bank account verification method.
One of: automatic, instant, or microdeposits. */
    verificationMethod?: string | undefined;
}

export abstract class StripeEntityOfSetupIntentPaymentMethodOptionsUsBankAccountFinancialConnections extends StripeEntity implements IStripeEntityOfSetupIntentPaymentMethodOptionsUsBankAccountFinancialConnections {

    constructor(data?: IStripeEntityOfSetupIntentPaymentMethodOptionsUsBankAccountFinancialConnections) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSetupIntentPaymentMethodOptionsUsBankAccountFinancialConnections {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSetupIntentPaymentMethodOptionsUsBankAccountFinancialConnections' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSetupIntentPaymentMethodOptionsUsBankAccountFinancialConnections extends IStripeEntity {
}

export class SetupIntentPaymentMethodOptionsUsBankAccountFinancialConnections extends StripeEntityOfSetupIntentPaymentMethodOptionsUsBankAccountFinancialConnections implements ISetupIntentPaymentMethodOptionsUsBankAccountFinancialConnections {
    /** The list of permissions to request. The payment_method permission must be
included. */
    permissions?: string[] | undefined;
    /** For webview integrations only. Upon completing OAuth login in the native browser, the
user will be redirected to this URL to return to your app. */
    returnUrl?: string | undefined;

    constructor(data?: ISetupIntentPaymentMethodOptionsUsBankAccountFinancialConnections) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(item);
            }
            this.returnUrl = _data["returnUrl"];
        }
    }

    static override fromJS(data: any): SetupIntentPaymentMethodOptionsUsBankAccountFinancialConnections {
        data = typeof data === 'object' ? data : {};
        let result = new SetupIntentPaymentMethodOptionsUsBankAccountFinancialConnections();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        data["returnUrl"] = this.returnUrl;
        super.toJSON(data);
        return data;
    }
}

export interface ISetupIntentPaymentMethodOptionsUsBankAccountFinancialConnections extends IStripeEntityOfSetupIntentPaymentMethodOptionsUsBankAccountFinancialConnections {
    /** The list of permissions to request. The payment_method permission must be
included. */
    permissions?: string[] | undefined;
    /** For webview integrations only. Upon completing OAuth login in the native browser, the
user will be redirected to this URL to return to your app. */
    returnUrl?: string | undefined;
}

export abstract class StripeEntityOfStripeListOfInvoiceLineItem extends StripeEntity implements IStripeEntityOfStripeListOfInvoiceLineItem {

    constructor(data?: IStripeEntityOfStripeListOfInvoiceLineItem) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfStripeListOfInvoiceLineItem {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfStripeListOfInvoiceLineItem' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfStripeListOfInvoiceLineItem extends IStripeEntity {
}

export class StripeListOfInvoiceLineItem extends StripeEntityOfStripeListOfInvoiceLineItem implements IStripeListOfInvoiceLineItem {
    /** A string describing the object type returned. */
    object?: string | undefined;
    /** A list containing the actual response elements, paginated by any request parameters. */
    data?: InvoiceLineItem[] | undefined;
    /** Whether or not there are more elements available after this set. If false,
this set comprises the end of the list. */
    hasMore?: boolean;
    /** The URL for accessing this list. */
    url?: string | undefined;

    constructor(data?: IStripeListOfInvoiceLineItem) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.object = _data["object"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(InvoiceLineItem.fromJS(item));
            }
            this.hasMore = _data["hasMore"];
            this.url = _data["url"];
        }
    }

    static override fromJS(data: any): StripeListOfInvoiceLineItem {
        data = typeof data === 'object' ? data : {};
        let result = new StripeListOfInvoiceLineItem();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["object"] = this.object;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["hasMore"] = this.hasMore;
        data["url"] = this.url;
        super.toJSON(data);
        return data;
    }
}

export interface IStripeListOfInvoiceLineItem extends IStripeEntityOfStripeListOfInvoiceLineItem {
    /** A string describing the object type returned. */
    object?: string | undefined;
    /** A list containing the actual response elements, paginated by any request parameters. */
    data?: InvoiceLineItem[] | undefined;
    /** Whether or not there are more elements available after this set. If false,
this set comprises the end of the list. */
    hasMore?: boolean;
    /** The URL for accessing this list. */
    url?: string | undefined;
}

export abstract class StripeEntityOfInvoiceLineItem extends StripeEntity implements IStripeEntityOfInvoiceLineItem {

    constructor(data?: IStripeEntityOfInvoiceLineItem) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfInvoiceLineItem {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfInvoiceLineItem' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfInvoiceLineItem extends IStripeEntity {
}

export class InvoiceLineItem extends StripeEntityOfInvoiceLineItem implements IInvoiceLineItem {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** The amount, in %s. */
    amount?: number;
    /** The integer amount in %s representing the amount for this line item, excluding all tax
and discounts. */
    amountExcludingTax?: number | undefined;
    /** Three-letter ISO currency
code, in lowercase. Must be a supported
currency. */
    currency?: string | undefined;
    /** An arbitrary string attached to the object. Often useful for displaying to users. */
    description?: string | undefined;
    /** The amount of discount calculated per discount for this line item. */
    discountAmounts?: InvoiceLineItemDiscountAmount[] | undefined;
    /** If true, discounts will apply to this line item. Always false for prorations. */
    discountable?: boolean;
    /** (IDs of the Discounts)
The discounts applied to the invoice line item. Line item discounts are applied before
invoice discounts. Use expand[]=discounts to expand each discount. */
    discountIds?: string[] | undefined;
    /** (Expanded)
The discounts applied to the invoice line item. Line item discounts are applied before
invoice discounts. Use expand[]=discounts to expand each discount.
            
For more information, see the expand documentation. */
    discounts?: Discount[] | undefined;
    internalDiscounts?: ExpandableFieldOfDiscount[] | undefined;
    /** The ID of the invoice item
associated with this line item if any. */
    invoiceItem?: string | undefined;
    /** Has the value true if the object exists in live mode or the value false if
the object exists in test mode. */
    livemode?: boolean;
    /** Set of key-value pairs that you can
attach to an object. This can be useful for storing additional information about the
object in a structured format. Note that for line items with type=subscription
this will reflect the metadata of the subscription that caused the line item to be
created. */
    metadata?: { [key: string]: string; } | undefined;
    period?: InvoiceLineItemPeriod | undefined;
    /** The plan of the subscription, if the line item is a subscription or a proration. */
    plan?: Plan | undefined;
    /** The price of the line item. */
    price?: Price | undefined;
    /** Whether this is a proration. */
    proration?: boolean;
    /** Additional details for proration line items. */
    prorationDetails?: InvoiceLineItemProrationDetails | undefined;
    /** The quantity of the subscription, if the line item is a subscription or a proration. */
    quantity?: number | undefined;
    /** The subscription that the invoice item pertains to, if any. */
    subscription?: string | undefined;
    /** The subscription item that generated this line item. Left empty if the line item is not
an explicit result of a subscription. */
    subscriptionItem?: string | undefined;
    /** The amount of tax calculated per tax rate for this line item. */
    taxAmounts?: InvoiceLineItemTaxAmount[] | undefined;
    /** The tax rates which apply to the line item. */
    taxRates?: TaxRate[] | undefined;
    /** A string identifying the type of the source of this line item, either an
invoiceitem or a subscription.
One of: invoiceitem, or subscription. */
    type?: string | undefined;
    /** The amount in %s representing the unit amount for this line item, excluding all tax and
discounts. */
    unitAmountExcludingTax?: number | undefined;

    constructor(data?: IInvoiceLineItem) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.object = _data["object"];
            this.amount = _data["amount"];
            this.amountExcludingTax = _data["amountExcludingTax"];
            this.currency = _data["currency"];
            this.description = _data["description"];
            if (Array.isArray(_data["discountAmounts"])) {
                this.discountAmounts = [] as any;
                for (let item of _data["discountAmounts"])
                    this.discountAmounts!.push(InvoiceLineItemDiscountAmount.fromJS(item));
            }
            this.discountable = _data["discountable"];
            if (Array.isArray(_data["discountIds"])) {
                this.discountIds = [] as any;
                for (let item of _data["discountIds"])
                    this.discountIds!.push(item);
            }
            if (Array.isArray(_data["discounts"])) {
                this.discounts = [] as any;
                for (let item of _data["discounts"])
                    this.discounts!.push(Discount.fromJS(item));
            }
            if (Array.isArray(_data["internalDiscounts"])) {
                this.internalDiscounts = [] as any;
                for (let item of _data["internalDiscounts"])
                    this.internalDiscounts!.push(ExpandableFieldOfDiscount.fromJS(item));
            }
            this.invoiceItem = _data["invoiceItem"];
            this.livemode = _data["livemode"];
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
            this.period = _data["period"] ? InvoiceLineItemPeriod.fromJS(_data["period"]) : <any>undefined;
            this.plan = _data["plan"] ? Plan.fromJS(_data["plan"]) : <any>undefined;
            this.price = _data["price"] ? Price.fromJS(_data["price"]) : <any>undefined;
            this.proration = _data["proration"];
            this.prorationDetails = _data["prorationDetails"] ? InvoiceLineItemProrationDetails.fromJS(_data["prorationDetails"]) : <any>undefined;
            this.quantity = _data["quantity"];
            this.subscription = _data["subscription"];
            this.subscriptionItem = _data["subscriptionItem"];
            if (Array.isArray(_data["taxAmounts"])) {
                this.taxAmounts = [] as any;
                for (let item of _data["taxAmounts"])
                    this.taxAmounts!.push(InvoiceLineItemTaxAmount.fromJS(item));
            }
            if (Array.isArray(_data["taxRates"])) {
                this.taxRates = [] as any;
                for (let item of _data["taxRates"])
                    this.taxRates!.push(TaxRate.fromJS(item));
            }
            this.type = _data["type"];
            this.unitAmountExcludingTax = _data["unitAmountExcludingTax"];
        }
    }

    static override fromJS(data: any): InvoiceLineItem {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceLineItem();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["object"] = this.object;
        data["amount"] = this.amount;
        data["amountExcludingTax"] = this.amountExcludingTax;
        data["currency"] = this.currency;
        data["description"] = this.description;
        if (Array.isArray(this.discountAmounts)) {
            data["discountAmounts"] = [];
            for (let item of this.discountAmounts)
                data["discountAmounts"].push(item.toJSON());
        }
        data["discountable"] = this.discountable;
        if (Array.isArray(this.discountIds)) {
            data["discountIds"] = [];
            for (let item of this.discountIds)
                data["discountIds"].push(item);
        }
        if (Array.isArray(this.discounts)) {
            data["discounts"] = [];
            for (let item of this.discounts)
                data["discounts"].push(item.toJSON());
        }
        if (Array.isArray(this.internalDiscounts)) {
            data["internalDiscounts"] = [];
            for (let item of this.internalDiscounts)
                data["internalDiscounts"].push(item.toJSON());
        }
        data["invoiceItem"] = this.invoiceItem;
        data["livemode"] = this.livemode;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        data["period"] = this.period ? this.period.toJSON() : <any>undefined;
        data["plan"] = this.plan ? this.plan.toJSON() : <any>undefined;
        data["price"] = this.price ? this.price.toJSON() : <any>undefined;
        data["proration"] = this.proration;
        data["prorationDetails"] = this.prorationDetails ? this.prorationDetails.toJSON() : <any>undefined;
        data["quantity"] = this.quantity;
        data["subscription"] = this.subscription;
        data["subscriptionItem"] = this.subscriptionItem;
        if (Array.isArray(this.taxAmounts)) {
            data["taxAmounts"] = [];
            for (let item of this.taxAmounts)
                data["taxAmounts"].push(item.toJSON());
        }
        if (Array.isArray(this.taxRates)) {
            data["taxRates"] = [];
            for (let item of this.taxRates)
                data["taxRates"].push(item.toJSON());
        }
        data["type"] = this.type;
        data["unitAmountExcludingTax"] = this.unitAmountExcludingTax;
        super.toJSON(data);
        return data;
    }
}

export interface IInvoiceLineItem extends IStripeEntityOfInvoiceLineItem {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** The amount, in %s. */
    amount?: number;
    /** The integer amount in %s representing the amount for this line item, excluding all tax
and discounts. */
    amountExcludingTax?: number | undefined;
    /** Three-letter ISO currency
code, in lowercase. Must be a supported
currency. */
    currency?: string | undefined;
    /** An arbitrary string attached to the object. Often useful for displaying to users. */
    description?: string | undefined;
    /** The amount of discount calculated per discount for this line item. */
    discountAmounts?: InvoiceLineItemDiscountAmount[] | undefined;
    /** If true, discounts will apply to this line item. Always false for prorations. */
    discountable?: boolean;
    /** (IDs of the Discounts)
The discounts applied to the invoice line item. Line item discounts are applied before
invoice discounts. Use expand[]=discounts to expand each discount. */
    discountIds?: string[] | undefined;
    /** (Expanded)
The discounts applied to the invoice line item. Line item discounts are applied before
invoice discounts. Use expand[]=discounts to expand each discount.
            
For more information, see the expand documentation. */
    discounts?: Discount[] | undefined;
    internalDiscounts?: ExpandableFieldOfDiscount[] | undefined;
    /** The ID of the invoice item
associated with this line item if any. */
    invoiceItem?: string | undefined;
    /** Has the value true if the object exists in live mode or the value false if
the object exists in test mode. */
    livemode?: boolean;
    /** Set of key-value pairs that you can
attach to an object. This can be useful for storing additional information about the
object in a structured format. Note that for line items with type=subscription
this will reflect the metadata of the subscription that caused the line item to be
created. */
    metadata?: { [key: string]: string; } | undefined;
    period?: InvoiceLineItemPeriod | undefined;
    /** The plan of the subscription, if the line item is a subscription or a proration. */
    plan?: Plan | undefined;
    /** The price of the line item. */
    price?: Price | undefined;
    /** Whether this is a proration. */
    proration?: boolean;
    /** Additional details for proration line items. */
    prorationDetails?: InvoiceLineItemProrationDetails | undefined;
    /** The quantity of the subscription, if the line item is a subscription or a proration. */
    quantity?: number | undefined;
    /** The subscription that the invoice item pertains to, if any. */
    subscription?: string | undefined;
    /** The subscription item that generated this line item. Left empty if the line item is not
an explicit result of a subscription. */
    subscriptionItem?: string | undefined;
    /** The amount of tax calculated per tax rate for this line item. */
    taxAmounts?: InvoiceLineItemTaxAmount[] | undefined;
    /** The tax rates which apply to the line item. */
    taxRates?: TaxRate[] | undefined;
    /** A string identifying the type of the source of this line item, either an
invoiceitem or a subscription.
One of: invoiceitem, or subscription. */
    type?: string | undefined;
    /** The amount in %s representing the unit amount for this line item, excluding all tax and
discounts. */
    unitAmountExcludingTax?: number | undefined;
}

export abstract class StripeEntityOfInvoiceLineItemDiscountAmount extends StripeEntity implements IStripeEntityOfInvoiceLineItemDiscountAmount {

    constructor(data?: IStripeEntityOfInvoiceLineItemDiscountAmount) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfInvoiceLineItemDiscountAmount {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfInvoiceLineItemDiscountAmount' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfInvoiceLineItemDiscountAmount extends IStripeEntity {
}

export class InvoiceLineItemDiscountAmount extends StripeEntityOfInvoiceLineItemDiscountAmount implements IInvoiceLineItemDiscountAmount {
    /** The amount, in %s, of the discount. */
    amount?: number;
    /** (ID of the Discount)
The discount that was applied to get this discount amount. */
    discountId?: string | undefined;
    /** (Expanded)
The discount that was applied to get this discount amount.
            
For more information, see the expand documentation. */
    discount?: Discount | undefined;
    internalDiscount?: ExpandableFieldOfDiscount | undefined;

    constructor(data?: IInvoiceLineItemDiscountAmount) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.amount = _data["amount"];
            this.discountId = _data["discountId"];
            this.discount = _data["discount"] ? Discount.fromJS(_data["discount"]) : <any>undefined;
            this.internalDiscount = _data["internalDiscount"] ? ExpandableFieldOfDiscount.fromJS(_data["internalDiscount"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): InvoiceLineItemDiscountAmount {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceLineItemDiscountAmount();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["discountId"] = this.discountId;
        data["discount"] = this.discount ? this.discount.toJSON() : <any>undefined;
        data["internalDiscount"] = this.internalDiscount ? this.internalDiscount.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IInvoiceLineItemDiscountAmount extends IStripeEntityOfInvoiceLineItemDiscountAmount {
    /** The amount, in %s, of the discount. */
    amount?: number;
    /** (ID of the Discount)
The discount that was applied to get this discount amount. */
    discountId?: string | undefined;
    /** (Expanded)
The discount that was applied to get this discount amount.
            
For more information, see the expand documentation. */
    discount?: Discount | undefined;
    internalDiscount?: ExpandableFieldOfDiscount | undefined;
}

export abstract class StripeEntityOfInvoiceLineItemPeriod extends StripeEntity implements IStripeEntityOfInvoiceLineItemPeriod {

    constructor(data?: IStripeEntityOfInvoiceLineItemPeriod) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfInvoiceLineItemPeriod {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfInvoiceLineItemPeriod' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfInvoiceLineItemPeriod extends IStripeEntity {
}

export class InvoiceLineItemPeriod extends StripeEntityOfInvoiceLineItemPeriod implements IInvoiceLineItemPeriod {
    /** The end of the period, which must be greater than or equal to the start. This value is
inclusive. */
    end?: Date;
    /** The start of the period. This value is inclusive. */
    start?: Date;

    constructor(data?: IInvoiceLineItemPeriod) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.end = _data["end"] ? new Date(_data["end"].toString()) : <any>undefined;
            this.start = _data["start"] ? new Date(_data["start"].toString()) : <any>undefined;
        }
    }

    static override fromJS(data: any): InvoiceLineItemPeriod {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceLineItemPeriod();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["end"] = this.end ? this.end.toISOString() : <any>undefined;
        data["start"] = this.start ? this.start.toISOString() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IInvoiceLineItemPeriod extends IStripeEntityOfInvoiceLineItemPeriod {
    /** The end of the period, which must be greater than or equal to the start. This value is
inclusive. */
    end?: Date;
    /** The start of the period. This value is inclusive. */
    start?: Date;
}

export abstract class StripeEntityOfPlan extends StripeEntity implements IStripeEntityOfPlan {

    constructor(data?: IStripeEntityOfPlan) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPlan {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPlan' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPlan extends IStripeEntity {
}

/** You can now model subscriptions more flexibly using the Prices API. It replaces the Plans API and is backwards compatible to simplify your migration.            Plans define the base price, currency, and billing cycle for recurring purchases of products. Products help you track inventory or provisioning, and plans help you track pricing. Different physical goods or levels of service should be represented by products, and pricing options should be represented by plans. This approach lets you change prices without having to change your provisioning scheme.            For example, you might have a single "gold" product that has plans for $10/month, $100/year, €9/month, and €90/year.            Related guides: Set up a subscription and more about products and prices. */
export class Plan extends StripeEntityOfPlan implements IPlan {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** Whether the plan can be used for new purchases. */
    active?: boolean;
    /** Specifies a usage aggregation strategy for plans of usage_type=metered. Allowed
values are sum for summing up all usage during a period,
last_during_period for using the last usage record reported within a period,
last_ever for using the last usage record ever (across period bounds) or
max which uses the usage record with the maximum reported usage during a period.
Defaults to sum.
One of: last_during_period, last_ever, max, or sum. */
    aggregateUsage?: string | undefined;
    /** The unit amount in %s to be charged, represented as a whole integer if possible. Only
set if billing_scheme=per_unit. */
    amount?: number | undefined;
    /** The unit amount in %s to be charged, represented as a decimal string with at most 12
decimal places. Only set if billing_scheme=per_unit. */
    amountDecimal?: number | undefined;
    /** Describes how to compute the price per period. Either per_unit or tiered.
per_unit indicates that the fixed amount (specified in amount) will be
charged per unit in quantity (for plans with usage_type=licensed), or per
unit of total usage (for plans with usage_type=metered). tiered indicates
that the unit pricing will be computed using a tiering strategy as defined using the
tiers and tiers_mode attributes.
One of: per_unit, or tiered. */
    billingScheme?: string | undefined;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** Three-letter ISO currency
code, in lowercase. Must be a supported
currency. */
    currency?: string | undefined;
    /** Whether this object is deleted or not. */
    deleted?: boolean | undefined;
    /** The frequency at which a subscription is billed. One of day, week,
month or year.
One of: day, month, week, or year. */
    interval?: string | undefined;
    /** The number of intervals (specified in the interval attribute) between
subscription billings. For example, interval=month and interval_count=3
bills every 3 months. */
    intervalCount?: number;
    /** Has the value true if the object exists in live mode or the value false if
the object exists in test mode. */
    livemode?: boolean;
    /** Set of key-value pairs that you can
attach to an object. This can be useful for storing additional information about the
object in a structured format. */
    metadata?: { [key: string]: string; } | undefined;
    /** A brief description of the plan, hidden from customers. */
    nickname?: string | undefined;
    /** (ID of the Product)
The product whose pricing this plan determines. */
    productId?: string | undefined;
    /** (Expanded)
The product whose pricing this plan determines.
            
For more information, see the expand documentation. */
    product?: Product2 | undefined;
    internalProduct?: ExpandableFieldOfProduct | undefined;
    /** Each element represents a pricing tier. This parameter requires billing_scheme to
be set to tiered. See also the documentation for billing_scheme. */
    tiers?: PlanTier[] | undefined;
    /** Defines if the tiering price should be graduated or volume based. In
volume-based tiering, the maximum quantity within a period determines the per
unit price. In graduated tiering, pricing can change as the quantity grows.
One of: graduated, or volume. */
    tiersMode?: string | undefined;
    /** Apply a transformation to the reported usage or set quantity before computing the amount
billed. Cannot be combined with tiers. */
    transformUsage?: PlanTransformUsage | undefined;
    /** Default number of trial days when subscribing a customer to this plan using trial_from_plan=true. */
    trialPeriodDays?: number | undefined;
    /** Configures how the quantity per period should be determined. Can be either
metered or licensed. licensed automatically bills the
quantity set when adding it to a subscription. metered aggregates the
total usage based on usage records. Defaults to licensed.
One of: licensed, or metered. */
    usageType?: string | undefined;

    constructor(data?: IPlan) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.object = _data["object"];
            this.active = _data["active"];
            this.aggregateUsage = _data["aggregateUsage"];
            this.amount = _data["amount"];
            this.amountDecimal = _data["amountDecimal"];
            this.billingScheme = _data["billingScheme"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.currency = _data["currency"];
            this.deleted = _data["deleted"];
            this.interval = _data["interval"];
            this.intervalCount = _data["intervalCount"];
            this.livemode = _data["livemode"];
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
            this.nickname = _data["nickname"];
            this.productId = _data["productId"];
            this.product = _data["product"] ? Product2.fromJS(_data["product"]) : <any>undefined;
            this.internalProduct = _data["internalProduct"] ? ExpandableFieldOfProduct.fromJS(_data["internalProduct"]) : <any>undefined;
            if (Array.isArray(_data["tiers"])) {
                this.tiers = [] as any;
                for (let item of _data["tiers"])
                    this.tiers!.push(PlanTier.fromJS(item));
            }
            this.tiersMode = _data["tiersMode"];
            this.transformUsage = _data["transformUsage"] ? PlanTransformUsage.fromJS(_data["transformUsage"]) : <any>undefined;
            this.trialPeriodDays = _data["trialPeriodDays"];
            this.usageType = _data["usageType"];
        }
    }

    static override fromJS(data: any): Plan {
        data = typeof data === 'object' ? data : {};
        let result = new Plan();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["object"] = this.object;
        data["active"] = this.active;
        data["aggregateUsage"] = this.aggregateUsage;
        data["amount"] = this.amount;
        data["amountDecimal"] = this.amountDecimal;
        data["billingScheme"] = this.billingScheme;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["currency"] = this.currency;
        data["deleted"] = this.deleted;
        data["interval"] = this.interval;
        data["intervalCount"] = this.intervalCount;
        data["livemode"] = this.livemode;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        data["nickname"] = this.nickname;
        data["productId"] = this.productId;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["internalProduct"] = this.internalProduct ? this.internalProduct.toJSON() : <any>undefined;
        if (Array.isArray(this.tiers)) {
            data["tiers"] = [];
            for (let item of this.tiers)
                data["tiers"].push(item.toJSON());
        }
        data["tiersMode"] = this.tiersMode;
        data["transformUsage"] = this.transformUsage ? this.transformUsage.toJSON() : <any>undefined;
        data["trialPeriodDays"] = this.trialPeriodDays;
        data["usageType"] = this.usageType;
        super.toJSON(data);
        return data;
    }
}

/** You can now model subscriptions more flexibly using the Prices API. It replaces the Plans API and is backwards compatible to simplify your migration.            Plans define the base price, currency, and billing cycle for recurring purchases of products. Products help you track inventory or provisioning, and plans help you track pricing. Different physical goods or levels of service should be represented by products, and pricing options should be represented by plans. This approach lets you change prices without having to change your provisioning scheme.            For example, you might have a single "gold" product that has plans for $10/month, $100/year, €9/month, and €90/year.            Related guides: Set up a subscription and more about products and prices. */
export interface IPlan extends IStripeEntityOfPlan {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** Whether the plan can be used for new purchases. */
    active?: boolean;
    /** Specifies a usage aggregation strategy for plans of usage_type=metered. Allowed
values are sum for summing up all usage during a period,
last_during_period for using the last usage record reported within a period,
last_ever for using the last usage record ever (across period bounds) or
max which uses the usage record with the maximum reported usage during a period.
Defaults to sum.
One of: last_during_period, last_ever, max, or sum. */
    aggregateUsage?: string | undefined;
    /** The unit amount in %s to be charged, represented as a whole integer if possible. Only
set if billing_scheme=per_unit. */
    amount?: number | undefined;
    /** The unit amount in %s to be charged, represented as a decimal string with at most 12
decimal places. Only set if billing_scheme=per_unit. */
    amountDecimal?: number | undefined;
    /** Describes how to compute the price per period. Either per_unit or tiered.
per_unit indicates that the fixed amount (specified in amount) will be
charged per unit in quantity (for plans with usage_type=licensed), or per
unit of total usage (for plans with usage_type=metered). tiered indicates
that the unit pricing will be computed using a tiering strategy as defined using the
tiers and tiers_mode attributes.
One of: per_unit, or tiered. */
    billingScheme?: string | undefined;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** Three-letter ISO currency
code, in lowercase. Must be a supported
currency. */
    currency?: string | undefined;
    /** Whether this object is deleted or not. */
    deleted?: boolean | undefined;
    /** The frequency at which a subscription is billed. One of day, week,
month or year.
One of: day, month, week, or year. */
    interval?: string | undefined;
    /** The number of intervals (specified in the interval attribute) between
subscription billings. For example, interval=month and interval_count=3
bills every 3 months. */
    intervalCount?: number;
    /** Has the value true if the object exists in live mode or the value false if
the object exists in test mode. */
    livemode?: boolean;
    /** Set of key-value pairs that you can
attach to an object. This can be useful for storing additional information about the
object in a structured format. */
    metadata?: { [key: string]: string; } | undefined;
    /** A brief description of the plan, hidden from customers. */
    nickname?: string | undefined;
    /** (ID of the Product)
The product whose pricing this plan determines. */
    productId?: string | undefined;
    /** (Expanded)
The product whose pricing this plan determines.
            
For more information, see the expand documentation. */
    product?: Product2 | undefined;
    internalProduct?: ExpandableFieldOfProduct | undefined;
    /** Each element represents a pricing tier. This parameter requires billing_scheme to
be set to tiered. See also the documentation for billing_scheme. */
    tiers?: PlanTier[] | undefined;
    /** Defines if the tiering price should be graduated or volume based. In
volume-based tiering, the maximum quantity within a period determines the per
unit price. In graduated tiering, pricing can change as the quantity grows.
One of: graduated, or volume. */
    tiersMode?: string | undefined;
    /** Apply a transformation to the reported usage or set quantity before computing the amount
billed. Cannot be combined with tiers. */
    transformUsage?: PlanTransformUsage | undefined;
    /** Default number of trial days when subscribing a customer to this plan using trial_from_plan=true. */
    trialPeriodDays?: number | undefined;
    /** Configures how the quantity per period should be determined. Can be either
metered or licensed. licensed automatically bills the
quantity set when adding it to a subscription. metered aggregates the
total usage based on usage records. Defaults to licensed.
One of: licensed, or metered. */
    usageType?: string | undefined;
}

export abstract class StripeEntityOfProduct extends StripeEntity implements IStripeEntityOfProduct {

    constructor(data?: IStripeEntityOfProduct) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfProduct {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfProduct' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfProduct extends IStripeEntity {
}

/** Products describe the specific goods or services you offer to your customers. For example, you might offer a Standard and Premium version of your goods or service; each version would be a separate Product. They can be used in conjunction with Prices to configure pricing in Payment Links, Checkout, and Subscriptions.            Related guides: Set up a subscription, share a Payment Link, accept payments with Checkout, and more about Products and Prices. */
export class Product2 extends StripeEntityOfProduct implements IProduct2 {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** Whether the product is currently available for purchase. */
    active?: boolean;
    /** A list of up to 5 attributes that each SKU can provide values for (e.g., ["color",
"size"]). */
    attributes?: string[] | undefined;
    /** A short one-line description of the product, meant to be displayable to the customer.
Only applicable to products of type=good. */
    caption?: string | undefined;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** An array of connect application identifiers that cannot purchase this product. Only
applicable to products of type=good. */
    deactivateOn?: string[] | undefined;
    /** (ID of the Price)
The ID of the Price object that is the
default price for this product. */
    defaultPriceId?: string | undefined;
    /** (Expanded)
The ID of the Price object that is the
default price for this product.
            
For more information, see the expand documentation. */
    defaultPrice?: Price | undefined;
    internalDefaultPrice?: ExpandableFieldOfPrice | undefined;
    /** Whether this object is deleted or not. */
    deleted?: boolean | undefined;
    /** The product's description, meant to be displayable to the customer. Use this field to
optionally store a long form explanation of the product being sold for your own
rendering purposes. */
    description?: string | undefined;
    /** A list of up to 8 URLs of images for this product, meant to be displayable to the
customer. */
    images?: string[] | undefined;
    /** Has the value true if the object exists in live mode or the value false if
the object exists in test mode. */
    livemode?: boolean;
    /** Set of key-value pairs that you can
attach to an object. This can be useful for storing additional information about the
object in a structured format. */
    metadata?: { [key: string]: string; } | undefined;
    /** The product's name, meant to be displayable to the customer. */
    name?: string | undefined;
    /** The dimensions of this product for shipping purposes. */
    packageDimensions?: ProductPackageDimensions | undefined;
    /** Whether this product is shipped (i.e., physical goods). */
    shippable?: boolean | undefined;
    /** Extra information about a product which will appear on your customer's credit card
statement. In the case that multiple products are billed at once, the first statement
descriptor will be used. */
    statementDescriptor?: string | undefined;
    /** (ID of the TaxCode)
A tax code ID. */
    taxCodeId?: string | undefined;
    /** (Expanded)
A tax code ID.
            
For more information, see the expand documentation. */
    taxCode?: TaxCode | undefined;
    internalTaxCode?: ExpandableFieldOfTaxCode | undefined;
    /** The type of the product. The product is either of type good, which is eligible
for use with Orders and SKUs, or service, which is eligible for use with
Subscriptions and Plans.
One of: good, or service. */
    type?: string | undefined;
    /** A label that represents units of this product. When set, this will be included in
customers' receipts, invoices, Checkout, and the customer portal. */
    unitLabel?: string | undefined;
    /** Time at which the object was last updated. Measured in seconds since the Unix epoch. */
    updated?: Date;
    /** A URL of a publicly-accessible webpage for this product. */
    url?: string | undefined;

    constructor(data?: IProduct2) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.object = _data["object"];
            this.active = _data["active"];
            if (Array.isArray(_data["attributes"])) {
                this.attributes = [] as any;
                for (let item of _data["attributes"])
                    this.attributes!.push(item);
            }
            this.caption = _data["caption"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            if (Array.isArray(_data["deactivateOn"])) {
                this.deactivateOn = [] as any;
                for (let item of _data["deactivateOn"])
                    this.deactivateOn!.push(item);
            }
            this.defaultPriceId = _data["defaultPriceId"];
            this.defaultPrice = _data["defaultPrice"] ? Price.fromJS(_data["defaultPrice"]) : <any>undefined;
            this.internalDefaultPrice = _data["internalDefaultPrice"] ? ExpandableFieldOfPrice.fromJS(_data["internalDefaultPrice"]) : <any>undefined;
            this.deleted = _data["deleted"];
            this.description = _data["description"];
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(item);
            }
            this.livemode = _data["livemode"];
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
            this.name = _data["name"];
            this.packageDimensions = _data["packageDimensions"] ? ProductPackageDimensions.fromJS(_data["packageDimensions"]) : <any>undefined;
            this.shippable = _data["shippable"];
            this.statementDescriptor = _data["statementDescriptor"];
            this.taxCodeId = _data["taxCodeId"];
            this.taxCode = _data["taxCode"] ? TaxCode.fromJS(_data["taxCode"]) : <any>undefined;
            this.internalTaxCode = _data["internalTaxCode"] ? ExpandableFieldOfTaxCode.fromJS(_data["internalTaxCode"]) : <any>undefined;
            this.type = _data["type"];
            this.unitLabel = _data["unitLabel"];
            this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
            this.url = _data["url"];
        }
    }

    static override fromJS(data: any): Product2 {
        data = typeof data === 'object' ? data : {};
        let result = new Product2();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["object"] = this.object;
        data["active"] = this.active;
        if (Array.isArray(this.attributes)) {
            data["attributes"] = [];
            for (let item of this.attributes)
                data["attributes"].push(item);
        }
        data["caption"] = this.caption;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        if (Array.isArray(this.deactivateOn)) {
            data["deactivateOn"] = [];
            for (let item of this.deactivateOn)
                data["deactivateOn"].push(item);
        }
        data["defaultPriceId"] = this.defaultPriceId;
        data["defaultPrice"] = this.defaultPrice ? this.defaultPrice.toJSON() : <any>undefined;
        data["internalDefaultPrice"] = this.internalDefaultPrice ? this.internalDefaultPrice.toJSON() : <any>undefined;
        data["deleted"] = this.deleted;
        data["description"] = this.description;
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item);
        }
        data["livemode"] = this.livemode;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        data["name"] = this.name;
        data["packageDimensions"] = this.packageDimensions ? this.packageDimensions.toJSON() : <any>undefined;
        data["shippable"] = this.shippable;
        data["statementDescriptor"] = this.statementDescriptor;
        data["taxCodeId"] = this.taxCodeId;
        data["taxCode"] = this.taxCode ? this.taxCode.toJSON() : <any>undefined;
        data["internalTaxCode"] = this.internalTaxCode ? this.internalTaxCode.toJSON() : <any>undefined;
        data["type"] = this.type;
        data["unitLabel"] = this.unitLabel;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        data["url"] = this.url;
        super.toJSON(data);
        return data;
    }
}

/** Products describe the specific goods or services you offer to your customers. For example, you might offer a Standard and Premium version of your goods or service; each version would be a separate Product. They can be used in conjunction with Prices to configure pricing in Payment Links, Checkout, and Subscriptions.            Related guides: Set up a subscription, share a Payment Link, accept payments with Checkout, and more about Products and Prices. */
export interface IProduct2 extends IStripeEntityOfProduct {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** Whether the product is currently available for purchase. */
    active?: boolean;
    /** A list of up to 5 attributes that each SKU can provide values for (e.g., ["color",
"size"]). */
    attributes?: string[] | undefined;
    /** A short one-line description of the product, meant to be displayable to the customer.
Only applicable to products of type=good. */
    caption?: string | undefined;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** An array of connect application identifiers that cannot purchase this product. Only
applicable to products of type=good. */
    deactivateOn?: string[] | undefined;
    /** (ID of the Price)
The ID of the Price object that is the
default price for this product. */
    defaultPriceId?: string | undefined;
    /** (Expanded)
The ID of the Price object that is the
default price for this product.
            
For more information, see the expand documentation. */
    defaultPrice?: Price | undefined;
    internalDefaultPrice?: ExpandableFieldOfPrice | undefined;
    /** Whether this object is deleted or not. */
    deleted?: boolean | undefined;
    /** The product's description, meant to be displayable to the customer. Use this field to
optionally store a long form explanation of the product being sold for your own
rendering purposes. */
    description?: string | undefined;
    /** A list of up to 8 URLs of images for this product, meant to be displayable to the
customer. */
    images?: string[] | undefined;
    /** Has the value true if the object exists in live mode or the value false if
the object exists in test mode. */
    livemode?: boolean;
    /** Set of key-value pairs that you can
attach to an object. This can be useful for storing additional information about the
object in a structured format. */
    metadata?: { [key: string]: string; } | undefined;
    /** The product's name, meant to be displayable to the customer. */
    name?: string | undefined;
    /** The dimensions of this product for shipping purposes. */
    packageDimensions?: ProductPackageDimensions | undefined;
    /** Whether this product is shipped (i.e., physical goods). */
    shippable?: boolean | undefined;
    /** Extra information about a product which will appear on your customer's credit card
statement. In the case that multiple products are billed at once, the first statement
descriptor will be used. */
    statementDescriptor?: string | undefined;
    /** (ID of the TaxCode)
A tax code ID. */
    taxCodeId?: string | undefined;
    /** (Expanded)
A tax code ID.
            
For more information, see the expand documentation. */
    taxCode?: TaxCode | undefined;
    internalTaxCode?: ExpandableFieldOfTaxCode | undefined;
    /** The type of the product. The product is either of type good, which is eligible
for use with Orders and SKUs, or service, which is eligible for use with
Subscriptions and Plans.
One of: good, or service. */
    type?: string | undefined;
    /** A label that represents units of this product. When set, this will be included in
customers' receipts, invoices, Checkout, and the customer portal. */
    unitLabel?: string | undefined;
    /** Time at which the object was last updated. Measured in seconds since the Unix epoch. */
    updated?: Date;
    /** A URL of a publicly-accessible webpage for this product. */
    url?: string | undefined;
}

export abstract class StripeEntityOfPrice extends StripeEntity implements IStripeEntityOfPrice {

    constructor(data?: IStripeEntityOfPrice) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPrice {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPrice' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPrice extends IStripeEntity {
}

/** Prices define the unit cost, currency, and (optional) billing cycle for both recurring and one-time purchases of products. Products help you track inventory or provisioning, and prices help you track payment terms. Different physical goods or levels of service should be represented by products, and pricing options should be represented by prices. This approach lets you change prices without having to change your provisioning scheme.            For example, you might have a single "gold" product that has prices for $10/month, $100/year, and €9 once.            Related guides: Set up a subscription, create an invoice, and more about products and prices. */
export class Price extends StripeEntityOfPrice implements IPrice {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** Whether the price can be used for new purchases. */
    active?: boolean;
    /** Describes how to compute the price per period. Either per_unit or tiered.
per_unit indicates that the fixed amount (specified in unit_amount or
unit_amount_decimal) will be charged per unit in quantity (for prices with
usage_type=licensed), or per unit of total usage (for prices with
usage_type=metered). tiered indicates that the unit pricing will be
computed using a tiering strategy as defined using the tiers and
tiers_mode attributes.
One of: per_unit, or tiered. */
    billingScheme?: string | undefined;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** Three-letter ISO currency
code, in lowercase. Must be a supported
currency. */
    currency?: string | undefined;
    /** Prices defined in each available currency option. Each key must be a three-letter ISO currency code and a supported currency. */
    currencyOptions?: { [key: string]: PriceCurrencyOptions; } | undefined;
    /** When set, provides configuration for the amount to be adjusted by the customer during
Checkout Sessions and Payment Links. */
    customUnitAmount?: PriceCustomUnitAmount | undefined;
    /** Whether this object is deleted or not. */
    deleted?: boolean | undefined;
    /** Has the value true if the object exists in live mode or the value false if
the object exists in test mode. */
    livemode?: boolean;
    /** A lookup key used to retrieve prices dynamically from a static string. This may be up to
200 characters. */
    lookupKey?: string | undefined;
    /** Set of key-value pairs that you can
attach to an object. This can be useful for storing additional information about the
object in a structured format. */
    metadata?: { [key: string]: string; } | undefined;
    /** A brief description of the price, hidden from customers. */
    nickname?: string | undefined;
    /** (ID of the Product)
The ID of the product this price is associated with. */
    productId?: string | undefined;
    /** (Expanded)
The ID of the product this price is associated with.
            
For more information, see the expand documentation. */
    product?: Product2 | undefined;
    internalProduct?: ExpandableFieldOfProduct | undefined;
    /** The recurring components of a price such as interval and usage_type. */
    recurring?: PriceRecurring | undefined;
    /** Only required if a default
tax behavior was not provided in the Stripe Tax settings. Specifies whether the
price is considered inclusive of taxes or exclusive of taxes. One of inclusive,
exclusive, or unspecified. Once specified as either inclusive or
exclusive, it cannot be changed.
One of: exclusive, inclusive, or unspecified. */
    taxBehavior?: string | undefined;
    /** Each element represents a pricing tier. This parameter requires billing_scheme to
be set to tiered. See also the documentation for billing_scheme. */
    tiers?: PriceTier[] | undefined;
    /** Defines if the tiering price should be graduated or volume based. In
volume-based tiering, the maximum quantity within a period determines the per
unit price. In graduated tiering, pricing can change as the quantity grows.
One of: graduated, or volume. */
    tiersMode?: string | undefined;
    /** Apply a transformation to the reported usage or set quantity before computing the amount
billed. Cannot be combined with tiers. */
    transformQuantity?: PriceTransformQuantity | undefined;
    /** One of one_time or recurring depending on whether the price is for a
one-time purchase or a recurring (subscription) purchase.
One of: one_time, or recurring. */
    type?: string | undefined;
    /** The unit amount in %s to be charged, represented as a whole integer if possible. Only
set if billing_scheme=per_unit. */
    unitAmount?: number | undefined;
    /** The unit amount in %s to be charged, represented as a decimal string with at most 12
decimal places. Only set if billing_scheme=per_unit. */
    unitAmountDecimal?: number | undefined;

    constructor(data?: IPrice) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.object = _data["object"];
            this.active = _data["active"];
            this.billingScheme = _data["billingScheme"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.currency = _data["currency"];
            if (_data["currencyOptions"]) {
                this.currencyOptions = {} as any;
                for (let key in _data["currencyOptions"]) {
                    if (_data["currencyOptions"].hasOwnProperty(key))
                        (<any>this.currencyOptions)![key] = _data["currencyOptions"][key] ? PriceCurrencyOptions.fromJS(_data["currencyOptions"][key]) : new PriceCurrencyOptions();
                }
            }
            this.customUnitAmount = _data["customUnitAmount"] ? PriceCustomUnitAmount.fromJS(_data["customUnitAmount"]) : <any>undefined;
            this.deleted = _data["deleted"];
            this.livemode = _data["livemode"];
            this.lookupKey = _data["lookupKey"];
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
            this.nickname = _data["nickname"];
            this.productId = _data["productId"];
            this.product = _data["product"] ? Product2.fromJS(_data["product"]) : <any>undefined;
            this.internalProduct = _data["internalProduct"] ? ExpandableFieldOfProduct.fromJS(_data["internalProduct"]) : <any>undefined;
            this.recurring = _data["recurring"] ? PriceRecurring.fromJS(_data["recurring"]) : <any>undefined;
            this.taxBehavior = _data["taxBehavior"];
            if (Array.isArray(_data["tiers"])) {
                this.tiers = [] as any;
                for (let item of _data["tiers"])
                    this.tiers!.push(PriceTier.fromJS(item));
            }
            this.tiersMode = _data["tiersMode"];
            this.transformQuantity = _data["transformQuantity"] ? PriceTransformQuantity.fromJS(_data["transformQuantity"]) : <any>undefined;
            this.type = _data["type"];
            this.unitAmount = _data["unitAmount"];
            this.unitAmountDecimal = _data["unitAmountDecimal"];
        }
    }

    static override fromJS(data: any): Price {
        data = typeof data === 'object' ? data : {};
        let result = new Price();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["object"] = this.object;
        data["active"] = this.active;
        data["billingScheme"] = this.billingScheme;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["currency"] = this.currency;
        if (this.currencyOptions) {
            data["currencyOptions"] = {};
            for (let key in this.currencyOptions) {
                if (this.currencyOptions.hasOwnProperty(key))
                    (<any>data["currencyOptions"])[key] = this.currencyOptions[key] ? this.currencyOptions[key].toJSON() : <any>undefined;
            }
        }
        data["customUnitAmount"] = this.customUnitAmount ? this.customUnitAmount.toJSON() : <any>undefined;
        data["deleted"] = this.deleted;
        data["livemode"] = this.livemode;
        data["lookupKey"] = this.lookupKey;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        data["nickname"] = this.nickname;
        data["productId"] = this.productId;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["internalProduct"] = this.internalProduct ? this.internalProduct.toJSON() : <any>undefined;
        data["recurring"] = this.recurring ? this.recurring.toJSON() : <any>undefined;
        data["taxBehavior"] = this.taxBehavior;
        if (Array.isArray(this.tiers)) {
            data["tiers"] = [];
            for (let item of this.tiers)
                data["tiers"].push(item.toJSON());
        }
        data["tiersMode"] = this.tiersMode;
        data["transformQuantity"] = this.transformQuantity ? this.transformQuantity.toJSON() : <any>undefined;
        data["type"] = this.type;
        data["unitAmount"] = this.unitAmount;
        data["unitAmountDecimal"] = this.unitAmountDecimal;
        super.toJSON(data);
        return data;
    }
}

/** Prices define the unit cost, currency, and (optional) billing cycle for both recurring and one-time purchases of products. Products help you track inventory or provisioning, and prices help you track payment terms. Different physical goods or levels of service should be represented by products, and pricing options should be represented by prices. This approach lets you change prices without having to change your provisioning scheme.            For example, you might have a single "gold" product that has prices for $10/month, $100/year, and €9 once.            Related guides: Set up a subscription, create an invoice, and more about products and prices. */
export interface IPrice extends IStripeEntityOfPrice {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** Whether the price can be used for new purchases. */
    active?: boolean;
    /** Describes how to compute the price per period. Either per_unit or tiered.
per_unit indicates that the fixed amount (specified in unit_amount or
unit_amount_decimal) will be charged per unit in quantity (for prices with
usage_type=licensed), or per unit of total usage (for prices with
usage_type=metered). tiered indicates that the unit pricing will be
computed using a tiering strategy as defined using the tiers and
tiers_mode attributes.
One of: per_unit, or tiered. */
    billingScheme?: string | undefined;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** Three-letter ISO currency
code, in lowercase. Must be a supported
currency. */
    currency?: string | undefined;
    /** Prices defined in each available currency option. Each key must be a three-letter ISO currency code and a supported currency. */
    currencyOptions?: { [key: string]: PriceCurrencyOptions; } | undefined;
    /** When set, provides configuration for the amount to be adjusted by the customer during
Checkout Sessions and Payment Links. */
    customUnitAmount?: PriceCustomUnitAmount | undefined;
    /** Whether this object is deleted or not. */
    deleted?: boolean | undefined;
    /** Has the value true if the object exists in live mode or the value false if
the object exists in test mode. */
    livemode?: boolean;
    /** A lookup key used to retrieve prices dynamically from a static string. This may be up to
200 characters. */
    lookupKey?: string | undefined;
    /** Set of key-value pairs that you can
attach to an object. This can be useful for storing additional information about the
object in a structured format. */
    metadata?: { [key: string]: string; } | undefined;
    /** A brief description of the price, hidden from customers. */
    nickname?: string | undefined;
    /** (ID of the Product)
The ID of the product this price is associated with. */
    productId?: string | undefined;
    /** (Expanded)
The ID of the product this price is associated with.
            
For more information, see the expand documentation. */
    product?: Product2 | undefined;
    internalProduct?: ExpandableFieldOfProduct | undefined;
    /** The recurring components of a price such as interval and usage_type. */
    recurring?: PriceRecurring | undefined;
    /** Only required if a default
tax behavior was not provided in the Stripe Tax settings. Specifies whether the
price is considered inclusive of taxes or exclusive of taxes. One of inclusive,
exclusive, or unspecified. Once specified as either inclusive or
exclusive, it cannot be changed.
One of: exclusive, inclusive, or unspecified. */
    taxBehavior?: string | undefined;
    /** Each element represents a pricing tier. This parameter requires billing_scheme to
be set to tiered. See also the documentation for billing_scheme. */
    tiers?: PriceTier[] | undefined;
    /** Defines if the tiering price should be graduated or volume based. In
volume-based tiering, the maximum quantity within a period determines the per
unit price. In graduated tiering, pricing can change as the quantity grows.
One of: graduated, or volume. */
    tiersMode?: string | undefined;
    /** Apply a transformation to the reported usage or set quantity before computing the amount
billed. Cannot be combined with tiers. */
    transformQuantity?: PriceTransformQuantity | undefined;
    /** One of one_time or recurring depending on whether the price is for a
one-time purchase or a recurring (subscription) purchase.
One of: one_time, or recurring. */
    type?: string | undefined;
    /** The unit amount in %s to be charged, represented as a whole integer if possible. Only
set if billing_scheme=per_unit. */
    unitAmount?: number | undefined;
    /** The unit amount in %s to be charged, represented as a decimal string with at most 12
decimal places. Only set if billing_scheme=per_unit. */
    unitAmountDecimal?: number | undefined;
}

export abstract class StripeEntityOfPriceCurrencyOptions extends StripeEntity implements IStripeEntityOfPriceCurrencyOptions {

    constructor(data?: IStripeEntityOfPriceCurrencyOptions) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPriceCurrencyOptions {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPriceCurrencyOptions' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPriceCurrencyOptions extends IStripeEntity {
}

export class PriceCurrencyOptions extends StripeEntityOfPriceCurrencyOptions implements IPriceCurrencyOptions {
    /** When set, provides configuration for the amount to be adjusted by the customer during
Checkout Sessions and Payment Links. */
    customUnitAmount?: PriceCurrencyOptionsCustomUnitAmount | undefined;
    /** Only required if a default
tax behavior was not provided in the Stripe Tax settings. Specifies whether the
price is considered inclusive of taxes or exclusive of taxes. One of inclusive,
exclusive, or unspecified. Once specified as either inclusive or
exclusive, it cannot be changed.
One of: exclusive, inclusive, or unspecified. */
    taxBehavior?: string | undefined;
    /** Each element represents a pricing tier. This parameter requires billing_scheme to
be set to tiered. See also the documentation for billing_scheme. */
    tiers?: PriceCurrencyOptionsTier[] | undefined;
    /** The unit amount in %s to be charged, represented as a whole integer if possible. Only
set if billing_scheme=per_unit. */
    unitAmount?: number | undefined;
    /** The unit amount in %s to be charged, represented as a decimal string with at most 12
decimal places. Only set if billing_scheme=per_unit. */
    unitAmountDecimal?: number | undefined;

    constructor(data?: IPriceCurrencyOptions) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.customUnitAmount = _data["customUnitAmount"] ? PriceCurrencyOptionsCustomUnitAmount.fromJS(_data["customUnitAmount"]) : <any>undefined;
            this.taxBehavior = _data["taxBehavior"];
            if (Array.isArray(_data["tiers"])) {
                this.tiers = [] as any;
                for (let item of _data["tiers"])
                    this.tiers!.push(PriceCurrencyOptionsTier.fromJS(item));
            }
            this.unitAmount = _data["unitAmount"];
            this.unitAmountDecimal = _data["unitAmountDecimal"];
        }
    }

    static override fromJS(data: any): PriceCurrencyOptions {
        data = typeof data === 'object' ? data : {};
        let result = new PriceCurrencyOptions();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customUnitAmount"] = this.customUnitAmount ? this.customUnitAmount.toJSON() : <any>undefined;
        data["taxBehavior"] = this.taxBehavior;
        if (Array.isArray(this.tiers)) {
            data["tiers"] = [];
            for (let item of this.tiers)
                data["tiers"].push(item.toJSON());
        }
        data["unitAmount"] = this.unitAmount;
        data["unitAmountDecimal"] = this.unitAmountDecimal;
        super.toJSON(data);
        return data;
    }
}

export interface IPriceCurrencyOptions extends IStripeEntityOfPriceCurrencyOptions {
    /** When set, provides configuration for the amount to be adjusted by the customer during
Checkout Sessions and Payment Links. */
    customUnitAmount?: PriceCurrencyOptionsCustomUnitAmount | undefined;
    /** Only required if a default
tax behavior was not provided in the Stripe Tax settings. Specifies whether the
price is considered inclusive of taxes or exclusive of taxes. One of inclusive,
exclusive, or unspecified. Once specified as either inclusive or
exclusive, it cannot be changed.
One of: exclusive, inclusive, or unspecified. */
    taxBehavior?: string | undefined;
    /** Each element represents a pricing tier. This parameter requires billing_scheme to
be set to tiered. See also the documentation for billing_scheme. */
    tiers?: PriceCurrencyOptionsTier[] | undefined;
    /** The unit amount in %s to be charged, represented as a whole integer if possible. Only
set if billing_scheme=per_unit. */
    unitAmount?: number | undefined;
    /** The unit amount in %s to be charged, represented as a decimal string with at most 12
decimal places. Only set if billing_scheme=per_unit. */
    unitAmountDecimal?: number | undefined;
}

export abstract class StripeEntityOfPriceCurrencyOptionsCustomUnitAmount extends StripeEntity implements IStripeEntityOfPriceCurrencyOptionsCustomUnitAmount {

    constructor(data?: IStripeEntityOfPriceCurrencyOptionsCustomUnitAmount) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPriceCurrencyOptionsCustomUnitAmount {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPriceCurrencyOptionsCustomUnitAmount' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPriceCurrencyOptionsCustomUnitAmount extends IStripeEntity {
}

export class PriceCurrencyOptionsCustomUnitAmount extends StripeEntityOfPriceCurrencyOptionsCustomUnitAmount implements IPriceCurrencyOptionsCustomUnitAmount {
    /** The maximum unit amount the customer can specify for this item. */
    maximum?: number | undefined;
    /** The minimum unit amount the customer can specify for this item. Must be at least the
minimum charge amount. */
    minimum?: number | undefined;
    /** The starting unit amount which can be updated by the customer. */
    preset?: number | undefined;

    constructor(data?: IPriceCurrencyOptionsCustomUnitAmount) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.maximum = _data["maximum"];
            this.minimum = _data["minimum"];
            this.preset = _data["preset"];
        }
    }

    static override fromJS(data: any): PriceCurrencyOptionsCustomUnitAmount {
        data = typeof data === 'object' ? data : {};
        let result = new PriceCurrencyOptionsCustomUnitAmount();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maximum"] = this.maximum;
        data["minimum"] = this.minimum;
        data["preset"] = this.preset;
        super.toJSON(data);
        return data;
    }
}

export interface IPriceCurrencyOptionsCustomUnitAmount extends IStripeEntityOfPriceCurrencyOptionsCustomUnitAmount {
    /** The maximum unit amount the customer can specify for this item. */
    maximum?: number | undefined;
    /** The minimum unit amount the customer can specify for this item. Must be at least the
minimum charge amount. */
    minimum?: number | undefined;
    /** The starting unit amount which can be updated by the customer. */
    preset?: number | undefined;
}

export abstract class StripeEntityOfPriceCurrencyOptionsTier extends StripeEntity implements IStripeEntityOfPriceCurrencyOptionsTier {

    constructor(data?: IStripeEntityOfPriceCurrencyOptionsTier) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPriceCurrencyOptionsTier {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPriceCurrencyOptionsTier' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPriceCurrencyOptionsTier extends IStripeEntity {
}

export class PriceCurrencyOptionsTier extends StripeEntityOfPriceCurrencyOptionsTier implements IPriceCurrencyOptionsTier {
    /** Price for the entire tier. */
    flatAmount?: number | undefined;
    /** Same as flat_amount, but contains a decimal value with at most 12 decimal places. */
    flatAmountDecimal?: number | undefined;
    /** Per unit price for units relevant to the tier. */
    unitAmount?: number | undefined;
    /** Same as unit_amount, but contains a decimal value with at most 12 decimal places. */
    unitAmountDecimal?: number | undefined;
    /** Up to and including to this quantity will be contained in the tier. */
    upTo?: number | undefined;

    constructor(data?: IPriceCurrencyOptionsTier) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.flatAmount = _data["flatAmount"];
            this.flatAmountDecimal = _data["flatAmountDecimal"];
            this.unitAmount = _data["unitAmount"];
            this.unitAmountDecimal = _data["unitAmountDecimal"];
            this.upTo = _data["upTo"];
        }
    }

    static override fromJS(data: any): PriceCurrencyOptionsTier {
        data = typeof data === 'object' ? data : {};
        let result = new PriceCurrencyOptionsTier();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["flatAmount"] = this.flatAmount;
        data["flatAmountDecimal"] = this.flatAmountDecimal;
        data["unitAmount"] = this.unitAmount;
        data["unitAmountDecimal"] = this.unitAmountDecimal;
        data["upTo"] = this.upTo;
        super.toJSON(data);
        return data;
    }
}

export interface IPriceCurrencyOptionsTier extends IStripeEntityOfPriceCurrencyOptionsTier {
    /** Price for the entire tier. */
    flatAmount?: number | undefined;
    /** Same as flat_amount, but contains a decimal value with at most 12 decimal places. */
    flatAmountDecimal?: number | undefined;
    /** Per unit price for units relevant to the tier. */
    unitAmount?: number | undefined;
    /** Same as unit_amount, but contains a decimal value with at most 12 decimal places. */
    unitAmountDecimal?: number | undefined;
    /** Up to and including to this quantity will be contained in the tier. */
    upTo?: number | undefined;
}

export abstract class StripeEntityOfPriceCustomUnitAmount extends StripeEntity implements IStripeEntityOfPriceCustomUnitAmount {

    constructor(data?: IStripeEntityOfPriceCustomUnitAmount) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPriceCustomUnitAmount {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPriceCustomUnitAmount' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPriceCustomUnitAmount extends IStripeEntity {
}

export class PriceCustomUnitAmount extends StripeEntityOfPriceCustomUnitAmount implements IPriceCustomUnitAmount {
    /** The maximum unit amount the customer can specify for this item. */
    maximum?: number | undefined;
    /** The minimum unit amount the customer can specify for this item. Must be at least the
minimum charge amount. */
    minimum?: number | undefined;
    /** The starting unit amount which can be updated by the customer. */
    preset?: number | undefined;

    constructor(data?: IPriceCustomUnitAmount) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.maximum = _data["maximum"];
            this.minimum = _data["minimum"];
            this.preset = _data["preset"];
        }
    }

    static override fromJS(data: any): PriceCustomUnitAmount {
        data = typeof data === 'object' ? data : {};
        let result = new PriceCustomUnitAmount();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maximum"] = this.maximum;
        data["minimum"] = this.minimum;
        data["preset"] = this.preset;
        super.toJSON(data);
        return data;
    }
}

export interface IPriceCustomUnitAmount extends IStripeEntityOfPriceCustomUnitAmount {
    /** The maximum unit amount the customer can specify for this item. */
    maximum?: number | undefined;
    /** The minimum unit amount the customer can specify for this item. Must be at least the
minimum charge amount. */
    minimum?: number | undefined;
    /** The starting unit amount which can be updated by the customer. */
    preset?: number | undefined;
}

/** Represents a generic expandable field. */
export class ExpandableFieldOfProduct implements IExpandableFieldOfProduct {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: Product2 | undefined;

    constructor(data?: IExpandableFieldOfProduct) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.expandedObject = _data["expandedObject"] ? Product2.fromJS(_data["expandedObject"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExpandableFieldOfProduct {
        data = typeof data === 'object' ? data : {};
        let result = new ExpandableFieldOfProduct();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["expandedObject"] = this.expandedObject ? this.expandedObject.toJSON() : <any>undefined;
        return data;
    }
}

/** Represents a generic expandable field. */
export interface IExpandableFieldOfProduct {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: Product2 | undefined;
}

export abstract class StripeEntityOfPriceRecurring extends StripeEntity implements IStripeEntityOfPriceRecurring {

    constructor(data?: IStripeEntityOfPriceRecurring) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPriceRecurring {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPriceRecurring' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPriceRecurring extends IStripeEntity {
}

export class PriceRecurring extends StripeEntityOfPriceRecurring implements IPriceRecurring {
    /** Specifies a usage aggregation strategy for prices of usage_type=metered. Allowed
values are sum for summing up all usage during a period,
last_during_period for using the last usage record reported within a period,
last_ever for using the last usage record ever (across period bounds) or
max which uses the usage record with the maximum reported usage during a period.
Defaults to sum.
One of: last_during_period, last_ever, max, or sum. */
    aggregateUsage?: string | undefined;
    /** The frequency at which a subscription is billed. One of day, week,
month or year.
One of: day, month, week, or year. */
    interval?: string | undefined;
    /** The number of intervals (specified in the interval attribute) between
subscription billings. For example, interval=month and interval_count=3
bills every 3 months. */
    intervalCount?: number;
    /** Default number of trial days when subscribing a customer to this price using trial_from_plan=true. */
    trialPeriodDays?: number | undefined;
    /** Configures how the quantity per period should be determined. Can be either
metered or licensed. licensed automatically bills the
quantity set when adding it to a subscription. metered aggregates the
total usage based on usage records. Defaults to licensed.
One of: licensed, or metered. */
    usageType?: string | undefined;

    constructor(data?: IPriceRecurring) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.aggregateUsage = _data["aggregateUsage"];
            this.interval = _data["interval"];
            this.intervalCount = _data["intervalCount"];
            this.trialPeriodDays = _data["trialPeriodDays"];
            this.usageType = _data["usageType"];
        }
    }

    static override fromJS(data: any): PriceRecurring {
        data = typeof data === 'object' ? data : {};
        let result = new PriceRecurring();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["aggregateUsage"] = this.aggregateUsage;
        data["interval"] = this.interval;
        data["intervalCount"] = this.intervalCount;
        data["trialPeriodDays"] = this.trialPeriodDays;
        data["usageType"] = this.usageType;
        super.toJSON(data);
        return data;
    }
}

export interface IPriceRecurring extends IStripeEntityOfPriceRecurring {
    /** Specifies a usage aggregation strategy for prices of usage_type=metered. Allowed
values are sum for summing up all usage during a period,
last_during_period for using the last usage record reported within a period,
last_ever for using the last usage record ever (across period bounds) or
max which uses the usage record with the maximum reported usage during a period.
Defaults to sum.
One of: last_during_period, last_ever, max, or sum. */
    aggregateUsage?: string | undefined;
    /** The frequency at which a subscription is billed. One of day, week,
month or year.
One of: day, month, week, or year. */
    interval?: string | undefined;
    /** The number of intervals (specified in the interval attribute) between
subscription billings. For example, interval=month and interval_count=3
bills every 3 months. */
    intervalCount?: number;
    /** Default number of trial days when subscribing a customer to this price using trial_from_plan=true. */
    trialPeriodDays?: number | undefined;
    /** Configures how the quantity per period should be determined. Can be either
metered or licensed. licensed automatically bills the
quantity set when adding it to a subscription. metered aggregates the
total usage based on usage records. Defaults to licensed.
One of: licensed, or metered. */
    usageType?: string | undefined;
}

export abstract class StripeEntityOfPriceTier extends StripeEntity implements IStripeEntityOfPriceTier {

    constructor(data?: IStripeEntityOfPriceTier) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPriceTier {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPriceTier' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPriceTier extends IStripeEntity {
}

export class PriceTier extends StripeEntityOfPriceTier implements IPriceTier {
    /** Price for the entire tier. */
    flatAmount?: number | undefined;
    /** Same as flat_amount, but contains a decimal value with at most 12 decimal places. */
    flatAmountDecimal?: number | undefined;
    /** Per unit price for units relevant to the tier. */
    unitAmount?: number | undefined;
    /** Same as unit_amount, but contains a decimal value with at most 12 decimal places. */
    unitAmountDecimal?: number | undefined;
    /** Up to and including to this quantity will be contained in the tier. */
    upTo?: number | undefined;

    constructor(data?: IPriceTier) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.flatAmount = _data["flatAmount"];
            this.flatAmountDecimal = _data["flatAmountDecimal"];
            this.unitAmount = _data["unitAmount"];
            this.unitAmountDecimal = _data["unitAmountDecimal"];
            this.upTo = _data["upTo"];
        }
    }

    static override fromJS(data: any): PriceTier {
        data = typeof data === 'object' ? data : {};
        let result = new PriceTier();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["flatAmount"] = this.flatAmount;
        data["flatAmountDecimal"] = this.flatAmountDecimal;
        data["unitAmount"] = this.unitAmount;
        data["unitAmountDecimal"] = this.unitAmountDecimal;
        data["upTo"] = this.upTo;
        super.toJSON(data);
        return data;
    }
}

export interface IPriceTier extends IStripeEntityOfPriceTier {
    /** Price for the entire tier. */
    flatAmount?: number | undefined;
    /** Same as flat_amount, but contains a decimal value with at most 12 decimal places. */
    flatAmountDecimal?: number | undefined;
    /** Per unit price for units relevant to the tier. */
    unitAmount?: number | undefined;
    /** Same as unit_amount, but contains a decimal value with at most 12 decimal places. */
    unitAmountDecimal?: number | undefined;
    /** Up to and including to this quantity will be contained in the tier. */
    upTo?: number | undefined;
}

export abstract class StripeEntityOfPriceTransformQuantity extends StripeEntity implements IStripeEntityOfPriceTransformQuantity {

    constructor(data?: IStripeEntityOfPriceTransformQuantity) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPriceTransformQuantity {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPriceTransformQuantity' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPriceTransformQuantity extends IStripeEntity {
}

export class PriceTransformQuantity extends StripeEntityOfPriceTransformQuantity implements IPriceTransformQuantity {
    /** Divide usage by this number. */
    divideBy?: number;
    /** After division, either round the result up or down.
One of: down, or up. */
    round?: string | undefined;

    constructor(data?: IPriceTransformQuantity) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.divideBy = _data["divideBy"];
            this.round = _data["round"];
        }
    }

    static override fromJS(data: any): PriceTransformQuantity {
        data = typeof data === 'object' ? data : {};
        let result = new PriceTransformQuantity();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["divideBy"] = this.divideBy;
        data["round"] = this.round;
        super.toJSON(data);
        return data;
    }
}

export interface IPriceTransformQuantity extends IStripeEntityOfPriceTransformQuantity {
    /** Divide usage by this number. */
    divideBy?: number;
    /** After division, either round the result up or down.
One of: down, or up. */
    round?: string | undefined;
}

/** Represents a generic expandable field. */
export class ExpandableFieldOfPrice implements IExpandableFieldOfPrice {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: Price | undefined;

    constructor(data?: IExpandableFieldOfPrice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.expandedObject = _data["expandedObject"] ? Price.fromJS(_data["expandedObject"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExpandableFieldOfPrice {
        data = typeof data === 'object' ? data : {};
        let result = new ExpandableFieldOfPrice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["expandedObject"] = this.expandedObject ? this.expandedObject.toJSON() : <any>undefined;
        return data;
    }
}

/** Represents a generic expandable field. */
export interface IExpandableFieldOfPrice {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: Price | undefined;
}

export abstract class StripeEntityOfProductPackageDimensions extends StripeEntity implements IStripeEntityOfProductPackageDimensions {

    constructor(data?: IStripeEntityOfProductPackageDimensions) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfProductPackageDimensions {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfProductPackageDimensions' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfProductPackageDimensions extends IStripeEntity {
}

export class ProductPackageDimensions extends StripeEntityOfProductPackageDimensions implements IProductPackageDimensions {
    /** Height, in inches. */
    height?: number;
    /** Length, in inches. */
    length?: number;
    /** Weight, in ounces. */
    weight?: number;
    /** Width, in inches. */
    width?: number;

    constructor(data?: IProductPackageDimensions) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.height = _data["height"];
            this.length = _data["length"];
            this.weight = _data["weight"];
            this.width = _data["width"];
        }
    }

    static override fromJS(data: any): ProductPackageDimensions {
        data = typeof data === 'object' ? data : {};
        let result = new ProductPackageDimensions();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["height"] = this.height;
        data["length"] = this.length;
        data["weight"] = this.weight;
        data["width"] = this.width;
        super.toJSON(data);
        return data;
    }
}

export interface IProductPackageDimensions extends IStripeEntityOfProductPackageDimensions {
    /** Height, in inches. */
    height?: number;
    /** Length, in inches. */
    length?: number;
    /** Weight, in ounces. */
    weight?: number;
    /** Width, in inches. */
    width?: number;
}

export abstract class StripeEntityOfTaxCode extends StripeEntity implements IStripeEntityOfTaxCode {

    constructor(data?: IStripeEntityOfTaxCode) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfTaxCode {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfTaxCode' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfTaxCode extends IStripeEntity {
}

/** Tax codes classify goods and services for tax purposes. */
export class TaxCode extends StripeEntityOfTaxCode implements ITaxCode {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** A detailed description of which types of products the tax code represents. */
    description?: string | undefined;
    /** A short name for the tax code. */
    name?: string | undefined;

    constructor(data?: ITaxCode) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.object = _data["object"];
            this.description = _data["description"];
            this.name = _data["name"];
        }
    }

    static override fromJS(data: any): TaxCode {
        data = typeof data === 'object' ? data : {};
        let result = new TaxCode();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["object"] = this.object;
        data["description"] = this.description;
        data["name"] = this.name;
        super.toJSON(data);
        return data;
    }
}

/** Tax codes classify goods and services for tax purposes. */
export interface ITaxCode extends IStripeEntityOfTaxCode {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** A detailed description of which types of products the tax code represents. */
    description?: string | undefined;
    /** A short name for the tax code. */
    name?: string | undefined;
}

/** Represents a generic expandable field. */
export class ExpandableFieldOfTaxCode implements IExpandableFieldOfTaxCode {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: TaxCode | undefined;

    constructor(data?: IExpandableFieldOfTaxCode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.expandedObject = _data["expandedObject"] ? TaxCode.fromJS(_data["expandedObject"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExpandableFieldOfTaxCode {
        data = typeof data === 'object' ? data : {};
        let result = new ExpandableFieldOfTaxCode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["expandedObject"] = this.expandedObject ? this.expandedObject.toJSON() : <any>undefined;
        return data;
    }
}

/** Represents a generic expandable field. */
export interface IExpandableFieldOfTaxCode {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: TaxCode | undefined;
}

export abstract class StripeEntityOfPlanTier extends StripeEntity implements IStripeEntityOfPlanTier {

    constructor(data?: IStripeEntityOfPlanTier) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPlanTier {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPlanTier' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPlanTier extends IStripeEntity {
}

export class PlanTier extends StripeEntityOfPlanTier implements IPlanTier {
    /** Price for the entire tier. */
    flatAmount?: number | undefined;
    /** Same as flat_amount, but contains a decimal value with at most 12 decimal places. */
    flatAmountDecimal?: number | undefined;
    /** Per unit price for units relevant to the tier. */
    unitAmount?: number | undefined;
    /** Same as unit_amount, but contains a decimal value with at most 12 decimal places. */
    unitAmountDecimal?: number | undefined;
    /** Up to and including to this quantity will be contained in the tier. */
    upTo?: number | undefined;

    constructor(data?: IPlanTier) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.flatAmount = _data["flatAmount"];
            this.flatAmountDecimal = _data["flatAmountDecimal"];
            this.unitAmount = _data["unitAmount"];
            this.unitAmountDecimal = _data["unitAmountDecimal"];
            this.upTo = _data["upTo"];
        }
    }

    static override fromJS(data: any): PlanTier {
        data = typeof data === 'object' ? data : {};
        let result = new PlanTier();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["flatAmount"] = this.flatAmount;
        data["flatAmountDecimal"] = this.flatAmountDecimal;
        data["unitAmount"] = this.unitAmount;
        data["unitAmountDecimal"] = this.unitAmountDecimal;
        data["upTo"] = this.upTo;
        super.toJSON(data);
        return data;
    }
}

export interface IPlanTier extends IStripeEntityOfPlanTier {
    /** Price for the entire tier. */
    flatAmount?: number | undefined;
    /** Same as flat_amount, but contains a decimal value with at most 12 decimal places. */
    flatAmountDecimal?: number | undefined;
    /** Per unit price for units relevant to the tier. */
    unitAmount?: number | undefined;
    /** Same as unit_amount, but contains a decimal value with at most 12 decimal places. */
    unitAmountDecimal?: number | undefined;
    /** Up to and including to this quantity will be contained in the tier. */
    upTo?: number | undefined;
}

export abstract class StripeEntityOfPlanTransformUsage extends StripeEntity implements IStripeEntityOfPlanTransformUsage {

    constructor(data?: IStripeEntityOfPlanTransformUsage) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPlanTransformUsage {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPlanTransformUsage' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPlanTransformUsage extends IStripeEntity {
}

export class PlanTransformUsage extends StripeEntityOfPlanTransformUsage implements IPlanTransformUsage {
    /** Divide usage by this number. */
    divideBy?: number;
    /** After division, either round the result up or down.
One of: down, or up. */
    round?: string | undefined;

    constructor(data?: IPlanTransformUsage) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.divideBy = _data["divideBy"];
            this.round = _data["round"];
        }
    }

    static override fromJS(data: any): PlanTransformUsage {
        data = typeof data === 'object' ? data : {};
        let result = new PlanTransformUsage();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["divideBy"] = this.divideBy;
        data["round"] = this.round;
        super.toJSON(data);
        return data;
    }
}

export interface IPlanTransformUsage extends IStripeEntityOfPlanTransformUsage {
    /** Divide usage by this number. */
    divideBy?: number;
    /** After division, either round the result up or down.
One of: down, or up. */
    round?: string | undefined;
}

export abstract class StripeEntityOfInvoiceLineItemProrationDetails extends StripeEntity implements IStripeEntityOfInvoiceLineItemProrationDetails {

    constructor(data?: IStripeEntityOfInvoiceLineItemProrationDetails) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfInvoiceLineItemProrationDetails {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfInvoiceLineItemProrationDetails' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfInvoiceLineItemProrationDetails extends IStripeEntity {
}

export class InvoiceLineItemProrationDetails extends StripeEntityOfInvoiceLineItemProrationDetails implements IInvoiceLineItemProrationDetails {
    /** For a credit proration line_item, the original debit line_items to which the
credit proration applies. */
    creditedItems?: InvoiceLineItemProrationDetailsCreditedItems | undefined;

    constructor(data?: IInvoiceLineItemProrationDetails) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.creditedItems = _data["creditedItems"] ? InvoiceLineItemProrationDetailsCreditedItems.fromJS(_data["creditedItems"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): InvoiceLineItemProrationDetails {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceLineItemProrationDetails();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["creditedItems"] = this.creditedItems ? this.creditedItems.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IInvoiceLineItemProrationDetails extends IStripeEntityOfInvoiceLineItemProrationDetails {
    /** For a credit proration line_item, the original debit line_items to which the
credit proration applies. */
    creditedItems?: InvoiceLineItemProrationDetailsCreditedItems | undefined;
}

export abstract class StripeEntityOfInvoiceLineItemProrationDetailsCreditedItems extends StripeEntity implements IStripeEntityOfInvoiceLineItemProrationDetailsCreditedItems {

    constructor(data?: IStripeEntityOfInvoiceLineItemProrationDetailsCreditedItems) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfInvoiceLineItemProrationDetailsCreditedItems {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfInvoiceLineItemProrationDetailsCreditedItems' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfInvoiceLineItemProrationDetailsCreditedItems extends IStripeEntity {
}

export class InvoiceLineItemProrationDetailsCreditedItems extends StripeEntityOfInvoiceLineItemProrationDetailsCreditedItems implements IInvoiceLineItemProrationDetailsCreditedItems {
    /** Invoice containing the credited invoice line items. */
    invoice?: string | undefined;
    /** Credited invoice line items. */
    invoiceLineItems?: string[] | undefined;

    constructor(data?: IInvoiceLineItemProrationDetailsCreditedItems) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.invoice = _data["invoice"];
            if (Array.isArray(_data["invoiceLineItems"])) {
                this.invoiceLineItems = [] as any;
                for (let item of _data["invoiceLineItems"])
                    this.invoiceLineItems!.push(item);
            }
        }
    }

    static override fromJS(data: any): InvoiceLineItemProrationDetailsCreditedItems {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceLineItemProrationDetailsCreditedItems();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["invoice"] = this.invoice;
        if (Array.isArray(this.invoiceLineItems)) {
            data["invoiceLineItems"] = [];
            for (let item of this.invoiceLineItems)
                data["invoiceLineItems"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IInvoiceLineItemProrationDetailsCreditedItems extends IStripeEntityOfInvoiceLineItemProrationDetailsCreditedItems {
    /** Invoice containing the credited invoice line items. */
    invoice?: string | undefined;
    /** Credited invoice line items. */
    invoiceLineItems?: string[] | undefined;
}

export abstract class StripeEntityOfInvoiceLineItemTaxAmount extends StripeEntity implements IStripeEntityOfInvoiceLineItemTaxAmount {

    constructor(data?: IStripeEntityOfInvoiceLineItemTaxAmount) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfInvoiceLineItemTaxAmount {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfInvoiceLineItemTaxAmount' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfInvoiceLineItemTaxAmount extends IStripeEntity {
}

export class InvoiceLineItemTaxAmount extends StripeEntityOfInvoiceLineItemTaxAmount implements IInvoiceLineItemTaxAmount {
    /** The amount, in %s, of the tax. */
    amount?: number;
    /** Whether this tax amount is inclusive or exclusive. */
    inclusive?: boolean;
    /** (ID of the TaxRate)
The tax rate that was applied to get this tax amount. */
    taxRateId?: string | undefined;
    /** (Expanded)
The tax rate that was applied to get this tax amount.
            
For more information, see the expand documentation. */
    taxRate?: TaxRate | undefined;
    internalTaxRate?: ExpandableFieldOfTaxRate | undefined;
    /** The reasoning behind this tax, for example, if the product is tax exempt. The possible
values for this field may be extended as new tax rules are supported.
One of: customer_exempt, not_collecting, not_subject_to_tax,
not_supported, portion_product_exempt, portion_reduced_rated,
portion_standard_rated, product_exempt, product_exempt_holiday,
proportionally_rated, reduced_rated, reverse_charge,
standard_rated, taxable_basis_reduced, or zero_rated. */
    taxabilityReason?: string | undefined;
    /** The amount on which tax is calculated, in %s. */
    taxableAmount?: number | undefined;

    constructor(data?: IInvoiceLineItemTaxAmount) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.amount = _data["amount"];
            this.inclusive = _data["inclusive"];
            this.taxRateId = _data["taxRateId"];
            this.taxRate = _data["taxRate"] ? TaxRate.fromJS(_data["taxRate"]) : <any>undefined;
            this.internalTaxRate = _data["internalTaxRate"] ? ExpandableFieldOfTaxRate.fromJS(_data["internalTaxRate"]) : <any>undefined;
            this.taxabilityReason = _data["taxabilityReason"];
            this.taxableAmount = _data["taxableAmount"];
        }
    }

    static override fromJS(data: any): InvoiceLineItemTaxAmount {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceLineItemTaxAmount();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["inclusive"] = this.inclusive;
        data["taxRateId"] = this.taxRateId;
        data["taxRate"] = this.taxRate ? this.taxRate.toJSON() : <any>undefined;
        data["internalTaxRate"] = this.internalTaxRate ? this.internalTaxRate.toJSON() : <any>undefined;
        data["taxabilityReason"] = this.taxabilityReason;
        data["taxableAmount"] = this.taxableAmount;
        super.toJSON(data);
        return data;
    }
}

export interface IInvoiceLineItemTaxAmount extends IStripeEntityOfInvoiceLineItemTaxAmount {
    /** The amount, in %s, of the tax. */
    amount?: number;
    /** Whether this tax amount is inclusive or exclusive. */
    inclusive?: boolean;
    /** (ID of the TaxRate)
The tax rate that was applied to get this tax amount. */
    taxRateId?: string | undefined;
    /** (Expanded)
The tax rate that was applied to get this tax amount.
            
For more information, see the expand documentation. */
    taxRate?: TaxRate | undefined;
    internalTaxRate?: ExpandableFieldOfTaxRate | undefined;
    /** The reasoning behind this tax, for example, if the product is tax exempt. The possible
values for this field may be extended as new tax rules are supported.
One of: customer_exempt, not_collecting, not_subject_to_tax,
not_supported, portion_product_exempt, portion_reduced_rated,
portion_standard_rated, product_exempt, product_exempt_holiday,
proportionally_rated, reduced_rated, reverse_charge,
standard_rated, taxable_basis_reduced, or zero_rated. */
    taxabilityReason?: string | undefined;
    /** The amount on which tax is calculated, in %s. */
    taxableAmount?: number | undefined;
}

/** Represents a generic expandable field. */
export class ExpandableFieldOfTaxRate implements IExpandableFieldOfTaxRate {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: TaxRate | undefined;

    constructor(data?: IExpandableFieldOfTaxRate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.expandedObject = _data["expandedObject"] ? TaxRate.fromJS(_data["expandedObject"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExpandableFieldOfTaxRate {
        data = typeof data === 'object' ? data : {};
        let result = new ExpandableFieldOfTaxRate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["expandedObject"] = this.expandedObject ? this.expandedObject.toJSON() : <any>undefined;
        return data;
    }
}

/** Represents a generic expandable field. */
export interface IExpandableFieldOfTaxRate {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: TaxRate | undefined;
}

/** Represents a generic expandable field. */
export class ExpandableFieldOfPaymentIntent implements IExpandableFieldOfPaymentIntent {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: PaymentIntent | undefined;

    constructor(data?: IExpandableFieldOfPaymentIntent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.expandedObject = _data["expandedObject"] ? PaymentIntent.fromJS(_data["expandedObject"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExpandableFieldOfPaymentIntent {
        data = typeof data === 'object' ? data : {};
        let result = new ExpandableFieldOfPaymentIntent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["expandedObject"] = this.expandedObject ? this.expandedObject.toJSON() : <any>undefined;
        return data;
    }
}

/** Represents a generic expandable field. */
export interface IExpandableFieldOfPaymentIntent {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: PaymentIntent | undefined;
}

export abstract class StripeEntityOfInvoicePaymentSettings extends StripeEntity implements IStripeEntityOfInvoicePaymentSettings {

    constructor(data?: IStripeEntityOfInvoicePaymentSettings) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfInvoicePaymentSettings {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfInvoicePaymentSettings' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfInvoicePaymentSettings extends IStripeEntity {
}

export class InvoicePaymentSettings extends StripeEntityOfInvoicePaymentSettings implements IInvoicePaymentSettings {
    /** ID of the mandate to be used for this invoice. It must correspond to the payment method
used to pay the invoice, including the invoice's default_payment_method or
default_source, if set. */
    defaultMandate?: string | undefined;
    /** Payment-method-specific configuration to provide to the invoice’s PaymentIntent. */
    paymentMethodOptions?: InvoicePaymentSettingsPaymentMethodOptions | undefined;
    /** The list of payment method types (e.g. card) to provide to the invoice’s PaymentIntent.
If not set, Stripe attempts to automatically determine the types to use by looking at
the invoice’s default payment method, the subscription’s default payment method, the
customer’s default payment method, and your invoice template
settings. */
    paymentMethodTypes?: string[] | undefined;

    constructor(data?: IInvoicePaymentSettings) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.defaultMandate = _data["defaultMandate"];
            this.paymentMethodOptions = _data["paymentMethodOptions"] ? InvoicePaymentSettingsPaymentMethodOptions.fromJS(_data["paymentMethodOptions"]) : <any>undefined;
            if (Array.isArray(_data["paymentMethodTypes"])) {
                this.paymentMethodTypes = [] as any;
                for (let item of _data["paymentMethodTypes"])
                    this.paymentMethodTypes!.push(item);
            }
        }
    }

    static override fromJS(data: any): InvoicePaymentSettings {
        data = typeof data === 'object' ? data : {};
        let result = new InvoicePaymentSettings();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultMandate"] = this.defaultMandate;
        data["paymentMethodOptions"] = this.paymentMethodOptions ? this.paymentMethodOptions.toJSON() : <any>undefined;
        if (Array.isArray(this.paymentMethodTypes)) {
            data["paymentMethodTypes"] = [];
            for (let item of this.paymentMethodTypes)
                data["paymentMethodTypes"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IInvoicePaymentSettings extends IStripeEntityOfInvoicePaymentSettings {
    /** ID of the mandate to be used for this invoice. It must correspond to the payment method
used to pay the invoice, including the invoice's default_payment_method or
default_source, if set. */
    defaultMandate?: string | undefined;
    /** Payment-method-specific configuration to provide to the invoice’s PaymentIntent. */
    paymentMethodOptions?: InvoicePaymentSettingsPaymentMethodOptions | undefined;
    /** The list of payment method types (e.g. card) to provide to the invoice’s PaymentIntent.
If not set, Stripe attempts to automatically determine the types to use by looking at
the invoice’s default payment method, the subscription’s default payment method, the
customer’s default payment method, and your invoice template
settings. */
    paymentMethodTypes?: string[] | undefined;
}

export abstract class StripeEntityOfInvoicePaymentSettingsPaymentMethodOptions extends StripeEntity implements IStripeEntityOfInvoicePaymentSettingsPaymentMethodOptions {

    constructor(data?: IStripeEntityOfInvoicePaymentSettingsPaymentMethodOptions) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfInvoicePaymentSettingsPaymentMethodOptions {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfInvoicePaymentSettingsPaymentMethodOptions' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfInvoicePaymentSettingsPaymentMethodOptions extends IStripeEntity {
}

export class InvoicePaymentSettingsPaymentMethodOptions extends StripeEntityOfInvoicePaymentSettingsPaymentMethodOptions implements IInvoicePaymentSettingsPaymentMethodOptions {
    /** If paying by acss_debit, this sub-hash contains details about the Canadian
pre-authorized debit payment method options to pass to the invoice’s PaymentIntent. */
    acssDebit?: InvoicePaymentSettingsPaymentMethodOptionsAcssDebit | undefined;
    /** If paying by bancontact, this sub-hash contains details about the Bancontact
payment method options to pass to the invoice’s PaymentIntent. */
    bancontact?: InvoicePaymentSettingsPaymentMethodOptionsBancontact | undefined;
    /** If paying by card, this sub-hash contains details about the Card payment method
options to pass to the invoice’s PaymentIntent. */
    card?: InvoicePaymentSettingsPaymentMethodOptionsCard | undefined;
    /** If paying by customer_balance, this sub-hash contains details about the Bank
transfer payment method options to pass to the invoice’s PaymentIntent. */
    customerBalance?: InvoicePaymentSettingsPaymentMethodOptionsCustomerBalance | undefined;
    /** If paying by konbini, this sub-hash contains details about the Konbini payment
method options to pass to the invoice’s PaymentIntent. */
    konbini?: InvoicePaymentSettingsPaymentMethodOptionsKonbini | undefined;
    /** If paying by us_bank_account, this sub-hash contains details about the ACH direct
debit payment method options to pass to the invoice’s PaymentIntent. */
    usBankAccount?: InvoicePaymentSettingsPaymentMethodOptionsUsBankAccount | undefined;

    constructor(data?: IInvoicePaymentSettingsPaymentMethodOptions) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.acssDebit = _data["acssDebit"] ? InvoicePaymentSettingsPaymentMethodOptionsAcssDebit.fromJS(_data["acssDebit"]) : <any>undefined;
            this.bancontact = _data["bancontact"] ? InvoicePaymentSettingsPaymentMethodOptionsBancontact.fromJS(_data["bancontact"]) : <any>undefined;
            this.card = _data["card"] ? InvoicePaymentSettingsPaymentMethodOptionsCard.fromJS(_data["card"]) : <any>undefined;
            this.customerBalance = _data["customerBalance"] ? InvoicePaymentSettingsPaymentMethodOptionsCustomerBalance.fromJS(_data["customerBalance"]) : <any>undefined;
            this.konbini = _data["konbini"] ? InvoicePaymentSettingsPaymentMethodOptionsKonbini.fromJS(_data["konbini"]) : <any>undefined;
            this.usBankAccount = _data["usBankAccount"] ? InvoicePaymentSettingsPaymentMethodOptionsUsBankAccount.fromJS(_data["usBankAccount"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): InvoicePaymentSettingsPaymentMethodOptions {
        data = typeof data === 'object' ? data : {};
        let result = new InvoicePaymentSettingsPaymentMethodOptions();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["acssDebit"] = this.acssDebit ? this.acssDebit.toJSON() : <any>undefined;
        data["bancontact"] = this.bancontact ? this.bancontact.toJSON() : <any>undefined;
        data["card"] = this.card ? this.card.toJSON() : <any>undefined;
        data["customerBalance"] = this.customerBalance ? this.customerBalance.toJSON() : <any>undefined;
        data["konbini"] = this.konbini ? this.konbini.toJSON() : <any>undefined;
        data["usBankAccount"] = this.usBankAccount ? this.usBankAccount.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IInvoicePaymentSettingsPaymentMethodOptions extends IStripeEntityOfInvoicePaymentSettingsPaymentMethodOptions {
    /** If paying by acss_debit, this sub-hash contains details about the Canadian
pre-authorized debit payment method options to pass to the invoice’s PaymentIntent. */
    acssDebit?: InvoicePaymentSettingsPaymentMethodOptionsAcssDebit | undefined;
    /** If paying by bancontact, this sub-hash contains details about the Bancontact
payment method options to pass to the invoice’s PaymentIntent. */
    bancontact?: InvoicePaymentSettingsPaymentMethodOptionsBancontact | undefined;
    /** If paying by card, this sub-hash contains details about the Card payment method
options to pass to the invoice’s PaymentIntent. */
    card?: InvoicePaymentSettingsPaymentMethodOptionsCard | undefined;
    /** If paying by customer_balance, this sub-hash contains details about the Bank
transfer payment method options to pass to the invoice’s PaymentIntent. */
    customerBalance?: InvoicePaymentSettingsPaymentMethodOptionsCustomerBalance | undefined;
    /** If paying by konbini, this sub-hash contains details about the Konbini payment
method options to pass to the invoice’s PaymentIntent. */
    konbini?: InvoicePaymentSettingsPaymentMethodOptionsKonbini | undefined;
    /** If paying by us_bank_account, this sub-hash contains details about the ACH direct
debit payment method options to pass to the invoice’s PaymentIntent. */
    usBankAccount?: InvoicePaymentSettingsPaymentMethodOptionsUsBankAccount | undefined;
}

export abstract class StripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsAcssDebit extends StripeEntity implements IStripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsAcssDebit {

    constructor(data?: IStripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsAcssDebit) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsAcssDebit {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsAcssDebit' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsAcssDebit extends IStripeEntity {
}

export class InvoicePaymentSettingsPaymentMethodOptionsAcssDebit extends StripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsAcssDebit implements IInvoicePaymentSettingsPaymentMethodOptionsAcssDebit {
    mandateOptions?: InvoicePaymentSettingsPaymentMethodOptionsAcssDebitMandateOptions | undefined;
    /** Bank account verification method.
One of: automatic, instant, or microdeposits. */
    verificationMethod?: string | undefined;

    constructor(data?: IInvoicePaymentSettingsPaymentMethodOptionsAcssDebit) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.mandateOptions = _data["mandateOptions"] ? InvoicePaymentSettingsPaymentMethodOptionsAcssDebitMandateOptions.fromJS(_data["mandateOptions"]) : <any>undefined;
            this.verificationMethod = _data["verificationMethod"];
        }
    }

    static override fromJS(data: any): InvoicePaymentSettingsPaymentMethodOptionsAcssDebit {
        data = typeof data === 'object' ? data : {};
        let result = new InvoicePaymentSettingsPaymentMethodOptionsAcssDebit();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mandateOptions"] = this.mandateOptions ? this.mandateOptions.toJSON() : <any>undefined;
        data["verificationMethod"] = this.verificationMethod;
        super.toJSON(data);
        return data;
    }
}

export interface IInvoicePaymentSettingsPaymentMethodOptionsAcssDebit extends IStripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsAcssDebit {
    mandateOptions?: InvoicePaymentSettingsPaymentMethodOptionsAcssDebitMandateOptions | undefined;
    /** Bank account verification method.
One of: automatic, instant, or microdeposits. */
    verificationMethod?: string | undefined;
}

export abstract class StripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsAcssDebitMandateOptions extends StripeEntity implements IStripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsAcssDebitMandateOptions {

    constructor(data?: IStripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsAcssDebitMandateOptions) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsAcssDebitMandateOptions {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsAcssDebitMandateOptions' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsAcssDebitMandateOptions extends IStripeEntity {
}

export class InvoicePaymentSettingsPaymentMethodOptionsAcssDebitMandateOptions extends StripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsAcssDebitMandateOptions implements IInvoicePaymentSettingsPaymentMethodOptionsAcssDebitMandateOptions {
    /** Transaction type of the mandate.
One of: business, or personal. */
    transactionType?: string | undefined;

    constructor(data?: IInvoicePaymentSettingsPaymentMethodOptionsAcssDebitMandateOptions) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.transactionType = _data["transactionType"];
        }
    }

    static override fromJS(data: any): InvoicePaymentSettingsPaymentMethodOptionsAcssDebitMandateOptions {
        data = typeof data === 'object' ? data : {};
        let result = new InvoicePaymentSettingsPaymentMethodOptionsAcssDebitMandateOptions();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionType"] = this.transactionType;
        super.toJSON(data);
        return data;
    }
}

export interface IInvoicePaymentSettingsPaymentMethodOptionsAcssDebitMandateOptions extends IStripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsAcssDebitMandateOptions {
    /** Transaction type of the mandate.
One of: business, or personal. */
    transactionType?: string | undefined;
}

export abstract class StripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsBancontact extends StripeEntity implements IStripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsBancontact {

    constructor(data?: IStripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsBancontact) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsBancontact {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsBancontact' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsBancontact extends IStripeEntity {
}

export class InvoicePaymentSettingsPaymentMethodOptionsBancontact extends StripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsBancontact implements IInvoicePaymentSettingsPaymentMethodOptionsBancontact {
    /** Preferred language of the Bancontact authorization page that the customer is redirected
to.
One of: de, en, fr, or nl. */
    preferredLanguage?: string | undefined;

    constructor(data?: IInvoicePaymentSettingsPaymentMethodOptionsBancontact) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.preferredLanguage = _data["preferredLanguage"];
        }
    }

    static override fromJS(data: any): InvoicePaymentSettingsPaymentMethodOptionsBancontact {
        data = typeof data === 'object' ? data : {};
        let result = new InvoicePaymentSettingsPaymentMethodOptionsBancontact();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["preferredLanguage"] = this.preferredLanguage;
        super.toJSON(data);
        return data;
    }
}

export interface IInvoicePaymentSettingsPaymentMethodOptionsBancontact extends IStripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsBancontact {
    /** Preferred language of the Bancontact authorization page that the customer is redirected
to.
One of: de, en, fr, or nl. */
    preferredLanguage?: string | undefined;
}

export abstract class StripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsCard extends StripeEntity implements IStripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsCard {

    constructor(data?: IStripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsCard) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsCard {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsCard' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsCard extends IStripeEntity {
}

export class InvoicePaymentSettingsPaymentMethodOptionsCard extends StripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsCard implements IInvoicePaymentSettingsPaymentMethodOptionsCard {
    installments?: InvoicePaymentSettingsPaymentMethodOptionsCardInstallments | undefined;
    /** We strongly recommend that you rely on our SCA Engine to automatically prompt your
customers for authentication based on risk level and other requirements.
However, if you wish to request 3D Secure based on logic from your own fraud engine,
provide this option. Read our guide on manually requesting 3D
Secure for more information on how this configuration interacts with Radar and our
SCA Engine.
One of: any, or automatic. */
    requestThreeDSecure?: string | undefined;

    constructor(data?: IInvoicePaymentSettingsPaymentMethodOptionsCard) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.installments = _data["installments"] ? InvoicePaymentSettingsPaymentMethodOptionsCardInstallments.fromJS(_data["installments"]) : <any>undefined;
            this.requestThreeDSecure = _data["requestThreeDSecure"];
        }
    }

    static override fromJS(data: any): InvoicePaymentSettingsPaymentMethodOptionsCard {
        data = typeof data === 'object' ? data : {};
        let result = new InvoicePaymentSettingsPaymentMethodOptionsCard();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["installments"] = this.installments ? this.installments.toJSON() : <any>undefined;
        data["requestThreeDSecure"] = this.requestThreeDSecure;
        super.toJSON(data);
        return data;
    }
}

export interface IInvoicePaymentSettingsPaymentMethodOptionsCard extends IStripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsCard {
    installments?: InvoicePaymentSettingsPaymentMethodOptionsCardInstallments | undefined;
    /** We strongly recommend that you rely on our SCA Engine to automatically prompt your
customers for authentication based on risk level and other requirements.
However, if you wish to request 3D Secure based on logic from your own fraud engine,
provide this option. Read our guide on manually requesting 3D
Secure for more information on how this configuration interacts with Radar and our
SCA Engine.
One of: any, or automatic. */
    requestThreeDSecure?: string | undefined;
}

export abstract class StripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsCardInstallments extends StripeEntity implements IStripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsCardInstallments {

    constructor(data?: IStripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsCardInstallments) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsCardInstallments {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsCardInstallments' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsCardInstallments extends IStripeEntity {
}

export class InvoicePaymentSettingsPaymentMethodOptionsCardInstallments extends StripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsCardInstallments implements IInvoicePaymentSettingsPaymentMethodOptionsCardInstallments {
    /** Whether Installments are enabled for this Invoice. */
    enabled?: boolean | undefined;

    constructor(data?: IInvoicePaymentSettingsPaymentMethodOptionsCardInstallments) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.enabled = _data["enabled"];
        }
    }

    static override fromJS(data: any): InvoicePaymentSettingsPaymentMethodOptionsCardInstallments {
        data = typeof data === 'object' ? data : {};
        let result = new InvoicePaymentSettingsPaymentMethodOptionsCardInstallments();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enabled"] = this.enabled;
        super.toJSON(data);
        return data;
    }
}

export interface IInvoicePaymentSettingsPaymentMethodOptionsCardInstallments extends IStripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsCardInstallments {
    /** Whether Installments are enabled for this Invoice. */
    enabled?: boolean | undefined;
}

export abstract class StripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsCustomerBalance extends StripeEntity implements IStripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsCustomerBalance {

    constructor(data?: IStripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsCustomerBalance) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsCustomerBalance {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsCustomerBalance' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsCustomerBalance extends IStripeEntity {
}

export class InvoicePaymentSettingsPaymentMethodOptionsCustomerBalance extends StripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsCustomerBalance implements IInvoicePaymentSettingsPaymentMethodOptionsCustomerBalance {
    bankTransfer?: InvoicePaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransfer | undefined;
    /** The funding method type to be used when there are not enough funds in the customer
balance. Permitted values include: bank_transfer. */
    fundingType?: string | undefined;

    constructor(data?: IInvoicePaymentSettingsPaymentMethodOptionsCustomerBalance) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.bankTransfer = _data["bankTransfer"] ? InvoicePaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransfer.fromJS(_data["bankTransfer"]) : <any>undefined;
            this.fundingType = _data["fundingType"];
        }
    }

    static override fromJS(data: any): InvoicePaymentSettingsPaymentMethodOptionsCustomerBalance {
        data = typeof data === 'object' ? data : {};
        let result = new InvoicePaymentSettingsPaymentMethodOptionsCustomerBalance();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankTransfer"] = this.bankTransfer ? this.bankTransfer.toJSON() : <any>undefined;
        data["fundingType"] = this.fundingType;
        super.toJSON(data);
        return data;
    }
}

export interface IInvoicePaymentSettingsPaymentMethodOptionsCustomerBalance extends IStripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsCustomerBalance {
    bankTransfer?: InvoicePaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransfer | undefined;
    /** The funding method type to be used when there are not enough funds in the customer
balance. Permitted values include: bank_transfer. */
    fundingType?: string | undefined;
}

export abstract class StripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransfer extends StripeEntity implements IStripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransfer {

    constructor(data?: IStripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransfer) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransfer {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransfer' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransfer extends IStripeEntity {
}

export class InvoicePaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransfer extends StripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransfer implements IInvoicePaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransfer {
    euBankTransfer?: InvoicePaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransferEuBankTransfer | undefined;
    /** The bank transfer type that can be used for funding. Permitted values include:
eu_bank_transfer, gb_bank_transfer, jp_bank_transfer, or
mx_bank_transfer. */
    type?: string | undefined;

    constructor(data?: IInvoicePaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransfer) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.euBankTransfer = _data["euBankTransfer"] ? InvoicePaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransferEuBankTransfer.fromJS(_data["euBankTransfer"]) : <any>undefined;
            this.type = _data["type"];
        }
    }

    static override fromJS(data: any): InvoicePaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransfer {
        data = typeof data === 'object' ? data : {};
        let result = new InvoicePaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransfer();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["euBankTransfer"] = this.euBankTransfer ? this.euBankTransfer.toJSON() : <any>undefined;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

export interface IInvoicePaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransfer extends IStripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransfer {
    euBankTransfer?: InvoicePaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransferEuBankTransfer | undefined;
    /** The bank transfer type that can be used for funding. Permitted values include:
eu_bank_transfer, gb_bank_transfer, jp_bank_transfer, or
mx_bank_transfer. */
    type?: string | undefined;
}

export abstract class StripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransferEuBankTransfer extends StripeEntity implements IStripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransferEuBankTransfer {

    constructor(data?: IStripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransferEuBankTransfer) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransferEuBankTransfer {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransferEuBankTransfer' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransferEuBankTransfer extends IStripeEntity {
}

export class InvoicePaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransferEuBankTransfer extends StripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransferEuBankTransfer implements IInvoicePaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransferEuBankTransfer {
    /** The desired country code of the bank account information. Permitted values include:
BE, DE, ES, FR, IE, or NL.
One of: BE, DE, ES, FR, IE, or NL. */
    country?: string | undefined;

    constructor(data?: IInvoicePaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransferEuBankTransfer) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.country = _data["country"];
        }
    }

    static override fromJS(data: any): InvoicePaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransferEuBankTransfer {
        data = typeof data === 'object' ? data : {};
        let result = new InvoicePaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransferEuBankTransfer();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["country"] = this.country;
        super.toJSON(data);
        return data;
    }
}

export interface IInvoicePaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransferEuBankTransfer extends IStripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransferEuBankTransfer {
    /** The desired country code of the bank account information. Permitted values include:
BE, DE, ES, FR, IE, or NL.
One of: BE, DE, ES, FR, IE, or NL. */
    country?: string | undefined;
}

export abstract class StripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsKonbini extends StripeEntity implements IStripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsKonbini {

    constructor(data?: IStripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsKonbini) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsKonbini {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsKonbini' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsKonbini extends IStripeEntity {
}

export class InvoicePaymentSettingsPaymentMethodOptionsKonbini extends StripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsKonbini implements IInvoicePaymentSettingsPaymentMethodOptionsKonbini {

    constructor(data?: IInvoicePaymentSettingsPaymentMethodOptionsKonbini) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): InvoicePaymentSettingsPaymentMethodOptionsKonbini {
        data = typeof data === 'object' ? data : {};
        let result = new InvoicePaymentSettingsPaymentMethodOptionsKonbini();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IInvoicePaymentSettingsPaymentMethodOptionsKonbini extends IStripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsKonbini {
}

export abstract class StripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsUsBankAccount extends StripeEntity implements IStripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsUsBankAccount {

    constructor(data?: IStripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsUsBankAccount) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsUsBankAccount {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsUsBankAccount' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsUsBankAccount extends IStripeEntity {
}

export class InvoicePaymentSettingsPaymentMethodOptionsUsBankAccount extends StripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsUsBankAccount implements IInvoicePaymentSettingsPaymentMethodOptionsUsBankAccount {
    financialConnections?: InvoicePaymentSettingsPaymentMethodOptionsUsBankAccountFinancialConnections | undefined;
    /** Bank account verification method.
One of: automatic, instant, or microdeposits. */
    verificationMethod?: string | undefined;

    constructor(data?: IInvoicePaymentSettingsPaymentMethodOptionsUsBankAccount) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.financialConnections = _data["financialConnections"] ? InvoicePaymentSettingsPaymentMethodOptionsUsBankAccountFinancialConnections.fromJS(_data["financialConnections"]) : <any>undefined;
            this.verificationMethod = _data["verificationMethod"];
        }
    }

    static override fromJS(data: any): InvoicePaymentSettingsPaymentMethodOptionsUsBankAccount {
        data = typeof data === 'object' ? data : {};
        let result = new InvoicePaymentSettingsPaymentMethodOptionsUsBankAccount();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["financialConnections"] = this.financialConnections ? this.financialConnections.toJSON() : <any>undefined;
        data["verificationMethod"] = this.verificationMethod;
        super.toJSON(data);
        return data;
    }
}

export interface IInvoicePaymentSettingsPaymentMethodOptionsUsBankAccount extends IStripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsUsBankAccount {
    financialConnections?: InvoicePaymentSettingsPaymentMethodOptionsUsBankAccountFinancialConnections | undefined;
    /** Bank account verification method.
One of: automatic, instant, or microdeposits. */
    verificationMethod?: string | undefined;
}

export abstract class StripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsUsBankAccountFinancialConnections extends StripeEntity implements IStripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsUsBankAccountFinancialConnections {

    constructor(data?: IStripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsUsBankAccountFinancialConnections) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsUsBankAccountFinancialConnections {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsUsBankAccountFinancialConnections' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsUsBankAccountFinancialConnections extends IStripeEntity {
}

export class InvoicePaymentSettingsPaymentMethodOptionsUsBankAccountFinancialConnections extends StripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsUsBankAccountFinancialConnections implements IInvoicePaymentSettingsPaymentMethodOptionsUsBankAccountFinancialConnections {
    /** The list of permissions to request. The payment_method permission must be
included. */
    permissions?: string[] | undefined;

    constructor(data?: IInvoicePaymentSettingsPaymentMethodOptionsUsBankAccountFinancialConnections) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(item);
            }
        }
    }

    static override fromJS(data: any): InvoicePaymentSettingsPaymentMethodOptionsUsBankAccountFinancialConnections {
        data = typeof data === 'object' ? data : {};
        let result = new InvoicePaymentSettingsPaymentMethodOptionsUsBankAccountFinancialConnections();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IInvoicePaymentSettingsPaymentMethodOptionsUsBankAccountFinancialConnections extends IStripeEntityOfInvoicePaymentSettingsPaymentMethodOptionsUsBankAccountFinancialConnections {
    /** The list of permissions to request. The payment_method permission must be
included. */
    permissions?: string[] | undefined;
}

export abstract class StripeEntityOfQuote extends StripeEntity implements IStripeEntityOfQuote {

    constructor(data?: IStripeEntityOfQuote) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfQuote {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfQuote' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfQuote extends IStripeEntity {
}

/** A Quote is a way to model prices that you'd like to provide to a customer. Once accepted, it will automatically create an invoice, subscription or subscription schedule. */
export class Quote extends StripeEntityOfQuote implements IQuote {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** Total before any discounts or taxes are applied. */
    amountSubtotal?: number;
    /** Total after discounts and taxes are applied. */
    amountTotal?: number;
    /** (ID of the Application)
ID of the Connect Application that created the quote. */
    applicationId?: string | undefined;
    /** (Expanded)
ID of the Connect Application that created the quote.
            
For more information, see the expand documentation. */
    application?: Application | undefined;
    internalApplication?: ExpandableFieldOfApplication | undefined;
    /** The amount of the application fee (if any) that will be requested to be applied to the
payment and transferred to the application owner's Stripe account. Only applicable if
there are no line items with recurring prices on the quote. */
    applicationFeeAmount?: number | undefined;
    /** A non-negative decimal between 0 and 100, with at most two decimal places. This
represents the percentage of the subscription invoice subtotal that will be transferred
to the application owner's Stripe account. Only applicable if there are line items with
recurring prices on the quote. */
    applicationFeePercent?: number | undefined;
    automaticTax?: QuoteAutomaticTax | undefined;
    /** Either charge_automatically, or send_invoice. When charging automatically,
Stripe will attempt to pay invoices at the end of the subscription cycle or on
finalization using the default payment method attached to the subscription or customer.
When sending an invoice, Stripe will email your customer an invoice with payment
instructions and mark the subscription as active. Defaults to
charge_automatically.
One of: charge_automatically, or send_invoice. */
    collectionMethod?: string | undefined;
    computed?: QuoteComputed | undefined;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** Three-letter ISO currency
code, in lowercase. Must be a supported
currency. */
    currency?: string | undefined;
    /** (ID of the Customer)
The customer which this quote belongs to. A customer is required before finalizing the
quote. Once specified, it cannot be changed. */
    customerId?: string | undefined;
    /** (Expanded)
The customer which this quote belongs to. A customer is required before finalizing the
quote. Once specified, it cannot be changed.
            
For more information, see the expand documentation. */
    customer?: Customer2 | undefined;
    internalCustomer?: ExpandableFieldOfCustomer | undefined;
    /** (IDs of the DefaultTaxRates)
The tax rates applied to this quote. */
    defaultTaxRateIds?: string[] | undefined;
    /** (Expanded)
The tax rates applied to this quote.
            
For more information, see the expand documentation. */
    defaultTaxRates?: TaxRate[] | undefined;
    internalDefaultTaxRates?: ExpandableFieldOfTaxRate[] | undefined;
    /** A description that will be displayed on the quote PDF. */
    description?: string | undefined;
    /** (IDs of the Discounts)
The discounts applied to this quote. */
    discountIds?: string[] | undefined;
    /** (Expanded)
The discounts applied to this quote.
            
For more information, see the expand documentation. */
    discounts?: Discount[] | undefined;
    internalDiscounts?: ExpandableFieldOfDiscount[] | undefined;
    /** The date on which the quote will be canceled if in open or draft status.
Measured in seconds since the Unix epoch. */
    expiresAt?: Date;
    /** A footer that will be displayed on the quote PDF. */
    footer?: string | undefined;
    /** Details of the quote that was cloned. See the cloning documentation for more details. */
    fromQuote?: QuoteFromQuote | undefined;
    /** A header that will be displayed on the quote PDF. */
    header?: string | undefined;
    /** (ID of the Invoice)
The invoice that was created from this quote. */
    invoiceId?: string | undefined;
    /** (Expanded)
The invoice that was created from this quote.
            
For more information, see the expand documentation. */
    invoice?: Invoice | undefined;
    internalInvoice?: ExpandableFieldOfInvoice | undefined;
    /** All invoices will be billed using the specified settings. */
    invoiceSettings?: QuoteInvoiceSettings | undefined;
    /** A list of items the customer is being quoted for. */
    lineItems?: StripeListOfLineItem | undefined;
    /** Has the value true if the object exists in live mode or the value false if
the object exists in test mode. */
    livemode?: boolean;
    /** Set of key-value pairs that you can
attach to an object. This can be useful for storing additional information about the
object in a structured format. */
    metadata?: { [key: string]: string; } | undefined;
    /** A unique number that identifies this particular quote. This number is assigned once the
quote is finalized. */
    number?: string | undefined;
    /** (ID of the Account)
The account on behalf of which to charge. See the Connect
documentation for details. */
    onBehalfOfId?: string | undefined;
    /** (Expanded)
The account on behalf of which to charge. See the Connect
documentation for details.
            
For more information, see the expand documentation. */
    onBehalfOf?: Account | undefined;
    internalOnBehalfOf?: ExpandableFieldOfAccount | undefined;
    /** The status of the quote.
One of: accepted, canceled, draft, or open. */
    status?: string | undefined;
    statusTransitions?: QuoteStatusTransitions | undefined;
    /** (ID of the Subscription)
The subscription that was created or updated from this quote. */
    subscriptionId?: string | undefined;
    /** (Expanded)
The subscription that was created or updated from this quote.
            
For more information, see the expand documentation. */
    subscription?: Subscription | undefined;
    internalSubscription?: ExpandableFieldOfSubscription | undefined;
    subscriptionData?: QuoteSubscriptionData | undefined;
    /** (ID of the SubscriptionSchedule)
The subscription schedule that was created or updated from this quote. */
    subscriptionScheduleId?: string | undefined;
    /** (Expanded)
The subscription schedule that was created or updated from this quote.
            
For more information, see the expand documentation. */
    subscriptionSchedule?: SubscriptionSchedule | undefined;
    internalSubscriptionSchedule?: ExpandableFieldOfSubscriptionSchedule | undefined;
    /** (ID of the TestHelpers.TestClock)
ID of the test clock this quote belongs to. */
    testClockId?: string | undefined;
    /** (Expanded)
ID of the test clock this quote belongs to.
            
For more information, see the expand documentation. */
    testClock?: TestClock | undefined;
    internalTestClock?: ExpandableFieldOfTestClock | undefined;
    totalDetails?: QuoteTotalDetails | undefined;
    /** The account (if any) the payments will be attributed to for tax reporting, and where
funds from each payment will be transferred to for each of the invoices. */
    transferData?: QuoteTransferData | undefined;

    constructor(data?: IQuote) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.object = _data["object"];
            this.amountSubtotal = _data["amountSubtotal"];
            this.amountTotal = _data["amountTotal"];
            this.applicationId = _data["applicationId"];
            this.application = _data["application"] ? Application.fromJS(_data["application"]) : <any>undefined;
            this.internalApplication = _data["internalApplication"] ? ExpandableFieldOfApplication.fromJS(_data["internalApplication"]) : <any>undefined;
            this.applicationFeeAmount = _data["applicationFeeAmount"];
            this.applicationFeePercent = _data["applicationFeePercent"];
            this.automaticTax = _data["automaticTax"] ? QuoteAutomaticTax.fromJS(_data["automaticTax"]) : <any>undefined;
            this.collectionMethod = _data["collectionMethod"];
            this.computed = _data["computed"] ? QuoteComputed.fromJS(_data["computed"]) : <any>undefined;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.currency = _data["currency"];
            this.customerId = _data["customerId"];
            this.customer = _data["customer"] ? Customer2.fromJS(_data["customer"]) : <any>undefined;
            this.internalCustomer = _data["internalCustomer"] ? ExpandableFieldOfCustomer.fromJS(_data["internalCustomer"]) : <any>undefined;
            if (Array.isArray(_data["defaultTaxRateIds"])) {
                this.defaultTaxRateIds = [] as any;
                for (let item of _data["defaultTaxRateIds"])
                    this.defaultTaxRateIds!.push(item);
            }
            if (Array.isArray(_data["defaultTaxRates"])) {
                this.defaultTaxRates = [] as any;
                for (let item of _data["defaultTaxRates"])
                    this.defaultTaxRates!.push(TaxRate.fromJS(item));
            }
            if (Array.isArray(_data["internalDefaultTaxRates"])) {
                this.internalDefaultTaxRates = [] as any;
                for (let item of _data["internalDefaultTaxRates"])
                    this.internalDefaultTaxRates!.push(ExpandableFieldOfTaxRate.fromJS(item));
            }
            this.description = _data["description"];
            if (Array.isArray(_data["discountIds"])) {
                this.discountIds = [] as any;
                for (let item of _data["discountIds"])
                    this.discountIds!.push(item);
            }
            if (Array.isArray(_data["discounts"])) {
                this.discounts = [] as any;
                for (let item of _data["discounts"])
                    this.discounts!.push(Discount.fromJS(item));
            }
            if (Array.isArray(_data["internalDiscounts"])) {
                this.internalDiscounts = [] as any;
                for (let item of _data["internalDiscounts"])
                    this.internalDiscounts!.push(ExpandableFieldOfDiscount.fromJS(item));
            }
            this.expiresAt = _data["expiresAt"] ? new Date(_data["expiresAt"].toString()) : <any>undefined;
            this.footer = _data["footer"];
            this.fromQuote = _data["fromQuote"] ? QuoteFromQuote.fromJS(_data["fromQuote"]) : <any>undefined;
            this.header = _data["header"];
            this.invoiceId = _data["invoiceId"];
            this.invoice = _data["invoice"] ? Invoice.fromJS(_data["invoice"]) : <any>undefined;
            this.internalInvoice = _data["internalInvoice"] ? ExpandableFieldOfInvoice.fromJS(_data["internalInvoice"]) : <any>undefined;
            this.invoiceSettings = _data["invoiceSettings"] ? QuoteInvoiceSettings.fromJS(_data["invoiceSettings"]) : <any>undefined;
            this.lineItems = _data["lineItems"] ? StripeListOfLineItem.fromJS(_data["lineItems"]) : <any>undefined;
            this.livemode = _data["livemode"];
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
            this.number = _data["number"];
            this.onBehalfOfId = _data["onBehalfOfId"];
            this.onBehalfOf = _data["onBehalfOf"] ? Account.fromJS(_data["onBehalfOf"]) : <any>undefined;
            this.internalOnBehalfOf = _data["internalOnBehalfOf"] ? ExpandableFieldOfAccount.fromJS(_data["internalOnBehalfOf"]) : <any>undefined;
            this.status = _data["status"];
            this.statusTransitions = _data["statusTransitions"] ? QuoteStatusTransitions.fromJS(_data["statusTransitions"]) : <any>undefined;
            this.subscriptionId = _data["subscriptionId"];
            this.subscription = _data["subscription"] ? Subscription.fromJS(_data["subscription"]) : <any>undefined;
            this.internalSubscription = _data["internalSubscription"] ? ExpandableFieldOfSubscription.fromJS(_data["internalSubscription"]) : <any>undefined;
            this.subscriptionData = _data["subscriptionData"] ? QuoteSubscriptionData.fromJS(_data["subscriptionData"]) : <any>undefined;
            this.subscriptionScheduleId = _data["subscriptionScheduleId"];
            this.subscriptionSchedule = _data["subscriptionSchedule"] ? SubscriptionSchedule.fromJS(_data["subscriptionSchedule"]) : <any>undefined;
            this.internalSubscriptionSchedule = _data["internalSubscriptionSchedule"] ? ExpandableFieldOfSubscriptionSchedule.fromJS(_data["internalSubscriptionSchedule"]) : <any>undefined;
            this.testClockId = _data["testClockId"];
            this.testClock = _data["testClock"] ? TestClock.fromJS(_data["testClock"]) : <any>undefined;
            this.internalTestClock = _data["internalTestClock"] ? ExpandableFieldOfTestClock.fromJS(_data["internalTestClock"]) : <any>undefined;
            this.totalDetails = _data["totalDetails"] ? QuoteTotalDetails.fromJS(_data["totalDetails"]) : <any>undefined;
            this.transferData = _data["transferData"] ? QuoteTransferData.fromJS(_data["transferData"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): Quote {
        data = typeof data === 'object' ? data : {};
        let result = new Quote();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["object"] = this.object;
        data["amountSubtotal"] = this.amountSubtotal;
        data["amountTotal"] = this.amountTotal;
        data["applicationId"] = this.applicationId;
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["internalApplication"] = this.internalApplication ? this.internalApplication.toJSON() : <any>undefined;
        data["applicationFeeAmount"] = this.applicationFeeAmount;
        data["applicationFeePercent"] = this.applicationFeePercent;
        data["automaticTax"] = this.automaticTax ? this.automaticTax.toJSON() : <any>undefined;
        data["collectionMethod"] = this.collectionMethod;
        data["computed"] = this.computed ? this.computed.toJSON() : <any>undefined;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["currency"] = this.currency;
        data["customerId"] = this.customerId;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["internalCustomer"] = this.internalCustomer ? this.internalCustomer.toJSON() : <any>undefined;
        if (Array.isArray(this.defaultTaxRateIds)) {
            data["defaultTaxRateIds"] = [];
            for (let item of this.defaultTaxRateIds)
                data["defaultTaxRateIds"].push(item);
        }
        if (Array.isArray(this.defaultTaxRates)) {
            data["defaultTaxRates"] = [];
            for (let item of this.defaultTaxRates)
                data["defaultTaxRates"].push(item.toJSON());
        }
        if (Array.isArray(this.internalDefaultTaxRates)) {
            data["internalDefaultTaxRates"] = [];
            for (let item of this.internalDefaultTaxRates)
                data["internalDefaultTaxRates"].push(item.toJSON());
        }
        data["description"] = this.description;
        if (Array.isArray(this.discountIds)) {
            data["discountIds"] = [];
            for (let item of this.discountIds)
                data["discountIds"].push(item);
        }
        if (Array.isArray(this.discounts)) {
            data["discounts"] = [];
            for (let item of this.discounts)
                data["discounts"].push(item.toJSON());
        }
        if (Array.isArray(this.internalDiscounts)) {
            data["internalDiscounts"] = [];
            for (let item of this.internalDiscounts)
                data["internalDiscounts"].push(item.toJSON());
        }
        data["expiresAt"] = this.expiresAt ? this.expiresAt.toISOString() : <any>undefined;
        data["footer"] = this.footer;
        data["fromQuote"] = this.fromQuote ? this.fromQuote.toJSON() : <any>undefined;
        data["header"] = this.header;
        data["invoiceId"] = this.invoiceId;
        data["invoice"] = this.invoice ? this.invoice.toJSON() : <any>undefined;
        data["internalInvoice"] = this.internalInvoice ? this.internalInvoice.toJSON() : <any>undefined;
        data["invoiceSettings"] = this.invoiceSettings ? this.invoiceSettings.toJSON() : <any>undefined;
        data["lineItems"] = this.lineItems ? this.lineItems.toJSON() : <any>undefined;
        data["livemode"] = this.livemode;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        data["number"] = this.number;
        data["onBehalfOfId"] = this.onBehalfOfId;
        data["onBehalfOf"] = this.onBehalfOf ? this.onBehalfOf.toJSON() : <any>undefined;
        data["internalOnBehalfOf"] = this.internalOnBehalfOf ? this.internalOnBehalfOf.toJSON() : <any>undefined;
        data["status"] = this.status;
        data["statusTransitions"] = this.statusTransitions ? this.statusTransitions.toJSON() : <any>undefined;
        data["subscriptionId"] = this.subscriptionId;
        data["subscription"] = this.subscription ? this.subscription.toJSON() : <any>undefined;
        data["internalSubscription"] = this.internalSubscription ? this.internalSubscription.toJSON() : <any>undefined;
        data["subscriptionData"] = this.subscriptionData ? this.subscriptionData.toJSON() : <any>undefined;
        data["subscriptionScheduleId"] = this.subscriptionScheduleId;
        data["subscriptionSchedule"] = this.subscriptionSchedule ? this.subscriptionSchedule.toJSON() : <any>undefined;
        data["internalSubscriptionSchedule"] = this.internalSubscriptionSchedule ? this.internalSubscriptionSchedule.toJSON() : <any>undefined;
        data["testClockId"] = this.testClockId;
        data["testClock"] = this.testClock ? this.testClock.toJSON() : <any>undefined;
        data["internalTestClock"] = this.internalTestClock ? this.internalTestClock.toJSON() : <any>undefined;
        data["totalDetails"] = this.totalDetails ? this.totalDetails.toJSON() : <any>undefined;
        data["transferData"] = this.transferData ? this.transferData.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** A Quote is a way to model prices that you'd like to provide to a customer. Once accepted, it will automatically create an invoice, subscription or subscription schedule. */
export interface IQuote extends IStripeEntityOfQuote {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** Total before any discounts or taxes are applied. */
    amountSubtotal?: number;
    /** Total after discounts and taxes are applied. */
    amountTotal?: number;
    /** (ID of the Application)
ID of the Connect Application that created the quote. */
    applicationId?: string | undefined;
    /** (Expanded)
ID of the Connect Application that created the quote.
            
For more information, see the expand documentation. */
    application?: Application | undefined;
    internalApplication?: ExpandableFieldOfApplication | undefined;
    /** The amount of the application fee (if any) that will be requested to be applied to the
payment and transferred to the application owner's Stripe account. Only applicable if
there are no line items with recurring prices on the quote. */
    applicationFeeAmount?: number | undefined;
    /** A non-negative decimal between 0 and 100, with at most two decimal places. This
represents the percentage of the subscription invoice subtotal that will be transferred
to the application owner's Stripe account. Only applicable if there are line items with
recurring prices on the quote. */
    applicationFeePercent?: number | undefined;
    automaticTax?: QuoteAutomaticTax | undefined;
    /** Either charge_automatically, or send_invoice. When charging automatically,
Stripe will attempt to pay invoices at the end of the subscription cycle or on
finalization using the default payment method attached to the subscription or customer.
When sending an invoice, Stripe will email your customer an invoice with payment
instructions and mark the subscription as active. Defaults to
charge_automatically.
One of: charge_automatically, or send_invoice. */
    collectionMethod?: string | undefined;
    computed?: QuoteComputed | undefined;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** Three-letter ISO currency
code, in lowercase. Must be a supported
currency. */
    currency?: string | undefined;
    /** (ID of the Customer)
The customer which this quote belongs to. A customer is required before finalizing the
quote. Once specified, it cannot be changed. */
    customerId?: string | undefined;
    /** (Expanded)
The customer which this quote belongs to. A customer is required before finalizing the
quote. Once specified, it cannot be changed.
            
For more information, see the expand documentation. */
    customer?: Customer2 | undefined;
    internalCustomer?: ExpandableFieldOfCustomer | undefined;
    /** (IDs of the DefaultTaxRates)
The tax rates applied to this quote. */
    defaultTaxRateIds?: string[] | undefined;
    /** (Expanded)
The tax rates applied to this quote.
            
For more information, see the expand documentation. */
    defaultTaxRates?: TaxRate[] | undefined;
    internalDefaultTaxRates?: ExpandableFieldOfTaxRate[] | undefined;
    /** A description that will be displayed on the quote PDF. */
    description?: string | undefined;
    /** (IDs of the Discounts)
The discounts applied to this quote. */
    discountIds?: string[] | undefined;
    /** (Expanded)
The discounts applied to this quote.
            
For more information, see the expand documentation. */
    discounts?: Discount[] | undefined;
    internalDiscounts?: ExpandableFieldOfDiscount[] | undefined;
    /** The date on which the quote will be canceled if in open or draft status.
Measured in seconds since the Unix epoch. */
    expiresAt?: Date;
    /** A footer that will be displayed on the quote PDF. */
    footer?: string | undefined;
    /** Details of the quote that was cloned. See the cloning documentation for more details. */
    fromQuote?: QuoteFromQuote | undefined;
    /** A header that will be displayed on the quote PDF. */
    header?: string | undefined;
    /** (ID of the Invoice)
The invoice that was created from this quote. */
    invoiceId?: string | undefined;
    /** (Expanded)
The invoice that was created from this quote.
            
For more information, see the expand documentation. */
    invoice?: Invoice | undefined;
    internalInvoice?: ExpandableFieldOfInvoice | undefined;
    /** All invoices will be billed using the specified settings. */
    invoiceSettings?: QuoteInvoiceSettings | undefined;
    /** A list of items the customer is being quoted for. */
    lineItems?: StripeListOfLineItem | undefined;
    /** Has the value true if the object exists in live mode or the value false if
the object exists in test mode. */
    livemode?: boolean;
    /** Set of key-value pairs that you can
attach to an object. This can be useful for storing additional information about the
object in a structured format. */
    metadata?: { [key: string]: string; } | undefined;
    /** A unique number that identifies this particular quote. This number is assigned once the
quote is finalized. */
    number?: string | undefined;
    /** (ID of the Account)
The account on behalf of which to charge. See the Connect
documentation for details. */
    onBehalfOfId?: string | undefined;
    /** (Expanded)
The account on behalf of which to charge. See the Connect
documentation for details.
            
For more information, see the expand documentation. */
    onBehalfOf?: Account | undefined;
    internalOnBehalfOf?: ExpandableFieldOfAccount | undefined;
    /** The status of the quote.
One of: accepted, canceled, draft, or open. */
    status?: string | undefined;
    statusTransitions?: QuoteStatusTransitions | undefined;
    /** (ID of the Subscription)
The subscription that was created or updated from this quote. */
    subscriptionId?: string | undefined;
    /** (Expanded)
The subscription that was created or updated from this quote.
            
For more information, see the expand documentation. */
    subscription?: Subscription | undefined;
    internalSubscription?: ExpandableFieldOfSubscription | undefined;
    subscriptionData?: QuoteSubscriptionData | undefined;
    /** (ID of the SubscriptionSchedule)
The subscription schedule that was created or updated from this quote. */
    subscriptionScheduleId?: string | undefined;
    /** (Expanded)
The subscription schedule that was created or updated from this quote.
            
For more information, see the expand documentation. */
    subscriptionSchedule?: SubscriptionSchedule | undefined;
    internalSubscriptionSchedule?: ExpandableFieldOfSubscriptionSchedule | undefined;
    /** (ID of the TestHelpers.TestClock)
ID of the test clock this quote belongs to. */
    testClockId?: string | undefined;
    /** (Expanded)
ID of the test clock this quote belongs to.
            
For more information, see the expand documentation. */
    testClock?: TestClock | undefined;
    internalTestClock?: ExpandableFieldOfTestClock | undefined;
    totalDetails?: QuoteTotalDetails | undefined;
    /** The account (if any) the payments will be attributed to for tax reporting, and where
funds from each payment will be transferred to for each of the invoices. */
    transferData?: QuoteTransferData | undefined;
}

export abstract class StripeEntityOfQuoteAutomaticTax extends StripeEntity implements IStripeEntityOfQuoteAutomaticTax {

    constructor(data?: IStripeEntityOfQuoteAutomaticTax) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfQuoteAutomaticTax {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfQuoteAutomaticTax' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfQuoteAutomaticTax extends IStripeEntity {
}

export class QuoteAutomaticTax extends StripeEntityOfQuoteAutomaticTax implements IQuoteAutomaticTax {
    /** Automatically calculate taxes. */
    enabled?: boolean;
    /** The status of the most recent automated tax calculation for this quote.
One of: complete, failed, or requires_location_inputs. */
    status?: string | undefined;

    constructor(data?: IQuoteAutomaticTax) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.enabled = _data["enabled"];
            this.status = _data["status"];
        }
    }

    static override fromJS(data: any): QuoteAutomaticTax {
        data = typeof data === 'object' ? data : {};
        let result = new QuoteAutomaticTax();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enabled"] = this.enabled;
        data["status"] = this.status;
        super.toJSON(data);
        return data;
    }
}

export interface IQuoteAutomaticTax extends IStripeEntityOfQuoteAutomaticTax {
    /** Automatically calculate taxes. */
    enabled?: boolean;
    /** The status of the most recent automated tax calculation for this quote.
One of: complete, failed, or requires_location_inputs. */
    status?: string | undefined;
}

export abstract class StripeEntityOfQuoteComputed extends StripeEntity implements IStripeEntityOfQuoteComputed {

    constructor(data?: IStripeEntityOfQuoteComputed) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfQuoteComputed {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfQuoteComputed' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfQuoteComputed extends IStripeEntity {
}

export class QuoteComputed extends StripeEntityOfQuoteComputed implements IQuoteComputed {
    /** The definitive totals and line items the customer will be charged on a recurring basis.
Takes into account the line items with recurring prices and discounts with
duration=forever coupons only. Defaults to null if no inputted line items
with recurring prices. */
    recurring?: QuoteComputedRecurring | undefined;
    upfront?: QuoteComputedUpfront | undefined;

    constructor(data?: IQuoteComputed) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.recurring = _data["recurring"] ? QuoteComputedRecurring.fromJS(_data["recurring"]) : <any>undefined;
            this.upfront = _data["upfront"] ? QuoteComputedUpfront.fromJS(_data["upfront"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): QuoteComputed {
        data = typeof data === 'object' ? data : {};
        let result = new QuoteComputed();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["recurring"] = this.recurring ? this.recurring.toJSON() : <any>undefined;
        data["upfront"] = this.upfront ? this.upfront.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IQuoteComputed extends IStripeEntityOfQuoteComputed {
    /** The definitive totals and line items the customer will be charged on a recurring basis.
Takes into account the line items with recurring prices and discounts with
duration=forever coupons only. Defaults to null if no inputted line items
with recurring prices. */
    recurring?: QuoteComputedRecurring | undefined;
    upfront?: QuoteComputedUpfront | undefined;
}

export abstract class StripeEntityOfQuoteComputedRecurring extends StripeEntity implements IStripeEntityOfQuoteComputedRecurring {

    constructor(data?: IStripeEntityOfQuoteComputedRecurring) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfQuoteComputedRecurring {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfQuoteComputedRecurring' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfQuoteComputedRecurring extends IStripeEntity {
}

export class QuoteComputedRecurring extends StripeEntityOfQuoteComputedRecurring implements IQuoteComputedRecurring {
    /** Total before any discounts or taxes are applied. */
    amountSubtotal?: number;
    /** Total after discounts and taxes are applied. */
    amountTotal?: number;
    /** The frequency at which a subscription is billed. One of day, week,
month or year.
One of: day, month, week, or year. */
    interval?: string | undefined;
    /** The number of intervals (specified in the interval attribute) between
subscription billings. For example, interval=month and interval_count=3
bills every 3 months. */
    intervalCount?: number;
    totalDetails?: QuoteComputedRecurringTotalDetails | undefined;

    constructor(data?: IQuoteComputedRecurring) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.amountSubtotal = _data["amountSubtotal"];
            this.amountTotal = _data["amountTotal"];
            this.interval = _data["interval"];
            this.intervalCount = _data["intervalCount"];
            this.totalDetails = _data["totalDetails"] ? QuoteComputedRecurringTotalDetails.fromJS(_data["totalDetails"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): QuoteComputedRecurring {
        data = typeof data === 'object' ? data : {};
        let result = new QuoteComputedRecurring();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amountSubtotal"] = this.amountSubtotal;
        data["amountTotal"] = this.amountTotal;
        data["interval"] = this.interval;
        data["intervalCount"] = this.intervalCount;
        data["totalDetails"] = this.totalDetails ? this.totalDetails.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IQuoteComputedRecurring extends IStripeEntityOfQuoteComputedRecurring {
    /** Total before any discounts or taxes are applied. */
    amountSubtotal?: number;
    /** Total after discounts and taxes are applied. */
    amountTotal?: number;
    /** The frequency at which a subscription is billed. One of day, week,
month or year.
One of: day, month, week, or year. */
    interval?: string | undefined;
    /** The number of intervals (specified in the interval attribute) between
subscription billings. For example, interval=month and interval_count=3
bills every 3 months. */
    intervalCount?: number;
    totalDetails?: QuoteComputedRecurringTotalDetails | undefined;
}

export abstract class StripeEntityOfQuoteComputedRecurringTotalDetails extends StripeEntity implements IStripeEntityOfQuoteComputedRecurringTotalDetails {

    constructor(data?: IStripeEntityOfQuoteComputedRecurringTotalDetails) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfQuoteComputedRecurringTotalDetails {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfQuoteComputedRecurringTotalDetails' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfQuoteComputedRecurringTotalDetails extends IStripeEntity {
}

export class QuoteComputedRecurringTotalDetails extends StripeEntityOfQuoteComputedRecurringTotalDetails implements IQuoteComputedRecurringTotalDetails {
    /** This is the sum of all the discounts. */
    amountDiscount?: number;
    /** This is the sum of all the shipping amounts. */
    amountShipping?: number | undefined;
    /** This is the sum of all the tax amounts. */
    amountTax?: number;
    breakdown?: QuoteComputedRecurringTotalDetailsBreakdown | undefined;

    constructor(data?: IQuoteComputedRecurringTotalDetails) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.amountDiscount = _data["amountDiscount"];
            this.amountShipping = _data["amountShipping"];
            this.amountTax = _data["amountTax"];
            this.breakdown = _data["breakdown"] ? QuoteComputedRecurringTotalDetailsBreakdown.fromJS(_data["breakdown"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): QuoteComputedRecurringTotalDetails {
        data = typeof data === 'object' ? data : {};
        let result = new QuoteComputedRecurringTotalDetails();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amountDiscount"] = this.amountDiscount;
        data["amountShipping"] = this.amountShipping;
        data["amountTax"] = this.amountTax;
        data["breakdown"] = this.breakdown ? this.breakdown.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IQuoteComputedRecurringTotalDetails extends IStripeEntityOfQuoteComputedRecurringTotalDetails {
    /** This is the sum of all the discounts. */
    amountDiscount?: number;
    /** This is the sum of all the shipping amounts. */
    amountShipping?: number | undefined;
    /** This is the sum of all the tax amounts. */
    amountTax?: number;
    breakdown?: QuoteComputedRecurringTotalDetailsBreakdown | undefined;
}

export abstract class StripeEntityOfQuoteComputedRecurringTotalDetailsBreakdown extends StripeEntity implements IStripeEntityOfQuoteComputedRecurringTotalDetailsBreakdown {

    constructor(data?: IStripeEntityOfQuoteComputedRecurringTotalDetailsBreakdown) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfQuoteComputedRecurringTotalDetailsBreakdown {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfQuoteComputedRecurringTotalDetailsBreakdown' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfQuoteComputedRecurringTotalDetailsBreakdown extends IStripeEntity {
}

export class QuoteComputedRecurringTotalDetailsBreakdown extends StripeEntityOfQuoteComputedRecurringTotalDetailsBreakdown implements IQuoteComputedRecurringTotalDetailsBreakdown {
    /** The aggregated discounts. */
    discounts?: QuoteComputedRecurringTotalDetailsBreakdownDiscount[] | undefined;
    /** The aggregated tax amounts by rate. */
    taxes?: QuoteComputedRecurringTotalDetailsBreakdownTax[] | undefined;

    constructor(data?: IQuoteComputedRecurringTotalDetailsBreakdown) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["discounts"])) {
                this.discounts = [] as any;
                for (let item of _data["discounts"])
                    this.discounts!.push(QuoteComputedRecurringTotalDetailsBreakdownDiscount.fromJS(item));
            }
            if (Array.isArray(_data["taxes"])) {
                this.taxes = [] as any;
                for (let item of _data["taxes"])
                    this.taxes!.push(QuoteComputedRecurringTotalDetailsBreakdownTax.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): QuoteComputedRecurringTotalDetailsBreakdown {
        data = typeof data === 'object' ? data : {};
        let result = new QuoteComputedRecurringTotalDetailsBreakdown();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.discounts)) {
            data["discounts"] = [];
            for (let item of this.discounts)
                data["discounts"].push(item.toJSON());
        }
        if (Array.isArray(this.taxes)) {
            data["taxes"] = [];
            for (let item of this.taxes)
                data["taxes"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IQuoteComputedRecurringTotalDetailsBreakdown extends IStripeEntityOfQuoteComputedRecurringTotalDetailsBreakdown {
    /** The aggregated discounts. */
    discounts?: QuoteComputedRecurringTotalDetailsBreakdownDiscount[] | undefined;
    /** The aggregated tax amounts by rate. */
    taxes?: QuoteComputedRecurringTotalDetailsBreakdownTax[] | undefined;
}

export abstract class StripeEntityOfQuoteComputedRecurringTotalDetailsBreakdownDiscount extends StripeEntity implements IStripeEntityOfQuoteComputedRecurringTotalDetailsBreakdownDiscount {

    constructor(data?: IStripeEntityOfQuoteComputedRecurringTotalDetailsBreakdownDiscount) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfQuoteComputedRecurringTotalDetailsBreakdownDiscount {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfQuoteComputedRecurringTotalDetailsBreakdownDiscount' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfQuoteComputedRecurringTotalDetailsBreakdownDiscount extends IStripeEntity {
}

export class QuoteComputedRecurringTotalDetailsBreakdownDiscount extends StripeEntityOfQuoteComputedRecurringTotalDetailsBreakdownDiscount implements IQuoteComputedRecurringTotalDetailsBreakdownDiscount {
    /** The amount discounted. */
    amount?: number;
    /** A discount represents the actual application of a coupon or promotion code. It contains
information about when the discount began, when it will end, and what it is applied to.
            
Related guide: Applying discounts to
subscriptions. */
    discount?: Discount | undefined;

    constructor(data?: IQuoteComputedRecurringTotalDetailsBreakdownDiscount) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.amount = _data["amount"];
            this.discount = _data["discount"] ? Discount.fromJS(_data["discount"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): QuoteComputedRecurringTotalDetailsBreakdownDiscount {
        data = typeof data === 'object' ? data : {};
        let result = new QuoteComputedRecurringTotalDetailsBreakdownDiscount();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["discount"] = this.discount ? this.discount.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IQuoteComputedRecurringTotalDetailsBreakdownDiscount extends IStripeEntityOfQuoteComputedRecurringTotalDetailsBreakdownDiscount {
    /** The amount discounted. */
    amount?: number;
    /** A discount represents the actual application of a coupon or promotion code. It contains
information about when the discount began, when it will end, and what it is applied to.
            
Related guide: Applying discounts to
subscriptions. */
    discount?: Discount | undefined;
}

export abstract class StripeEntityOfQuoteComputedRecurringTotalDetailsBreakdownTax extends StripeEntity implements IStripeEntityOfQuoteComputedRecurringTotalDetailsBreakdownTax {

    constructor(data?: IStripeEntityOfQuoteComputedRecurringTotalDetailsBreakdownTax) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfQuoteComputedRecurringTotalDetailsBreakdownTax {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfQuoteComputedRecurringTotalDetailsBreakdownTax' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfQuoteComputedRecurringTotalDetailsBreakdownTax extends IStripeEntity {
}

export class QuoteComputedRecurringTotalDetailsBreakdownTax extends StripeEntityOfQuoteComputedRecurringTotalDetailsBreakdownTax implements IQuoteComputedRecurringTotalDetailsBreakdownTax {
    /** Amount of tax applied for this rate. */
    amount?: number;
    /** Tax rates can be applied to invoices, subscriptions and Checkout
Sessions to collect tax.
            
Related guide: Tax rates. */
    rate?: TaxRate | undefined;
    /** The reasoning behind this tax, for example, if the product is tax exempt. The possible
values for this field may be extended as new tax rules are supported.
One of: customer_exempt, excluded_territory,
jurisdiction_unsupported, not_collecting, not_subject_to_tax,
not_supported, portion_product_exempt, portion_reduced_rated,
portion_standard_rated, product_exempt, product_exempt_holiday,
proportionally_rated, reduced_rated, reverse_charge,
standard_rated, taxable_basis_reduced, vat_exempt, or
zero_rated. */
    taxabilityReason?: string | undefined;
    /** The amount on which tax is calculated, in %s. */
    taxableAmount?: number | undefined;

    constructor(data?: IQuoteComputedRecurringTotalDetailsBreakdownTax) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.amount = _data["amount"];
            this.rate = _data["rate"] ? TaxRate.fromJS(_data["rate"]) : <any>undefined;
            this.taxabilityReason = _data["taxabilityReason"];
            this.taxableAmount = _data["taxableAmount"];
        }
    }

    static override fromJS(data: any): QuoteComputedRecurringTotalDetailsBreakdownTax {
        data = typeof data === 'object' ? data : {};
        let result = new QuoteComputedRecurringTotalDetailsBreakdownTax();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["rate"] = this.rate ? this.rate.toJSON() : <any>undefined;
        data["taxabilityReason"] = this.taxabilityReason;
        data["taxableAmount"] = this.taxableAmount;
        super.toJSON(data);
        return data;
    }
}

export interface IQuoteComputedRecurringTotalDetailsBreakdownTax extends IStripeEntityOfQuoteComputedRecurringTotalDetailsBreakdownTax {
    /** Amount of tax applied for this rate. */
    amount?: number;
    /** Tax rates can be applied to invoices, subscriptions and Checkout
Sessions to collect tax.
            
Related guide: Tax rates. */
    rate?: TaxRate | undefined;
    /** The reasoning behind this tax, for example, if the product is tax exempt. The possible
values for this field may be extended as new tax rules are supported.
One of: customer_exempt, excluded_territory,
jurisdiction_unsupported, not_collecting, not_subject_to_tax,
not_supported, portion_product_exempt, portion_reduced_rated,
portion_standard_rated, product_exempt, product_exempt_holiday,
proportionally_rated, reduced_rated, reverse_charge,
standard_rated, taxable_basis_reduced, vat_exempt, or
zero_rated. */
    taxabilityReason?: string | undefined;
    /** The amount on which tax is calculated, in %s. */
    taxableAmount?: number | undefined;
}

export abstract class StripeEntityOfQuoteComputedUpfront extends StripeEntity implements IStripeEntityOfQuoteComputedUpfront {

    constructor(data?: IStripeEntityOfQuoteComputedUpfront) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfQuoteComputedUpfront {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfQuoteComputedUpfront' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfQuoteComputedUpfront extends IStripeEntity {
}

export class QuoteComputedUpfront extends StripeEntityOfQuoteComputedUpfront implements IQuoteComputedUpfront {
    /** Total before any discounts or taxes are applied. */
    amountSubtotal?: number;
    /** Total after discounts and taxes are applied. */
    amountTotal?: number;
    /** The line items that will appear on the next invoice after this quote is accepted. This
does not include pending invoice items that exist on the customer but may still be
included in the next invoice. */
    lineItems?: StripeListOfLineItem | undefined;
    totalDetails?: QuoteComputedUpfrontTotalDetails | undefined;

    constructor(data?: IQuoteComputedUpfront) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.amountSubtotal = _data["amountSubtotal"];
            this.amountTotal = _data["amountTotal"];
            this.lineItems = _data["lineItems"] ? StripeListOfLineItem.fromJS(_data["lineItems"]) : <any>undefined;
            this.totalDetails = _data["totalDetails"] ? QuoteComputedUpfrontTotalDetails.fromJS(_data["totalDetails"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): QuoteComputedUpfront {
        data = typeof data === 'object' ? data : {};
        let result = new QuoteComputedUpfront();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amountSubtotal"] = this.amountSubtotal;
        data["amountTotal"] = this.amountTotal;
        data["lineItems"] = this.lineItems ? this.lineItems.toJSON() : <any>undefined;
        data["totalDetails"] = this.totalDetails ? this.totalDetails.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IQuoteComputedUpfront extends IStripeEntityOfQuoteComputedUpfront {
    /** Total before any discounts or taxes are applied. */
    amountSubtotal?: number;
    /** Total after discounts and taxes are applied. */
    amountTotal?: number;
    /** The line items that will appear on the next invoice after this quote is accepted. This
does not include pending invoice items that exist on the customer but may still be
included in the next invoice. */
    lineItems?: StripeListOfLineItem | undefined;
    totalDetails?: QuoteComputedUpfrontTotalDetails | undefined;
}

export abstract class StripeEntityOfStripeListOfLineItem extends StripeEntity implements IStripeEntityOfStripeListOfLineItem {

    constructor(data?: IStripeEntityOfStripeListOfLineItem) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfStripeListOfLineItem {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfStripeListOfLineItem' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfStripeListOfLineItem extends IStripeEntity {
}

export class StripeListOfLineItem extends StripeEntityOfStripeListOfLineItem implements IStripeListOfLineItem {
    /** A string describing the object type returned. */
    object?: string | undefined;
    /** A list containing the actual response elements, paginated by any request parameters. */
    data?: LineItem[] | undefined;
    /** Whether or not there are more elements available after this set. If false,
this set comprises the end of the list. */
    hasMore?: boolean;
    /** The URL for accessing this list. */
    url?: string | undefined;

    constructor(data?: IStripeListOfLineItem) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.object = _data["object"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(LineItem.fromJS(item));
            }
            this.hasMore = _data["hasMore"];
            this.url = _data["url"];
        }
    }

    static override fromJS(data: any): StripeListOfLineItem {
        data = typeof data === 'object' ? data : {};
        let result = new StripeListOfLineItem();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["object"] = this.object;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["hasMore"] = this.hasMore;
        data["url"] = this.url;
        super.toJSON(data);
        return data;
    }
}

export interface IStripeListOfLineItem extends IStripeEntityOfStripeListOfLineItem {
    /** A string describing the object type returned. */
    object?: string | undefined;
    /** A list containing the actual response elements, paginated by any request parameters. */
    data?: LineItem[] | undefined;
    /** Whether or not there are more elements available after this set. If false,
this set comprises the end of the list. */
    hasMore?: boolean;
    /** The URL for accessing this list. */
    url?: string | undefined;
}

export abstract class StripeEntityOfLineItem extends StripeEntity implements IStripeEntityOfLineItem {

    constructor(data?: IStripeEntityOfLineItem) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfLineItem {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfLineItem' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfLineItem extends IStripeEntity {
}

/** A line item. */
export class LineItem extends StripeEntityOfLineItem implements ILineItem {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** Total discount amount applied. If no discounts were applied, defaults to 0. */
    amountDiscount?: number;
    /** Total before any discounts or taxes are applied. */
    amountSubtotal?: number;
    /** Total tax amount applied. If no tax was applied, defaults to 0. */
    amountTax?: number;
    /** Total after discounts and taxes. */
    amountTotal?: number;
    /** Three-letter ISO currency
code, in lowercase. Must be a supported
currency. */
    currency?: string | undefined;
    /** Whether this object is deleted or not. */
    deleted?: boolean | undefined;
    /** An arbitrary string attached to the object. Often useful for displaying to users.
Defaults to product name. */
    description?: string | undefined;
    /** The discounts applied to the line item. */
    discounts?: LineItemDiscount[] | undefined;
    /** The price used to generate the line item. */
    price?: Price | undefined;
    /** The quantity of products being purchased. */
    quantity?: number | undefined;
    /** The taxes applied to the line item. */
    taxes?: LineItemTax[] | undefined;

    constructor(data?: ILineItem) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.object = _data["object"];
            this.amountDiscount = _data["amountDiscount"];
            this.amountSubtotal = _data["amountSubtotal"];
            this.amountTax = _data["amountTax"];
            this.amountTotal = _data["amountTotal"];
            this.currency = _data["currency"];
            this.deleted = _data["deleted"];
            this.description = _data["description"];
            if (Array.isArray(_data["discounts"])) {
                this.discounts = [] as any;
                for (let item of _data["discounts"])
                    this.discounts!.push(LineItemDiscount.fromJS(item));
            }
            this.price = _data["price"] ? Price.fromJS(_data["price"]) : <any>undefined;
            this.quantity = _data["quantity"];
            if (Array.isArray(_data["taxes"])) {
                this.taxes = [] as any;
                for (let item of _data["taxes"])
                    this.taxes!.push(LineItemTax.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): LineItem {
        data = typeof data === 'object' ? data : {};
        let result = new LineItem();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["object"] = this.object;
        data["amountDiscount"] = this.amountDiscount;
        data["amountSubtotal"] = this.amountSubtotal;
        data["amountTax"] = this.amountTax;
        data["amountTotal"] = this.amountTotal;
        data["currency"] = this.currency;
        data["deleted"] = this.deleted;
        data["description"] = this.description;
        if (Array.isArray(this.discounts)) {
            data["discounts"] = [];
            for (let item of this.discounts)
                data["discounts"].push(item.toJSON());
        }
        data["price"] = this.price ? this.price.toJSON() : <any>undefined;
        data["quantity"] = this.quantity;
        if (Array.isArray(this.taxes)) {
            data["taxes"] = [];
            for (let item of this.taxes)
                data["taxes"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** A line item. */
export interface ILineItem extends IStripeEntityOfLineItem {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** Total discount amount applied. If no discounts were applied, defaults to 0. */
    amountDiscount?: number;
    /** Total before any discounts or taxes are applied. */
    amountSubtotal?: number;
    /** Total tax amount applied. If no tax was applied, defaults to 0. */
    amountTax?: number;
    /** Total after discounts and taxes. */
    amountTotal?: number;
    /** Three-letter ISO currency
code, in lowercase. Must be a supported
currency. */
    currency?: string | undefined;
    /** Whether this object is deleted or not. */
    deleted?: boolean | undefined;
    /** An arbitrary string attached to the object. Often useful for displaying to users.
Defaults to product name. */
    description?: string | undefined;
    /** The discounts applied to the line item. */
    discounts?: LineItemDiscount[] | undefined;
    /** The price used to generate the line item. */
    price?: Price | undefined;
    /** The quantity of products being purchased. */
    quantity?: number | undefined;
    /** The taxes applied to the line item. */
    taxes?: LineItemTax[] | undefined;
}

export abstract class StripeEntityOfLineItemDiscount extends StripeEntity implements IStripeEntityOfLineItemDiscount {

    constructor(data?: IStripeEntityOfLineItemDiscount) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfLineItemDiscount {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfLineItemDiscount' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfLineItemDiscount extends IStripeEntity {
}

export class LineItemDiscount extends StripeEntityOfLineItemDiscount implements ILineItemDiscount {
    /** The amount discounted. */
    amount?: number;
    /** A discount represents the actual application of a coupon or promotion code. It contains
information about when the discount began, when it will end, and what it is applied to.
            
Related guide: Applying discounts to
subscriptions. */
    discount?: Discount | undefined;

    constructor(data?: ILineItemDiscount) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.amount = _data["amount"];
            this.discount = _data["discount"] ? Discount.fromJS(_data["discount"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): LineItemDiscount {
        data = typeof data === 'object' ? data : {};
        let result = new LineItemDiscount();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["discount"] = this.discount ? this.discount.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface ILineItemDiscount extends IStripeEntityOfLineItemDiscount {
    /** The amount discounted. */
    amount?: number;
    /** A discount represents the actual application of a coupon or promotion code. It contains
information about when the discount began, when it will end, and what it is applied to.
            
Related guide: Applying discounts to
subscriptions. */
    discount?: Discount | undefined;
}

export abstract class StripeEntityOfLineItemTax extends StripeEntity implements IStripeEntityOfLineItemTax {

    constructor(data?: IStripeEntityOfLineItemTax) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfLineItemTax {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfLineItemTax' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfLineItemTax extends IStripeEntity {
}

export class LineItemTax extends StripeEntityOfLineItemTax implements ILineItemTax {
    /** Amount of tax applied for this rate. */
    amount?: number;
    /** Tax rates can be applied to invoices, subscriptions and Checkout
Sessions to collect tax.
            
Related guide: Tax rates. */
    rate?: TaxRate | undefined;
    /** The reasoning behind this tax, for example, if the product is tax exempt. The possible
values for this field may be extended as new tax rules are supported.
One of: customer_exempt, excluded_territory,
jurisdiction_unsupported, not_collecting, not_subject_to_tax,
not_supported, portion_product_exempt, portion_reduced_rated,
portion_standard_rated, product_exempt, product_exempt_holiday,
proportionally_rated, reduced_rated, reverse_charge,
standard_rated, taxable_basis_reduced, vat_exempt, or
zero_rated. */
    taxabilityReason?: string | undefined;
    /** The amount on which tax is calculated, in %s. */
    taxableAmount?: number | undefined;

    constructor(data?: ILineItemTax) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.amount = _data["amount"];
            this.rate = _data["rate"] ? TaxRate.fromJS(_data["rate"]) : <any>undefined;
            this.taxabilityReason = _data["taxabilityReason"];
            this.taxableAmount = _data["taxableAmount"];
        }
    }

    static override fromJS(data: any): LineItemTax {
        data = typeof data === 'object' ? data : {};
        let result = new LineItemTax();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["rate"] = this.rate ? this.rate.toJSON() : <any>undefined;
        data["taxabilityReason"] = this.taxabilityReason;
        data["taxableAmount"] = this.taxableAmount;
        super.toJSON(data);
        return data;
    }
}

export interface ILineItemTax extends IStripeEntityOfLineItemTax {
    /** Amount of tax applied for this rate. */
    amount?: number;
    /** Tax rates can be applied to invoices, subscriptions and Checkout
Sessions to collect tax.
            
Related guide: Tax rates. */
    rate?: TaxRate | undefined;
    /** The reasoning behind this tax, for example, if the product is tax exempt. The possible
values for this field may be extended as new tax rules are supported.
One of: customer_exempt, excluded_territory,
jurisdiction_unsupported, not_collecting, not_subject_to_tax,
not_supported, portion_product_exempt, portion_reduced_rated,
portion_standard_rated, product_exempt, product_exempt_holiday,
proportionally_rated, reduced_rated, reverse_charge,
standard_rated, taxable_basis_reduced, vat_exempt, or
zero_rated. */
    taxabilityReason?: string | undefined;
    /** The amount on which tax is calculated, in %s. */
    taxableAmount?: number | undefined;
}

export abstract class StripeEntityOfQuoteComputedUpfrontTotalDetails extends StripeEntity implements IStripeEntityOfQuoteComputedUpfrontTotalDetails {

    constructor(data?: IStripeEntityOfQuoteComputedUpfrontTotalDetails) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfQuoteComputedUpfrontTotalDetails {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfQuoteComputedUpfrontTotalDetails' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfQuoteComputedUpfrontTotalDetails extends IStripeEntity {
}

export class QuoteComputedUpfrontTotalDetails extends StripeEntityOfQuoteComputedUpfrontTotalDetails implements IQuoteComputedUpfrontTotalDetails {
    /** This is the sum of all the discounts. */
    amountDiscount?: number;
    /** This is the sum of all the shipping amounts. */
    amountShipping?: number | undefined;
    /** This is the sum of all the tax amounts. */
    amountTax?: number;
    breakdown?: QuoteComputedUpfrontTotalDetailsBreakdown | undefined;

    constructor(data?: IQuoteComputedUpfrontTotalDetails) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.amountDiscount = _data["amountDiscount"];
            this.amountShipping = _data["amountShipping"];
            this.amountTax = _data["amountTax"];
            this.breakdown = _data["breakdown"] ? QuoteComputedUpfrontTotalDetailsBreakdown.fromJS(_data["breakdown"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): QuoteComputedUpfrontTotalDetails {
        data = typeof data === 'object' ? data : {};
        let result = new QuoteComputedUpfrontTotalDetails();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amountDiscount"] = this.amountDiscount;
        data["amountShipping"] = this.amountShipping;
        data["amountTax"] = this.amountTax;
        data["breakdown"] = this.breakdown ? this.breakdown.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IQuoteComputedUpfrontTotalDetails extends IStripeEntityOfQuoteComputedUpfrontTotalDetails {
    /** This is the sum of all the discounts. */
    amountDiscount?: number;
    /** This is the sum of all the shipping amounts. */
    amountShipping?: number | undefined;
    /** This is the sum of all the tax amounts. */
    amountTax?: number;
    breakdown?: QuoteComputedUpfrontTotalDetailsBreakdown | undefined;
}

export abstract class StripeEntityOfQuoteComputedUpfrontTotalDetailsBreakdown extends StripeEntity implements IStripeEntityOfQuoteComputedUpfrontTotalDetailsBreakdown {

    constructor(data?: IStripeEntityOfQuoteComputedUpfrontTotalDetailsBreakdown) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfQuoteComputedUpfrontTotalDetailsBreakdown {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfQuoteComputedUpfrontTotalDetailsBreakdown' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfQuoteComputedUpfrontTotalDetailsBreakdown extends IStripeEntity {
}

export class QuoteComputedUpfrontTotalDetailsBreakdown extends StripeEntityOfQuoteComputedUpfrontTotalDetailsBreakdown implements IQuoteComputedUpfrontTotalDetailsBreakdown {
    /** The aggregated discounts. */
    discounts?: QuoteComputedUpfrontTotalDetailsBreakdownDiscount[] | undefined;
    /** The aggregated tax amounts by rate. */
    taxes?: QuoteComputedUpfrontTotalDetailsBreakdownTax[] | undefined;

    constructor(data?: IQuoteComputedUpfrontTotalDetailsBreakdown) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["discounts"])) {
                this.discounts = [] as any;
                for (let item of _data["discounts"])
                    this.discounts!.push(QuoteComputedUpfrontTotalDetailsBreakdownDiscount.fromJS(item));
            }
            if (Array.isArray(_data["taxes"])) {
                this.taxes = [] as any;
                for (let item of _data["taxes"])
                    this.taxes!.push(QuoteComputedUpfrontTotalDetailsBreakdownTax.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): QuoteComputedUpfrontTotalDetailsBreakdown {
        data = typeof data === 'object' ? data : {};
        let result = new QuoteComputedUpfrontTotalDetailsBreakdown();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.discounts)) {
            data["discounts"] = [];
            for (let item of this.discounts)
                data["discounts"].push(item.toJSON());
        }
        if (Array.isArray(this.taxes)) {
            data["taxes"] = [];
            for (let item of this.taxes)
                data["taxes"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IQuoteComputedUpfrontTotalDetailsBreakdown extends IStripeEntityOfQuoteComputedUpfrontTotalDetailsBreakdown {
    /** The aggregated discounts. */
    discounts?: QuoteComputedUpfrontTotalDetailsBreakdownDiscount[] | undefined;
    /** The aggregated tax amounts by rate. */
    taxes?: QuoteComputedUpfrontTotalDetailsBreakdownTax[] | undefined;
}

export abstract class StripeEntityOfQuoteComputedUpfrontTotalDetailsBreakdownDiscount extends StripeEntity implements IStripeEntityOfQuoteComputedUpfrontTotalDetailsBreakdownDiscount {

    constructor(data?: IStripeEntityOfQuoteComputedUpfrontTotalDetailsBreakdownDiscount) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfQuoteComputedUpfrontTotalDetailsBreakdownDiscount {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfQuoteComputedUpfrontTotalDetailsBreakdownDiscount' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfQuoteComputedUpfrontTotalDetailsBreakdownDiscount extends IStripeEntity {
}

export class QuoteComputedUpfrontTotalDetailsBreakdownDiscount extends StripeEntityOfQuoteComputedUpfrontTotalDetailsBreakdownDiscount implements IQuoteComputedUpfrontTotalDetailsBreakdownDiscount {
    /** The amount discounted. */
    amount?: number;
    /** A discount represents the actual application of a coupon or promotion code. It contains
information about when the discount began, when it will end, and what it is applied to.
            
Related guide: Applying discounts to
subscriptions. */
    discount?: Discount | undefined;

    constructor(data?: IQuoteComputedUpfrontTotalDetailsBreakdownDiscount) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.amount = _data["amount"];
            this.discount = _data["discount"] ? Discount.fromJS(_data["discount"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): QuoteComputedUpfrontTotalDetailsBreakdownDiscount {
        data = typeof data === 'object' ? data : {};
        let result = new QuoteComputedUpfrontTotalDetailsBreakdownDiscount();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["discount"] = this.discount ? this.discount.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IQuoteComputedUpfrontTotalDetailsBreakdownDiscount extends IStripeEntityOfQuoteComputedUpfrontTotalDetailsBreakdownDiscount {
    /** The amount discounted. */
    amount?: number;
    /** A discount represents the actual application of a coupon or promotion code. It contains
information about when the discount began, when it will end, and what it is applied to.
            
Related guide: Applying discounts to
subscriptions. */
    discount?: Discount | undefined;
}

export abstract class StripeEntityOfQuoteComputedUpfrontTotalDetailsBreakdownTax extends StripeEntity implements IStripeEntityOfQuoteComputedUpfrontTotalDetailsBreakdownTax {

    constructor(data?: IStripeEntityOfQuoteComputedUpfrontTotalDetailsBreakdownTax) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfQuoteComputedUpfrontTotalDetailsBreakdownTax {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfQuoteComputedUpfrontTotalDetailsBreakdownTax' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfQuoteComputedUpfrontTotalDetailsBreakdownTax extends IStripeEntity {
}

export class QuoteComputedUpfrontTotalDetailsBreakdownTax extends StripeEntityOfQuoteComputedUpfrontTotalDetailsBreakdownTax implements IQuoteComputedUpfrontTotalDetailsBreakdownTax {
    /** Amount of tax applied for this rate. */
    amount?: number;
    /** Tax rates can be applied to invoices, subscriptions and Checkout
Sessions to collect tax.
            
Related guide: Tax rates. */
    rate?: TaxRate | undefined;
    /** The reasoning behind this tax, for example, if the product is tax exempt. The possible
values for this field may be extended as new tax rules are supported.
One of: customer_exempt, excluded_territory,
jurisdiction_unsupported, not_collecting, not_subject_to_tax,
not_supported, portion_product_exempt, portion_reduced_rated,
portion_standard_rated, product_exempt, product_exempt_holiday,
proportionally_rated, reduced_rated, reverse_charge,
standard_rated, taxable_basis_reduced, vat_exempt, or
zero_rated. */
    taxabilityReason?: string | undefined;
    /** The amount on which tax is calculated, in %s. */
    taxableAmount?: number | undefined;

    constructor(data?: IQuoteComputedUpfrontTotalDetailsBreakdownTax) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.amount = _data["amount"];
            this.rate = _data["rate"] ? TaxRate.fromJS(_data["rate"]) : <any>undefined;
            this.taxabilityReason = _data["taxabilityReason"];
            this.taxableAmount = _data["taxableAmount"];
        }
    }

    static override fromJS(data: any): QuoteComputedUpfrontTotalDetailsBreakdownTax {
        data = typeof data === 'object' ? data : {};
        let result = new QuoteComputedUpfrontTotalDetailsBreakdownTax();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["rate"] = this.rate ? this.rate.toJSON() : <any>undefined;
        data["taxabilityReason"] = this.taxabilityReason;
        data["taxableAmount"] = this.taxableAmount;
        super.toJSON(data);
        return data;
    }
}

export interface IQuoteComputedUpfrontTotalDetailsBreakdownTax extends IStripeEntityOfQuoteComputedUpfrontTotalDetailsBreakdownTax {
    /** Amount of tax applied for this rate. */
    amount?: number;
    /** Tax rates can be applied to invoices, subscriptions and Checkout
Sessions to collect tax.
            
Related guide: Tax rates. */
    rate?: TaxRate | undefined;
    /** The reasoning behind this tax, for example, if the product is tax exempt. The possible
values for this field may be extended as new tax rules are supported.
One of: customer_exempt, excluded_territory,
jurisdiction_unsupported, not_collecting, not_subject_to_tax,
not_supported, portion_product_exempt, portion_reduced_rated,
portion_standard_rated, product_exempt, product_exempt_holiday,
proportionally_rated, reduced_rated, reverse_charge,
standard_rated, taxable_basis_reduced, vat_exempt, or
zero_rated. */
    taxabilityReason?: string | undefined;
    /** The amount on which tax is calculated, in %s. */
    taxableAmount?: number | undefined;
}

export abstract class StripeEntityOfQuoteFromQuote extends StripeEntity implements IStripeEntityOfQuoteFromQuote {

    constructor(data?: IStripeEntityOfQuoteFromQuote) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfQuoteFromQuote {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfQuoteFromQuote' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfQuoteFromQuote extends IStripeEntity {
}

export class QuoteFromQuote extends StripeEntityOfQuoteFromQuote implements IQuoteFromQuote {
    /** Whether this quote is a revision of a different quote. */
    isRevision?: boolean;
    /** (ID of the Quote)
The quote that was cloned. */
    quoteId?: string | undefined;
    /** (Expanded)
The quote that was cloned.
            
For more information, see the expand documentation. */
    quote?: Quote | undefined;
    internalQuote?: ExpandableFieldOfQuote | undefined;

    constructor(data?: IQuoteFromQuote) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.isRevision = _data["isRevision"];
            this.quoteId = _data["quoteId"];
            this.quote = _data["quote"] ? Quote.fromJS(_data["quote"]) : <any>undefined;
            this.internalQuote = _data["internalQuote"] ? ExpandableFieldOfQuote.fromJS(_data["internalQuote"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): QuoteFromQuote {
        data = typeof data === 'object' ? data : {};
        let result = new QuoteFromQuote();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isRevision"] = this.isRevision;
        data["quoteId"] = this.quoteId;
        data["quote"] = this.quote ? this.quote.toJSON() : <any>undefined;
        data["internalQuote"] = this.internalQuote ? this.internalQuote.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IQuoteFromQuote extends IStripeEntityOfQuoteFromQuote {
    /** Whether this quote is a revision of a different quote. */
    isRevision?: boolean;
    /** (ID of the Quote)
The quote that was cloned. */
    quoteId?: string | undefined;
    /** (Expanded)
The quote that was cloned.
            
For more information, see the expand documentation. */
    quote?: Quote | undefined;
    internalQuote?: ExpandableFieldOfQuote | undefined;
}

/** Represents a generic expandable field. */
export class ExpandableFieldOfQuote implements IExpandableFieldOfQuote {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: Quote | undefined;

    constructor(data?: IExpandableFieldOfQuote) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.expandedObject = _data["expandedObject"] ? Quote.fromJS(_data["expandedObject"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExpandableFieldOfQuote {
        data = typeof data === 'object' ? data : {};
        let result = new ExpandableFieldOfQuote();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["expandedObject"] = this.expandedObject ? this.expandedObject.toJSON() : <any>undefined;
        return data;
    }
}

/** Represents a generic expandable field. */
export interface IExpandableFieldOfQuote {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: Quote | undefined;
}

export abstract class StripeEntityOfQuoteInvoiceSettings extends StripeEntity implements IStripeEntityOfQuoteInvoiceSettings {

    constructor(data?: IStripeEntityOfQuoteInvoiceSettings) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfQuoteInvoiceSettings {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfQuoteInvoiceSettings' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfQuoteInvoiceSettings extends IStripeEntity {
}

export class QuoteInvoiceSettings extends StripeEntityOfQuoteInvoiceSettings implements IQuoteInvoiceSettings {
    /** Number of days within which a customer must pay invoices generated by this quote. This
value will be null for quotes where
collection_method=charge_automatically. */
    daysUntilDue?: number | undefined;

    constructor(data?: IQuoteInvoiceSettings) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.daysUntilDue = _data["daysUntilDue"];
        }
    }

    static override fromJS(data: any): QuoteInvoiceSettings {
        data = typeof data === 'object' ? data : {};
        let result = new QuoteInvoiceSettings();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["daysUntilDue"] = this.daysUntilDue;
        super.toJSON(data);
        return data;
    }
}

export interface IQuoteInvoiceSettings extends IStripeEntityOfQuoteInvoiceSettings {
    /** Number of days within which a customer must pay invoices generated by this quote. This
value will be null for quotes where
collection_method=charge_automatically. */
    daysUntilDue?: number | undefined;
}

export abstract class StripeEntityOfQuoteStatusTransitions extends StripeEntity implements IStripeEntityOfQuoteStatusTransitions {

    constructor(data?: IStripeEntityOfQuoteStatusTransitions) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfQuoteStatusTransitions {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfQuoteStatusTransitions' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfQuoteStatusTransitions extends IStripeEntity {
}

export class QuoteStatusTransitions extends StripeEntityOfQuoteStatusTransitions implements IQuoteStatusTransitions {
    /** The time that the quote was accepted. Measured in seconds since Unix epoch. */
    acceptedAt?: Date | undefined;
    /** The time that the quote was canceled. Measured in seconds since Unix epoch. */
    canceledAt?: Date | undefined;
    /** The time that the quote was finalized. Measured in seconds since Unix epoch. */
    finalizedAt?: Date | undefined;

    constructor(data?: IQuoteStatusTransitions) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.acceptedAt = _data["acceptedAt"] ? new Date(_data["acceptedAt"].toString()) : <any>undefined;
            this.canceledAt = _data["canceledAt"] ? new Date(_data["canceledAt"].toString()) : <any>undefined;
            this.finalizedAt = _data["finalizedAt"] ? new Date(_data["finalizedAt"].toString()) : <any>undefined;
        }
    }

    static override fromJS(data: any): QuoteStatusTransitions {
        data = typeof data === 'object' ? data : {};
        let result = new QuoteStatusTransitions();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["acceptedAt"] = this.acceptedAt ? this.acceptedAt.toISOString() : <any>undefined;
        data["canceledAt"] = this.canceledAt ? this.canceledAt.toISOString() : <any>undefined;
        data["finalizedAt"] = this.finalizedAt ? this.finalizedAt.toISOString() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IQuoteStatusTransitions extends IStripeEntityOfQuoteStatusTransitions {
    /** The time that the quote was accepted. Measured in seconds since Unix epoch. */
    acceptedAt?: Date | undefined;
    /** The time that the quote was canceled. Measured in seconds since Unix epoch. */
    canceledAt?: Date | undefined;
    /** The time that the quote was finalized. Measured in seconds since Unix epoch. */
    finalizedAt?: Date | undefined;
}

/** Represents a generic expandable field. */
export class ExpandableFieldOfSubscription implements IExpandableFieldOfSubscription {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: Subscription | undefined;

    constructor(data?: IExpandableFieldOfSubscription) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.expandedObject = _data["expandedObject"] ? Subscription.fromJS(_data["expandedObject"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExpandableFieldOfSubscription {
        data = typeof data === 'object' ? data : {};
        let result = new ExpandableFieldOfSubscription();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["expandedObject"] = this.expandedObject ? this.expandedObject.toJSON() : <any>undefined;
        return data;
    }
}

/** Represents a generic expandable field. */
export interface IExpandableFieldOfSubscription {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: Subscription | undefined;
}

export abstract class StripeEntityOfQuoteSubscriptionData extends StripeEntity implements IStripeEntityOfQuoteSubscriptionData {

    constructor(data?: IStripeEntityOfQuoteSubscriptionData) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfQuoteSubscriptionData {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfQuoteSubscriptionData' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfQuoteSubscriptionData extends IStripeEntity {
}

export class QuoteSubscriptionData extends StripeEntityOfQuoteSubscriptionData implements IQuoteSubscriptionData {
    /** The subscription's description, meant to be displayable to the customer. Use this field
to optionally store an explanation of the subscription. */
    description?: string | undefined;
    /** When creating a new subscription, the date of which the subscription schedule will start
after the quote is accepted. This date is ignored if it is in the past when the quote is
accepted. Measured in seconds since the Unix epoch. */
    effectiveDate?: Date | undefined;
    /** Integer representing the number of trial period days before the customer is charged for
the first time. */
    trialPeriodDays?: number | undefined;

    constructor(data?: IQuoteSubscriptionData) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.description = _data["description"];
            this.effectiveDate = _data["effectiveDate"] ? new Date(_data["effectiveDate"].toString()) : <any>undefined;
            this.trialPeriodDays = _data["trialPeriodDays"];
        }
    }

    static override fromJS(data: any): QuoteSubscriptionData {
        data = typeof data === 'object' ? data : {};
        let result = new QuoteSubscriptionData();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["effectiveDate"] = this.effectiveDate ? this.effectiveDate.toISOString() : <any>undefined;
        data["trialPeriodDays"] = this.trialPeriodDays;
        super.toJSON(data);
        return data;
    }
}

export interface IQuoteSubscriptionData extends IStripeEntityOfQuoteSubscriptionData {
    /** The subscription's description, meant to be displayable to the customer. Use this field
to optionally store an explanation of the subscription. */
    description?: string | undefined;
    /** When creating a new subscription, the date of which the subscription schedule will start
after the quote is accepted. This date is ignored if it is in the past when the quote is
accepted. Measured in seconds since the Unix epoch. */
    effectiveDate?: Date | undefined;
    /** Integer representing the number of trial period days before the customer is charged for
the first time. */
    trialPeriodDays?: number | undefined;
}

export abstract class StripeEntityOfSubscriptionSchedule extends StripeEntity implements IStripeEntityOfSubscriptionSchedule {

    constructor(data?: IStripeEntityOfSubscriptionSchedule) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSubscriptionSchedule {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSubscriptionSchedule' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSubscriptionSchedule extends IStripeEntity {
}

/** A subscription schedule allows you to create and manage the lifecycle of a subscription by predefining expected changes.            Related guide: Subscription schedules. */
export class SubscriptionSchedule extends StripeEntityOfSubscriptionSchedule implements ISubscriptionSchedule {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** (ID of the Application)
ID of the Connect Application that created the schedule. */
    applicationId?: string | undefined;
    /** (Expanded)
ID of the Connect Application that created the schedule.
            
For more information, see the expand documentation. */
    application?: Application | undefined;
    internalApplication?: ExpandableFieldOfApplication | undefined;
    /** Time at which the subscription schedule was canceled. Measured in seconds since the Unix
epoch. */
    canceledAt?: Date | undefined;
    /** Time at which the subscription schedule was completed. Measured in seconds since the
Unix epoch. */
    completedAt?: Date | undefined;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** Object representing the start and end dates for the current phase of the subscription
schedule, if it is active. */
    currentPhase?: SubscriptionScheduleCurrentPhase | undefined;
    /** (ID of the Customer)
ID of the customer who owns the subscription schedule. */
    customerId?: string | undefined;
    /** (Expanded)
ID of the customer who owns the subscription schedule.
            
For more information, see the expand documentation. */
    customer?: Customer2 | undefined;
    internalCustomer?: ExpandableFieldOfCustomer | undefined;
    defaultSettings?: SubscriptionScheduleDefaultSettings | undefined;
    /** Behavior of the subscription schedule and underlying subscription when it ends. Possible
values are release or cancel with the default being release.
release will end the subscription schedule and keep the underlying subscription
running.cancel will end the subscription schedule and cancel the underlying
subscription.
One of: cancel, none, release, or renew. */
    endBehavior?: string | undefined;
    /** Has the value true if the object exists in live mode or the value false if
the object exists in test mode. */
    livemode?: boolean;
    /** Set of key-value pairs that you can
attach to an object. This can be useful for storing additional information about the
object in a structured format. */
    metadata?: { [key: string]: string; } | undefined;
    /** Configuration for the subscription schedule's phases. */
    phases?: SubscriptionSchedulePhase[] | undefined;
    /** Time at which the subscription schedule was released. Measured in seconds since the Unix
epoch. */
    releasedAt?: Date | undefined;
    /** ID of the subscription once managed by the subscription schedule (if it is released). */
    releasedSubscription?: string | undefined;
    /** The present status of the subscription schedule. Possible values are not_started,
active, completed, released, and canceled. You can read more
about the different states in our behavior
guide.
One of: active, canceled, completed, not_started, or
released. */
    status?: string | undefined;
    /** (ID of the Subscription)
ID of the subscription managed by the subscription schedule. */
    subscriptionId?: string | undefined;
    /** (Expanded)
ID of the subscription managed by the subscription schedule.
            
For more information, see the expand documentation. */
    subscription?: Subscription | undefined;
    internalSubscription?: ExpandableFieldOfSubscription | undefined;
    /** (ID of the TestHelpers.TestClock)
ID of the test clock this subscription schedule belongs to. */
    testClockId?: string | undefined;
    /** (Expanded)
ID of the test clock this subscription schedule belongs to.
            
For more information, see the expand documentation. */
    testClock?: TestClock | undefined;
    internalTestClock?: ExpandableFieldOfTestClock | undefined;

    constructor(data?: ISubscriptionSchedule) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.object = _data["object"];
            this.applicationId = _data["applicationId"];
            this.application = _data["application"] ? Application.fromJS(_data["application"]) : <any>undefined;
            this.internalApplication = _data["internalApplication"] ? ExpandableFieldOfApplication.fromJS(_data["internalApplication"]) : <any>undefined;
            this.canceledAt = _data["canceledAt"] ? new Date(_data["canceledAt"].toString()) : <any>undefined;
            this.completedAt = _data["completedAt"] ? new Date(_data["completedAt"].toString()) : <any>undefined;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.currentPhase = _data["currentPhase"] ? SubscriptionScheduleCurrentPhase.fromJS(_data["currentPhase"]) : <any>undefined;
            this.customerId = _data["customerId"];
            this.customer = _data["customer"] ? Customer2.fromJS(_data["customer"]) : <any>undefined;
            this.internalCustomer = _data["internalCustomer"] ? ExpandableFieldOfCustomer.fromJS(_data["internalCustomer"]) : <any>undefined;
            this.defaultSettings = _data["defaultSettings"] ? SubscriptionScheduleDefaultSettings.fromJS(_data["defaultSettings"]) : <any>undefined;
            this.endBehavior = _data["endBehavior"];
            this.livemode = _data["livemode"];
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
            if (Array.isArray(_data["phases"])) {
                this.phases = [] as any;
                for (let item of _data["phases"])
                    this.phases!.push(SubscriptionSchedulePhase.fromJS(item));
            }
            this.releasedAt = _data["releasedAt"] ? new Date(_data["releasedAt"].toString()) : <any>undefined;
            this.releasedSubscription = _data["releasedSubscription"];
            this.status = _data["status"];
            this.subscriptionId = _data["subscriptionId"];
            this.subscription = _data["subscription"] ? Subscription.fromJS(_data["subscription"]) : <any>undefined;
            this.internalSubscription = _data["internalSubscription"] ? ExpandableFieldOfSubscription.fromJS(_data["internalSubscription"]) : <any>undefined;
            this.testClockId = _data["testClockId"];
            this.testClock = _data["testClock"] ? TestClock.fromJS(_data["testClock"]) : <any>undefined;
            this.internalTestClock = _data["internalTestClock"] ? ExpandableFieldOfTestClock.fromJS(_data["internalTestClock"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): SubscriptionSchedule {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionSchedule();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["object"] = this.object;
        data["applicationId"] = this.applicationId;
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["internalApplication"] = this.internalApplication ? this.internalApplication.toJSON() : <any>undefined;
        data["canceledAt"] = this.canceledAt ? this.canceledAt.toISOString() : <any>undefined;
        data["completedAt"] = this.completedAt ? this.completedAt.toISOString() : <any>undefined;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["currentPhase"] = this.currentPhase ? this.currentPhase.toJSON() : <any>undefined;
        data["customerId"] = this.customerId;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["internalCustomer"] = this.internalCustomer ? this.internalCustomer.toJSON() : <any>undefined;
        data["defaultSettings"] = this.defaultSettings ? this.defaultSettings.toJSON() : <any>undefined;
        data["endBehavior"] = this.endBehavior;
        data["livemode"] = this.livemode;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        if (Array.isArray(this.phases)) {
            data["phases"] = [];
            for (let item of this.phases)
                data["phases"].push(item.toJSON());
        }
        data["releasedAt"] = this.releasedAt ? this.releasedAt.toISOString() : <any>undefined;
        data["releasedSubscription"] = this.releasedSubscription;
        data["status"] = this.status;
        data["subscriptionId"] = this.subscriptionId;
        data["subscription"] = this.subscription ? this.subscription.toJSON() : <any>undefined;
        data["internalSubscription"] = this.internalSubscription ? this.internalSubscription.toJSON() : <any>undefined;
        data["testClockId"] = this.testClockId;
        data["testClock"] = this.testClock ? this.testClock.toJSON() : <any>undefined;
        data["internalTestClock"] = this.internalTestClock ? this.internalTestClock.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** A subscription schedule allows you to create and manage the lifecycle of a subscription by predefining expected changes.            Related guide: Subscription schedules. */
export interface ISubscriptionSchedule extends IStripeEntityOfSubscriptionSchedule {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** (ID of the Application)
ID of the Connect Application that created the schedule. */
    applicationId?: string | undefined;
    /** (Expanded)
ID of the Connect Application that created the schedule.
            
For more information, see the expand documentation. */
    application?: Application | undefined;
    internalApplication?: ExpandableFieldOfApplication | undefined;
    /** Time at which the subscription schedule was canceled. Measured in seconds since the Unix
epoch. */
    canceledAt?: Date | undefined;
    /** Time at which the subscription schedule was completed. Measured in seconds since the
Unix epoch. */
    completedAt?: Date | undefined;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** Object representing the start and end dates for the current phase of the subscription
schedule, if it is active. */
    currentPhase?: SubscriptionScheduleCurrentPhase | undefined;
    /** (ID of the Customer)
ID of the customer who owns the subscription schedule. */
    customerId?: string | undefined;
    /** (Expanded)
ID of the customer who owns the subscription schedule.
            
For more information, see the expand documentation. */
    customer?: Customer2 | undefined;
    internalCustomer?: ExpandableFieldOfCustomer | undefined;
    defaultSettings?: SubscriptionScheduleDefaultSettings | undefined;
    /** Behavior of the subscription schedule and underlying subscription when it ends. Possible
values are release or cancel with the default being release.
release will end the subscription schedule and keep the underlying subscription
running.cancel will end the subscription schedule and cancel the underlying
subscription.
One of: cancel, none, release, or renew. */
    endBehavior?: string | undefined;
    /** Has the value true if the object exists in live mode or the value false if
the object exists in test mode. */
    livemode?: boolean;
    /** Set of key-value pairs that you can
attach to an object. This can be useful for storing additional information about the
object in a structured format. */
    metadata?: { [key: string]: string; } | undefined;
    /** Configuration for the subscription schedule's phases. */
    phases?: SubscriptionSchedulePhase[] | undefined;
    /** Time at which the subscription schedule was released. Measured in seconds since the Unix
epoch. */
    releasedAt?: Date | undefined;
    /** ID of the subscription once managed by the subscription schedule (if it is released). */
    releasedSubscription?: string | undefined;
    /** The present status of the subscription schedule. Possible values are not_started,
active, completed, released, and canceled. You can read more
about the different states in our behavior
guide.
One of: active, canceled, completed, not_started, or
released. */
    status?: string | undefined;
    /** (ID of the Subscription)
ID of the subscription managed by the subscription schedule. */
    subscriptionId?: string | undefined;
    /** (Expanded)
ID of the subscription managed by the subscription schedule.
            
For more information, see the expand documentation. */
    subscription?: Subscription | undefined;
    internalSubscription?: ExpandableFieldOfSubscription | undefined;
    /** (ID of the TestHelpers.TestClock)
ID of the test clock this subscription schedule belongs to. */
    testClockId?: string | undefined;
    /** (Expanded)
ID of the test clock this subscription schedule belongs to.
            
For more information, see the expand documentation. */
    testClock?: TestClock | undefined;
    internalTestClock?: ExpandableFieldOfTestClock | undefined;
}

export abstract class StripeEntityOfSubscriptionScheduleCurrentPhase extends StripeEntity implements IStripeEntityOfSubscriptionScheduleCurrentPhase {

    constructor(data?: IStripeEntityOfSubscriptionScheduleCurrentPhase) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSubscriptionScheduleCurrentPhase {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSubscriptionScheduleCurrentPhase' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSubscriptionScheduleCurrentPhase extends IStripeEntity {
}

export class SubscriptionScheduleCurrentPhase extends StripeEntityOfSubscriptionScheduleCurrentPhase implements ISubscriptionScheduleCurrentPhase {
    /** The end of this phase of the subscription schedule. */
    endDate?: Date | undefined;
    /** The start of this phase of the subscription schedule. */
    startDate?: Date | undefined;

    constructor(data?: ISubscriptionScheduleCurrentPhase) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
        }
    }

    static override fromJS(data: any): SubscriptionScheduleCurrentPhase {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionScheduleCurrentPhase();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface ISubscriptionScheduleCurrentPhase extends IStripeEntityOfSubscriptionScheduleCurrentPhase {
    /** The end of this phase of the subscription schedule. */
    endDate?: Date | undefined;
    /** The start of this phase of the subscription schedule. */
    startDate?: Date | undefined;
}

export abstract class StripeEntityOfSubscriptionScheduleDefaultSettings extends StripeEntity implements IStripeEntityOfSubscriptionScheduleDefaultSettings {

    constructor(data?: IStripeEntityOfSubscriptionScheduleDefaultSettings) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSubscriptionScheduleDefaultSettings {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSubscriptionScheduleDefaultSettings' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSubscriptionScheduleDefaultSettings extends IStripeEntity {
}

export class SubscriptionScheduleDefaultSettings extends StripeEntityOfSubscriptionScheduleDefaultSettings implements ISubscriptionScheduleDefaultSettings {
    /** A non-negative decimal between 0 and 100, with at most two decimal places. This
represents the percentage of the subscription invoice subtotal that will be transferred
to the application owner's Stripe account during this phase of the schedule. */
    applicationFeePercent?: number | undefined;
    automaticTax?: SubscriptionScheduleDefaultSettingsAutomaticTax | undefined;
    /** Possible values are phase_start or automatic. If phase_start then
billing cycle anchor of the subscription is set to the start of the phase when entering
the phase. If automatic then the billing cycle anchor is automatically modified
as needed when entering the phase. For more information, see the billing cycle documentation.
One of: automatic, or phase_start. */
    billingCycleAnchor?: string | undefined;
    /** Define thresholds at which an invoice will be sent, and the subscription advanced to a
new billing period. */
    billingThresholds?: SubscriptionScheduleDefaultSettingsBillingThresholds | undefined;
    /** Either charge_automatically, or send_invoice. When charging automatically,
Stripe will attempt to pay the underlying subscription at the end of each billing cycle
using the default source attached to the customer. When sending an invoice, Stripe will
email your customer an invoice with payment instructions and mark the subscription as
active.
One of: charge_automatically, or send_invoice. */
    collectionMethod?: string | undefined;
    /** (ID of the PaymentMethod)
ID of the default payment method for the subscription schedule. If not set, invoices
will use the default payment method in the customer's invoice settings. */
    defaultPaymentMethodId?: string | undefined;
    /** (Expanded)
ID of the default payment method for the subscription schedule. If not set, invoices
will use the default payment method in the customer's invoice settings.
            
For more information, see the expand documentation. */
    defaultPaymentMethod?: PaymentMethod | undefined;
    internalDefaultPaymentMethod?: ExpandableFieldOfPaymentMethod | undefined;
    /** Subscription description, meant to be displayable to the customer. Use this field to
optionally store an explanation of the subscription. */
    description?: string | undefined;
    /** The subscription schedule's default invoice settings. */
    invoiceSettings?: SubscriptionScheduleDefaultSettingsInvoiceSettings | undefined;
    /** (ID of the Account)
The account (if any) the charge was made on behalf of for charges associated with the
schedule's subscription. See the Connect documentation for details. */
    onBehalfOfId?: string | undefined;
    /** (Expanded)
The account (if any) the charge was made on behalf of for charges associated with the
schedule's subscription. See the Connect documentation for details.
            
For more information, see the expand documentation. */
    onBehalfOf?: Account | undefined;
    internalOnBehalfOf?: ExpandableFieldOfAccount | undefined;
    /** The account (if any) the associated subscription's payments will be attributed to for
tax reporting, and where funds from each payment will be transferred to for each of the
subscription's invoices. */
    transferData?: SubscriptionScheduleDefaultSettingsTransferData | undefined;

    constructor(data?: ISubscriptionScheduleDefaultSettings) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.applicationFeePercent = _data["applicationFeePercent"];
            this.automaticTax = _data["automaticTax"] ? SubscriptionScheduleDefaultSettingsAutomaticTax.fromJS(_data["automaticTax"]) : <any>undefined;
            this.billingCycleAnchor = _data["billingCycleAnchor"];
            this.billingThresholds = _data["billingThresholds"] ? SubscriptionScheduleDefaultSettingsBillingThresholds.fromJS(_data["billingThresholds"]) : <any>undefined;
            this.collectionMethod = _data["collectionMethod"];
            this.defaultPaymentMethodId = _data["defaultPaymentMethodId"];
            this.defaultPaymentMethod = _data["defaultPaymentMethod"] ? PaymentMethod.fromJS(_data["defaultPaymentMethod"]) : <any>undefined;
            this.internalDefaultPaymentMethod = _data["internalDefaultPaymentMethod"] ? ExpandableFieldOfPaymentMethod.fromJS(_data["internalDefaultPaymentMethod"]) : <any>undefined;
            this.description = _data["description"];
            this.invoiceSettings = _data["invoiceSettings"] ? SubscriptionScheduleDefaultSettingsInvoiceSettings.fromJS(_data["invoiceSettings"]) : <any>undefined;
            this.onBehalfOfId = _data["onBehalfOfId"];
            this.onBehalfOf = _data["onBehalfOf"] ? Account.fromJS(_data["onBehalfOf"]) : <any>undefined;
            this.internalOnBehalfOf = _data["internalOnBehalfOf"] ? ExpandableFieldOfAccount.fromJS(_data["internalOnBehalfOf"]) : <any>undefined;
            this.transferData = _data["transferData"] ? SubscriptionScheduleDefaultSettingsTransferData.fromJS(_data["transferData"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): SubscriptionScheduleDefaultSettings {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionScheduleDefaultSettings();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["applicationFeePercent"] = this.applicationFeePercent;
        data["automaticTax"] = this.automaticTax ? this.automaticTax.toJSON() : <any>undefined;
        data["billingCycleAnchor"] = this.billingCycleAnchor;
        data["billingThresholds"] = this.billingThresholds ? this.billingThresholds.toJSON() : <any>undefined;
        data["collectionMethod"] = this.collectionMethod;
        data["defaultPaymentMethodId"] = this.defaultPaymentMethodId;
        data["defaultPaymentMethod"] = this.defaultPaymentMethod ? this.defaultPaymentMethod.toJSON() : <any>undefined;
        data["internalDefaultPaymentMethod"] = this.internalDefaultPaymentMethod ? this.internalDefaultPaymentMethod.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["invoiceSettings"] = this.invoiceSettings ? this.invoiceSettings.toJSON() : <any>undefined;
        data["onBehalfOfId"] = this.onBehalfOfId;
        data["onBehalfOf"] = this.onBehalfOf ? this.onBehalfOf.toJSON() : <any>undefined;
        data["internalOnBehalfOf"] = this.internalOnBehalfOf ? this.internalOnBehalfOf.toJSON() : <any>undefined;
        data["transferData"] = this.transferData ? this.transferData.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface ISubscriptionScheduleDefaultSettings extends IStripeEntityOfSubscriptionScheduleDefaultSettings {
    /** A non-negative decimal between 0 and 100, with at most two decimal places. This
represents the percentage of the subscription invoice subtotal that will be transferred
to the application owner's Stripe account during this phase of the schedule. */
    applicationFeePercent?: number | undefined;
    automaticTax?: SubscriptionScheduleDefaultSettingsAutomaticTax | undefined;
    /** Possible values are phase_start or automatic. If phase_start then
billing cycle anchor of the subscription is set to the start of the phase when entering
the phase. If automatic then the billing cycle anchor is automatically modified
as needed when entering the phase. For more information, see the billing cycle documentation.
One of: automatic, or phase_start. */
    billingCycleAnchor?: string | undefined;
    /** Define thresholds at which an invoice will be sent, and the subscription advanced to a
new billing period. */
    billingThresholds?: SubscriptionScheduleDefaultSettingsBillingThresholds | undefined;
    /** Either charge_automatically, or send_invoice. When charging automatically,
Stripe will attempt to pay the underlying subscription at the end of each billing cycle
using the default source attached to the customer. When sending an invoice, Stripe will
email your customer an invoice with payment instructions and mark the subscription as
active.
One of: charge_automatically, or send_invoice. */
    collectionMethod?: string | undefined;
    /** (ID of the PaymentMethod)
ID of the default payment method for the subscription schedule. If not set, invoices
will use the default payment method in the customer's invoice settings. */
    defaultPaymentMethodId?: string | undefined;
    /** (Expanded)
ID of the default payment method for the subscription schedule. If not set, invoices
will use the default payment method in the customer's invoice settings.
            
For more information, see the expand documentation. */
    defaultPaymentMethod?: PaymentMethod | undefined;
    internalDefaultPaymentMethod?: ExpandableFieldOfPaymentMethod | undefined;
    /** Subscription description, meant to be displayable to the customer. Use this field to
optionally store an explanation of the subscription. */
    description?: string | undefined;
    /** The subscription schedule's default invoice settings. */
    invoiceSettings?: SubscriptionScheduleDefaultSettingsInvoiceSettings | undefined;
    /** (ID of the Account)
The account (if any) the charge was made on behalf of for charges associated with the
schedule's subscription. See the Connect documentation for details. */
    onBehalfOfId?: string | undefined;
    /** (Expanded)
The account (if any) the charge was made on behalf of for charges associated with the
schedule's subscription. See the Connect documentation for details.
            
For more information, see the expand documentation. */
    onBehalfOf?: Account | undefined;
    internalOnBehalfOf?: ExpandableFieldOfAccount | undefined;
    /** The account (if any) the associated subscription's payments will be attributed to for
tax reporting, and where funds from each payment will be transferred to for each of the
subscription's invoices. */
    transferData?: SubscriptionScheduleDefaultSettingsTransferData | undefined;
}

export abstract class StripeEntityOfSubscriptionScheduleDefaultSettingsAutomaticTax extends StripeEntity implements IStripeEntityOfSubscriptionScheduleDefaultSettingsAutomaticTax {

    constructor(data?: IStripeEntityOfSubscriptionScheduleDefaultSettingsAutomaticTax) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSubscriptionScheduleDefaultSettingsAutomaticTax {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSubscriptionScheduleDefaultSettingsAutomaticTax' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSubscriptionScheduleDefaultSettingsAutomaticTax extends IStripeEntity {
}

export class SubscriptionScheduleDefaultSettingsAutomaticTax extends StripeEntityOfSubscriptionScheduleDefaultSettingsAutomaticTax implements ISubscriptionScheduleDefaultSettingsAutomaticTax {
    /** Whether Stripe automatically computes tax on invoices created during this phase. */
    enabled?: boolean;

    constructor(data?: ISubscriptionScheduleDefaultSettingsAutomaticTax) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.enabled = _data["enabled"];
        }
    }

    static override fromJS(data: any): SubscriptionScheduleDefaultSettingsAutomaticTax {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionScheduleDefaultSettingsAutomaticTax();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enabled"] = this.enabled;
        super.toJSON(data);
        return data;
    }
}

export interface ISubscriptionScheduleDefaultSettingsAutomaticTax extends IStripeEntityOfSubscriptionScheduleDefaultSettingsAutomaticTax {
    /** Whether Stripe automatically computes tax on invoices created during this phase. */
    enabled?: boolean;
}

export abstract class StripeEntityOfSubscriptionScheduleDefaultSettingsBillingThresholds extends StripeEntity implements IStripeEntityOfSubscriptionScheduleDefaultSettingsBillingThresholds {

    constructor(data?: IStripeEntityOfSubscriptionScheduleDefaultSettingsBillingThresholds) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSubscriptionScheduleDefaultSettingsBillingThresholds {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSubscriptionScheduleDefaultSettingsBillingThresholds' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSubscriptionScheduleDefaultSettingsBillingThresholds extends IStripeEntity {
}

export class SubscriptionScheduleDefaultSettingsBillingThresholds extends StripeEntityOfSubscriptionScheduleDefaultSettingsBillingThresholds implements ISubscriptionScheduleDefaultSettingsBillingThresholds {
    /** Monetary threshold that triggers the subscription to create an invoice. */
    amountGte?: number | undefined;
    /** Indicates if the billing_cycle_anchor should be reset when a threshold is
reached. If true, billing_cycle_anchor will be updated to the date/time the
threshold was last reached; otherwise, the value will remain unchanged. This value may
not be true if the subscription contains items with plans that have
aggregate_usage=last_ever. */
    resetBillingCycleAnchor?: boolean | undefined;

    constructor(data?: ISubscriptionScheduleDefaultSettingsBillingThresholds) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.amountGte = _data["amountGte"];
            this.resetBillingCycleAnchor = _data["resetBillingCycleAnchor"];
        }
    }

    static override fromJS(data: any): SubscriptionScheduleDefaultSettingsBillingThresholds {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionScheduleDefaultSettingsBillingThresholds();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amountGte"] = this.amountGte;
        data["resetBillingCycleAnchor"] = this.resetBillingCycleAnchor;
        super.toJSON(data);
        return data;
    }
}

export interface ISubscriptionScheduleDefaultSettingsBillingThresholds extends IStripeEntityOfSubscriptionScheduleDefaultSettingsBillingThresholds {
    /** Monetary threshold that triggers the subscription to create an invoice. */
    amountGte?: number | undefined;
    /** Indicates if the billing_cycle_anchor should be reset when a threshold is
reached. If true, billing_cycle_anchor will be updated to the date/time the
threshold was last reached; otherwise, the value will remain unchanged. This value may
not be true if the subscription contains items with plans that have
aggregate_usage=last_ever. */
    resetBillingCycleAnchor?: boolean | undefined;
}

export abstract class StripeEntityOfSubscriptionScheduleDefaultSettingsInvoiceSettings extends StripeEntity implements IStripeEntityOfSubscriptionScheduleDefaultSettingsInvoiceSettings {

    constructor(data?: IStripeEntityOfSubscriptionScheduleDefaultSettingsInvoiceSettings) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSubscriptionScheduleDefaultSettingsInvoiceSettings {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSubscriptionScheduleDefaultSettingsInvoiceSettings' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSubscriptionScheduleDefaultSettingsInvoiceSettings extends IStripeEntity {
}

export class SubscriptionScheduleDefaultSettingsInvoiceSettings extends StripeEntityOfSubscriptionScheduleDefaultSettingsInvoiceSettings implements ISubscriptionScheduleDefaultSettingsInvoiceSettings {
    /** Number of days within which a customer must pay invoices generated by this subscription
schedule. This value will be null for subscription schedules where
billing=charge_automatically. */
    daysUntilDue?: number | undefined;

    constructor(data?: ISubscriptionScheduleDefaultSettingsInvoiceSettings) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.daysUntilDue = _data["daysUntilDue"];
        }
    }

    static override fromJS(data: any): SubscriptionScheduleDefaultSettingsInvoiceSettings {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionScheduleDefaultSettingsInvoiceSettings();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["daysUntilDue"] = this.daysUntilDue;
        super.toJSON(data);
        return data;
    }
}

export interface ISubscriptionScheduleDefaultSettingsInvoiceSettings extends IStripeEntityOfSubscriptionScheduleDefaultSettingsInvoiceSettings {
    /** Number of days within which a customer must pay invoices generated by this subscription
schedule. This value will be null for subscription schedules where
billing=charge_automatically. */
    daysUntilDue?: number | undefined;
}

export abstract class StripeEntityOfSubscriptionScheduleDefaultSettingsTransferData extends StripeEntity implements IStripeEntityOfSubscriptionScheduleDefaultSettingsTransferData {

    constructor(data?: IStripeEntityOfSubscriptionScheduleDefaultSettingsTransferData) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSubscriptionScheduleDefaultSettingsTransferData {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSubscriptionScheduleDefaultSettingsTransferData' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSubscriptionScheduleDefaultSettingsTransferData extends IStripeEntity {
}

export class SubscriptionScheduleDefaultSettingsTransferData extends StripeEntityOfSubscriptionScheduleDefaultSettingsTransferData implements ISubscriptionScheduleDefaultSettingsTransferData {
    /** A non-negative decimal between 0 and 100, with at most two decimal places. This
represents the percentage of the subscription invoice subtotal that will be transferred
to the destination account. By default, the entire amount is transferred to the
destination. */
    amountPercent?: number | undefined;
    /** (ID of the Account)
The account where funds from the payment will be transferred to upon payment success. */
    destinationId?: string | undefined;
    /** (Expanded)
The account where funds from the payment will be transferred to upon payment success.
            
For more information, see the expand documentation. */
    destination?: Account | undefined;
    internalDestination?: ExpandableFieldOfAccount | undefined;

    constructor(data?: ISubscriptionScheduleDefaultSettingsTransferData) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.amountPercent = _data["amountPercent"];
            this.destinationId = _data["destinationId"];
            this.destination = _data["destination"] ? Account.fromJS(_data["destination"]) : <any>undefined;
            this.internalDestination = _data["internalDestination"] ? ExpandableFieldOfAccount.fromJS(_data["internalDestination"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): SubscriptionScheduleDefaultSettingsTransferData {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionScheduleDefaultSettingsTransferData();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amountPercent"] = this.amountPercent;
        data["destinationId"] = this.destinationId;
        data["destination"] = this.destination ? this.destination.toJSON() : <any>undefined;
        data["internalDestination"] = this.internalDestination ? this.internalDestination.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface ISubscriptionScheduleDefaultSettingsTransferData extends IStripeEntityOfSubscriptionScheduleDefaultSettingsTransferData {
    /** A non-negative decimal between 0 and 100, with at most two decimal places. This
represents the percentage of the subscription invoice subtotal that will be transferred
to the destination account. By default, the entire amount is transferred to the
destination. */
    amountPercent?: number | undefined;
    /** (ID of the Account)
The account where funds from the payment will be transferred to upon payment success. */
    destinationId?: string | undefined;
    /** (Expanded)
The account where funds from the payment will be transferred to upon payment success.
            
For more information, see the expand documentation. */
    destination?: Account | undefined;
    internalDestination?: ExpandableFieldOfAccount | undefined;
}

export abstract class StripeEntityOfSubscriptionSchedulePhase extends StripeEntity implements IStripeEntityOfSubscriptionSchedulePhase {

    constructor(data?: IStripeEntityOfSubscriptionSchedulePhase) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSubscriptionSchedulePhase {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSubscriptionSchedulePhase' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSubscriptionSchedulePhase extends IStripeEntity {
}

export class SubscriptionSchedulePhase extends StripeEntityOfSubscriptionSchedulePhase implements ISubscriptionSchedulePhase {
    /** A list of prices and quantities that will generate invoice items appended to the next
invoice for this phase. */
    addInvoiceItems?: SubscriptionSchedulePhaseAddInvoiceItem[] | undefined;
    /** A non-negative decimal between 0 and 100, with at most two decimal places. This
represents the percentage of the subscription invoice subtotal that will be transferred
to the application owner's Stripe account during this phase of the schedule. */
    applicationFeePercent?: number | undefined;
    automaticTax?: SubscriptionSchedulePhaseAutomaticTax | undefined;
    /** Possible values are phase_start or automatic. If phase_start then
billing cycle anchor of the subscription is set to the start of the phase when entering
the phase. If automatic then the billing cycle anchor is automatically modified
as needed when entering the phase. For more information, see the billing cycle documentation.
One of: automatic, or phase_start. */
    billingCycleAnchor?: string | undefined;
    /** Define thresholds at which an invoice will be sent, and the subscription advanced to a
new billing period. */
    billingThresholds?: SubscriptionSchedulePhaseBillingThresholds | undefined;
    /** Either charge_automatically, or send_invoice. When charging automatically,
Stripe will attempt to pay the underlying subscription at the end of each billing cycle
using the default source attached to the customer. When sending an invoice, Stripe will
email your customer an invoice with payment instructions and mark the subscription as
active.
One of: charge_automatically, or send_invoice. */
    collectionMethod?: string | undefined;
    /** (ID of the Coupon)
ID of the coupon to use during this phase of the subscription schedule. */
    couponId?: string | undefined;
    /** (Expanded)
ID of the coupon to use during this phase of the subscription schedule.
            
For more information, see the expand documentation. */
    coupon?: Coupon | undefined;
    internalCoupon?: ExpandableFieldOfCoupon | undefined;
    /** Three-letter ISO currency
code, in lowercase. Must be a supported
currency. */
    currency?: string | undefined;
    /** (ID of the PaymentMethod)
ID of the default payment method for the subscription schedule. It must belong to the
customer associated with the subscription schedule. If not set, invoices will use the
default payment method in the customer's invoice settings. */
    defaultPaymentMethodId?: string | undefined;
    /** (Expanded)
ID of the default payment method for the subscription schedule. It must belong to the
customer associated with the subscription schedule. If not set, invoices will use the
default payment method in the customer's invoice settings.
            
For more information, see the expand documentation. */
    defaultPaymentMethod?: PaymentMethod | undefined;
    internalDefaultPaymentMethod?: ExpandableFieldOfPaymentMethod | undefined;
    /** The default tax rates to apply to the subscription during this phase of the subscription
schedule. */
    defaultTaxRates?: TaxRate[] | undefined;
    /** Subscription description, meant to be displayable to the customer. Use this field to
optionally store an explanation of the subscription. */
    description?: string | undefined;
    /** The end of this phase of the subscription schedule. */
    endDate?: Date;
    /** The invoice settings applicable during this phase. */
    invoiceSettings?: SubscriptionSchedulePhaseInvoiceSettings | undefined;
    /** Subscription items to configure the subscription to during this phase of the
subscription schedule. */
    items?: SubscriptionSchedulePhaseItem[] | undefined;
    /** Set of key-value pairs that you can
attach to a phase. Metadata on a schedule's phase will update the underlying
subscription's metadata when the phase is entered. Updating the underlying
subscription's metadata directly will not affect the current phase's
metadata. */
    metadata?: { [key: string]: string; } | undefined;
    /** (ID of the Account)
The account (if any) the charge was made on behalf of for charges associated with the
schedule's subscription. See the Connect documentation for details. */
    onBehalfOfId?: string | undefined;
    /** (Expanded)
The account (if any) the charge was made on behalf of for charges associated with the
schedule's subscription. See the Connect documentation for details.
            
For more information, see the expand documentation. */
    onBehalfOf?: Account | undefined;
    internalOnBehalfOf?: ExpandableFieldOfAccount | undefined;
    /** If the subscription schedule will prorate when transitioning to this phase. Possible
values are create_prorations and none.
One of: always_invoice, create_prorations, or none. */
    prorationBehavior?: string | undefined;
    /** The start of this phase of the subscription schedule. */
    startDate?: Date;
    /** The account (if any) the associated subscription's payments will be attributed to for
tax reporting, and where funds from each payment will be transferred to for each of the
subscription's invoices. */
    transferData?: SubscriptionSchedulePhaseTransferData | undefined;
    /** When the trial ends within the phase. */
    trialEnd?: Date | undefined;

    constructor(data?: ISubscriptionSchedulePhase) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["addInvoiceItems"])) {
                this.addInvoiceItems = [] as any;
                for (let item of _data["addInvoiceItems"])
                    this.addInvoiceItems!.push(SubscriptionSchedulePhaseAddInvoiceItem.fromJS(item));
            }
            this.applicationFeePercent = _data["applicationFeePercent"];
            this.automaticTax = _data["automaticTax"] ? SubscriptionSchedulePhaseAutomaticTax.fromJS(_data["automaticTax"]) : <any>undefined;
            this.billingCycleAnchor = _data["billingCycleAnchor"];
            this.billingThresholds = _data["billingThresholds"] ? SubscriptionSchedulePhaseBillingThresholds.fromJS(_data["billingThresholds"]) : <any>undefined;
            this.collectionMethod = _data["collectionMethod"];
            this.couponId = _data["couponId"];
            this.coupon = _data["coupon"] ? Coupon.fromJS(_data["coupon"]) : <any>undefined;
            this.internalCoupon = _data["internalCoupon"] ? ExpandableFieldOfCoupon.fromJS(_data["internalCoupon"]) : <any>undefined;
            this.currency = _data["currency"];
            this.defaultPaymentMethodId = _data["defaultPaymentMethodId"];
            this.defaultPaymentMethod = _data["defaultPaymentMethod"] ? PaymentMethod.fromJS(_data["defaultPaymentMethod"]) : <any>undefined;
            this.internalDefaultPaymentMethod = _data["internalDefaultPaymentMethod"] ? ExpandableFieldOfPaymentMethod.fromJS(_data["internalDefaultPaymentMethod"]) : <any>undefined;
            if (Array.isArray(_data["defaultTaxRates"])) {
                this.defaultTaxRates = [] as any;
                for (let item of _data["defaultTaxRates"])
                    this.defaultTaxRates!.push(TaxRate.fromJS(item));
            }
            this.description = _data["description"];
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.invoiceSettings = _data["invoiceSettings"] ? SubscriptionSchedulePhaseInvoiceSettings.fromJS(_data["invoiceSettings"]) : <any>undefined;
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SubscriptionSchedulePhaseItem.fromJS(item));
            }
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
            this.onBehalfOfId = _data["onBehalfOfId"];
            this.onBehalfOf = _data["onBehalfOf"] ? Account.fromJS(_data["onBehalfOf"]) : <any>undefined;
            this.internalOnBehalfOf = _data["internalOnBehalfOf"] ? ExpandableFieldOfAccount.fromJS(_data["internalOnBehalfOf"]) : <any>undefined;
            this.prorationBehavior = _data["prorationBehavior"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.transferData = _data["transferData"] ? SubscriptionSchedulePhaseTransferData.fromJS(_data["transferData"]) : <any>undefined;
            this.trialEnd = _data["trialEnd"] ? new Date(_data["trialEnd"].toString()) : <any>undefined;
        }
    }

    static override fromJS(data: any): SubscriptionSchedulePhase {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionSchedulePhase();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.addInvoiceItems)) {
            data["addInvoiceItems"] = [];
            for (let item of this.addInvoiceItems)
                data["addInvoiceItems"].push(item.toJSON());
        }
        data["applicationFeePercent"] = this.applicationFeePercent;
        data["automaticTax"] = this.automaticTax ? this.automaticTax.toJSON() : <any>undefined;
        data["billingCycleAnchor"] = this.billingCycleAnchor;
        data["billingThresholds"] = this.billingThresholds ? this.billingThresholds.toJSON() : <any>undefined;
        data["collectionMethod"] = this.collectionMethod;
        data["couponId"] = this.couponId;
        data["coupon"] = this.coupon ? this.coupon.toJSON() : <any>undefined;
        data["internalCoupon"] = this.internalCoupon ? this.internalCoupon.toJSON() : <any>undefined;
        data["currency"] = this.currency;
        data["defaultPaymentMethodId"] = this.defaultPaymentMethodId;
        data["defaultPaymentMethod"] = this.defaultPaymentMethod ? this.defaultPaymentMethod.toJSON() : <any>undefined;
        data["internalDefaultPaymentMethod"] = this.internalDefaultPaymentMethod ? this.internalDefaultPaymentMethod.toJSON() : <any>undefined;
        if (Array.isArray(this.defaultTaxRates)) {
            data["defaultTaxRates"] = [];
            for (let item of this.defaultTaxRates)
                data["defaultTaxRates"].push(item.toJSON());
        }
        data["description"] = this.description;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["invoiceSettings"] = this.invoiceSettings ? this.invoiceSettings.toJSON() : <any>undefined;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        data["onBehalfOfId"] = this.onBehalfOfId;
        data["onBehalfOf"] = this.onBehalfOf ? this.onBehalfOf.toJSON() : <any>undefined;
        data["internalOnBehalfOf"] = this.internalOnBehalfOf ? this.internalOnBehalfOf.toJSON() : <any>undefined;
        data["prorationBehavior"] = this.prorationBehavior;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["transferData"] = this.transferData ? this.transferData.toJSON() : <any>undefined;
        data["trialEnd"] = this.trialEnd ? this.trialEnd.toISOString() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface ISubscriptionSchedulePhase extends IStripeEntityOfSubscriptionSchedulePhase {
    /** A list of prices and quantities that will generate invoice items appended to the next
invoice for this phase. */
    addInvoiceItems?: SubscriptionSchedulePhaseAddInvoiceItem[] | undefined;
    /** A non-negative decimal between 0 and 100, with at most two decimal places. This
represents the percentage of the subscription invoice subtotal that will be transferred
to the application owner's Stripe account during this phase of the schedule. */
    applicationFeePercent?: number | undefined;
    automaticTax?: SubscriptionSchedulePhaseAutomaticTax | undefined;
    /** Possible values are phase_start or automatic. If phase_start then
billing cycle anchor of the subscription is set to the start of the phase when entering
the phase. If automatic then the billing cycle anchor is automatically modified
as needed when entering the phase. For more information, see the billing cycle documentation.
One of: automatic, or phase_start. */
    billingCycleAnchor?: string | undefined;
    /** Define thresholds at which an invoice will be sent, and the subscription advanced to a
new billing period. */
    billingThresholds?: SubscriptionSchedulePhaseBillingThresholds | undefined;
    /** Either charge_automatically, or send_invoice. When charging automatically,
Stripe will attempt to pay the underlying subscription at the end of each billing cycle
using the default source attached to the customer. When sending an invoice, Stripe will
email your customer an invoice with payment instructions and mark the subscription as
active.
One of: charge_automatically, or send_invoice. */
    collectionMethod?: string | undefined;
    /** (ID of the Coupon)
ID of the coupon to use during this phase of the subscription schedule. */
    couponId?: string | undefined;
    /** (Expanded)
ID of the coupon to use during this phase of the subscription schedule.
            
For more information, see the expand documentation. */
    coupon?: Coupon | undefined;
    internalCoupon?: ExpandableFieldOfCoupon | undefined;
    /** Three-letter ISO currency
code, in lowercase. Must be a supported
currency. */
    currency?: string | undefined;
    /** (ID of the PaymentMethod)
ID of the default payment method for the subscription schedule. It must belong to the
customer associated with the subscription schedule. If not set, invoices will use the
default payment method in the customer's invoice settings. */
    defaultPaymentMethodId?: string | undefined;
    /** (Expanded)
ID of the default payment method for the subscription schedule. It must belong to the
customer associated with the subscription schedule. If not set, invoices will use the
default payment method in the customer's invoice settings.
            
For more information, see the expand documentation. */
    defaultPaymentMethod?: PaymentMethod | undefined;
    internalDefaultPaymentMethod?: ExpandableFieldOfPaymentMethod | undefined;
    /** The default tax rates to apply to the subscription during this phase of the subscription
schedule. */
    defaultTaxRates?: TaxRate[] | undefined;
    /** Subscription description, meant to be displayable to the customer. Use this field to
optionally store an explanation of the subscription. */
    description?: string | undefined;
    /** The end of this phase of the subscription schedule. */
    endDate?: Date;
    /** The invoice settings applicable during this phase. */
    invoiceSettings?: SubscriptionSchedulePhaseInvoiceSettings | undefined;
    /** Subscription items to configure the subscription to during this phase of the
subscription schedule. */
    items?: SubscriptionSchedulePhaseItem[] | undefined;
    /** Set of key-value pairs that you can
attach to a phase. Metadata on a schedule's phase will update the underlying
subscription's metadata when the phase is entered. Updating the underlying
subscription's metadata directly will not affect the current phase's
metadata. */
    metadata?: { [key: string]: string; } | undefined;
    /** (ID of the Account)
The account (if any) the charge was made on behalf of for charges associated with the
schedule's subscription. See the Connect documentation for details. */
    onBehalfOfId?: string | undefined;
    /** (Expanded)
The account (if any) the charge was made on behalf of for charges associated with the
schedule's subscription. See the Connect documentation for details.
            
For more information, see the expand documentation. */
    onBehalfOf?: Account | undefined;
    internalOnBehalfOf?: ExpandableFieldOfAccount | undefined;
    /** If the subscription schedule will prorate when transitioning to this phase. Possible
values are create_prorations and none.
One of: always_invoice, create_prorations, or none. */
    prorationBehavior?: string | undefined;
    /** The start of this phase of the subscription schedule. */
    startDate?: Date;
    /** The account (if any) the associated subscription's payments will be attributed to for
tax reporting, and where funds from each payment will be transferred to for each of the
subscription's invoices. */
    transferData?: SubscriptionSchedulePhaseTransferData | undefined;
    /** When the trial ends within the phase. */
    trialEnd?: Date | undefined;
}

export abstract class StripeEntityOfSubscriptionSchedulePhaseAddInvoiceItem extends StripeEntity implements IStripeEntityOfSubscriptionSchedulePhaseAddInvoiceItem {

    constructor(data?: IStripeEntityOfSubscriptionSchedulePhaseAddInvoiceItem) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSubscriptionSchedulePhaseAddInvoiceItem {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSubscriptionSchedulePhaseAddInvoiceItem' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSubscriptionSchedulePhaseAddInvoiceItem extends IStripeEntity {
}

export class SubscriptionSchedulePhaseAddInvoiceItem extends StripeEntityOfSubscriptionSchedulePhaseAddInvoiceItem implements ISubscriptionSchedulePhaseAddInvoiceItem {
    /** (ID of the Price)
ID of the price used to generate the invoice item. */
    priceId?: string | undefined;
    /** (Expanded)
ID of the price used to generate the invoice item.
            
For more information, see the expand documentation. */
    price?: Price | undefined;
    internalPrice?: ExpandableFieldOfPrice | undefined;
    /** The quantity of the invoice item. */
    quantity?: number | undefined;
    /** The tax rates which apply to the item. When set, the default_tax_rates do not
apply to this item. */
    taxRates?: TaxRate[] | undefined;

    constructor(data?: ISubscriptionSchedulePhaseAddInvoiceItem) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.priceId = _data["priceId"];
            this.price = _data["price"] ? Price.fromJS(_data["price"]) : <any>undefined;
            this.internalPrice = _data["internalPrice"] ? ExpandableFieldOfPrice.fromJS(_data["internalPrice"]) : <any>undefined;
            this.quantity = _data["quantity"];
            if (Array.isArray(_data["taxRates"])) {
                this.taxRates = [] as any;
                for (let item of _data["taxRates"])
                    this.taxRates!.push(TaxRate.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): SubscriptionSchedulePhaseAddInvoiceItem {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionSchedulePhaseAddInvoiceItem();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["priceId"] = this.priceId;
        data["price"] = this.price ? this.price.toJSON() : <any>undefined;
        data["internalPrice"] = this.internalPrice ? this.internalPrice.toJSON() : <any>undefined;
        data["quantity"] = this.quantity;
        if (Array.isArray(this.taxRates)) {
            data["taxRates"] = [];
            for (let item of this.taxRates)
                data["taxRates"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface ISubscriptionSchedulePhaseAddInvoiceItem extends IStripeEntityOfSubscriptionSchedulePhaseAddInvoiceItem {
    /** (ID of the Price)
ID of the price used to generate the invoice item. */
    priceId?: string | undefined;
    /** (Expanded)
ID of the price used to generate the invoice item.
            
For more information, see the expand documentation. */
    price?: Price | undefined;
    internalPrice?: ExpandableFieldOfPrice | undefined;
    /** The quantity of the invoice item. */
    quantity?: number | undefined;
    /** The tax rates which apply to the item. When set, the default_tax_rates do not
apply to this item. */
    taxRates?: TaxRate[] | undefined;
}

export abstract class StripeEntityOfSubscriptionSchedulePhaseAutomaticTax extends StripeEntity implements IStripeEntityOfSubscriptionSchedulePhaseAutomaticTax {

    constructor(data?: IStripeEntityOfSubscriptionSchedulePhaseAutomaticTax) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSubscriptionSchedulePhaseAutomaticTax {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSubscriptionSchedulePhaseAutomaticTax' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSubscriptionSchedulePhaseAutomaticTax extends IStripeEntity {
}

export class SubscriptionSchedulePhaseAutomaticTax extends StripeEntityOfSubscriptionSchedulePhaseAutomaticTax implements ISubscriptionSchedulePhaseAutomaticTax {
    /** Whether Stripe automatically computes tax on invoices created during this phase. */
    enabled?: boolean;

    constructor(data?: ISubscriptionSchedulePhaseAutomaticTax) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.enabled = _data["enabled"];
        }
    }

    static override fromJS(data: any): SubscriptionSchedulePhaseAutomaticTax {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionSchedulePhaseAutomaticTax();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enabled"] = this.enabled;
        super.toJSON(data);
        return data;
    }
}

export interface ISubscriptionSchedulePhaseAutomaticTax extends IStripeEntityOfSubscriptionSchedulePhaseAutomaticTax {
    /** Whether Stripe automatically computes tax on invoices created during this phase. */
    enabled?: boolean;
}

export abstract class StripeEntityOfSubscriptionSchedulePhaseBillingThresholds extends StripeEntity implements IStripeEntityOfSubscriptionSchedulePhaseBillingThresholds {

    constructor(data?: IStripeEntityOfSubscriptionSchedulePhaseBillingThresholds) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSubscriptionSchedulePhaseBillingThresholds {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSubscriptionSchedulePhaseBillingThresholds' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSubscriptionSchedulePhaseBillingThresholds extends IStripeEntity {
}

export class SubscriptionSchedulePhaseBillingThresholds extends StripeEntityOfSubscriptionSchedulePhaseBillingThresholds implements ISubscriptionSchedulePhaseBillingThresholds {
    /** Monetary threshold that triggers the subscription to create an invoice. */
    amountGte?: number | undefined;
    /** Indicates if the billing_cycle_anchor should be reset when a threshold is
reached. If true, billing_cycle_anchor will be updated to the date/time the
threshold was last reached; otherwise, the value will remain unchanged. This value may
not be true if the subscription contains items with plans that have
aggregate_usage=last_ever. */
    resetBillingCycleAnchor?: boolean | undefined;

    constructor(data?: ISubscriptionSchedulePhaseBillingThresholds) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.amountGte = _data["amountGte"];
            this.resetBillingCycleAnchor = _data["resetBillingCycleAnchor"];
        }
    }

    static override fromJS(data: any): SubscriptionSchedulePhaseBillingThresholds {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionSchedulePhaseBillingThresholds();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amountGte"] = this.amountGte;
        data["resetBillingCycleAnchor"] = this.resetBillingCycleAnchor;
        super.toJSON(data);
        return data;
    }
}

export interface ISubscriptionSchedulePhaseBillingThresholds extends IStripeEntityOfSubscriptionSchedulePhaseBillingThresholds {
    /** Monetary threshold that triggers the subscription to create an invoice. */
    amountGte?: number | undefined;
    /** Indicates if the billing_cycle_anchor should be reset when a threshold is
reached. If true, billing_cycle_anchor will be updated to the date/time the
threshold was last reached; otherwise, the value will remain unchanged. This value may
not be true if the subscription contains items with plans that have
aggregate_usage=last_ever. */
    resetBillingCycleAnchor?: boolean | undefined;
}

/** Represents a generic expandable field. */
export class ExpandableFieldOfCoupon implements IExpandableFieldOfCoupon {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: Coupon | undefined;

    constructor(data?: IExpandableFieldOfCoupon) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.expandedObject = _data["expandedObject"] ? Coupon.fromJS(_data["expandedObject"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExpandableFieldOfCoupon {
        data = typeof data === 'object' ? data : {};
        let result = new ExpandableFieldOfCoupon();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["expandedObject"] = this.expandedObject ? this.expandedObject.toJSON() : <any>undefined;
        return data;
    }
}

/** Represents a generic expandable field. */
export interface IExpandableFieldOfCoupon {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: Coupon | undefined;
}

export abstract class StripeEntityOfSubscriptionSchedulePhaseInvoiceSettings extends StripeEntity implements IStripeEntityOfSubscriptionSchedulePhaseInvoiceSettings {

    constructor(data?: IStripeEntityOfSubscriptionSchedulePhaseInvoiceSettings) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSubscriptionSchedulePhaseInvoiceSettings {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSubscriptionSchedulePhaseInvoiceSettings' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSubscriptionSchedulePhaseInvoiceSettings extends IStripeEntity {
}

export class SubscriptionSchedulePhaseInvoiceSettings extends StripeEntityOfSubscriptionSchedulePhaseInvoiceSettings implements ISubscriptionSchedulePhaseInvoiceSettings {
    /** Number of days within which a customer must pay invoices generated by this subscription
schedule. This value will be null for subscription schedules where
billing=charge_automatically. */
    daysUntilDue?: number | undefined;

    constructor(data?: ISubscriptionSchedulePhaseInvoiceSettings) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.daysUntilDue = _data["daysUntilDue"];
        }
    }

    static override fromJS(data: any): SubscriptionSchedulePhaseInvoiceSettings {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionSchedulePhaseInvoiceSettings();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["daysUntilDue"] = this.daysUntilDue;
        super.toJSON(data);
        return data;
    }
}

export interface ISubscriptionSchedulePhaseInvoiceSettings extends IStripeEntityOfSubscriptionSchedulePhaseInvoiceSettings {
    /** Number of days within which a customer must pay invoices generated by this subscription
schedule. This value will be null for subscription schedules where
billing=charge_automatically. */
    daysUntilDue?: number | undefined;
}

export abstract class StripeEntityOfSubscriptionSchedulePhaseItem extends StripeEntity implements IStripeEntityOfSubscriptionSchedulePhaseItem {

    constructor(data?: IStripeEntityOfSubscriptionSchedulePhaseItem) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSubscriptionSchedulePhaseItem {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSubscriptionSchedulePhaseItem' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSubscriptionSchedulePhaseItem extends IStripeEntity {
}

export class SubscriptionSchedulePhaseItem extends StripeEntityOfSubscriptionSchedulePhaseItem implements ISubscriptionSchedulePhaseItem {
    /** Define thresholds at which an invoice will be sent, and the related subscription
advanced to a new billing period. */
    billingThresholds?: SubscriptionSchedulePhaseItemBillingThresholds | undefined;
    /** Set of key-value pairs that you can
attach to an item. Metadata on this item will update the underlying subscription item's
metadata when the phase is entered. */
    metadata?: { [key: string]: string; } | undefined;
    /** (ID of the Plan)
ID of the plan to which the customer should be subscribed. */
    planId?: string | undefined;
    /** (Expanded)
ID of the plan to which the customer should be subscribed.
            
For more information, see the expand documentation. */
    plan?: Plan | undefined;
    internalPlan?: ExpandableFieldOfPlan | undefined;
    /** (ID of the Price)
ID of the price to which the customer should be subscribed. */
    priceId?: string | undefined;
    /** (Expanded)
ID of the price to which the customer should be subscribed.
            
For more information, see the expand documentation. */
    price?: Price | undefined;
    internalPrice?: ExpandableFieldOfPrice | undefined;
    /** Quantity of the plan to which the customer should be subscribed. */
    quantity?: number;
    /** The tax rates which apply to this phase_item. When set, the
default_tax_rates on the phase do not apply to this phase_item. */
    taxRates?: TaxRate[] | undefined;

    constructor(data?: ISubscriptionSchedulePhaseItem) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.billingThresholds = _data["billingThresholds"] ? SubscriptionSchedulePhaseItemBillingThresholds.fromJS(_data["billingThresholds"]) : <any>undefined;
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
            this.planId = _data["planId"];
            this.plan = _data["plan"] ? Plan.fromJS(_data["plan"]) : <any>undefined;
            this.internalPlan = _data["internalPlan"] ? ExpandableFieldOfPlan.fromJS(_data["internalPlan"]) : <any>undefined;
            this.priceId = _data["priceId"];
            this.price = _data["price"] ? Price.fromJS(_data["price"]) : <any>undefined;
            this.internalPrice = _data["internalPrice"] ? ExpandableFieldOfPrice.fromJS(_data["internalPrice"]) : <any>undefined;
            this.quantity = _data["quantity"];
            if (Array.isArray(_data["taxRates"])) {
                this.taxRates = [] as any;
                for (let item of _data["taxRates"])
                    this.taxRates!.push(TaxRate.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): SubscriptionSchedulePhaseItem {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionSchedulePhaseItem();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["billingThresholds"] = this.billingThresholds ? this.billingThresholds.toJSON() : <any>undefined;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        data["planId"] = this.planId;
        data["plan"] = this.plan ? this.plan.toJSON() : <any>undefined;
        data["internalPlan"] = this.internalPlan ? this.internalPlan.toJSON() : <any>undefined;
        data["priceId"] = this.priceId;
        data["price"] = this.price ? this.price.toJSON() : <any>undefined;
        data["internalPrice"] = this.internalPrice ? this.internalPrice.toJSON() : <any>undefined;
        data["quantity"] = this.quantity;
        if (Array.isArray(this.taxRates)) {
            data["taxRates"] = [];
            for (let item of this.taxRates)
                data["taxRates"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface ISubscriptionSchedulePhaseItem extends IStripeEntityOfSubscriptionSchedulePhaseItem {
    /** Define thresholds at which an invoice will be sent, and the related subscription
advanced to a new billing period. */
    billingThresholds?: SubscriptionSchedulePhaseItemBillingThresholds | undefined;
    /** Set of key-value pairs that you can
attach to an item. Metadata on this item will update the underlying subscription item's
metadata when the phase is entered. */
    metadata?: { [key: string]: string; } | undefined;
    /** (ID of the Plan)
ID of the plan to which the customer should be subscribed. */
    planId?: string | undefined;
    /** (Expanded)
ID of the plan to which the customer should be subscribed.
            
For more information, see the expand documentation. */
    plan?: Plan | undefined;
    internalPlan?: ExpandableFieldOfPlan | undefined;
    /** (ID of the Price)
ID of the price to which the customer should be subscribed. */
    priceId?: string | undefined;
    /** (Expanded)
ID of the price to which the customer should be subscribed.
            
For more information, see the expand documentation. */
    price?: Price | undefined;
    internalPrice?: ExpandableFieldOfPrice | undefined;
    /** Quantity of the plan to which the customer should be subscribed. */
    quantity?: number;
    /** The tax rates which apply to this phase_item. When set, the
default_tax_rates on the phase do not apply to this phase_item. */
    taxRates?: TaxRate[] | undefined;
}

export abstract class StripeEntityOfSubscriptionSchedulePhaseItemBillingThresholds extends StripeEntity implements IStripeEntityOfSubscriptionSchedulePhaseItemBillingThresholds {

    constructor(data?: IStripeEntityOfSubscriptionSchedulePhaseItemBillingThresholds) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSubscriptionSchedulePhaseItemBillingThresholds {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSubscriptionSchedulePhaseItemBillingThresholds' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSubscriptionSchedulePhaseItemBillingThresholds extends IStripeEntity {
}

export class SubscriptionSchedulePhaseItemBillingThresholds extends StripeEntityOfSubscriptionSchedulePhaseItemBillingThresholds implements ISubscriptionSchedulePhaseItemBillingThresholds {
    /** Usage threshold that triggers the subscription to create an invoice. */
    usageGte?: number | undefined;

    constructor(data?: ISubscriptionSchedulePhaseItemBillingThresholds) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.usageGte = _data["usageGte"];
        }
    }

    static override fromJS(data: any): SubscriptionSchedulePhaseItemBillingThresholds {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionSchedulePhaseItemBillingThresholds();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["usageGte"] = this.usageGte;
        super.toJSON(data);
        return data;
    }
}

export interface ISubscriptionSchedulePhaseItemBillingThresholds extends IStripeEntityOfSubscriptionSchedulePhaseItemBillingThresholds {
    /** Usage threshold that triggers the subscription to create an invoice. */
    usageGte?: number | undefined;
}

/** Represents a generic expandable field. */
export class ExpandableFieldOfPlan implements IExpandableFieldOfPlan {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: Plan | undefined;

    constructor(data?: IExpandableFieldOfPlan) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.expandedObject = _data["expandedObject"] ? Plan.fromJS(_data["expandedObject"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExpandableFieldOfPlan {
        data = typeof data === 'object' ? data : {};
        let result = new ExpandableFieldOfPlan();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["expandedObject"] = this.expandedObject ? this.expandedObject.toJSON() : <any>undefined;
        return data;
    }
}

/** Represents a generic expandable field. */
export interface IExpandableFieldOfPlan {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: Plan | undefined;
}

export abstract class StripeEntityOfSubscriptionSchedulePhaseTransferData extends StripeEntity implements IStripeEntityOfSubscriptionSchedulePhaseTransferData {

    constructor(data?: IStripeEntityOfSubscriptionSchedulePhaseTransferData) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSubscriptionSchedulePhaseTransferData {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSubscriptionSchedulePhaseTransferData' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSubscriptionSchedulePhaseTransferData extends IStripeEntity {
}

export class SubscriptionSchedulePhaseTransferData extends StripeEntityOfSubscriptionSchedulePhaseTransferData implements ISubscriptionSchedulePhaseTransferData {
    /** A non-negative decimal between 0 and 100, with at most two decimal places. This
represents the percentage of the subscription invoice subtotal that will be transferred
to the destination account. By default, the entire amount is transferred to the
destination. */
    amountPercent?: number | undefined;
    /** (ID of the Account)
The account where funds from the payment will be transferred to upon payment success. */
    destinationId?: string | undefined;
    /** (Expanded)
The account where funds from the payment will be transferred to upon payment success.
            
For more information, see the expand documentation. */
    destination?: Account | undefined;
    internalDestination?: ExpandableFieldOfAccount | undefined;

    constructor(data?: ISubscriptionSchedulePhaseTransferData) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.amountPercent = _data["amountPercent"];
            this.destinationId = _data["destinationId"];
            this.destination = _data["destination"] ? Account.fromJS(_data["destination"]) : <any>undefined;
            this.internalDestination = _data["internalDestination"] ? ExpandableFieldOfAccount.fromJS(_data["internalDestination"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): SubscriptionSchedulePhaseTransferData {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionSchedulePhaseTransferData();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amountPercent"] = this.amountPercent;
        data["destinationId"] = this.destinationId;
        data["destination"] = this.destination ? this.destination.toJSON() : <any>undefined;
        data["internalDestination"] = this.internalDestination ? this.internalDestination.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface ISubscriptionSchedulePhaseTransferData extends IStripeEntityOfSubscriptionSchedulePhaseTransferData {
    /** A non-negative decimal between 0 and 100, with at most two decimal places. This
represents the percentage of the subscription invoice subtotal that will be transferred
to the destination account. By default, the entire amount is transferred to the
destination. */
    amountPercent?: number | undefined;
    /** (ID of the Account)
The account where funds from the payment will be transferred to upon payment success. */
    destinationId?: string | undefined;
    /** (Expanded)
The account where funds from the payment will be transferred to upon payment success.
            
For more information, see the expand documentation. */
    destination?: Account | undefined;
    internalDestination?: ExpandableFieldOfAccount | undefined;
}

export abstract class StripeEntityOfTestClock extends StripeEntity implements IStripeEntityOfTestClock {

    constructor(data?: IStripeEntityOfTestClock) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfTestClock {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfTestClock' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfTestClock extends IStripeEntity {
}

/** A test clock enables deterministic control over objects in testmode. With a test clock, you can create objects at a frozen time in the past or future, and advance to a specific future time to observe webhooks and state changes. After the clock advances, you can either validate the current state of your scenario (and test your assumptions), change the current state of your scenario (and test more complex scenarios), or keep advancing forward in time. */
export class TestClock extends StripeEntityOfTestClock implements ITestClock {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** Whether this object is deleted or not. */
    deleted?: boolean | undefined;
    /** Time at which this clock is scheduled to auto delete. */
    deletesAfter?: Date;
    /** Time at which all objects belonging to this clock are frozen. */
    frozenTime?: Date;
    /** Has the value true if the object exists in live mode or the value false if
the object exists in test mode. */
    livemode?: boolean;
    /** The custom name supplied at creation. */
    name?: string | undefined;
    /** The status of the Test Clock.
One of: advancing, internal_failure, or ready. */
    status?: string | undefined;

    constructor(data?: ITestClock) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.object = _data["object"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.deleted = _data["deleted"];
            this.deletesAfter = _data["deletesAfter"] ? new Date(_data["deletesAfter"].toString()) : <any>undefined;
            this.frozenTime = _data["frozenTime"] ? new Date(_data["frozenTime"].toString()) : <any>undefined;
            this.livemode = _data["livemode"];
            this.name = _data["name"];
            this.status = _data["status"];
        }
    }

    static override fromJS(data: any): TestClock {
        data = typeof data === 'object' ? data : {};
        let result = new TestClock();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["object"] = this.object;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["deleted"] = this.deleted;
        data["deletesAfter"] = this.deletesAfter ? this.deletesAfter.toISOString() : <any>undefined;
        data["frozenTime"] = this.frozenTime ? this.frozenTime.toISOString() : <any>undefined;
        data["livemode"] = this.livemode;
        data["name"] = this.name;
        data["status"] = this.status;
        super.toJSON(data);
        return data;
    }
}

/** A test clock enables deterministic control over objects in testmode. With a test clock, you can create objects at a frozen time in the past or future, and advance to a specific future time to observe webhooks and state changes. After the clock advances, you can either validate the current state of your scenario (and test your assumptions), change the current state of your scenario (and test more complex scenarios), or keep advancing forward in time. */
export interface ITestClock extends IStripeEntityOfTestClock {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** Whether this object is deleted or not. */
    deleted?: boolean | undefined;
    /** Time at which this clock is scheduled to auto delete. */
    deletesAfter?: Date;
    /** Time at which all objects belonging to this clock are frozen. */
    frozenTime?: Date;
    /** Has the value true if the object exists in live mode or the value false if
the object exists in test mode. */
    livemode?: boolean;
    /** The custom name supplied at creation. */
    name?: string | undefined;
    /** The status of the Test Clock.
One of: advancing, internal_failure, or ready. */
    status?: string | undefined;
}

/** Represents a generic expandable field. */
export class ExpandableFieldOfTestClock implements IExpandableFieldOfTestClock {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: TestClock | undefined;

    constructor(data?: IExpandableFieldOfTestClock) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.expandedObject = _data["expandedObject"] ? TestClock.fromJS(_data["expandedObject"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExpandableFieldOfTestClock {
        data = typeof data === 'object' ? data : {};
        let result = new ExpandableFieldOfTestClock();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["expandedObject"] = this.expandedObject ? this.expandedObject.toJSON() : <any>undefined;
        return data;
    }
}

/** Represents a generic expandable field. */
export interface IExpandableFieldOfTestClock {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: TestClock | undefined;
}

/** Represents a generic expandable field. */
export class ExpandableFieldOfSubscriptionSchedule implements IExpandableFieldOfSubscriptionSchedule {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: SubscriptionSchedule | undefined;

    constructor(data?: IExpandableFieldOfSubscriptionSchedule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.expandedObject = _data["expandedObject"] ? SubscriptionSchedule.fromJS(_data["expandedObject"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExpandableFieldOfSubscriptionSchedule {
        data = typeof data === 'object' ? data : {};
        let result = new ExpandableFieldOfSubscriptionSchedule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["expandedObject"] = this.expandedObject ? this.expandedObject.toJSON() : <any>undefined;
        return data;
    }
}

/** Represents a generic expandable field. */
export interface IExpandableFieldOfSubscriptionSchedule {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: SubscriptionSchedule | undefined;
}

export abstract class StripeEntityOfQuoteTotalDetails extends StripeEntity implements IStripeEntityOfQuoteTotalDetails {

    constructor(data?: IStripeEntityOfQuoteTotalDetails) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfQuoteTotalDetails {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfQuoteTotalDetails' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfQuoteTotalDetails extends IStripeEntity {
}

export class QuoteTotalDetails extends StripeEntityOfQuoteTotalDetails implements IQuoteTotalDetails {
    /** This is the sum of all the discounts. */
    amountDiscount?: number;
    /** This is the sum of all the shipping amounts. */
    amountShipping?: number | undefined;
    /** This is the sum of all the tax amounts. */
    amountTax?: number;
    breakdown?: QuoteTotalDetailsBreakdown | undefined;

    constructor(data?: IQuoteTotalDetails) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.amountDiscount = _data["amountDiscount"];
            this.amountShipping = _data["amountShipping"];
            this.amountTax = _data["amountTax"];
            this.breakdown = _data["breakdown"] ? QuoteTotalDetailsBreakdown.fromJS(_data["breakdown"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): QuoteTotalDetails {
        data = typeof data === 'object' ? data : {};
        let result = new QuoteTotalDetails();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amountDiscount"] = this.amountDiscount;
        data["amountShipping"] = this.amountShipping;
        data["amountTax"] = this.amountTax;
        data["breakdown"] = this.breakdown ? this.breakdown.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IQuoteTotalDetails extends IStripeEntityOfQuoteTotalDetails {
    /** This is the sum of all the discounts. */
    amountDiscount?: number;
    /** This is the sum of all the shipping amounts. */
    amountShipping?: number | undefined;
    /** This is the sum of all the tax amounts. */
    amountTax?: number;
    breakdown?: QuoteTotalDetailsBreakdown | undefined;
}

export abstract class StripeEntityOfQuoteTotalDetailsBreakdown extends StripeEntity implements IStripeEntityOfQuoteTotalDetailsBreakdown {

    constructor(data?: IStripeEntityOfQuoteTotalDetailsBreakdown) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfQuoteTotalDetailsBreakdown {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfQuoteTotalDetailsBreakdown' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfQuoteTotalDetailsBreakdown extends IStripeEntity {
}

export class QuoteTotalDetailsBreakdown extends StripeEntityOfQuoteTotalDetailsBreakdown implements IQuoteTotalDetailsBreakdown {
    /** The aggregated discounts. */
    discounts?: QuoteTotalDetailsBreakdownDiscount[] | undefined;
    /** The aggregated tax amounts by rate. */
    taxes?: QuoteTotalDetailsBreakdownTax[] | undefined;

    constructor(data?: IQuoteTotalDetailsBreakdown) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["discounts"])) {
                this.discounts = [] as any;
                for (let item of _data["discounts"])
                    this.discounts!.push(QuoteTotalDetailsBreakdownDiscount.fromJS(item));
            }
            if (Array.isArray(_data["taxes"])) {
                this.taxes = [] as any;
                for (let item of _data["taxes"])
                    this.taxes!.push(QuoteTotalDetailsBreakdownTax.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): QuoteTotalDetailsBreakdown {
        data = typeof data === 'object' ? data : {};
        let result = new QuoteTotalDetailsBreakdown();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.discounts)) {
            data["discounts"] = [];
            for (let item of this.discounts)
                data["discounts"].push(item.toJSON());
        }
        if (Array.isArray(this.taxes)) {
            data["taxes"] = [];
            for (let item of this.taxes)
                data["taxes"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IQuoteTotalDetailsBreakdown extends IStripeEntityOfQuoteTotalDetailsBreakdown {
    /** The aggregated discounts. */
    discounts?: QuoteTotalDetailsBreakdownDiscount[] | undefined;
    /** The aggregated tax amounts by rate. */
    taxes?: QuoteTotalDetailsBreakdownTax[] | undefined;
}

export abstract class StripeEntityOfQuoteTotalDetailsBreakdownDiscount extends StripeEntity implements IStripeEntityOfQuoteTotalDetailsBreakdownDiscount {

    constructor(data?: IStripeEntityOfQuoteTotalDetailsBreakdownDiscount) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfQuoteTotalDetailsBreakdownDiscount {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfQuoteTotalDetailsBreakdownDiscount' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfQuoteTotalDetailsBreakdownDiscount extends IStripeEntity {
}

export class QuoteTotalDetailsBreakdownDiscount extends StripeEntityOfQuoteTotalDetailsBreakdownDiscount implements IQuoteTotalDetailsBreakdownDiscount {
    /** The amount discounted. */
    amount?: number;
    /** A discount represents the actual application of a coupon or promotion code. It contains
information about when the discount began, when it will end, and what it is applied to.
            
Related guide: Applying discounts to
subscriptions. */
    discount?: Discount | undefined;

    constructor(data?: IQuoteTotalDetailsBreakdownDiscount) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.amount = _data["amount"];
            this.discount = _data["discount"] ? Discount.fromJS(_data["discount"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): QuoteTotalDetailsBreakdownDiscount {
        data = typeof data === 'object' ? data : {};
        let result = new QuoteTotalDetailsBreakdownDiscount();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["discount"] = this.discount ? this.discount.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IQuoteTotalDetailsBreakdownDiscount extends IStripeEntityOfQuoteTotalDetailsBreakdownDiscount {
    /** The amount discounted. */
    amount?: number;
    /** A discount represents the actual application of a coupon or promotion code. It contains
information about when the discount began, when it will end, and what it is applied to.
            
Related guide: Applying discounts to
subscriptions. */
    discount?: Discount | undefined;
}

export abstract class StripeEntityOfQuoteTotalDetailsBreakdownTax extends StripeEntity implements IStripeEntityOfQuoteTotalDetailsBreakdownTax {

    constructor(data?: IStripeEntityOfQuoteTotalDetailsBreakdownTax) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfQuoteTotalDetailsBreakdownTax {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfQuoteTotalDetailsBreakdownTax' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfQuoteTotalDetailsBreakdownTax extends IStripeEntity {
}

export class QuoteTotalDetailsBreakdownTax extends StripeEntityOfQuoteTotalDetailsBreakdownTax implements IQuoteTotalDetailsBreakdownTax {
    /** Amount of tax applied for this rate. */
    amount?: number;
    /** Tax rates can be applied to invoices, subscriptions and Checkout
Sessions to collect tax.
            
Related guide: Tax rates. */
    rate?: TaxRate | undefined;
    /** The reasoning behind this tax, for example, if the product is tax exempt. The possible
values for this field may be extended as new tax rules are supported.
One of: customer_exempt, excluded_territory,
jurisdiction_unsupported, not_collecting, not_subject_to_tax,
not_supported, portion_product_exempt, portion_reduced_rated,
portion_standard_rated, product_exempt, product_exempt_holiday,
proportionally_rated, reduced_rated, reverse_charge,
standard_rated, taxable_basis_reduced, vat_exempt, or
zero_rated. */
    taxabilityReason?: string | undefined;
    /** The amount on which tax is calculated, in %s. */
    taxableAmount?: number | undefined;

    constructor(data?: IQuoteTotalDetailsBreakdownTax) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.amount = _data["amount"];
            this.rate = _data["rate"] ? TaxRate.fromJS(_data["rate"]) : <any>undefined;
            this.taxabilityReason = _data["taxabilityReason"];
            this.taxableAmount = _data["taxableAmount"];
        }
    }

    static override fromJS(data: any): QuoteTotalDetailsBreakdownTax {
        data = typeof data === 'object' ? data : {};
        let result = new QuoteTotalDetailsBreakdownTax();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["rate"] = this.rate ? this.rate.toJSON() : <any>undefined;
        data["taxabilityReason"] = this.taxabilityReason;
        data["taxableAmount"] = this.taxableAmount;
        super.toJSON(data);
        return data;
    }
}

export interface IQuoteTotalDetailsBreakdownTax extends IStripeEntityOfQuoteTotalDetailsBreakdownTax {
    /** Amount of tax applied for this rate. */
    amount?: number;
    /** Tax rates can be applied to invoices, subscriptions and Checkout
Sessions to collect tax.
            
Related guide: Tax rates. */
    rate?: TaxRate | undefined;
    /** The reasoning behind this tax, for example, if the product is tax exempt. The possible
values for this field may be extended as new tax rules are supported.
One of: customer_exempt, excluded_territory,
jurisdiction_unsupported, not_collecting, not_subject_to_tax,
not_supported, portion_product_exempt, portion_reduced_rated,
portion_standard_rated, product_exempt, product_exempt_holiday,
proportionally_rated, reduced_rated, reverse_charge,
standard_rated, taxable_basis_reduced, vat_exempt, or
zero_rated. */
    taxabilityReason?: string | undefined;
    /** The amount on which tax is calculated, in %s. */
    taxableAmount?: number | undefined;
}

export abstract class StripeEntityOfQuoteTransferData extends StripeEntity implements IStripeEntityOfQuoteTransferData {

    constructor(data?: IStripeEntityOfQuoteTransferData) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfQuoteTransferData {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfQuoteTransferData' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfQuoteTransferData extends IStripeEntity {
}

export class QuoteTransferData extends StripeEntityOfQuoteTransferData implements IQuoteTransferData {
    /** The amount in %s that will be transferred to the destination account when the invoice is
paid. By default, the entire amount is transferred to the destination. */
    amount?: number | undefined;
    /** A non-negative decimal between 0 and 100, with at most two decimal places. This
represents the percentage of the subscription invoice subtotal that will be transferred
to the destination account. By default, the entire amount will be transferred to the
destination. */
    amountPercent?: number | undefined;
    /** (ID of the Account)
The account where funds from the payment will be transferred to upon payment success. */
    destinationId?: string | undefined;
    /** (Expanded)
The account where funds from the payment will be transferred to upon payment success.
            
For more information, see the expand documentation. */
    destination?: Account | undefined;
    internalDestination?: ExpandableFieldOfAccount | undefined;

    constructor(data?: IQuoteTransferData) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.amount = _data["amount"];
            this.amountPercent = _data["amountPercent"];
            this.destinationId = _data["destinationId"];
            this.destination = _data["destination"] ? Account.fromJS(_data["destination"]) : <any>undefined;
            this.internalDestination = _data["internalDestination"] ? ExpandableFieldOfAccount.fromJS(_data["internalDestination"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): QuoteTransferData {
        data = typeof data === 'object' ? data : {};
        let result = new QuoteTransferData();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["amountPercent"] = this.amountPercent;
        data["destinationId"] = this.destinationId;
        data["destination"] = this.destination ? this.destination.toJSON() : <any>undefined;
        data["internalDestination"] = this.internalDestination ? this.internalDestination.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IQuoteTransferData extends IStripeEntityOfQuoteTransferData {
    /** The amount in %s that will be transferred to the destination account when the invoice is
paid. By default, the entire amount is transferred to the destination. */
    amount?: number | undefined;
    /** A non-negative decimal between 0 and 100, with at most two decimal places. This
represents the percentage of the subscription invoice subtotal that will be transferred
to the destination account. By default, the entire amount will be transferred to the
destination. */
    amountPercent?: number | undefined;
    /** (ID of the Account)
The account where funds from the payment will be transferred to upon payment success. */
    destinationId?: string | undefined;
    /** (Expanded)
The account where funds from the payment will be transferred to upon payment success.
            
For more information, see the expand documentation. */
    destination?: Account | undefined;
    internalDestination?: ExpandableFieldOfAccount | undefined;
}

export abstract class StripeEntityOfInvoiceRenderingOptions extends StripeEntity implements IStripeEntityOfInvoiceRenderingOptions {

    constructor(data?: IStripeEntityOfInvoiceRenderingOptions) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfInvoiceRenderingOptions {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfInvoiceRenderingOptions' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfInvoiceRenderingOptions extends IStripeEntity {
}

export class InvoiceRenderingOptions extends StripeEntityOfInvoiceRenderingOptions implements IInvoiceRenderingOptions {
    /** How line-item prices and amounts will be displayed with respect to tax on invoice PDFs. */
    amountTaxDisplay?: string | undefined;

    constructor(data?: IInvoiceRenderingOptions) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.amountTaxDisplay = _data["amountTaxDisplay"];
        }
    }

    static override fromJS(data: any): InvoiceRenderingOptions {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceRenderingOptions();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amountTaxDisplay"] = this.amountTaxDisplay;
        super.toJSON(data);
        return data;
    }
}

export interface IInvoiceRenderingOptions extends IStripeEntityOfInvoiceRenderingOptions {
    /** How line-item prices and amounts will be displayed with respect to tax on invoice PDFs. */
    amountTaxDisplay?: string | undefined;
}

export abstract class StripeEntityOfInvoiceShippingCost extends StripeEntity implements IStripeEntityOfInvoiceShippingCost {

    constructor(data?: IStripeEntityOfInvoiceShippingCost) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfInvoiceShippingCost {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfInvoiceShippingCost' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfInvoiceShippingCost extends IStripeEntity {
}

export class InvoiceShippingCost extends StripeEntityOfInvoiceShippingCost implements IInvoiceShippingCost {
    /** Total shipping cost before any taxes are applied. */
    amountSubtotal?: number;
    /** Total tax amount applied due to shipping costs. If no tax was applied, defaults to 0. */
    amountTax?: number;
    /** Total shipping cost after taxes are applied. */
    amountTotal?: number;
    /** (ID of the ShippingRate)
The ID of the ShippingRate for this invoice. */
    shippingRateId?: string | undefined;
    /** (Expanded)
The ID of the ShippingRate for this invoice.
            
For more information, see the expand documentation. */
    shippingRate?: ShippingRate | undefined;
    internalShippingRate?: ExpandableFieldOfShippingRate | undefined;
    /** The taxes applied to the shipping rate. */
    taxes?: InvoiceShippingCostTax[] | undefined;

    constructor(data?: IInvoiceShippingCost) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.amountSubtotal = _data["amountSubtotal"];
            this.amountTax = _data["amountTax"];
            this.amountTotal = _data["amountTotal"];
            this.shippingRateId = _data["shippingRateId"];
            this.shippingRate = _data["shippingRate"] ? ShippingRate.fromJS(_data["shippingRate"]) : <any>undefined;
            this.internalShippingRate = _data["internalShippingRate"] ? ExpandableFieldOfShippingRate.fromJS(_data["internalShippingRate"]) : <any>undefined;
            if (Array.isArray(_data["taxes"])) {
                this.taxes = [] as any;
                for (let item of _data["taxes"])
                    this.taxes!.push(InvoiceShippingCostTax.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): InvoiceShippingCost {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceShippingCost();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amountSubtotal"] = this.amountSubtotal;
        data["amountTax"] = this.amountTax;
        data["amountTotal"] = this.amountTotal;
        data["shippingRateId"] = this.shippingRateId;
        data["shippingRate"] = this.shippingRate ? this.shippingRate.toJSON() : <any>undefined;
        data["internalShippingRate"] = this.internalShippingRate ? this.internalShippingRate.toJSON() : <any>undefined;
        if (Array.isArray(this.taxes)) {
            data["taxes"] = [];
            for (let item of this.taxes)
                data["taxes"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IInvoiceShippingCost extends IStripeEntityOfInvoiceShippingCost {
    /** Total shipping cost before any taxes are applied. */
    amountSubtotal?: number;
    /** Total tax amount applied due to shipping costs. If no tax was applied, defaults to 0. */
    amountTax?: number;
    /** Total shipping cost after taxes are applied. */
    amountTotal?: number;
    /** (ID of the ShippingRate)
The ID of the ShippingRate for this invoice. */
    shippingRateId?: string | undefined;
    /** (Expanded)
The ID of the ShippingRate for this invoice.
            
For more information, see the expand documentation. */
    shippingRate?: ShippingRate | undefined;
    internalShippingRate?: ExpandableFieldOfShippingRate | undefined;
    /** The taxes applied to the shipping rate. */
    taxes?: InvoiceShippingCostTax[] | undefined;
}

export abstract class StripeEntityOfShippingRate extends StripeEntity implements IStripeEntityOfShippingRate {

    constructor(data?: IStripeEntityOfShippingRate) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfShippingRate {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfShippingRate' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfShippingRate extends IStripeEntity {
}

/** Shipping rates describe the price of shipping presented to your customers and can be applied to Checkout Sessions and Orders to collect shipping costs. */
export class ShippingRate extends StripeEntityOfShippingRate implements IShippingRate {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** Whether the shipping rate can be used for new purchases. Defaults to true. */
    active?: boolean;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** The estimated range for how long shipping will take, meant to be displayable to the
customer. This will appear on CheckoutSessions. */
    deliveryEstimate?: ShippingRateDeliveryEstimate | undefined;
    /** The name of the shipping rate, meant to be displayable to the customer. This will appear
on CheckoutSessions. */
    displayName?: string | undefined;
    fixedAmount?: ShippingRateFixedAmount | undefined;
    /** Has the value true if the object exists in live mode or the value false if
the object exists in test mode. */
    livemode?: boolean;
    /** Set of key-value pairs that you can
attach to an object. This can be useful for storing additional information about the
object in a structured format. */
    metadata?: { [key: string]: string; } | undefined;
    /** Specifies whether the rate is considered inclusive of taxes or exclusive of taxes. One
of inclusive, exclusive, or unspecified.
One of: exclusive, inclusive, or unspecified. */
    taxBehavior?: string | undefined;
    /** (ID of the TaxCode)
A tax code ID. The Shipping tax
code is txcd_92010001. */
    taxCodeId?: string | undefined;
    /** (Expanded)
A tax code ID. The Shipping tax
code is txcd_92010001.
            
For more information, see the expand documentation. */
    taxCode?: TaxCode | undefined;
    internalTaxCode?: ExpandableFieldOfTaxCode | undefined;
    /** The type of calculation to use on the shipping rate. Can only be fixed_amount for
now. */
    type?: string | undefined;

    constructor(data?: IShippingRate) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.object = _data["object"];
            this.active = _data["active"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.deliveryEstimate = _data["deliveryEstimate"] ? ShippingRateDeliveryEstimate.fromJS(_data["deliveryEstimate"]) : <any>undefined;
            this.displayName = _data["displayName"];
            this.fixedAmount = _data["fixedAmount"] ? ShippingRateFixedAmount.fromJS(_data["fixedAmount"]) : <any>undefined;
            this.livemode = _data["livemode"];
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
            this.taxBehavior = _data["taxBehavior"];
            this.taxCodeId = _data["taxCodeId"];
            this.taxCode = _data["taxCode"] ? TaxCode.fromJS(_data["taxCode"]) : <any>undefined;
            this.internalTaxCode = _data["internalTaxCode"] ? ExpandableFieldOfTaxCode.fromJS(_data["internalTaxCode"]) : <any>undefined;
            this.type = _data["type"];
        }
    }

    static override fromJS(data: any): ShippingRate {
        data = typeof data === 'object' ? data : {};
        let result = new ShippingRate();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["object"] = this.object;
        data["active"] = this.active;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["deliveryEstimate"] = this.deliveryEstimate ? this.deliveryEstimate.toJSON() : <any>undefined;
        data["displayName"] = this.displayName;
        data["fixedAmount"] = this.fixedAmount ? this.fixedAmount.toJSON() : <any>undefined;
        data["livemode"] = this.livemode;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        data["taxBehavior"] = this.taxBehavior;
        data["taxCodeId"] = this.taxCodeId;
        data["taxCode"] = this.taxCode ? this.taxCode.toJSON() : <any>undefined;
        data["internalTaxCode"] = this.internalTaxCode ? this.internalTaxCode.toJSON() : <any>undefined;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** Shipping rates describe the price of shipping presented to your customers and can be applied to Checkout Sessions and Orders to collect shipping costs. */
export interface IShippingRate extends IStripeEntityOfShippingRate {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** Whether the shipping rate can be used for new purchases. Defaults to true. */
    active?: boolean;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** The estimated range for how long shipping will take, meant to be displayable to the
customer. This will appear on CheckoutSessions. */
    deliveryEstimate?: ShippingRateDeliveryEstimate | undefined;
    /** The name of the shipping rate, meant to be displayable to the customer. This will appear
on CheckoutSessions. */
    displayName?: string | undefined;
    fixedAmount?: ShippingRateFixedAmount | undefined;
    /** Has the value true if the object exists in live mode or the value false if
the object exists in test mode. */
    livemode?: boolean;
    /** Set of key-value pairs that you can
attach to an object. This can be useful for storing additional information about the
object in a structured format. */
    metadata?: { [key: string]: string; } | undefined;
    /** Specifies whether the rate is considered inclusive of taxes or exclusive of taxes. One
of inclusive, exclusive, or unspecified.
One of: exclusive, inclusive, or unspecified. */
    taxBehavior?: string | undefined;
    /** (ID of the TaxCode)
A tax code ID. The Shipping tax
code is txcd_92010001. */
    taxCodeId?: string | undefined;
    /** (Expanded)
A tax code ID. The Shipping tax
code is txcd_92010001.
            
For more information, see the expand documentation. */
    taxCode?: TaxCode | undefined;
    internalTaxCode?: ExpandableFieldOfTaxCode | undefined;
    /** The type of calculation to use on the shipping rate. Can only be fixed_amount for
now. */
    type?: string | undefined;
}

export abstract class StripeEntityOfShippingRateDeliveryEstimate extends StripeEntity implements IStripeEntityOfShippingRateDeliveryEstimate {

    constructor(data?: IStripeEntityOfShippingRateDeliveryEstimate) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfShippingRateDeliveryEstimate {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfShippingRateDeliveryEstimate' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfShippingRateDeliveryEstimate extends IStripeEntity {
}

export class ShippingRateDeliveryEstimate extends StripeEntityOfShippingRateDeliveryEstimate implements IShippingRateDeliveryEstimate {
    /** The upper bound of the estimated range. If empty, represents no upper bound i.e.,
infinite. */
    maximum?: ShippingRateDeliveryEstimateMaximum | undefined;
    /** The lower bound of the estimated range. If empty, represents no lower bound. */
    minimum?: ShippingRateDeliveryEstimateMinimum | undefined;

    constructor(data?: IShippingRateDeliveryEstimate) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.maximum = _data["maximum"] ? ShippingRateDeliveryEstimateMaximum.fromJS(_data["maximum"]) : <any>undefined;
            this.minimum = _data["minimum"] ? ShippingRateDeliveryEstimateMinimum.fromJS(_data["minimum"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): ShippingRateDeliveryEstimate {
        data = typeof data === 'object' ? data : {};
        let result = new ShippingRateDeliveryEstimate();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maximum"] = this.maximum ? this.maximum.toJSON() : <any>undefined;
        data["minimum"] = this.minimum ? this.minimum.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IShippingRateDeliveryEstimate extends IStripeEntityOfShippingRateDeliveryEstimate {
    /** The upper bound of the estimated range. If empty, represents no upper bound i.e.,
infinite. */
    maximum?: ShippingRateDeliveryEstimateMaximum | undefined;
    /** The lower bound of the estimated range. If empty, represents no lower bound. */
    minimum?: ShippingRateDeliveryEstimateMinimum | undefined;
}

export abstract class StripeEntityOfShippingRateDeliveryEstimateMaximum extends StripeEntity implements IStripeEntityOfShippingRateDeliveryEstimateMaximum {

    constructor(data?: IStripeEntityOfShippingRateDeliveryEstimateMaximum) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfShippingRateDeliveryEstimateMaximum {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfShippingRateDeliveryEstimateMaximum' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfShippingRateDeliveryEstimateMaximum extends IStripeEntity {
}

export class ShippingRateDeliveryEstimateMaximum extends StripeEntityOfShippingRateDeliveryEstimateMaximum implements IShippingRateDeliveryEstimateMaximum {
    /** A unit of time.
One of: business_day, day, hour, month, or week. */
    unit?: string | undefined;
    /** Must be greater than 0. */
    value?: number;

    constructor(data?: IShippingRateDeliveryEstimateMaximum) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.unit = _data["unit"];
            this.value = _data["value"];
        }
    }

    static override fromJS(data: any): ShippingRateDeliveryEstimateMaximum {
        data = typeof data === 'object' ? data : {};
        let result = new ShippingRateDeliveryEstimateMaximum();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unit"] = this.unit;
        data["value"] = this.value;
        super.toJSON(data);
        return data;
    }
}

export interface IShippingRateDeliveryEstimateMaximum extends IStripeEntityOfShippingRateDeliveryEstimateMaximum {
    /** A unit of time.
One of: business_day, day, hour, month, or week. */
    unit?: string | undefined;
    /** Must be greater than 0. */
    value?: number;
}

export abstract class StripeEntityOfShippingRateDeliveryEstimateMinimum extends StripeEntity implements IStripeEntityOfShippingRateDeliveryEstimateMinimum {

    constructor(data?: IStripeEntityOfShippingRateDeliveryEstimateMinimum) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfShippingRateDeliveryEstimateMinimum {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfShippingRateDeliveryEstimateMinimum' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfShippingRateDeliveryEstimateMinimum extends IStripeEntity {
}

export class ShippingRateDeliveryEstimateMinimum extends StripeEntityOfShippingRateDeliveryEstimateMinimum implements IShippingRateDeliveryEstimateMinimum {
    /** A unit of time.
One of: business_day, day, hour, month, or week. */
    unit?: string | undefined;
    /** Must be greater than 0. */
    value?: number;

    constructor(data?: IShippingRateDeliveryEstimateMinimum) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.unit = _data["unit"];
            this.value = _data["value"];
        }
    }

    static override fromJS(data: any): ShippingRateDeliveryEstimateMinimum {
        data = typeof data === 'object' ? data : {};
        let result = new ShippingRateDeliveryEstimateMinimum();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unit"] = this.unit;
        data["value"] = this.value;
        super.toJSON(data);
        return data;
    }
}

export interface IShippingRateDeliveryEstimateMinimum extends IStripeEntityOfShippingRateDeliveryEstimateMinimum {
    /** A unit of time.
One of: business_day, day, hour, month, or week. */
    unit?: string | undefined;
    /** Must be greater than 0. */
    value?: number;
}

export abstract class StripeEntityOfShippingRateFixedAmount extends StripeEntity implements IStripeEntityOfShippingRateFixedAmount {

    constructor(data?: IStripeEntityOfShippingRateFixedAmount) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfShippingRateFixedAmount {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfShippingRateFixedAmount' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfShippingRateFixedAmount extends IStripeEntity {
}

export class ShippingRateFixedAmount extends StripeEntityOfShippingRateFixedAmount implements IShippingRateFixedAmount {
    /** A non-negative integer in cents representing how much to charge. */
    amount?: number;
    /** Three-letter ISO currency
code, in lowercase. Must be a supported
currency. */
    currency?: string | undefined;
    /** Shipping rates defined in each available currency option. Each key must be a
three-letter ISO currency
code and a supported currency. */
    currencyOptions?: { [key: string]: ShippingRateFixedAmountCurrencyOptions; } | undefined;

    constructor(data?: IShippingRateFixedAmount) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.amount = _data["amount"];
            this.currency = _data["currency"];
            if (_data["currencyOptions"]) {
                this.currencyOptions = {} as any;
                for (let key in _data["currencyOptions"]) {
                    if (_data["currencyOptions"].hasOwnProperty(key))
                        (<any>this.currencyOptions)![key] = _data["currencyOptions"][key] ? ShippingRateFixedAmountCurrencyOptions.fromJS(_data["currencyOptions"][key]) : new ShippingRateFixedAmountCurrencyOptions();
                }
            }
        }
    }

    static override fromJS(data: any): ShippingRateFixedAmount {
        data = typeof data === 'object' ? data : {};
        let result = new ShippingRateFixedAmount();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["currency"] = this.currency;
        if (this.currencyOptions) {
            data["currencyOptions"] = {};
            for (let key in this.currencyOptions) {
                if (this.currencyOptions.hasOwnProperty(key))
                    (<any>data["currencyOptions"])[key] = this.currencyOptions[key] ? this.currencyOptions[key].toJSON() : <any>undefined;
            }
        }
        super.toJSON(data);
        return data;
    }
}

export interface IShippingRateFixedAmount extends IStripeEntityOfShippingRateFixedAmount {
    /** A non-negative integer in cents representing how much to charge. */
    amount?: number;
    /** Three-letter ISO currency
code, in lowercase. Must be a supported
currency. */
    currency?: string | undefined;
    /** Shipping rates defined in each available currency option. Each key must be a
three-letter ISO currency
code and a supported currency. */
    currencyOptions?: { [key: string]: ShippingRateFixedAmountCurrencyOptions; } | undefined;
}

export abstract class StripeEntityOfShippingRateFixedAmountCurrencyOptions extends StripeEntity implements IStripeEntityOfShippingRateFixedAmountCurrencyOptions {

    constructor(data?: IStripeEntityOfShippingRateFixedAmountCurrencyOptions) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfShippingRateFixedAmountCurrencyOptions {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfShippingRateFixedAmountCurrencyOptions' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfShippingRateFixedAmountCurrencyOptions extends IStripeEntity {
}

export class ShippingRateFixedAmountCurrencyOptions extends StripeEntityOfShippingRateFixedAmountCurrencyOptions implements IShippingRateFixedAmountCurrencyOptions {
    /** A non-negative integer in cents representing how much to charge. */
    amount?: number;
    /** Specifies whether the rate is considered inclusive of taxes or exclusive of taxes. One
of inclusive, exclusive, or unspecified.
One of: exclusive, inclusive, or unspecified. */
    taxBehavior?: string | undefined;

    constructor(data?: IShippingRateFixedAmountCurrencyOptions) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.amount = _data["amount"];
            this.taxBehavior = _data["taxBehavior"];
        }
    }

    static override fromJS(data: any): ShippingRateFixedAmountCurrencyOptions {
        data = typeof data === 'object' ? data : {};
        let result = new ShippingRateFixedAmountCurrencyOptions();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["taxBehavior"] = this.taxBehavior;
        super.toJSON(data);
        return data;
    }
}

export interface IShippingRateFixedAmountCurrencyOptions extends IStripeEntityOfShippingRateFixedAmountCurrencyOptions {
    /** A non-negative integer in cents representing how much to charge. */
    amount?: number;
    /** Specifies whether the rate is considered inclusive of taxes or exclusive of taxes. One
of inclusive, exclusive, or unspecified.
One of: exclusive, inclusive, or unspecified. */
    taxBehavior?: string | undefined;
}

/** Represents a generic expandable field. */
export class ExpandableFieldOfShippingRate implements IExpandableFieldOfShippingRate {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: ShippingRate | undefined;

    constructor(data?: IExpandableFieldOfShippingRate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.expandedObject = _data["expandedObject"] ? ShippingRate.fromJS(_data["expandedObject"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExpandableFieldOfShippingRate {
        data = typeof data === 'object' ? data : {};
        let result = new ExpandableFieldOfShippingRate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["expandedObject"] = this.expandedObject ? this.expandedObject.toJSON() : <any>undefined;
        return data;
    }
}

/** Represents a generic expandable field. */
export interface IExpandableFieldOfShippingRate {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: ShippingRate | undefined;
}

export abstract class StripeEntityOfInvoiceShippingCostTax extends StripeEntity implements IStripeEntityOfInvoiceShippingCostTax {

    constructor(data?: IStripeEntityOfInvoiceShippingCostTax) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfInvoiceShippingCostTax {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfInvoiceShippingCostTax' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfInvoiceShippingCostTax extends IStripeEntity {
}

export class InvoiceShippingCostTax extends StripeEntityOfInvoiceShippingCostTax implements IInvoiceShippingCostTax {
    /** Amount of tax applied for this rate. */
    amount?: number;
    /** Tax rates can be applied to invoices, subscriptions and Checkout
Sessions to collect tax.
            
Related guide: Tax rates. */
    rate?: TaxRate | undefined;
    /** The reasoning behind this tax, for example, if the product is tax exempt. The possible
values for this field may be extended as new tax rules are supported.
One of: customer_exempt, excluded_territory,
jurisdiction_unsupported, not_collecting, not_subject_to_tax,
not_supported, portion_product_exempt, portion_reduced_rated,
portion_standard_rated, product_exempt, product_exempt_holiday,
proportionally_rated, reduced_rated, reverse_charge,
standard_rated, taxable_basis_reduced, vat_exempt, or
zero_rated. */
    taxabilityReason?: string | undefined;
    /** The amount on which tax is calculated, in %s. */
    taxableAmount?: number | undefined;

    constructor(data?: IInvoiceShippingCostTax) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.amount = _data["amount"];
            this.rate = _data["rate"] ? TaxRate.fromJS(_data["rate"]) : <any>undefined;
            this.taxabilityReason = _data["taxabilityReason"];
            this.taxableAmount = _data["taxableAmount"];
        }
    }

    static override fromJS(data: any): InvoiceShippingCostTax {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceShippingCostTax();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["rate"] = this.rate ? this.rate.toJSON() : <any>undefined;
        data["taxabilityReason"] = this.taxabilityReason;
        data["taxableAmount"] = this.taxableAmount;
        super.toJSON(data);
        return data;
    }
}

export interface IInvoiceShippingCostTax extends IStripeEntityOfInvoiceShippingCostTax {
    /** Amount of tax applied for this rate. */
    amount?: number;
    /** Tax rates can be applied to invoices, subscriptions and Checkout
Sessions to collect tax.
            
Related guide: Tax rates. */
    rate?: TaxRate | undefined;
    /** The reasoning behind this tax, for example, if the product is tax exempt. The possible
values for this field may be extended as new tax rules are supported.
One of: customer_exempt, excluded_territory,
jurisdiction_unsupported, not_collecting, not_subject_to_tax,
not_supported, portion_product_exempt, portion_reduced_rated,
portion_standard_rated, product_exempt, product_exempt_holiday,
proportionally_rated, reduced_rated, reverse_charge,
standard_rated, taxable_basis_reduced, vat_exempt, or
zero_rated. */
    taxabilityReason?: string | undefined;
    /** The amount on which tax is calculated, in %s. */
    taxableAmount?: number | undefined;
}

export abstract class StripeEntityOfInvoiceShippingDetails extends StripeEntity implements IStripeEntityOfInvoiceShippingDetails {

    constructor(data?: IStripeEntityOfInvoiceShippingDetails) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfInvoiceShippingDetails {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfInvoiceShippingDetails' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfInvoiceShippingDetails extends IStripeEntity {
}

export class InvoiceShippingDetails extends StripeEntityOfInvoiceShippingDetails implements IInvoiceShippingDetails {
    address?: Address | undefined;
    /** The delivery service that shipped a physical product, such as Fedex, UPS, USPS, etc. */
    carrier?: string | undefined;
    /** Recipient name. */
    name?: string | undefined;
    /** Recipient phone (including extension). */
    phone?: string | undefined;
    /** The tracking number for a physical product, obtained from the delivery service. If
multiple tracking numbers were generated for this purchase, please separate them with
commas. */
    trackingNumber?: string | undefined;

    constructor(data?: IInvoiceShippingDetails) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.address = _data["address"] ? Address.fromJS(_data["address"]) : <any>undefined;
            this.carrier = _data["carrier"];
            this.name = _data["name"];
            this.phone = _data["phone"];
            this.trackingNumber = _data["trackingNumber"];
        }
    }

    static override fromJS(data: any): InvoiceShippingDetails {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceShippingDetails();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["carrier"] = this.carrier;
        data["name"] = this.name;
        data["phone"] = this.phone;
        data["trackingNumber"] = this.trackingNumber;
        super.toJSON(data);
        return data;
    }
}

export interface IInvoiceShippingDetails extends IStripeEntityOfInvoiceShippingDetails {
    address?: Address | undefined;
    /** The delivery service that shipped a physical product, such as Fedex, UPS, USPS, etc. */
    carrier?: string | undefined;
    /** Recipient name. */
    name?: string | undefined;
    /** Recipient phone (including extension). */
    phone?: string | undefined;
    /** The tracking number for a physical product, obtained from the delivery service. If
multiple tracking numbers were generated for this purchase, please separate them with
commas. */
    trackingNumber?: string | undefined;
}

export abstract class StripeEntityOfInvoiceStatusTransitions extends StripeEntity implements IStripeEntityOfInvoiceStatusTransitions {

    constructor(data?: IStripeEntityOfInvoiceStatusTransitions) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfInvoiceStatusTransitions {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfInvoiceStatusTransitions' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfInvoiceStatusTransitions extends IStripeEntity {
}

export class InvoiceStatusTransitions extends StripeEntityOfInvoiceStatusTransitions implements IInvoiceStatusTransitions {
    /** The time that the invoice draft was finalized. */
    finalizedAt?: Date | undefined;
    /** The time that the invoice was marked uncollectible. */
    markedUncollectibleAt?: Date | undefined;
    /** The time that the invoice was paid. */
    paidAt?: Date | undefined;
    /** The time that the invoice was voided. */
    voidedAt?: Date | undefined;

    constructor(data?: IInvoiceStatusTransitions) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.finalizedAt = _data["finalizedAt"] ? new Date(_data["finalizedAt"].toString()) : <any>undefined;
            this.markedUncollectibleAt = _data["markedUncollectibleAt"] ? new Date(_data["markedUncollectibleAt"].toString()) : <any>undefined;
            this.paidAt = _data["paidAt"] ? new Date(_data["paidAt"].toString()) : <any>undefined;
            this.voidedAt = _data["voidedAt"] ? new Date(_data["voidedAt"].toString()) : <any>undefined;
        }
    }

    static override fromJS(data: any): InvoiceStatusTransitions {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceStatusTransitions();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["finalizedAt"] = this.finalizedAt ? this.finalizedAt.toISOString() : <any>undefined;
        data["markedUncollectibleAt"] = this.markedUncollectibleAt ? this.markedUncollectibleAt.toISOString() : <any>undefined;
        data["paidAt"] = this.paidAt ? this.paidAt.toISOString() : <any>undefined;
        data["voidedAt"] = this.voidedAt ? this.voidedAt.toISOString() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IInvoiceStatusTransitions extends IStripeEntityOfInvoiceStatusTransitions {
    /** The time that the invoice draft was finalized. */
    finalizedAt?: Date | undefined;
    /** The time that the invoice was marked uncollectible. */
    markedUncollectibleAt?: Date | undefined;
    /** The time that the invoice was paid. */
    paidAt?: Date | undefined;
    /** The time that the invoice was voided. */
    voidedAt?: Date | undefined;
}

export abstract class StripeEntityOfInvoiceThresholdReason extends StripeEntity implements IStripeEntityOfInvoiceThresholdReason {

    constructor(data?: IStripeEntityOfInvoiceThresholdReason) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfInvoiceThresholdReason {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfInvoiceThresholdReason' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfInvoiceThresholdReason extends IStripeEntity {
}

export class InvoiceThresholdReason extends StripeEntityOfInvoiceThresholdReason implements IInvoiceThresholdReason {
    /** The total invoice amount threshold boundary if it triggered the threshold invoice. */
    amountGte?: number | undefined;
    /** Indicates which line items triggered a threshold invoice. */
    itemReasons?: InvoiceThresholdReasonItemReason[] | undefined;

    constructor(data?: IInvoiceThresholdReason) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.amountGte = _data["amountGte"];
            if (Array.isArray(_data["itemReasons"])) {
                this.itemReasons = [] as any;
                for (let item of _data["itemReasons"])
                    this.itemReasons!.push(InvoiceThresholdReasonItemReason.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): InvoiceThresholdReason {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceThresholdReason();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amountGte"] = this.amountGte;
        if (Array.isArray(this.itemReasons)) {
            data["itemReasons"] = [];
            for (let item of this.itemReasons)
                data["itemReasons"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IInvoiceThresholdReason extends IStripeEntityOfInvoiceThresholdReason {
    /** The total invoice amount threshold boundary if it triggered the threshold invoice. */
    amountGte?: number | undefined;
    /** Indicates which line items triggered a threshold invoice. */
    itemReasons?: InvoiceThresholdReasonItemReason[] | undefined;
}

export abstract class StripeEntityOfInvoiceThresholdReasonItemReason extends StripeEntity implements IStripeEntityOfInvoiceThresholdReasonItemReason {

    constructor(data?: IStripeEntityOfInvoiceThresholdReasonItemReason) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfInvoiceThresholdReasonItemReason {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfInvoiceThresholdReasonItemReason' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfInvoiceThresholdReasonItemReason extends IStripeEntity {
}

export class InvoiceThresholdReasonItemReason extends StripeEntityOfInvoiceThresholdReasonItemReason implements IInvoiceThresholdReasonItemReason {
    /** The IDs of the line items that triggered the threshold invoice. */
    lineItemIds?: string[] | undefined;
    /** The quantity threshold boundary that applied to the given line item. */
    usageGte?: number;

    constructor(data?: IInvoiceThresholdReasonItemReason) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["lineItemIds"])) {
                this.lineItemIds = [] as any;
                for (let item of _data["lineItemIds"])
                    this.lineItemIds!.push(item);
            }
            this.usageGte = _data["usageGte"];
        }
    }

    static override fromJS(data: any): InvoiceThresholdReasonItemReason {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceThresholdReasonItemReason();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.lineItemIds)) {
            data["lineItemIds"] = [];
            for (let item of this.lineItemIds)
                data["lineItemIds"].push(item);
        }
        data["usageGte"] = this.usageGte;
        super.toJSON(data);
        return data;
    }
}

export interface IInvoiceThresholdReasonItemReason extends IStripeEntityOfInvoiceThresholdReasonItemReason {
    /** The IDs of the line items that triggered the threshold invoice. */
    lineItemIds?: string[] | undefined;
    /** The quantity threshold boundary that applied to the given line item. */
    usageGte?: number;
}

export abstract class StripeEntityOfInvoiceDiscountAmount extends StripeEntity implements IStripeEntityOfInvoiceDiscountAmount {

    constructor(data?: IStripeEntityOfInvoiceDiscountAmount) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfInvoiceDiscountAmount {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfInvoiceDiscountAmount' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfInvoiceDiscountAmount extends IStripeEntity {
}

export class InvoiceDiscountAmount extends StripeEntityOfInvoiceDiscountAmount implements IInvoiceDiscountAmount {
    amount?: number;
    discountId?: string | undefined;
    discount?: Discount | undefined;
    internalDiscount?: ExpandableFieldOfDiscount | undefined;

    constructor(data?: IInvoiceDiscountAmount) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.amount = _data["amount"];
            this.discountId = _data["discountId"];
            this.discount = _data["discount"] ? Discount.fromJS(_data["discount"]) : <any>undefined;
            this.internalDiscount = _data["internalDiscount"] ? ExpandableFieldOfDiscount.fromJS(_data["internalDiscount"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): InvoiceDiscountAmount {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceDiscountAmount();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["discountId"] = this.discountId;
        data["discount"] = this.discount ? this.discount.toJSON() : <any>undefined;
        data["internalDiscount"] = this.internalDiscount ? this.internalDiscount.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IInvoiceDiscountAmount extends IStripeEntityOfInvoiceDiscountAmount {
    amount?: number;
    discountId?: string | undefined;
    discount?: Discount | undefined;
    internalDiscount?: ExpandableFieldOfDiscount | undefined;
}

export abstract class StripeEntityOfInvoiceTaxAmount extends StripeEntity implements IStripeEntityOfInvoiceTaxAmount {

    constructor(data?: IStripeEntityOfInvoiceTaxAmount) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfInvoiceTaxAmount {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfInvoiceTaxAmount' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfInvoiceTaxAmount extends IStripeEntity {
}

export class InvoiceTaxAmount extends StripeEntityOfInvoiceTaxAmount implements IInvoiceTaxAmount {
    amount?: number;
    inclusive?: boolean;
    taxRateId?: string | undefined;
    taxRate?: TaxRate | undefined;
    internalTaxRate?: ExpandableFieldOfTaxRate | undefined;

    constructor(data?: IInvoiceTaxAmount) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.amount = _data["amount"];
            this.inclusive = _data["inclusive"];
            this.taxRateId = _data["taxRateId"];
            this.taxRate = _data["taxRate"] ? TaxRate.fromJS(_data["taxRate"]) : <any>undefined;
            this.internalTaxRate = _data["internalTaxRate"] ? ExpandableFieldOfTaxRate.fromJS(_data["internalTaxRate"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): InvoiceTaxAmount {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceTaxAmount();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["inclusive"] = this.inclusive;
        data["taxRateId"] = this.taxRateId;
        data["taxRate"] = this.taxRate ? this.taxRate.toJSON() : <any>undefined;
        data["internalTaxRate"] = this.internalTaxRate ? this.internalTaxRate.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IInvoiceTaxAmount extends IStripeEntityOfInvoiceTaxAmount {
    amount?: number;
    inclusive?: boolean;
    taxRateId?: string | undefined;
    taxRate?: TaxRate | undefined;
    internalTaxRate?: ExpandableFieldOfTaxRate | undefined;
}

export abstract class StripeEntityOfInvoiceTransferData extends StripeEntity implements IStripeEntityOfInvoiceTransferData {

    constructor(data?: IStripeEntityOfInvoiceTransferData) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfInvoiceTransferData {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfInvoiceTransferData' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfInvoiceTransferData extends IStripeEntity {
}

export class InvoiceTransferData extends StripeEntityOfInvoiceTransferData implements IInvoiceTransferData {
    /** The amount in %s that will be transferred to the destination account when the invoice is
paid. By default, the entire amount is transferred to the destination. */
    amount?: number | undefined;
    /** (ID of the Account)
The account where funds from the payment will be transferred to upon payment success. */
    destinationId?: string | undefined;
    /** (Expanded)
The account where funds from the payment will be transferred to upon payment success.
            
For more information, see the expand documentation. */
    destination?: Account | undefined;
    internalDestination?: ExpandableFieldOfAccount | undefined;

    constructor(data?: IInvoiceTransferData) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.amount = _data["amount"];
            this.destinationId = _data["destinationId"];
            this.destination = _data["destination"] ? Account.fromJS(_data["destination"]) : <any>undefined;
            this.internalDestination = _data["internalDestination"] ? ExpandableFieldOfAccount.fromJS(_data["internalDestination"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): InvoiceTransferData {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceTransferData();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["destinationId"] = this.destinationId;
        data["destination"] = this.destination ? this.destination.toJSON() : <any>undefined;
        data["internalDestination"] = this.internalDestination ? this.internalDestination.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IInvoiceTransferData extends IStripeEntityOfInvoiceTransferData {
    /** The amount in %s that will be transferred to the destination account when the invoice is
paid. By default, the entire amount is transferred to the destination. */
    amount?: number | undefined;
    /** (ID of the Account)
The account where funds from the payment will be transferred to upon payment success. */
    destinationId?: string | undefined;
    /** (Expanded)
The account where funds from the payment will be transferred to upon payment success.
            
For more information, see the expand documentation. */
    destination?: Account | undefined;
    internalDestination?: ExpandableFieldOfAccount | undefined;
}

export abstract class StripeEntityOfPaymentIntentNextAction extends StripeEntity implements IStripeEntityOfPaymentIntentNextAction {

    constructor(data?: IStripeEntityOfPaymentIntentNextAction) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentNextAction {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentNextAction' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentNextAction extends IStripeEntity {
}

export class PaymentIntentNextAction extends StripeEntityOfPaymentIntentNextAction implements IPaymentIntentNextAction {
    alipayHandleRedirect?: PaymentIntentNextActionAlipayHandleRedirect | undefined;
    boletoDisplayDetails?: PaymentIntentNextActionBoletoDisplayDetails | undefined;
    cardAwaitNotification?: PaymentIntentNextActionCardAwaitNotification | undefined;
    cashappHandleRedirectOrDisplayQrCode?: PaymentIntentNextActionCashappHandleRedirectOrDisplayQrCode | undefined;
    displayBankTransferInstructions?: PaymentIntentNextActionDisplayBankTransferInstructions | undefined;
    konbiniDisplayDetails?: PaymentIntentNextActionKonbiniDisplayDetails | undefined;
    oxxoDisplayDetails?: PaymentIntentNextActionOxxoDisplayDetails | undefined;
    paynowDisplayQrCode?: PaymentIntentNextActionPaynowDisplayQrCode | undefined;
    pixDisplayQrCode?: PaymentIntentNextActionPixDisplayQrCode | undefined;
    promptpayDisplayQrCode?: PaymentIntentNextActionPromptpayDisplayQrCode | undefined;
    redirectToUrl?: PaymentIntentNextActionRedirectToUrl | undefined;
    /** Type of the next action to perform, one of redirect_to_url,
use_stripe_sdk, alipay_handle_redirect, oxxo_display_details, or
verify_with_microdeposits. */
    type?: string | undefined;
    verifyWithMicrodeposits?: PaymentIntentNextActionVerifyWithMicrodeposits | undefined;
    wechatPayDisplayQrCode?: PaymentIntentNextActionWechatPayDisplayQrCode | undefined;
    wechatPayRedirectToAndroidApp?: PaymentIntentNextActionWechatPayRedirectToAndroidApp | undefined;
    wechatPayRedirectToIosApp?: PaymentIntentNextActionWechatPayRedirectToIosApp | undefined;

    constructor(data?: IPaymentIntentNextAction) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.alipayHandleRedirect = _data["alipayHandleRedirect"] ? PaymentIntentNextActionAlipayHandleRedirect.fromJS(_data["alipayHandleRedirect"]) : <any>undefined;
            this.boletoDisplayDetails = _data["boletoDisplayDetails"] ? PaymentIntentNextActionBoletoDisplayDetails.fromJS(_data["boletoDisplayDetails"]) : <any>undefined;
            this.cardAwaitNotification = _data["cardAwaitNotification"] ? PaymentIntentNextActionCardAwaitNotification.fromJS(_data["cardAwaitNotification"]) : <any>undefined;
            this.cashappHandleRedirectOrDisplayQrCode = _data["cashappHandleRedirectOrDisplayQrCode"] ? PaymentIntentNextActionCashappHandleRedirectOrDisplayQrCode.fromJS(_data["cashappHandleRedirectOrDisplayQrCode"]) : <any>undefined;
            this.displayBankTransferInstructions = _data["displayBankTransferInstructions"] ? PaymentIntentNextActionDisplayBankTransferInstructions.fromJS(_data["displayBankTransferInstructions"]) : <any>undefined;
            this.konbiniDisplayDetails = _data["konbiniDisplayDetails"] ? PaymentIntentNextActionKonbiniDisplayDetails.fromJS(_data["konbiniDisplayDetails"]) : <any>undefined;
            this.oxxoDisplayDetails = _data["oxxoDisplayDetails"] ? PaymentIntentNextActionOxxoDisplayDetails.fromJS(_data["oxxoDisplayDetails"]) : <any>undefined;
            this.paynowDisplayQrCode = _data["paynowDisplayQrCode"] ? PaymentIntentNextActionPaynowDisplayQrCode.fromJS(_data["paynowDisplayQrCode"]) : <any>undefined;
            this.pixDisplayQrCode = _data["pixDisplayQrCode"] ? PaymentIntentNextActionPixDisplayQrCode.fromJS(_data["pixDisplayQrCode"]) : <any>undefined;
            this.promptpayDisplayQrCode = _data["promptpayDisplayQrCode"] ? PaymentIntentNextActionPromptpayDisplayQrCode.fromJS(_data["promptpayDisplayQrCode"]) : <any>undefined;
            this.redirectToUrl = _data["redirectToUrl"] ? PaymentIntentNextActionRedirectToUrl.fromJS(_data["redirectToUrl"]) : <any>undefined;
            this.type = _data["type"];
            this.verifyWithMicrodeposits = _data["verifyWithMicrodeposits"] ? PaymentIntentNextActionVerifyWithMicrodeposits.fromJS(_data["verifyWithMicrodeposits"]) : <any>undefined;
            this.wechatPayDisplayQrCode = _data["wechatPayDisplayQrCode"] ? PaymentIntentNextActionWechatPayDisplayQrCode.fromJS(_data["wechatPayDisplayQrCode"]) : <any>undefined;
            this.wechatPayRedirectToAndroidApp = _data["wechatPayRedirectToAndroidApp"] ? PaymentIntentNextActionWechatPayRedirectToAndroidApp.fromJS(_data["wechatPayRedirectToAndroidApp"]) : <any>undefined;
            this.wechatPayRedirectToIosApp = _data["wechatPayRedirectToIosApp"] ? PaymentIntentNextActionWechatPayRedirectToIosApp.fromJS(_data["wechatPayRedirectToIosApp"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): PaymentIntentNextAction {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentNextAction();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["alipayHandleRedirect"] = this.alipayHandleRedirect ? this.alipayHandleRedirect.toJSON() : <any>undefined;
        data["boletoDisplayDetails"] = this.boletoDisplayDetails ? this.boletoDisplayDetails.toJSON() : <any>undefined;
        data["cardAwaitNotification"] = this.cardAwaitNotification ? this.cardAwaitNotification.toJSON() : <any>undefined;
        data["cashappHandleRedirectOrDisplayQrCode"] = this.cashappHandleRedirectOrDisplayQrCode ? this.cashappHandleRedirectOrDisplayQrCode.toJSON() : <any>undefined;
        data["displayBankTransferInstructions"] = this.displayBankTransferInstructions ? this.displayBankTransferInstructions.toJSON() : <any>undefined;
        data["konbiniDisplayDetails"] = this.konbiniDisplayDetails ? this.konbiniDisplayDetails.toJSON() : <any>undefined;
        data["oxxoDisplayDetails"] = this.oxxoDisplayDetails ? this.oxxoDisplayDetails.toJSON() : <any>undefined;
        data["paynowDisplayQrCode"] = this.paynowDisplayQrCode ? this.paynowDisplayQrCode.toJSON() : <any>undefined;
        data["pixDisplayQrCode"] = this.pixDisplayQrCode ? this.pixDisplayQrCode.toJSON() : <any>undefined;
        data["promptpayDisplayQrCode"] = this.promptpayDisplayQrCode ? this.promptpayDisplayQrCode.toJSON() : <any>undefined;
        data["redirectToUrl"] = this.redirectToUrl ? this.redirectToUrl.toJSON() : <any>undefined;
        data["type"] = this.type;
        data["verifyWithMicrodeposits"] = this.verifyWithMicrodeposits ? this.verifyWithMicrodeposits.toJSON() : <any>undefined;
        data["wechatPayDisplayQrCode"] = this.wechatPayDisplayQrCode ? this.wechatPayDisplayQrCode.toJSON() : <any>undefined;
        data["wechatPayRedirectToAndroidApp"] = this.wechatPayRedirectToAndroidApp ? this.wechatPayRedirectToAndroidApp.toJSON() : <any>undefined;
        data["wechatPayRedirectToIosApp"] = this.wechatPayRedirectToIosApp ? this.wechatPayRedirectToIosApp.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentNextAction extends IStripeEntityOfPaymentIntentNextAction {
    alipayHandleRedirect?: PaymentIntentNextActionAlipayHandleRedirect | undefined;
    boletoDisplayDetails?: PaymentIntentNextActionBoletoDisplayDetails | undefined;
    cardAwaitNotification?: PaymentIntentNextActionCardAwaitNotification | undefined;
    cashappHandleRedirectOrDisplayQrCode?: PaymentIntentNextActionCashappHandleRedirectOrDisplayQrCode | undefined;
    displayBankTransferInstructions?: PaymentIntentNextActionDisplayBankTransferInstructions | undefined;
    konbiniDisplayDetails?: PaymentIntentNextActionKonbiniDisplayDetails | undefined;
    oxxoDisplayDetails?: PaymentIntentNextActionOxxoDisplayDetails | undefined;
    paynowDisplayQrCode?: PaymentIntentNextActionPaynowDisplayQrCode | undefined;
    pixDisplayQrCode?: PaymentIntentNextActionPixDisplayQrCode | undefined;
    promptpayDisplayQrCode?: PaymentIntentNextActionPromptpayDisplayQrCode | undefined;
    redirectToUrl?: PaymentIntentNextActionRedirectToUrl | undefined;
    /** Type of the next action to perform, one of redirect_to_url,
use_stripe_sdk, alipay_handle_redirect, oxxo_display_details, or
verify_with_microdeposits. */
    type?: string | undefined;
    verifyWithMicrodeposits?: PaymentIntentNextActionVerifyWithMicrodeposits | undefined;
    wechatPayDisplayQrCode?: PaymentIntentNextActionWechatPayDisplayQrCode | undefined;
    wechatPayRedirectToAndroidApp?: PaymentIntentNextActionWechatPayRedirectToAndroidApp | undefined;
    wechatPayRedirectToIosApp?: PaymentIntentNextActionWechatPayRedirectToIosApp | undefined;
}

export abstract class StripeEntityOfPaymentIntentNextActionAlipayHandleRedirect extends StripeEntity implements IStripeEntityOfPaymentIntentNextActionAlipayHandleRedirect {

    constructor(data?: IStripeEntityOfPaymentIntentNextActionAlipayHandleRedirect) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentNextActionAlipayHandleRedirect {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentNextActionAlipayHandleRedirect' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentNextActionAlipayHandleRedirect extends IStripeEntity {
}

export class PaymentIntentNextActionAlipayHandleRedirect extends StripeEntityOfPaymentIntentNextActionAlipayHandleRedirect implements IPaymentIntentNextActionAlipayHandleRedirect {
    /** The native data to be used with Alipay SDK you must redirect your customer to in order
to authenticate the payment in an Android App. */
    nativeData?: string | undefined;
    /** The native URL you must redirect your customer to in order to authenticate the payment
in an iOS App. */
    nativeUrl?: string | undefined;
    /** If the customer does not exit their browser while authenticating, they will be
redirected to this specified URL after completion. */
    returnUrl?: string | undefined;
    /** The URL you must redirect your customer to in order to authenticate the payment. */
    url?: string | undefined;

    constructor(data?: IPaymentIntentNextActionAlipayHandleRedirect) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.nativeData = _data["nativeData"];
            this.nativeUrl = _data["nativeUrl"];
            this.returnUrl = _data["returnUrl"];
            this.url = _data["url"];
        }
    }

    static override fromJS(data: any): PaymentIntentNextActionAlipayHandleRedirect {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentNextActionAlipayHandleRedirect();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nativeData"] = this.nativeData;
        data["nativeUrl"] = this.nativeUrl;
        data["returnUrl"] = this.returnUrl;
        data["url"] = this.url;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentNextActionAlipayHandleRedirect extends IStripeEntityOfPaymentIntentNextActionAlipayHandleRedirect {
    /** The native data to be used with Alipay SDK you must redirect your customer to in order
to authenticate the payment in an Android App. */
    nativeData?: string | undefined;
    /** The native URL you must redirect your customer to in order to authenticate the payment
in an iOS App. */
    nativeUrl?: string | undefined;
    /** If the customer does not exit their browser while authenticating, they will be
redirected to this specified URL after completion. */
    returnUrl?: string | undefined;
    /** The URL you must redirect your customer to in order to authenticate the payment. */
    url?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentNextActionBoletoDisplayDetails extends StripeEntity implements IStripeEntityOfPaymentIntentNextActionBoletoDisplayDetails {

    constructor(data?: IStripeEntityOfPaymentIntentNextActionBoletoDisplayDetails) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentNextActionBoletoDisplayDetails {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentNextActionBoletoDisplayDetails' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentNextActionBoletoDisplayDetails extends IStripeEntity {
}

export class PaymentIntentNextActionBoletoDisplayDetails extends StripeEntityOfPaymentIntentNextActionBoletoDisplayDetails implements IPaymentIntentNextActionBoletoDisplayDetails {
    /** The timestamp after which the boleto expires. */
    expiresAt?: Date | undefined;
    /** The URL to the hosted boleto voucher page, which allows customers to view the boleto
voucher. */
    hostedVoucherUrl?: string | undefined;
    /** The boleto number. */
    number?: string | undefined;
    /** The URL to the downloadable boleto voucher PDF. */
    pdf?: string | undefined;

    constructor(data?: IPaymentIntentNextActionBoletoDisplayDetails) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.expiresAt = _data["expiresAt"] ? new Date(_data["expiresAt"].toString()) : <any>undefined;
            this.hostedVoucherUrl = _data["hostedVoucherUrl"];
            this.number = _data["number"];
            this.pdf = _data["pdf"];
        }
    }

    static override fromJS(data: any): PaymentIntentNextActionBoletoDisplayDetails {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentNextActionBoletoDisplayDetails();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expiresAt"] = this.expiresAt ? this.expiresAt.toISOString() : <any>undefined;
        data["hostedVoucherUrl"] = this.hostedVoucherUrl;
        data["number"] = this.number;
        data["pdf"] = this.pdf;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentNextActionBoletoDisplayDetails extends IStripeEntityOfPaymentIntentNextActionBoletoDisplayDetails {
    /** The timestamp after which the boleto expires. */
    expiresAt?: Date | undefined;
    /** The URL to the hosted boleto voucher page, which allows customers to view the boleto
voucher. */
    hostedVoucherUrl?: string | undefined;
    /** The boleto number. */
    number?: string | undefined;
    /** The URL to the downloadable boleto voucher PDF. */
    pdf?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentNextActionCardAwaitNotification extends StripeEntity implements IStripeEntityOfPaymentIntentNextActionCardAwaitNotification {

    constructor(data?: IStripeEntityOfPaymentIntentNextActionCardAwaitNotification) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentNextActionCardAwaitNotification {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentNextActionCardAwaitNotification' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentNextActionCardAwaitNotification extends IStripeEntity {
}

export class PaymentIntentNextActionCardAwaitNotification extends StripeEntityOfPaymentIntentNextActionCardAwaitNotification implements IPaymentIntentNextActionCardAwaitNotification {
    /** The time that payment will be attempted. If customer approval is required, they need to
provide approval before this time. */
    chargeAttemptAt?: Date | undefined;
    /** For payments greater than INR 15000, the customer must provide explicit approval of the
payment with their bank. For payments of lower amount, no customer action is required. */
    customerApprovalRequired?: boolean | undefined;

    constructor(data?: IPaymentIntentNextActionCardAwaitNotification) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.chargeAttemptAt = _data["chargeAttemptAt"] ? new Date(_data["chargeAttemptAt"].toString()) : <any>undefined;
            this.customerApprovalRequired = _data["customerApprovalRequired"];
        }
    }

    static override fromJS(data: any): PaymentIntentNextActionCardAwaitNotification {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentNextActionCardAwaitNotification();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["chargeAttemptAt"] = this.chargeAttemptAt ? this.chargeAttemptAt.toISOString() : <any>undefined;
        data["customerApprovalRequired"] = this.customerApprovalRequired;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentNextActionCardAwaitNotification extends IStripeEntityOfPaymentIntentNextActionCardAwaitNotification {
    /** The time that payment will be attempted. If customer approval is required, they need to
provide approval before this time. */
    chargeAttemptAt?: Date | undefined;
    /** For payments greater than INR 15000, the customer must provide explicit approval of the
payment with their bank. For payments of lower amount, no customer action is required. */
    customerApprovalRequired?: boolean | undefined;
}

export abstract class StripeEntityOfPaymentIntentNextActionCashappHandleRedirectOrDisplayQrCode extends StripeEntity implements IStripeEntityOfPaymentIntentNextActionCashappHandleRedirectOrDisplayQrCode {

    constructor(data?: IStripeEntityOfPaymentIntentNextActionCashappHandleRedirectOrDisplayQrCode) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentNextActionCashappHandleRedirectOrDisplayQrCode {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentNextActionCashappHandleRedirectOrDisplayQrCode' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentNextActionCashappHandleRedirectOrDisplayQrCode extends IStripeEntity {
}

export class PaymentIntentNextActionCashappHandleRedirectOrDisplayQrCode extends StripeEntityOfPaymentIntentNextActionCashappHandleRedirectOrDisplayQrCode implements IPaymentIntentNextActionCashappHandleRedirectOrDisplayQrCode {
    /** The URL to the hosted Cash App Pay instructions page, which allows customers to view the
QR code, and supports QR code refreshing on expiration. */
    hostedInstructionsUrl?: string | undefined;
    /** The url for mobile redirect based auth. */
    mobileAuthUrl?: string | undefined;
    qrCode?: PaymentIntentNextActionCashappHandleRedirectOrDisplayQrCodeQrCode | undefined;

    constructor(data?: IPaymentIntentNextActionCashappHandleRedirectOrDisplayQrCode) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.hostedInstructionsUrl = _data["hostedInstructionsUrl"];
            this.mobileAuthUrl = _data["mobileAuthUrl"];
            this.qrCode = _data["qrCode"] ? PaymentIntentNextActionCashappHandleRedirectOrDisplayQrCodeQrCode.fromJS(_data["qrCode"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): PaymentIntentNextActionCashappHandleRedirectOrDisplayQrCode {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentNextActionCashappHandleRedirectOrDisplayQrCode();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hostedInstructionsUrl"] = this.hostedInstructionsUrl;
        data["mobileAuthUrl"] = this.mobileAuthUrl;
        data["qrCode"] = this.qrCode ? this.qrCode.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentNextActionCashappHandleRedirectOrDisplayQrCode extends IStripeEntityOfPaymentIntentNextActionCashappHandleRedirectOrDisplayQrCode {
    /** The URL to the hosted Cash App Pay instructions page, which allows customers to view the
QR code, and supports QR code refreshing on expiration. */
    hostedInstructionsUrl?: string | undefined;
    /** The url for mobile redirect based auth. */
    mobileAuthUrl?: string | undefined;
    qrCode?: PaymentIntentNextActionCashappHandleRedirectOrDisplayQrCodeQrCode | undefined;
}

export abstract class StripeEntityOfPaymentIntentNextActionCashappHandleRedirectOrDisplayQrCodeQrCode extends StripeEntity implements IStripeEntityOfPaymentIntentNextActionCashappHandleRedirectOrDisplayQrCodeQrCode {

    constructor(data?: IStripeEntityOfPaymentIntentNextActionCashappHandleRedirectOrDisplayQrCodeQrCode) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentNextActionCashappHandleRedirectOrDisplayQrCodeQrCode {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentNextActionCashappHandleRedirectOrDisplayQrCodeQrCode' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentNextActionCashappHandleRedirectOrDisplayQrCodeQrCode extends IStripeEntity {
}

export class PaymentIntentNextActionCashappHandleRedirectOrDisplayQrCodeQrCode extends StripeEntityOfPaymentIntentNextActionCashappHandleRedirectOrDisplayQrCodeQrCode implements IPaymentIntentNextActionCashappHandleRedirectOrDisplayQrCodeQrCode {
    /** The date (unix timestamp) when the QR code expires. */
    expiresAt?: Date;
    /** The image_url_png string used to render QR code. */
    imageUrlPng?: string | undefined;
    /** The image_url_svg string used to render QR code. */
    imageUrlSvg?: string | undefined;

    constructor(data?: IPaymentIntentNextActionCashappHandleRedirectOrDisplayQrCodeQrCode) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.expiresAt = _data["expiresAt"] ? new Date(_data["expiresAt"].toString()) : <any>undefined;
            this.imageUrlPng = _data["imageUrlPng"];
            this.imageUrlSvg = _data["imageUrlSvg"];
        }
    }

    static override fromJS(data: any): PaymentIntentNextActionCashappHandleRedirectOrDisplayQrCodeQrCode {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentNextActionCashappHandleRedirectOrDisplayQrCodeQrCode();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expiresAt"] = this.expiresAt ? this.expiresAt.toISOString() : <any>undefined;
        data["imageUrlPng"] = this.imageUrlPng;
        data["imageUrlSvg"] = this.imageUrlSvg;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentNextActionCashappHandleRedirectOrDisplayQrCodeQrCode extends IStripeEntityOfPaymentIntentNextActionCashappHandleRedirectOrDisplayQrCodeQrCode {
    /** The date (unix timestamp) when the QR code expires. */
    expiresAt?: Date;
    /** The image_url_png string used to render QR code. */
    imageUrlPng?: string | undefined;
    /** The image_url_svg string used to render QR code. */
    imageUrlSvg?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentNextActionDisplayBankTransferInstructions extends StripeEntity implements IStripeEntityOfPaymentIntentNextActionDisplayBankTransferInstructions {

    constructor(data?: IStripeEntityOfPaymentIntentNextActionDisplayBankTransferInstructions) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentNextActionDisplayBankTransferInstructions {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentNextActionDisplayBankTransferInstructions' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentNextActionDisplayBankTransferInstructions extends IStripeEntity {
}

export class PaymentIntentNextActionDisplayBankTransferInstructions extends StripeEntityOfPaymentIntentNextActionDisplayBankTransferInstructions implements IPaymentIntentNextActionDisplayBankTransferInstructions {
    /** The remaining amount that needs to be transferred to complete the payment. */
    amountRemaining?: number | undefined;
    /** Three-letter ISO currency
code, in lowercase. Must be a supported
currency. */
    currency?: string | undefined;
    /** A list of financial addresses that can be used to fund the customer balance. */
    financialAddresses?: PaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddress[] | undefined;
    /** A link to a hosted page that guides your customer through completing the transfer. */
    hostedInstructionsUrl?: string | undefined;
    /** A string identifying this payment. Instruct your customer to include this code in the
reference or memo field of their bank transfer. */
    reference?: string | undefined;
    /** Type of bank transfer.
One of: eu_bank_transfer, gb_bank_transfer, jp_bank_transfer, or
mx_bank_transfer. */
    type?: string | undefined;

    constructor(data?: IPaymentIntentNextActionDisplayBankTransferInstructions) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.amountRemaining = _data["amountRemaining"];
            this.currency = _data["currency"];
            if (Array.isArray(_data["financialAddresses"])) {
                this.financialAddresses = [] as any;
                for (let item of _data["financialAddresses"])
                    this.financialAddresses!.push(PaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddress.fromJS(item));
            }
            this.hostedInstructionsUrl = _data["hostedInstructionsUrl"];
            this.reference = _data["reference"];
            this.type = _data["type"];
        }
    }

    static override fromJS(data: any): PaymentIntentNextActionDisplayBankTransferInstructions {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentNextActionDisplayBankTransferInstructions();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amountRemaining"] = this.amountRemaining;
        data["currency"] = this.currency;
        if (Array.isArray(this.financialAddresses)) {
            data["financialAddresses"] = [];
            for (let item of this.financialAddresses)
                data["financialAddresses"].push(item.toJSON());
        }
        data["hostedInstructionsUrl"] = this.hostedInstructionsUrl;
        data["reference"] = this.reference;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentNextActionDisplayBankTransferInstructions extends IStripeEntityOfPaymentIntentNextActionDisplayBankTransferInstructions {
    /** The remaining amount that needs to be transferred to complete the payment. */
    amountRemaining?: number | undefined;
    /** Three-letter ISO currency
code, in lowercase. Must be a supported
currency. */
    currency?: string | undefined;
    /** A list of financial addresses that can be used to fund the customer balance. */
    financialAddresses?: PaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddress[] | undefined;
    /** A link to a hosted page that guides your customer through completing the transfer. */
    hostedInstructionsUrl?: string | undefined;
    /** A string identifying this payment. Instruct your customer to include this code in the
reference or memo field of their bank transfer. */
    reference?: string | undefined;
    /** Type of bank transfer.
One of: eu_bank_transfer, gb_bank_transfer, jp_bank_transfer, or
mx_bank_transfer. */
    type?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddress extends StripeEntity implements IStripeEntityOfPaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddress {

    constructor(data?: IStripeEntityOfPaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddress) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddress {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddress' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddress extends IStripeEntity {
}

export class PaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddress extends StripeEntityOfPaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddress implements IPaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddress {
    /** Iban Records contain E.U. bank account details per the SEPA format. */
    iban?: PaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressIban | undefined;
    /** Sort Code Records contain U.K. bank account details per the sort code format. */
    sortCode?: PaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressSortCode | undefined;
    /** SPEI Records contain Mexico bank account details per the SPEI format. */
    spei?: PaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressSpei | undefined;
    /** The payment networks supported by this FinancialAddress. */
    supportedNetworks?: string[] | undefined;
    /** The type of financial address.
One of: iban, sort_code, spei, or zengin. */
    type?: string | undefined;
    /** Zengin Records contain Japan bank account details per the Zengin format. */
    zengin?: PaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressZengin | undefined;

    constructor(data?: IPaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddress) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.iban = _data["iban"] ? PaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressIban.fromJS(_data["iban"]) : <any>undefined;
            this.sortCode = _data["sortCode"] ? PaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressSortCode.fromJS(_data["sortCode"]) : <any>undefined;
            this.spei = _data["spei"] ? PaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressSpei.fromJS(_data["spei"]) : <any>undefined;
            if (Array.isArray(_data["supportedNetworks"])) {
                this.supportedNetworks = [] as any;
                for (let item of _data["supportedNetworks"])
                    this.supportedNetworks!.push(item);
            }
            this.type = _data["type"];
            this.zengin = _data["zengin"] ? PaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressZengin.fromJS(_data["zengin"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): PaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddress {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddress();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["iban"] = this.iban ? this.iban.toJSON() : <any>undefined;
        data["sortCode"] = this.sortCode ? this.sortCode.toJSON() : <any>undefined;
        data["spei"] = this.spei ? this.spei.toJSON() : <any>undefined;
        if (Array.isArray(this.supportedNetworks)) {
            data["supportedNetworks"] = [];
            for (let item of this.supportedNetworks)
                data["supportedNetworks"].push(item);
        }
        data["type"] = this.type;
        data["zengin"] = this.zengin ? this.zengin.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddress extends IStripeEntityOfPaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddress {
    /** Iban Records contain E.U. bank account details per the SEPA format. */
    iban?: PaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressIban | undefined;
    /** Sort Code Records contain U.K. bank account details per the sort code format. */
    sortCode?: PaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressSortCode | undefined;
    /** SPEI Records contain Mexico bank account details per the SPEI format. */
    spei?: PaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressSpei | undefined;
    /** The payment networks supported by this FinancialAddress. */
    supportedNetworks?: string[] | undefined;
    /** The type of financial address.
One of: iban, sort_code, spei, or zengin. */
    type?: string | undefined;
    /** Zengin Records contain Japan bank account details per the Zengin format. */
    zengin?: PaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressZengin | undefined;
}

export abstract class StripeEntityOfPaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressIban extends StripeEntity implements IStripeEntityOfPaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressIban {

    constructor(data?: IStripeEntityOfPaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressIban) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressIban {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressIban' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressIban extends IStripeEntity {
}

export class PaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressIban extends StripeEntityOfPaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressIban implements IPaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressIban {
    /** The name of the person or business that owns the bank account. */
    accountHolderName?: string | undefined;
    /** The BIC/SWIFT code of the account. */
    bic?: string | undefined;
    /** Two-letter country code (ISO
3166-1 alpha-2). */
    country?: string | undefined;
    /** The IBAN of the account. */
    iban?: string | undefined;

    constructor(data?: IPaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressIban) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.accountHolderName = _data["accountHolderName"];
            this.bic = _data["bic"];
            this.country = _data["country"];
            this.iban = _data["iban"];
        }
    }

    static override fromJS(data: any): PaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressIban {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressIban();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountHolderName"] = this.accountHolderName;
        data["bic"] = this.bic;
        data["country"] = this.country;
        data["iban"] = this.iban;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressIban extends IStripeEntityOfPaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressIban {
    /** The name of the person or business that owns the bank account. */
    accountHolderName?: string | undefined;
    /** The BIC/SWIFT code of the account. */
    bic?: string | undefined;
    /** Two-letter country code (ISO
3166-1 alpha-2). */
    country?: string | undefined;
    /** The IBAN of the account. */
    iban?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressSortCode extends StripeEntity implements IStripeEntityOfPaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressSortCode {

    constructor(data?: IStripeEntityOfPaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressSortCode) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressSortCode {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressSortCode' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressSortCode extends IStripeEntity {
}

export class PaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressSortCode extends StripeEntityOfPaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressSortCode implements IPaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressSortCode {
    /** The name of the person or business that owns the bank account. */
    accountHolderName?: string | undefined;
    /** The account number. */
    accountNumber?: string | undefined;
    /** The six-digit sort code. */
    sortCode?: string | undefined;

    constructor(data?: IPaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressSortCode) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.accountHolderName = _data["accountHolderName"];
            this.accountNumber = _data["accountNumber"];
            this.sortCode = _data["sortCode"];
        }
    }

    static override fromJS(data: any): PaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressSortCode {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressSortCode();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountHolderName"] = this.accountHolderName;
        data["accountNumber"] = this.accountNumber;
        data["sortCode"] = this.sortCode;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressSortCode extends IStripeEntityOfPaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressSortCode {
    /** The name of the person or business that owns the bank account. */
    accountHolderName?: string | undefined;
    /** The account number. */
    accountNumber?: string | undefined;
    /** The six-digit sort code. */
    sortCode?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressSpei extends StripeEntity implements IStripeEntityOfPaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressSpei {

    constructor(data?: IStripeEntityOfPaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressSpei) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressSpei {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressSpei' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressSpei extends IStripeEntity {
}

export class PaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressSpei extends StripeEntityOfPaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressSpei implements IPaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressSpei {
    /** The three-digit bank code. */
    bankCode?: string | undefined;
    /** The short banking institution name. */
    bankName?: string | undefined;
    /** The CLABE number. */
    clabe?: string | undefined;

    constructor(data?: IPaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressSpei) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.bankCode = _data["bankCode"];
            this.bankName = _data["bankName"];
            this.clabe = _data["clabe"];
        }
    }

    static override fromJS(data: any): PaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressSpei {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressSpei();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankCode"] = this.bankCode;
        data["bankName"] = this.bankName;
        data["clabe"] = this.clabe;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressSpei extends IStripeEntityOfPaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressSpei {
    /** The three-digit bank code. */
    bankCode?: string | undefined;
    /** The short banking institution name. */
    bankName?: string | undefined;
    /** The CLABE number. */
    clabe?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressZengin extends StripeEntity implements IStripeEntityOfPaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressZengin {

    constructor(data?: IStripeEntityOfPaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressZengin) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressZengin {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressZengin' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressZengin extends IStripeEntity {
}

export class PaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressZengin extends StripeEntityOfPaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressZengin implements IPaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressZengin {
    /** The account holder name. */
    accountHolderName?: string | undefined;
    /** The account number. */
    accountNumber?: string | undefined;
    /** The bank account type. In Japan, this can only be futsu or toza. */
    accountType?: string | undefined;
    /** The bank code of the account. */
    bankCode?: string | undefined;
    /** The bank name of the account. */
    bankName?: string | undefined;
    /** The branch code of the account. */
    branchCode?: string | undefined;
    /** The branch name of the account. */
    branchName?: string | undefined;

    constructor(data?: IPaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressZengin) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.accountHolderName = _data["accountHolderName"];
            this.accountNumber = _data["accountNumber"];
            this.accountType = _data["accountType"];
            this.bankCode = _data["bankCode"];
            this.bankName = _data["bankName"];
            this.branchCode = _data["branchCode"];
            this.branchName = _data["branchName"];
        }
    }

    static override fromJS(data: any): PaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressZengin {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressZengin();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountHolderName"] = this.accountHolderName;
        data["accountNumber"] = this.accountNumber;
        data["accountType"] = this.accountType;
        data["bankCode"] = this.bankCode;
        data["bankName"] = this.bankName;
        data["branchCode"] = this.branchCode;
        data["branchName"] = this.branchName;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressZengin extends IStripeEntityOfPaymentIntentNextActionDisplayBankTransferInstructionsFinancialAddressZengin {
    /** The account holder name. */
    accountHolderName?: string | undefined;
    /** The account number. */
    accountNumber?: string | undefined;
    /** The bank account type. In Japan, this can only be futsu or toza. */
    accountType?: string | undefined;
    /** The bank code of the account. */
    bankCode?: string | undefined;
    /** The bank name of the account. */
    bankName?: string | undefined;
    /** The branch code of the account. */
    branchCode?: string | undefined;
    /** The branch name of the account. */
    branchName?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentNextActionKonbiniDisplayDetails extends StripeEntity implements IStripeEntityOfPaymentIntentNextActionKonbiniDisplayDetails {

    constructor(data?: IStripeEntityOfPaymentIntentNextActionKonbiniDisplayDetails) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentNextActionKonbiniDisplayDetails {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentNextActionKonbiniDisplayDetails' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentNextActionKonbiniDisplayDetails extends IStripeEntity {
}

export class PaymentIntentNextActionKonbiniDisplayDetails extends StripeEntityOfPaymentIntentNextActionKonbiniDisplayDetails implements IPaymentIntentNextActionKonbiniDisplayDetails {
    /** The timestamp at which the pending Konbini payment expires. */
    expiresAt?: Date;
    /** The URL for the Konbini payment instructions page, which allows customers to view and
print a Konbini voucher. */
    hostedVoucherUrl?: string | undefined;
    stores?: PaymentIntentNextActionKonbiniDisplayDetailsStores | undefined;

    constructor(data?: IPaymentIntentNextActionKonbiniDisplayDetails) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.expiresAt = _data["expiresAt"] ? new Date(_data["expiresAt"].toString()) : <any>undefined;
            this.hostedVoucherUrl = _data["hostedVoucherUrl"];
            this.stores = _data["stores"] ? PaymentIntentNextActionKonbiniDisplayDetailsStores.fromJS(_data["stores"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): PaymentIntentNextActionKonbiniDisplayDetails {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentNextActionKonbiniDisplayDetails();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expiresAt"] = this.expiresAt ? this.expiresAt.toISOString() : <any>undefined;
        data["hostedVoucherUrl"] = this.hostedVoucherUrl;
        data["stores"] = this.stores ? this.stores.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentNextActionKonbiniDisplayDetails extends IStripeEntityOfPaymentIntentNextActionKonbiniDisplayDetails {
    /** The timestamp at which the pending Konbini payment expires. */
    expiresAt?: Date;
    /** The URL for the Konbini payment instructions page, which allows customers to view and
print a Konbini voucher. */
    hostedVoucherUrl?: string | undefined;
    stores?: PaymentIntentNextActionKonbiniDisplayDetailsStores | undefined;
}

export abstract class StripeEntityOfPaymentIntentNextActionKonbiniDisplayDetailsStores extends StripeEntity implements IStripeEntityOfPaymentIntentNextActionKonbiniDisplayDetailsStores {

    constructor(data?: IStripeEntityOfPaymentIntentNextActionKonbiniDisplayDetailsStores) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentNextActionKonbiniDisplayDetailsStores {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentNextActionKonbiniDisplayDetailsStores' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentNextActionKonbiniDisplayDetailsStores extends IStripeEntity {
}

export class PaymentIntentNextActionKonbiniDisplayDetailsStores extends StripeEntityOfPaymentIntentNextActionKonbiniDisplayDetailsStores implements IPaymentIntentNextActionKonbiniDisplayDetailsStores {
    /** FamilyMart instruction details. */
    familymart?: PaymentIntentNextActionKonbiniDisplayDetailsStoresFamilymart | undefined;
    /** Lawson instruction details. */
    lawson?: PaymentIntentNextActionKonbiniDisplayDetailsStoresLawson | undefined;
    /** Ministop instruction details. */
    ministop?: PaymentIntentNextActionKonbiniDisplayDetailsStoresMinistop | undefined;
    /** Seicomart instruction details. */
    seicomart?: PaymentIntentNextActionKonbiniDisplayDetailsStoresSeicomart | undefined;

    constructor(data?: IPaymentIntentNextActionKonbiniDisplayDetailsStores) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.familymart = _data["familymart"] ? PaymentIntentNextActionKonbiniDisplayDetailsStoresFamilymart.fromJS(_data["familymart"]) : <any>undefined;
            this.lawson = _data["lawson"] ? PaymentIntentNextActionKonbiniDisplayDetailsStoresLawson.fromJS(_data["lawson"]) : <any>undefined;
            this.ministop = _data["ministop"] ? PaymentIntentNextActionKonbiniDisplayDetailsStoresMinistop.fromJS(_data["ministop"]) : <any>undefined;
            this.seicomart = _data["seicomart"] ? PaymentIntentNextActionKonbiniDisplayDetailsStoresSeicomart.fromJS(_data["seicomart"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): PaymentIntentNextActionKonbiniDisplayDetailsStores {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentNextActionKonbiniDisplayDetailsStores();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["familymart"] = this.familymart ? this.familymart.toJSON() : <any>undefined;
        data["lawson"] = this.lawson ? this.lawson.toJSON() : <any>undefined;
        data["ministop"] = this.ministop ? this.ministop.toJSON() : <any>undefined;
        data["seicomart"] = this.seicomart ? this.seicomart.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentNextActionKonbiniDisplayDetailsStores extends IStripeEntityOfPaymentIntentNextActionKonbiniDisplayDetailsStores {
    /** FamilyMart instruction details. */
    familymart?: PaymentIntentNextActionKonbiniDisplayDetailsStoresFamilymart | undefined;
    /** Lawson instruction details. */
    lawson?: PaymentIntentNextActionKonbiniDisplayDetailsStoresLawson | undefined;
    /** Ministop instruction details. */
    ministop?: PaymentIntentNextActionKonbiniDisplayDetailsStoresMinistop | undefined;
    /** Seicomart instruction details. */
    seicomart?: PaymentIntentNextActionKonbiniDisplayDetailsStoresSeicomart | undefined;
}

export abstract class StripeEntityOfPaymentIntentNextActionKonbiniDisplayDetailsStoresFamilymart extends StripeEntity implements IStripeEntityOfPaymentIntentNextActionKonbiniDisplayDetailsStoresFamilymart {

    constructor(data?: IStripeEntityOfPaymentIntentNextActionKonbiniDisplayDetailsStoresFamilymart) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentNextActionKonbiniDisplayDetailsStoresFamilymart {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentNextActionKonbiniDisplayDetailsStoresFamilymart' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentNextActionKonbiniDisplayDetailsStoresFamilymart extends IStripeEntity {
}

export class PaymentIntentNextActionKonbiniDisplayDetailsStoresFamilymart extends StripeEntityOfPaymentIntentNextActionKonbiniDisplayDetailsStoresFamilymart implements IPaymentIntentNextActionKonbiniDisplayDetailsStoresFamilymart {
    /** The confirmation number. */
    confirmationNumber?: string | undefined;
    /** The payment code. */
    paymentCode?: string | undefined;

    constructor(data?: IPaymentIntentNextActionKonbiniDisplayDetailsStoresFamilymart) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.confirmationNumber = _data["confirmationNumber"];
            this.paymentCode = _data["paymentCode"];
        }
    }

    static override fromJS(data: any): PaymentIntentNextActionKonbiniDisplayDetailsStoresFamilymart {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentNextActionKonbiniDisplayDetailsStoresFamilymart();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["confirmationNumber"] = this.confirmationNumber;
        data["paymentCode"] = this.paymentCode;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentNextActionKonbiniDisplayDetailsStoresFamilymart extends IStripeEntityOfPaymentIntentNextActionKonbiniDisplayDetailsStoresFamilymart {
    /** The confirmation number. */
    confirmationNumber?: string | undefined;
    /** The payment code. */
    paymentCode?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentNextActionKonbiniDisplayDetailsStoresLawson extends StripeEntity implements IStripeEntityOfPaymentIntentNextActionKonbiniDisplayDetailsStoresLawson {

    constructor(data?: IStripeEntityOfPaymentIntentNextActionKonbiniDisplayDetailsStoresLawson) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentNextActionKonbiniDisplayDetailsStoresLawson {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentNextActionKonbiniDisplayDetailsStoresLawson' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentNextActionKonbiniDisplayDetailsStoresLawson extends IStripeEntity {
}

export class PaymentIntentNextActionKonbiniDisplayDetailsStoresLawson extends StripeEntityOfPaymentIntentNextActionKonbiniDisplayDetailsStoresLawson implements IPaymentIntentNextActionKonbiniDisplayDetailsStoresLawson {
    /** The confirmation number. */
    confirmationNumber?: string | undefined;
    /** The payment code. */
    paymentCode?: string | undefined;

    constructor(data?: IPaymentIntentNextActionKonbiniDisplayDetailsStoresLawson) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.confirmationNumber = _data["confirmationNumber"];
            this.paymentCode = _data["paymentCode"];
        }
    }

    static override fromJS(data: any): PaymentIntentNextActionKonbiniDisplayDetailsStoresLawson {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentNextActionKonbiniDisplayDetailsStoresLawson();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["confirmationNumber"] = this.confirmationNumber;
        data["paymentCode"] = this.paymentCode;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentNextActionKonbiniDisplayDetailsStoresLawson extends IStripeEntityOfPaymentIntentNextActionKonbiniDisplayDetailsStoresLawson {
    /** The confirmation number. */
    confirmationNumber?: string | undefined;
    /** The payment code. */
    paymentCode?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentNextActionKonbiniDisplayDetailsStoresMinistop extends StripeEntity implements IStripeEntityOfPaymentIntentNextActionKonbiniDisplayDetailsStoresMinistop {

    constructor(data?: IStripeEntityOfPaymentIntentNextActionKonbiniDisplayDetailsStoresMinistop) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentNextActionKonbiniDisplayDetailsStoresMinistop {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentNextActionKonbiniDisplayDetailsStoresMinistop' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentNextActionKonbiniDisplayDetailsStoresMinistop extends IStripeEntity {
}

export class PaymentIntentNextActionKonbiniDisplayDetailsStoresMinistop extends StripeEntityOfPaymentIntentNextActionKonbiniDisplayDetailsStoresMinistop implements IPaymentIntentNextActionKonbiniDisplayDetailsStoresMinistop {
    /** The confirmation number. */
    confirmationNumber?: string | undefined;
    /** The payment code. */
    paymentCode?: string | undefined;

    constructor(data?: IPaymentIntentNextActionKonbiniDisplayDetailsStoresMinistop) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.confirmationNumber = _data["confirmationNumber"];
            this.paymentCode = _data["paymentCode"];
        }
    }

    static override fromJS(data: any): PaymentIntentNextActionKonbiniDisplayDetailsStoresMinistop {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentNextActionKonbiniDisplayDetailsStoresMinistop();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["confirmationNumber"] = this.confirmationNumber;
        data["paymentCode"] = this.paymentCode;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentNextActionKonbiniDisplayDetailsStoresMinistop extends IStripeEntityOfPaymentIntentNextActionKonbiniDisplayDetailsStoresMinistop {
    /** The confirmation number. */
    confirmationNumber?: string | undefined;
    /** The payment code. */
    paymentCode?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentNextActionKonbiniDisplayDetailsStoresSeicomart extends StripeEntity implements IStripeEntityOfPaymentIntentNextActionKonbiniDisplayDetailsStoresSeicomart {

    constructor(data?: IStripeEntityOfPaymentIntentNextActionKonbiniDisplayDetailsStoresSeicomart) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentNextActionKonbiniDisplayDetailsStoresSeicomart {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentNextActionKonbiniDisplayDetailsStoresSeicomart' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentNextActionKonbiniDisplayDetailsStoresSeicomart extends IStripeEntity {
}

export class PaymentIntentNextActionKonbiniDisplayDetailsStoresSeicomart extends StripeEntityOfPaymentIntentNextActionKonbiniDisplayDetailsStoresSeicomart implements IPaymentIntentNextActionKonbiniDisplayDetailsStoresSeicomart {
    /** The confirmation number. */
    confirmationNumber?: string | undefined;
    /** The payment code. */
    paymentCode?: string | undefined;

    constructor(data?: IPaymentIntentNextActionKonbiniDisplayDetailsStoresSeicomart) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.confirmationNumber = _data["confirmationNumber"];
            this.paymentCode = _data["paymentCode"];
        }
    }

    static override fromJS(data: any): PaymentIntentNextActionKonbiniDisplayDetailsStoresSeicomart {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentNextActionKonbiniDisplayDetailsStoresSeicomart();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["confirmationNumber"] = this.confirmationNumber;
        data["paymentCode"] = this.paymentCode;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentNextActionKonbiniDisplayDetailsStoresSeicomart extends IStripeEntityOfPaymentIntentNextActionKonbiniDisplayDetailsStoresSeicomart {
    /** The confirmation number. */
    confirmationNumber?: string | undefined;
    /** The payment code. */
    paymentCode?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentNextActionOxxoDisplayDetails extends StripeEntity implements IStripeEntityOfPaymentIntentNextActionOxxoDisplayDetails {

    constructor(data?: IStripeEntityOfPaymentIntentNextActionOxxoDisplayDetails) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentNextActionOxxoDisplayDetails {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentNextActionOxxoDisplayDetails' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentNextActionOxxoDisplayDetails extends IStripeEntity {
}

export class PaymentIntentNextActionOxxoDisplayDetails extends StripeEntityOfPaymentIntentNextActionOxxoDisplayDetails implements IPaymentIntentNextActionOxxoDisplayDetails {
    /** The timestamp after which the OXXO voucher expires. */
    expiresAfter?: Date | undefined;
    /** The URL for the hosted OXXO voucher page, which allows customers to view and print an
OXXO voucher. */
    hostedVoucherUrl?: string | undefined;
    /** OXXO reference number. */
    number?: string | undefined;

    constructor(data?: IPaymentIntentNextActionOxxoDisplayDetails) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.expiresAfter = _data["expiresAfter"] ? new Date(_data["expiresAfter"].toString()) : <any>undefined;
            this.hostedVoucherUrl = _data["hostedVoucherUrl"];
            this.number = _data["number"];
        }
    }

    static override fromJS(data: any): PaymentIntentNextActionOxxoDisplayDetails {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentNextActionOxxoDisplayDetails();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expiresAfter"] = this.expiresAfter ? this.expiresAfter.toISOString() : <any>undefined;
        data["hostedVoucherUrl"] = this.hostedVoucherUrl;
        data["number"] = this.number;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentNextActionOxxoDisplayDetails extends IStripeEntityOfPaymentIntentNextActionOxxoDisplayDetails {
    /** The timestamp after which the OXXO voucher expires. */
    expiresAfter?: Date | undefined;
    /** The URL for the hosted OXXO voucher page, which allows customers to view and print an
OXXO voucher. */
    hostedVoucherUrl?: string | undefined;
    /** OXXO reference number. */
    number?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentNextActionPaynowDisplayQrCode extends StripeEntity implements IStripeEntityOfPaymentIntentNextActionPaynowDisplayQrCode {

    constructor(data?: IStripeEntityOfPaymentIntentNextActionPaynowDisplayQrCode) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentNextActionPaynowDisplayQrCode {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentNextActionPaynowDisplayQrCode' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentNextActionPaynowDisplayQrCode extends IStripeEntity {
}

export class PaymentIntentNextActionPaynowDisplayQrCode extends StripeEntityOfPaymentIntentNextActionPaynowDisplayQrCode implements IPaymentIntentNextActionPaynowDisplayQrCode {
    /** The raw data string used to generate QR code, it should be used together with QR code
library. */
    data?: string | undefined;
    /** The URL to the hosted PayNow instructions page, which allows customers to view the
PayNow QR code. */
    hostedInstructionsUrl?: string | undefined;
    /** The image_url_png string used to render QR code. */
    imageUrlPng?: string | undefined;
    /** The image_url_svg string used to render QR code. */
    imageUrlSvg?: string | undefined;

    constructor(data?: IPaymentIntentNextActionPaynowDisplayQrCode) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.data = _data["data"];
            this.hostedInstructionsUrl = _data["hostedInstructionsUrl"];
            this.imageUrlPng = _data["imageUrlPng"];
            this.imageUrlSvg = _data["imageUrlSvg"];
        }
    }

    static override fromJS(data: any): PaymentIntentNextActionPaynowDisplayQrCode {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentNextActionPaynowDisplayQrCode();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        data["hostedInstructionsUrl"] = this.hostedInstructionsUrl;
        data["imageUrlPng"] = this.imageUrlPng;
        data["imageUrlSvg"] = this.imageUrlSvg;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentNextActionPaynowDisplayQrCode extends IStripeEntityOfPaymentIntentNextActionPaynowDisplayQrCode {
    /** The raw data string used to generate QR code, it should be used together with QR code
library. */
    data?: string | undefined;
    /** The URL to the hosted PayNow instructions page, which allows customers to view the
PayNow QR code. */
    hostedInstructionsUrl?: string | undefined;
    /** The image_url_png string used to render QR code. */
    imageUrlPng?: string | undefined;
    /** The image_url_svg string used to render QR code. */
    imageUrlSvg?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentNextActionPixDisplayQrCode extends StripeEntity implements IStripeEntityOfPaymentIntentNextActionPixDisplayQrCode {

    constructor(data?: IStripeEntityOfPaymentIntentNextActionPixDisplayQrCode) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentNextActionPixDisplayQrCode {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentNextActionPixDisplayQrCode' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentNextActionPixDisplayQrCode extends IStripeEntity {
}

export class PaymentIntentNextActionPixDisplayQrCode extends StripeEntityOfPaymentIntentNextActionPixDisplayQrCode implements IPaymentIntentNextActionPixDisplayQrCode {
    /** The raw data string used to generate QR code, it should be used together with QR code
library. */
    data?: string | undefined;
    /** The date (unix timestamp) when the PIX expires. */
    expiresAt?: number;
    /** The URL to the hosted pix instructions page, which allows customers to view the pix QR
code. */
    hostedInstructionsUrl?: string | undefined;
    /** The image_url_png string used to render png QR code. */
    imageUrlPng?: string | undefined;
    /** The image_url_svg string used to render svg QR code. */
    imageUrlSvg?: string | undefined;

    constructor(data?: IPaymentIntentNextActionPixDisplayQrCode) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.data = _data["data"];
            this.expiresAt = _data["expiresAt"];
            this.hostedInstructionsUrl = _data["hostedInstructionsUrl"];
            this.imageUrlPng = _data["imageUrlPng"];
            this.imageUrlSvg = _data["imageUrlSvg"];
        }
    }

    static override fromJS(data: any): PaymentIntentNextActionPixDisplayQrCode {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentNextActionPixDisplayQrCode();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        data["expiresAt"] = this.expiresAt;
        data["hostedInstructionsUrl"] = this.hostedInstructionsUrl;
        data["imageUrlPng"] = this.imageUrlPng;
        data["imageUrlSvg"] = this.imageUrlSvg;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentNextActionPixDisplayQrCode extends IStripeEntityOfPaymentIntentNextActionPixDisplayQrCode {
    /** The raw data string used to generate QR code, it should be used together with QR code
library. */
    data?: string | undefined;
    /** The date (unix timestamp) when the PIX expires. */
    expiresAt?: number;
    /** The URL to the hosted pix instructions page, which allows customers to view the pix QR
code. */
    hostedInstructionsUrl?: string | undefined;
    /** The image_url_png string used to render png QR code. */
    imageUrlPng?: string | undefined;
    /** The image_url_svg string used to render svg QR code. */
    imageUrlSvg?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentNextActionPromptpayDisplayQrCode extends StripeEntity implements IStripeEntityOfPaymentIntentNextActionPromptpayDisplayQrCode {

    constructor(data?: IStripeEntityOfPaymentIntentNextActionPromptpayDisplayQrCode) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentNextActionPromptpayDisplayQrCode {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentNextActionPromptpayDisplayQrCode' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentNextActionPromptpayDisplayQrCode extends IStripeEntity {
}

export class PaymentIntentNextActionPromptpayDisplayQrCode extends StripeEntityOfPaymentIntentNextActionPromptpayDisplayQrCode implements IPaymentIntentNextActionPromptpayDisplayQrCode {
    /** The raw data string used to generate QR code, it should be used together with QR code
library. */
    data?: string | undefined;
    /** The URL to the hosted PromptPay instructions page, which allows customers to view the
PromptPay QR code. */
    hostedInstructionsUrl?: string | undefined;
    /** The PNG path used to render the QR code, can be used as the source in an HTML img tag. */
    imageUrlPng?: string | undefined;
    /** The SVG path used to render the QR code, can be used as the source in an HTML img tag. */
    imageUrlSvg?: string | undefined;

    constructor(data?: IPaymentIntentNextActionPromptpayDisplayQrCode) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.data = _data["data"];
            this.hostedInstructionsUrl = _data["hostedInstructionsUrl"];
            this.imageUrlPng = _data["imageUrlPng"];
            this.imageUrlSvg = _data["imageUrlSvg"];
        }
    }

    static override fromJS(data: any): PaymentIntentNextActionPromptpayDisplayQrCode {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentNextActionPromptpayDisplayQrCode();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        data["hostedInstructionsUrl"] = this.hostedInstructionsUrl;
        data["imageUrlPng"] = this.imageUrlPng;
        data["imageUrlSvg"] = this.imageUrlSvg;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentNextActionPromptpayDisplayQrCode extends IStripeEntityOfPaymentIntentNextActionPromptpayDisplayQrCode {
    /** The raw data string used to generate QR code, it should be used together with QR code
library. */
    data?: string | undefined;
    /** The URL to the hosted PromptPay instructions page, which allows customers to view the
PromptPay QR code. */
    hostedInstructionsUrl?: string | undefined;
    /** The PNG path used to render the QR code, can be used as the source in an HTML img tag. */
    imageUrlPng?: string | undefined;
    /** The SVG path used to render the QR code, can be used as the source in an HTML img tag. */
    imageUrlSvg?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentNextActionRedirectToUrl extends StripeEntity implements IStripeEntityOfPaymentIntentNextActionRedirectToUrl {

    constructor(data?: IStripeEntityOfPaymentIntentNextActionRedirectToUrl) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentNextActionRedirectToUrl {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentNextActionRedirectToUrl' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentNextActionRedirectToUrl extends IStripeEntity {
}

export class PaymentIntentNextActionRedirectToUrl extends StripeEntityOfPaymentIntentNextActionRedirectToUrl implements IPaymentIntentNextActionRedirectToUrl {
    /** If the customer does not exit their browser while authenticating, they will be
redirected to this specified URL after completion. */
    returnUrl?: string | undefined;
    /** The URL you must redirect your customer to in order to authenticate the payment. */
    url?: string | undefined;

    constructor(data?: IPaymentIntentNextActionRedirectToUrl) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.returnUrl = _data["returnUrl"];
            this.url = _data["url"];
        }
    }

    static override fromJS(data: any): PaymentIntentNextActionRedirectToUrl {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentNextActionRedirectToUrl();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["returnUrl"] = this.returnUrl;
        data["url"] = this.url;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentNextActionRedirectToUrl extends IStripeEntityOfPaymentIntentNextActionRedirectToUrl {
    /** If the customer does not exit their browser while authenticating, they will be
redirected to this specified URL after completion. */
    returnUrl?: string | undefined;
    /** The URL you must redirect your customer to in order to authenticate the payment. */
    url?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentNextActionVerifyWithMicrodeposits extends StripeEntity implements IStripeEntityOfPaymentIntentNextActionVerifyWithMicrodeposits {

    constructor(data?: IStripeEntityOfPaymentIntentNextActionVerifyWithMicrodeposits) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentNextActionVerifyWithMicrodeposits {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentNextActionVerifyWithMicrodeposits' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentNextActionVerifyWithMicrodeposits extends IStripeEntity {
}

export class PaymentIntentNextActionVerifyWithMicrodeposits extends StripeEntityOfPaymentIntentNextActionVerifyWithMicrodeposits implements IPaymentIntentNextActionVerifyWithMicrodeposits {
    /** The timestamp when the microdeposits are expected to land. */
    arrivalDate?: Date;
    /** The URL for the hosted verification page, which allows customers to verify their bank
account. */
    hostedVerificationUrl?: string | undefined;
    /** The type of the microdeposit sent to the customer. Used to distinguish between different
verification methods.
One of: amounts, or descriptor_code. */
    microdepositType?: string | undefined;

    constructor(data?: IPaymentIntentNextActionVerifyWithMicrodeposits) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.arrivalDate = _data["arrivalDate"] ? new Date(_data["arrivalDate"].toString()) : <any>undefined;
            this.hostedVerificationUrl = _data["hostedVerificationUrl"];
            this.microdepositType = _data["microdepositType"];
        }
    }

    static override fromJS(data: any): PaymentIntentNextActionVerifyWithMicrodeposits {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentNextActionVerifyWithMicrodeposits();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["arrivalDate"] = this.arrivalDate ? this.arrivalDate.toISOString() : <any>undefined;
        data["hostedVerificationUrl"] = this.hostedVerificationUrl;
        data["microdepositType"] = this.microdepositType;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentNextActionVerifyWithMicrodeposits extends IStripeEntityOfPaymentIntentNextActionVerifyWithMicrodeposits {
    /** The timestamp when the microdeposits are expected to land. */
    arrivalDate?: Date;
    /** The URL for the hosted verification page, which allows customers to verify their bank
account. */
    hostedVerificationUrl?: string | undefined;
    /** The type of the microdeposit sent to the customer. Used to distinguish between different
verification methods.
One of: amounts, or descriptor_code. */
    microdepositType?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentNextActionWechatPayDisplayQrCode extends StripeEntity implements IStripeEntityOfPaymentIntentNextActionWechatPayDisplayQrCode {

    constructor(data?: IStripeEntityOfPaymentIntentNextActionWechatPayDisplayQrCode) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentNextActionWechatPayDisplayQrCode {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentNextActionWechatPayDisplayQrCode' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentNextActionWechatPayDisplayQrCode extends IStripeEntity {
}

export class PaymentIntentNextActionWechatPayDisplayQrCode extends StripeEntityOfPaymentIntentNextActionWechatPayDisplayQrCode implements IPaymentIntentNextActionWechatPayDisplayQrCode {
    /** The data being used to generate QR code. */
    data?: string | undefined;
    /** The URL to the hosted WeChat Pay instructions page, which allows customers to view the
WeChat Pay QR code. */
    hostedInstructionsUrl?: string | undefined;
    /** The base64 image data for a pre-generated QR code. */
    imageDataUrl?: string | undefined;
    /** The image_url_png string used to render QR code. */
    imageUrlPng?: string | undefined;
    /** The image_url_svg string used to render QR code. */
    imageUrlSvg?: string | undefined;

    constructor(data?: IPaymentIntentNextActionWechatPayDisplayQrCode) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.data = _data["data"];
            this.hostedInstructionsUrl = _data["hostedInstructionsUrl"];
            this.imageDataUrl = _data["imageDataUrl"];
            this.imageUrlPng = _data["imageUrlPng"];
            this.imageUrlSvg = _data["imageUrlSvg"];
        }
    }

    static override fromJS(data: any): PaymentIntentNextActionWechatPayDisplayQrCode {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentNextActionWechatPayDisplayQrCode();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        data["hostedInstructionsUrl"] = this.hostedInstructionsUrl;
        data["imageDataUrl"] = this.imageDataUrl;
        data["imageUrlPng"] = this.imageUrlPng;
        data["imageUrlSvg"] = this.imageUrlSvg;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentNextActionWechatPayDisplayQrCode extends IStripeEntityOfPaymentIntentNextActionWechatPayDisplayQrCode {
    /** The data being used to generate QR code. */
    data?: string | undefined;
    /** The URL to the hosted WeChat Pay instructions page, which allows customers to view the
WeChat Pay QR code. */
    hostedInstructionsUrl?: string | undefined;
    /** The base64 image data for a pre-generated QR code. */
    imageDataUrl?: string | undefined;
    /** The image_url_png string used to render QR code. */
    imageUrlPng?: string | undefined;
    /** The image_url_svg string used to render QR code. */
    imageUrlSvg?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentNextActionWechatPayRedirectToAndroidApp extends StripeEntity implements IStripeEntityOfPaymentIntentNextActionWechatPayRedirectToAndroidApp {

    constructor(data?: IStripeEntityOfPaymentIntentNextActionWechatPayRedirectToAndroidApp) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentNextActionWechatPayRedirectToAndroidApp {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentNextActionWechatPayRedirectToAndroidApp' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentNextActionWechatPayRedirectToAndroidApp extends IStripeEntity {
}

export class PaymentIntentNextActionWechatPayRedirectToAndroidApp extends StripeEntityOfPaymentIntentNextActionWechatPayRedirectToAndroidApp implements IPaymentIntentNextActionWechatPayRedirectToAndroidApp {
    /** app_id is the APP ID registered on WeChat open platform. */
    appId?: string | undefined;
    /** nonce_str is a random string. */
    nonceStr?: string | undefined;
    /** package is static value. */
    package?: string | undefined;
    /** an unique merchant ID assigned by WeChat Pay. */
    partnerId?: string | undefined;
    /** an unique trading ID assigned by WeChat Pay. */
    prepayId?: string | undefined;
    /** A signature. */
    sign?: string | undefined;
    /** Specifies the current time in epoch format. */
    timestamp?: string | undefined;

    constructor(data?: IPaymentIntentNextActionWechatPayRedirectToAndroidApp) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.appId = _data["appId"];
            this.nonceStr = _data["nonceStr"];
            this.package = _data["package"];
            this.partnerId = _data["partnerId"];
            this.prepayId = _data["prepayId"];
            this.sign = _data["sign"];
            this.timestamp = _data["timestamp"];
        }
    }

    static override fromJS(data: any): PaymentIntentNextActionWechatPayRedirectToAndroidApp {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentNextActionWechatPayRedirectToAndroidApp();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appId"] = this.appId;
        data["nonceStr"] = this.nonceStr;
        data["package"] = this.package;
        data["partnerId"] = this.partnerId;
        data["prepayId"] = this.prepayId;
        data["sign"] = this.sign;
        data["timestamp"] = this.timestamp;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentNextActionWechatPayRedirectToAndroidApp extends IStripeEntityOfPaymentIntentNextActionWechatPayRedirectToAndroidApp {
    /** app_id is the APP ID registered on WeChat open platform. */
    appId?: string | undefined;
    /** nonce_str is a random string. */
    nonceStr?: string | undefined;
    /** package is static value. */
    package?: string | undefined;
    /** an unique merchant ID assigned by WeChat Pay. */
    partnerId?: string | undefined;
    /** an unique trading ID assigned by WeChat Pay. */
    prepayId?: string | undefined;
    /** A signature. */
    sign?: string | undefined;
    /** Specifies the current time in epoch format. */
    timestamp?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentNextActionWechatPayRedirectToIosApp extends StripeEntity implements IStripeEntityOfPaymentIntentNextActionWechatPayRedirectToIosApp {

    constructor(data?: IStripeEntityOfPaymentIntentNextActionWechatPayRedirectToIosApp) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentNextActionWechatPayRedirectToIosApp {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentNextActionWechatPayRedirectToIosApp' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentNextActionWechatPayRedirectToIosApp extends IStripeEntity {
}

export class PaymentIntentNextActionWechatPayRedirectToIosApp extends StripeEntityOfPaymentIntentNextActionWechatPayRedirectToIosApp implements IPaymentIntentNextActionWechatPayRedirectToIosApp {
    /** An universal link that redirect to WeChat Pay app. */
    nativeUrl?: string | undefined;

    constructor(data?: IPaymentIntentNextActionWechatPayRedirectToIosApp) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.nativeUrl = _data["nativeUrl"];
        }
    }

    static override fromJS(data: any): PaymentIntentNextActionWechatPayRedirectToIosApp {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentNextActionWechatPayRedirectToIosApp();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nativeUrl"] = this.nativeUrl;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentNextActionWechatPayRedirectToIosApp extends IStripeEntityOfPaymentIntentNextActionWechatPayRedirectToIosApp {
    /** An universal link that redirect to WeChat Pay app. */
    nativeUrl?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentPaymentMethodOptions extends StripeEntity implements IStripeEntityOfPaymentIntentPaymentMethodOptions {

    constructor(data?: IStripeEntityOfPaymentIntentPaymentMethodOptions) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentPaymentMethodOptions {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentPaymentMethodOptions' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentPaymentMethodOptions extends IStripeEntity {
}

export class PaymentIntentPaymentMethodOptions extends StripeEntityOfPaymentIntentPaymentMethodOptions implements IPaymentIntentPaymentMethodOptions {
    acssDebit?: PaymentIntentPaymentMethodOptionsAcssDebit | undefined;
    affirm?: PaymentIntentPaymentMethodOptionsAffirm | undefined;
    afterpayClearpay?: PaymentIntentPaymentMethodOptionsAfterpayClearpay | undefined;
    alipay?: PaymentIntentPaymentMethodOptionsAlipay | undefined;
    auBecsDebit?: PaymentIntentPaymentMethodOptionsAuBecsDebit | undefined;
    bacsDebit?: PaymentIntentPaymentMethodOptionsBacsDebit | undefined;
    bancontact?: PaymentIntentPaymentMethodOptionsBancontact | undefined;
    blik?: PaymentIntentPaymentMethodOptionsBlik | undefined;
    boleto?: PaymentIntentPaymentMethodOptionsBoleto | undefined;
    card?: PaymentIntentPaymentMethodOptionsCard | undefined;
    cardPresent?: PaymentIntentPaymentMethodOptionsCardPresent | undefined;
    cashapp?: PaymentIntentPaymentMethodOptionsCashapp | undefined;
    customerBalance?: PaymentIntentPaymentMethodOptionsCustomerBalance | undefined;
    eps?: PaymentIntentPaymentMethodOptionsEps | undefined;
    fpx?: PaymentIntentPaymentMethodOptionsFpx | undefined;
    giropay?: PaymentIntentPaymentMethodOptionsGiropay | undefined;
    grabpay?: PaymentIntentPaymentMethodOptionsGrabpay | undefined;
    ideal?: PaymentIntentPaymentMethodOptionsIdeal | undefined;
    interacPresent?: PaymentIntentPaymentMethodOptionsInteracPresent | undefined;
    klarna?: PaymentIntentPaymentMethodOptionsKlarna | undefined;
    konbini?: PaymentIntentPaymentMethodOptionsKonbini | undefined;
    link?: PaymentIntentPaymentMethodOptionsLink | undefined;
    oxxo?: PaymentIntentPaymentMethodOptionsOxxo | undefined;
    p24?: PaymentIntentPaymentMethodOptionsP24 | undefined;
    paynow?: PaymentIntentPaymentMethodOptionsPaynow | undefined;
    paypal?: PaymentIntentPaymentMethodOptionsPaypal | undefined;
    pix?: PaymentIntentPaymentMethodOptionsPix | undefined;
    promptpay?: PaymentIntentPaymentMethodOptionsPromptpay | undefined;
    sepaDebit?: PaymentIntentPaymentMethodOptionsSepaDebit | undefined;
    sofort?: PaymentIntentPaymentMethodOptionsSofort | undefined;
    usBankAccount?: PaymentIntentPaymentMethodOptionsUsBankAccount | undefined;
    wechatPay?: PaymentIntentPaymentMethodOptionsWechatPay | undefined;
    zip?: PaymentIntentPaymentMethodOptionsZip | undefined;

    constructor(data?: IPaymentIntentPaymentMethodOptions) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.acssDebit = _data["acssDebit"] ? PaymentIntentPaymentMethodOptionsAcssDebit.fromJS(_data["acssDebit"]) : <any>undefined;
            this.affirm = _data["affirm"] ? PaymentIntentPaymentMethodOptionsAffirm.fromJS(_data["affirm"]) : <any>undefined;
            this.afterpayClearpay = _data["afterpayClearpay"] ? PaymentIntentPaymentMethodOptionsAfterpayClearpay.fromJS(_data["afterpayClearpay"]) : <any>undefined;
            this.alipay = _data["alipay"] ? PaymentIntentPaymentMethodOptionsAlipay.fromJS(_data["alipay"]) : <any>undefined;
            this.auBecsDebit = _data["auBecsDebit"] ? PaymentIntentPaymentMethodOptionsAuBecsDebit.fromJS(_data["auBecsDebit"]) : <any>undefined;
            this.bacsDebit = _data["bacsDebit"] ? PaymentIntentPaymentMethodOptionsBacsDebit.fromJS(_data["bacsDebit"]) : <any>undefined;
            this.bancontact = _data["bancontact"] ? PaymentIntentPaymentMethodOptionsBancontact.fromJS(_data["bancontact"]) : <any>undefined;
            this.blik = _data["blik"] ? PaymentIntentPaymentMethodOptionsBlik.fromJS(_data["blik"]) : <any>undefined;
            this.boleto = _data["boleto"] ? PaymentIntentPaymentMethodOptionsBoleto.fromJS(_data["boleto"]) : <any>undefined;
            this.card = _data["card"] ? PaymentIntentPaymentMethodOptionsCard.fromJS(_data["card"]) : <any>undefined;
            this.cardPresent = _data["cardPresent"] ? PaymentIntentPaymentMethodOptionsCardPresent.fromJS(_data["cardPresent"]) : <any>undefined;
            this.cashapp = _data["cashapp"] ? PaymentIntentPaymentMethodOptionsCashapp.fromJS(_data["cashapp"]) : <any>undefined;
            this.customerBalance = _data["customerBalance"] ? PaymentIntentPaymentMethodOptionsCustomerBalance.fromJS(_data["customerBalance"]) : <any>undefined;
            this.eps = _data["eps"] ? PaymentIntentPaymentMethodOptionsEps.fromJS(_data["eps"]) : <any>undefined;
            this.fpx = _data["fpx"] ? PaymentIntentPaymentMethodOptionsFpx.fromJS(_data["fpx"]) : <any>undefined;
            this.giropay = _data["giropay"] ? PaymentIntentPaymentMethodOptionsGiropay.fromJS(_data["giropay"]) : <any>undefined;
            this.grabpay = _data["grabpay"] ? PaymentIntentPaymentMethodOptionsGrabpay.fromJS(_data["grabpay"]) : <any>undefined;
            this.ideal = _data["ideal"] ? PaymentIntentPaymentMethodOptionsIdeal.fromJS(_data["ideal"]) : <any>undefined;
            this.interacPresent = _data["interacPresent"] ? PaymentIntentPaymentMethodOptionsInteracPresent.fromJS(_data["interacPresent"]) : <any>undefined;
            this.klarna = _data["klarna"] ? PaymentIntentPaymentMethodOptionsKlarna.fromJS(_data["klarna"]) : <any>undefined;
            this.konbini = _data["konbini"] ? PaymentIntentPaymentMethodOptionsKonbini.fromJS(_data["konbini"]) : <any>undefined;
            this.link = _data["link"] ? PaymentIntentPaymentMethodOptionsLink.fromJS(_data["link"]) : <any>undefined;
            this.oxxo = _data["oxxo"] ? PaymentIntentPaymentMethodOptionsOxxo.fromJS(_data["oxxo"]) : <any>undefined;
            this.p24 = _data["p24"] ? PaymentIntentPaymentMethodOptionsP24.fromJS(_data["p24"]) : <any>undefined;
            this.paynow = _data["paynow"] ? PaymentIntentPaymentMethodOptionsPaynow.fromJS(_data["paynow"]) : <any>undefined;
            this.paypal = _data["paypal"] ? PaymentIntentPaymentMethodOptionsPaypal.fromJS(_data["paypal"]) : <any>undefined;
            this.pix = _data["pix"] ? PaymentIntentPaymentMethodOptionsPix.fromJS(_data["pix"]) : <any>undefined;
            this.promptpay = _data["promptpay"] ? PaymentIntentPaymentMethodOptionsPromptpay.fromJS(_data["promptpay"]) : <any>undefined;
            this.sepaDebit = _data["sepaDebit"] ? PaymentIntentPaymentMethodOptionsSepaDebit.fromJS(_data["sepaDebit"]) : <any>undefined;
            this.sofort = _data["sofort"] ? PaymentIntentPaymentMethodOptionsSofort.fromJS(_data["sofort"]) : <any>undefined;
            this.usBankAccount = _data["usBankAccount"] ? PaymentIntentPaymentMethodOptionsUsBankAccount.fromJS(_data["usBankAccount"]) : <any>undefined;
            this.wechatPay = _data["wechatPay"] ? PaymentIntentPaymentMethodOptionsWechatPay.fromJS(_data["wechatPay"]) : <any>undefined;
            this.zip = _data["zip"] ? PaymentIntentPaymentMethodOptionsZip.fromJS(_data["zip"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): PaymentIntentPaymentMethodOptions {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentPaymentMethodOptions();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["acssDebit"] = this.acssDebit ? this.acssDebit.toJSON() : <any>undefined;
        data["affirm"] = this.affirm ? this.affirm.toJSON() : <any>undefined;
        data["afterpayClearpay"] = this.afterpayClearpay ? this.afterpayClearpay.toJSON() : <any>undefined;
        data["alipay"] = this.alipay ? this.alipay.toJSON() : <any>undefined;
        data["auBecsDebit"] = this.auBecsDebit ? this.auBecsDebit.toJSON() : <any>undefined;
        data["bacsDebit"] = this.bacsDebit ? this.bacsDebit.toJSON() : <any>undefined;
        data["bancontact"] = this.bancontact ? this.bancontact.toJSON() : <any>undefined;
        data["blik"] = this.blik ? this.blik.toJSON() : <any>undefined;
        data["boleto"] = this.boleto ? this.boleto.toJSON() : <any>undefined;
        data["card"] = this.card ? this.card.toJSON() : <any>undefined;
        data["cardPresent"] = this.cardPresent ? this.cardPresent.toJSON() : <any>undefined;
        data["cashapp"] = this.cashapp ? this.cashapp.toJSON() : <any>undefined;
        data["customerBalance"] = this.customerBalance ? this.customerBalance.toJSON() : <any>undefined;
        data["eps"] = this.eps ? this.eps.toJSON() : <any>undefined;
        data["fpx"] = this.fpx ? this.fpx.toJSON() : <any>undefined;
        data["giropay"] = this.giropay ? this.giropay.toJSON() : <any>undefined;
        data["grabpay"] = this.grabpay ? this.grabpay.toJSON() : <any>undefined;
        data["ideal"] = this.ideal ? this.ideal.toJSON() : <any>undefined;
        data["interacPresent"] = this.interacPresent ? this.interacPresent.toJSON() : <any>undefined;
        data["klarna"] = this.klarna ? this.klarna.toJSON() : <any>undefined;
        data["konbini"] = this.konbini ? this.konbini.toJSON() : <any>undefined;
        data["link"] = this.link ? this.link.toJSON() : <any>undefined;
        data["oxxo"] = this.oxxo ? this.oxxo.toJSON() : <any>undefined;
        data["p24"] = this.p24 ? this.p24.toJSON() : <any>undefined;
        data["paynow"] = this.paynow ? this.paynow.toJSON() : <any>undefined;
        data["paypal"] = this.paypal ? this.paypal.toJSON() : <any>undefined;
        data["pix"] = this.pix ? this.pix.toJSON() : <any>undefined;
        data["promptpay"] = this.promptpay ? this.promptpay.toJSON() : <any>undefined;
        data["sepaDebit"] = this.sepaDebit ? this.sepaDebit.toJSON() : <any>undefined;
        data["sofort"] = this.sofort ? this.sofort.toJSON() : <any>undefined;
        data["usBankAccount"] = this.usBankAccount ? this.usBankAccount.toJSON() : <any>undefined;
        data["wechatPay"] = this.wechatPay ? this.wechatPay.toJSON() : <any>undefined;
        data["zip"] = this.zip ? this.zip.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentPaymentMethodOptions extends IStripeEntityOfPaymentIntentPaymentMethodOptions {
    acssDebit?: PaymentIntentPaymentMethodOptionsAcssDebit | undefined;
    affirm?: PaymentIntentPaymentMethodOptionsAffirm | undefined;
    afterpayClearpay?: PaymentIntentPaymentMethodOptionsAfterpayClearpay | undefined;
    alipay?: PaymentIntentPaymentMethodOptionsAlipay | undefined;
    auBecsDebit?: PaymentIntentPaymentMethodOptionsAuBecsDebit | undefined;
    bacsDebit?: PaymentIntentPaymentMethodOptionsBacsDebit | undefined;
    bancontact?: PaymentIntentPaymentMethodOptionsBancontact | undefined;
    blik?: PaymentIntentPaymentMethodOptionsBlik | undefined;
    boleto?: PaymentIntentPaymentMethodOptionsBoleto | undefined;
    card?: PaymentIntentPaymentMethodOptionsCard | undefined;
    cardPresent?: PaymentIntentPaymentMethodOptionsCardPresent | undefined;
    cashapp?: PaymentIntentPaymentMethodOptionsCashapp | undefined;
    customerBalance?: PaymentIntentPaymentMethodOptionsCustomerBalance | undefined;
    eps?: PaymentIntentPaymentMethodOptionsEps | undefined;
    fpx?: PaymentIntentPaymentMethodOptionsFpx | undefined;
    giropay?: PaymentIntentPaymentMethodOptionsGiropay | undefined;
    grabpay?: PaymentIntentPaymentMethodOptionsGrabpay | undefined;
    ideal?: PaymentIntentPaymentMethodOptionsIdeal | undefined;
    interacPresent?: PaymentIntentPaymentMethodOptionsInteracPresent | undefined;
    klarna?: PaymentIntentPaymentMethodOptionsKlarna | undefined;
    konbini?: PaymentIntentPaymentMethodOptionsKonbini | undefined;
    link?: PaymentIntentPaymentMethodOptionsLink | undefined;
    oxxo?: PaymentIntentPaymentMethodOptionsOxxo | undefined;
    p24?: PaymentIntentPaymentMethodOptionsP24 | undefined;
    paynow?: PaymentIntentPaymentMethodOptionsPaynow | undefined;
    paypal?: PaymentIntentPaymentMethodOptionsPaypal | undefined;
    pix?: PaymentIntentPaymentMethodOptionsPix | undefined;
    promptpay?: PaymentIntentPaymentMethodOptionsPromptpay | undefined;
    sepaDebit?: PaymentIntentPaymentMethodOptionsSepaDebit | undefined;
    sofort?: PaymentIntentPaymentMethodOptionsSofort | undefined;
    usBankAccount?: PaymentIntentPaymentMethodOptionsUsBankAccount | undefined;
    wechatPay?: PaymentIntentPaymentMethodOptionsWechatPay | undefined;
    zip?: PaymentIntentPaymentMethodOptionsZip | undefined;
}

export abstract class StripeEntityOfPaymentIntentPaymentMethodOptionsAcssDebit extends StripeEntity implements IStripeEntityOfPaymentIntentPaymentMethodOptionsAcssDebit {

    constructor(data?: IStripeEntityOfPaymentIntentPaymentMethodOptionsAcssDebit) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentPaymentMethodOptionsAcssDebit {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentPaymentMethodOptionsAcssDebit' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentPaymentMethodOptionsAcssDebit extends IStripeEntity {
}

export class PaymentIntentPaymentMethodOptionsAcssDebit extends StripeEntityOfPaymentIntentPaymentMethodOptionsAcssDebit implements IPaymentIntentPaymentMethodOptionsAcssDebit {
    mandateOptions?: PaymentIntentPaymentMethodOptionsAcssDebitMandateOptions | undefined;
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA.
One of: none, off_session, or on_session. */
    setupFutureUsage?: string | undefined;
    /** Bank account verification method.
One of: automatic, instant, or microdeposits. */
    verificationMethod?: string | undefined;

    constructor(data?: IPaymentIntentPaymentMethodOptionsAcssDebit) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.mandateOptions = _data["mandateOptions"] ? PaymentIntentPaymentMethodOptionsAcssDebitMandateOptions.fromJS(_data["mandateOptions"]) : <any>undefined;
            this.setupFutureUsage = _data["setupFutureUsage"];
            this.verificationMethod = _data["verificationMethod"];
        }
    }

    static override fromJS(data: any): PaymentIntentPaymentMethodOptionsAcssDebit {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentPaymentMethodOptionsAcssDebit();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mandateOptions"] = this.mandateOptions ? this.mandateOptions.toJSON() : <any>undefined;
        data["setupFutureUsage"] = this.setupFutureUsage;
        data["verificationMethod"] = this.verificationMethod;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentPaymentMethodOptionsAcssDebit extends IStripeEntityOfPaymentIntentPaymentMethodOptionsAcssDebit {
    mandateOptions?: PaymentIntentPaymentMethodOptionsAcssDebitMandateOptions | undefined;
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA.
One of: none, off_session, or on_session. */
    setupFutureUsage?: string | undefined;
    /** Bank account verification method.
One of: automatic, instant, or microdeposits. */
    verificationMethod?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentPaymentMethodOptionsAcssDebitMandateOptions extends StripeEntity implements IStripeEntityOfPaymentIntentPaymentMethodOptionsAcssDebitMandateOptions {

    constructor(data?: IStripeEntityOfPaymentIntentPaymentMethodOptionsAcssDebitMandateOptions) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentPaymentMethodOptionsAcssDebitMandateOptions {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentPaymentMethodOptionsAcssDebitMandateOptions' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentPaymentMethodOptionsAcssDebitMandateOptions extends IStripeEntity {
}

export class PaymentIntentPaymentMethodOptionsAcssDebitMandateOptions extends StripeEntityOfPaymentIntentPaymentMethodOptionsAcssDebitMandateOptions implements IPaymentIntentPaymentMethodOptionsAcssDebitMandateOptions {
    /** A URL for custom mandate text. */
    customMandateUrl?: string | undefined;
    /** Description of the interval. Only required if the 'payment_schedule' parameter is
'interval' or 'combined'. */
    intervalDescription?: string | undefined;
    /** Payment schedule for the mandate.
One of: combined, interval, or sporadic. */
    paymentSchedule?: string | undefined;
    /** Transaction type of the mandate.
One of: business, or personal. */
    transactionType?: string | undefined;

    constructor(data?: IPaymentIntentPaymentMethodOptionsAcssDebitMandateOptions) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.customMandateUrl = _data["customMandateUrl"];
            this.intervalDescription = _data["intervalDescription"];
            this.paymentSchedule = _data["paymentSchedule"];
            this.transactionType = _data["transactionType"];
        }
    }

    static override fromJS(data: any): PaymentIntentPaymentMethodOptionsAcssDebitMandateOptions {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentPaymentMethodOptionsAcssDebitMandateOptions();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customMandateUrl"] = this.customMandateUrl;
        data["intervalDescription"] = this.intervalDescription;
        data["paymentSchedule"] = this.paymentSchedule;
        data["transactionType"] = this.transactionType;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentPaymentMethodOptionsAcssDebitMandateOptions extends IStripeEntityOfPaymentIntentPaymentMethodOptionsAcssDebitMandateOptions {
    /** A URL for custom mandate text. */
    customMandateUrl?: string | undefined;
    /** Description of the interval. Only required if the 'payment_schedule' parameter is
'interval' or 'combined'. */
    intervalDescription?: string | undefined;
    /** Payment schedule for the mandate.
One of: combined, interval, or sporadic. */
    paymentSchedule?: string | undefined;
    /** Transaction type of the mandate.
One of: business, or personal. */
    transactionType?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentPaymentMethodOptionsAffirm extends StripeEntity implements IStripeEntityOfPaymentIntentPaymentMethodOptionsAffirm {

    constructor(data?: IStripeEntityOfPaymentIntentPaymentMethodOptionsAffirm) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentPaymentMethodOptionsAffirm {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentPaymentMethodOptionsAffirm' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentPaymentMethodOptionsAffirm extends IStripeEntity {
}

export class PaymentIntentPaymentMethodOptionsAffirm extends StripeEntityOfPaymentIntentPaymentMethodOptionsAffirm implements IPaymentIntentPaymentMethodOptionsAffirm {
    /** Controls when the funds will be captured from the customer's account. */
    captureMethod?: string | undefined;
    /** Preferred language of the Affirm authorization page that the customer is redirected to. */
    preferredLocale?: string | undefined;
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA. */
    setupFutureUsage?: string | undefined;

    constructor(data?: IPaymentIntentPaymentMethodOptionsAffirm) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.captureMethod = _data["captureMethod"];
            this.preferredLocale = _data["preferredLocale"];
            this.setupFutureUsage = _data["setupFutureUsage"];
        }
    }

    static override fromJS(data: any): PaymentIntentPaymentMethodOptionsAffirm {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentPaymentMethodOptionsAffirm();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["captureMethod"] = this.captureMethod;
        data["preferredLocale"] = this.preferredLocale;
        data["setupFutureUsage"] = this.setupFutureUsage;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentPaymentMethodOptionsAffirm extends IStripeEntityOfPaymentIntentPaymentMethodOptionsAffirm {
    /** Controls when the funds will be captured from the customer's account. */
    captureMethod?: string | undefined;
    /** Preferred language of the Affirm authorization page that the customer is redirected to. */
    preferredLocale?: string | undefined;
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA. */
    setupFutureUsage?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentPaymentMethodOptionsAfterpayClearpay extends StripeEntity implements IStripeEntityOfPaymentIntentPaymentMethodOptionsAfterpayClearpay {

    constructor(data?: IStripeEntityOfPaymentIntentPaymentMethodOptionsAfterpayClearpay) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentPaymentMethodOptionsAfterpayClearpay {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentPaymentMethodOptionsAfterpayClearpay' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentPaymentMethodOptionsAfterpayClearpay extends IStripeEntity {
}

export class PaymentIntentPaymentMethodOptionsAfterpayClearpay extends StripeEntityOfPaymentIntentPaymentMethodOptionsAfterpayClearpay implements IPaymentIntentPaymentMethodOptionsAfterpayClearpay {
    /** Controls when the funds will be captured from the customer's account. */
    captureMethod?: string | undefined;
    /** Order identifier shown to the customer in Afterpay’s online portal. We recommend using a
value that helps you answer any questions a customer might have about the payment. The
identifier is limited to 128 characters and may contain only letters, digits,
underscores, backslashes and dashes. */
    reference?: string | undefined;
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA. */
    setupFutureUsage?: string | undefined;

    constructor(data?: IPaymentIntentPaymentMethodOptionsAfterpayClearpay) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.captureMethod = _data["captureMethod"];
            this.reference = _data["reference"];
            this.setupFutureUsage = _data["setupFutureUsage"];
        }
    }

    static override fromJS(data: any): PaymentIntentPaymentMethodOptionsAfterpayClearpay {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentPaymentMethodOptionsAfterpayClearpay();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["captureMethod"] = this.captureMethod;
        data["reference"] = this.reference;
        data["setupFutureUsage"] = this.setupFutureUsage;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentPaymentMethodOptionsAfterpayClearpay extends IStripeEntityOfPaymentIntentPaymentMethodOptionsAfterpayClearpay {
    /** Controls when the funds will be captured from the customer's account. */
    captureMethod?: string | undefined;
    /** Order identifier shown to the customer in Afterpay’s online portal. We recommend using a
value that helps you answer any questions a customer might have about the payment. The
identifier is limited to 128 characters and may contain only letters, digits,
underscores, backslashes and dashes. */
    reference?: string | undefined;
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA. */
    setupFutureUsage?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentPaymentMethodOptionsAlipay extends StripeEntity implements IStripeEntityOfPaymentIntentPaymentMethodOptionsAlipay {

    constructor(data?: IStripeEntityOfPaymentIntentPaymentMethodOptionsAlipay) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentPaymentMethodOptionsAlipay {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentPaymentMethodOptionsAlipay' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentPaymentMethodOptionsAlipay extends IStripeEntity {
}

export class PaymentIntentPaymentMethodOptionsAlipay extends StripeEntityOfPaymentIntentPaymentMethodOptionsAlipay implements IPaymentIntentPaymentMethodOptionsAlipay {
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA.
One of: none, or off_session. */
    setupFutureUsage?: string | undefined;

    constructor(data?: IPaymentIntentPaymentMethodOptionsAlipay) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.setupFutureUsage = _data["setupFutureUsage"];
        }
    }

    static override fromJS(data: any): PaymentIntentPaymentMethodOptionsAlipay {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentPaymentMethodOptionsAlipay();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setupFutureUsage"] = this.setupFutureUsage;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentPaymentMethodOptionsAlipay extends IStripeEntityOfPaymentIntentPaymentMethodOptionsAlipay {
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA.
One of: none, or off_session. */
    setupFutureUsage?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentPaymentMethodOptionsAuBecsDebit extends StripeEntity implements IStripeEntityOfPaymentIntentPaymentMethodOptionsAuBecsDebit {

    constructor(data?: IStripeEntityOfPaymentIntentPaymentMethodOptionsAuBecsDebit) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentPaymentMethodOptionsAuBecsDebit {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentPaymentMethodOptionsAuBecsDebit' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentPaymentMethodOptionsAuBecsDebit extends IStripeEntity {
}

export class PaymentIntentPaymentMethodOptionsAuBecsDebit extends StripeEntityOfPaymentIntentPaymentMethodOptionsAuBecsDebit implements IPaymentIntentPaymentMethodOptionsAuBecsDebit {
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA.
One of: none, off_session, or on_session. */
    setupFutureUsage?: string | undefined;

    constructor(data?: IPaymentIntentPaymentMethodOptionsAuBecsDebit) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.setupFutureUsage = _data["setupFutureUsage"];
        }
    }

    static override fromJS(data: any): PaymentIntentPaymentMethodOptionsAuBecsDebit {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentPaymentMethodOptionsAuBecsDebit();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setupFutureUsage"] = this.setupFutureUsage;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentPaymentMethodOptionsAuBecsDebit extends IStripeEntityOfPaymentIntentPaymentMethodOptionsAuBecsDebit {
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA.
One of: none, off_session, or on_session. */
    setupFutureUsage?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentPaymentMethodOptionsBacsDebit extends StripeEntity implements IStripeEntityOfPaymentIntentPaymentMethodOptionsBacsDebit {

    constructor(data?: IStripeEntityOfPaymentIntentPaymentMethodOptionsBacsDebit) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentPaymentMethodOptionsBacsDebit {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentPaymentMethodOptionsBacsDebit' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentPaymentMethodOptionsBacsDebit extends IStripeEntity {
}

export class PaymentIntentPaymentMethodOptionsBacsDebit extends StripeEntityOfPaymentIntentPaymentMethodOptionsBacsDebit implements IPaymentIntentPaymentMethodOptionsBacsDebit {
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA.
One of: none, off_session, or on_session. */
    setupFutureUsage?: string | undefined;

    constructor(data?: IPaymentIntentPaymentMethodOptionsBacsDebit) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.setupFutureUsage = _data["setupFutureUsage"];
        }
    }

    static override fromJS(data: any): PaymentIntentPaymentMethodOptionsBacsDebit {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentPaymentMethodOptionsBacsDebit();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setupFutureUsage"] = this.setupFutureUsage;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentPaymentMethodOptionsBacsDebit extends IStripeEntityOfPaymentIntentPaymentMethodOptionsBacsDebit {
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA.
One of: none, off_session, or on_session. */
    setupFutureUsage?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentPaymentMethodOptionsBancontact extends StripeEntity implements IStripeEntityOfPaymentIntentPaymentMethodOptionsBancontact {

    constructor(data?: IStripeEntityOfPaymentIntentPaymentMethodOptionsBancontact) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentPaymentMethodOptionsBancontact {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentPaymentMethodOptionsBancontact' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentPaymentMethodOptionsBancontact extends IStripeEntity {
}

export class PaymentIntentPaymentMethodOptionsBancontact extends StripeEntityOfPaymentIntentPaymentMethodOptionsBancontact implements IPaymentIntentPaymentMethodOptionsBancontact {
    /** Preferred language of the Bancontact authorization page that the customer is redirected
to.
One of: de, en, fr, or nl. */
    preferredLanguage?: string | undefined;
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA.
One of: none, or off_session. */
    setupFutureUsage?: string | undefined;

    constructor(data?: IPaymentIntentPaymentMethodOptionsBancontact) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.preferredLanguage = _data["preferredLanguage"];
            this.setupFutureUsage = _data["setupFutureUsage"];
        }
    }

    static override fromJS(data: any): PaymentIntentPaymentMethodOptionsBancontact {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentPaymentMethodOptionsBancontact();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["preferredLanguage"] = this.preferredLanguage;
        data["setupFutureUsage"] = this.setupFutureUsage;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentPaymentMethodOptionsBancontact extends IStripeEntityOfPaymentIntentPaymentMethodOptionsBancontact {
    /** Preferred language of the Bancontact authorization page that the customer is redirected
to.
One of: de, en, fr, or nl. */
    preferredLanguage?: string | undefined;
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA.
One of: none, or off_session. */
    setupFutureUsage?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentPaymentMethodOptionsBlik extends StripeEntity implements IStripeEntityOfPaymentIntentPaymentMethodOptionsBlik {

    constructor(data?: IStripeEntityOfPaymentIntentPaymentMethodOptionsBlik) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentPaymentMethodOptionsBlik {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentPaymentMethodOptionsBlik' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentPaymentMethodOptionsBlik extends IStripeEntity {
}

export class PaymentIntentPaymentMethodOptionsBlik extends StripeEntityOfPaymentIntentPaymentMethodOptionsBlik implements IPaymentIntentPaymentMethodOptionsBlik {

    constructor(data?: IPaymentIntentPaymentMethodOptionsBlik) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): PaymentIntentPaymentMethodOptionsBlik {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentPaymentMethodOptionsBlik();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentPaymentMethodOptionsBlik extends IStripeEntityOfPaymentIntentPaymentMethodOptionsBlik {
}

export abstract class StripeEntityOfPaymentIntentPaymentMethodOptionsBoleto extends StripeEntity implements IStripeEntityOfPaymentIntentPaymentMethodOptionsBoleto {

    constructor(data?: IStripeEntityOfPaymentIntentPaymentMethodOptionsBoleto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentPaymentMethodOptionsBoleto {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentPaymentMethodOptionsBoleto' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentPaymentMethodOptionsBoleto extends IStripeEntity {
}

export class PaymentIntentPaymentMethodOptionsBoleto extends StripeEntityOfPaymentIntentPaymentMethodOptionsBoleto implements IPaymentIntentPaymentMethodOptionsBoleto {
    /** The number of calendar days before a Boleto voucher expires. For example, if you create
a Boleto voucher on Monday and you set expires_after_days to 2, the Boleto voucher will
expire on Wednesday at 23:59 America/Sao_Paulo time. */
    expiresAfterDays?: number;
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA.
One of: none, off_session, or on_session. */
    setupFutureUsage?: string | undefined;

    constructor(data?: IPaymentIntentPaymentMethodOptionsBoleto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.expiresAfterDays = _data["expiresAfterDays"];
            this.setupFutureUsage = _data["setupFutureUsage"];
        }
    }

    static override fromJS(data: any): PaymentIntentPaymentMethodOptionsBoleto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentPaymentMethodOptionsBoleto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expiresAfterDays"] = this.expiresAfterDays;
        data["setupFutureUsage"] = this.setupFutureUsage;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentPaymentMethodOptionsBoleto extends IStripeEntityOfPaymentIntentPaymentMethodOptionsBoleto {
    /** The number of calendar days before a Boleto voucher expires. For example, if you create
a Boleto voucher on Monday and you set expires_after_days to 2, the Boleto voucher will
expire on Wednesday at 23:59 America/Sao_Paulo time. */
    expiresAfterDays?: number;
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA.
One of: none, off_session, or on_session. */
    setupFutureUsage?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentPaymentMethodOptionsCard extends StripeEntity implements IStripeEntityOfPaymentIntentPaymentMethodOptionsCard {

    constructor(data?: IStripeEntityOfPaymentIntentPaymentMethodOptionsCard) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentPaymentMethodOptionsCard {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentPaymentMethodOptionsCard' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentPaymentMethodOptionsCard extends IStripeEntity {
}

export class PaymentIntentPaymentMethodOptionsCard extends StripeEntityOfPaymentIntentPaymentMethodOptionsCard implements IPaymentIntentPaymentMethodOptionsCard {
    /** Controls when the funds will be captured from the customer's account. */
    captureMethod?: string | undefined;
    /** Installment details for this payment (Mexico only).
            
For more information, see the installments integration guide. */
    installments?: PaymentIntentPaymentMethodOptionsCardInstallments | undefined;
    /** Configuration options for setting up an eMandate for cards issued in India. */
    mandateOptions?: PaymentIntentPaymentMethodOptionsCardMandateOptions | undefined;
    /** Selected network to process this payment intent on. Depends on the available networks of
the card attached to the payment intent. Can be only set confirm-time.
One of: amex, cartes_bancaires, diners, discover,
eftpos_au, interac, jcb, mastercard, unionpay,
unknown, or visa. */
    network?: string | undefined;
    /** We strongly recommend that you rely on our SCA Engine to automatically prompt your
customers for authentication based on risk level and other requirements.
However, if you wish to request 3D Secure based on logic from your own fraud engine,
provide this option. Permitted values include: automatic or any. If not
provided, defaults to automatic. Read our guide on manually requesting 3D
Secure for more information on how this configuration interacts with Radar and our
SCA Engine.
One of: any, automatic, or challenge_only. */
    requestThreeDSecure?: string | undefined;
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA.
One of: none, off_session, or on_session. */
    setupFutureUsage?: string | undefined;
    /** Provides information about a card payment that customers see on their statements.
Concatenated with the Kana prefix (shortened Kana descriptor) or Kana statement
descriptor that’s set on the account to form the complete statement descriptor. Maximum
22 characters. On card statements, the concatenation of both prefix and suffix
(including separators) will appear truncated to 22 characters. */
    statementDescriptorSuffixKana?: string | undefined;
    /** Provides information about a card payment that customers see on their statements.
Concatenated with the Kanji prefix (shortened Kanji descriptor) or Kanji statement
descriptor that’s set on the account to form the complete statement descriptor. Maximum
17 characters. On card statements, the concatenation of both prefix and suffix
(including separators) will appear truncated to 17 characters. */
    statementDescriptorSuffixKanji?: string | undefined;

    constructor(data?: IPaymentIntentPaymentMethodOptionsCard) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.captureMethod = _data["captureMethod"];
            this.installments = _data["installments"] ? PaymentIntentPaymentMethodOptionsCardInstallments.fromJS(_data["installments"]) : <any>undefined;
            this.mandateOptions = _data["mandateOptions"] ? PaymentIntentPaymentMethodOptionsCardMandateOptions.fromJS(_data["mandateOptions"]) : <any>undefined;
            this.network = _data["network"];
            this.requestThreeDSecure = _data["requestThreeDSecure"];
            this.setupFutureUsage = _data["setupFutureUsage"];
            this.statementDescriptorSuffixKana = _data["statementDescriptorSuffixKana"];
            this.statementDescriptorSuffixKanji = _data["statementDescriptorSuffixKanji"];
        }
    }

    static override fromJS(data: any): PaymentIntentPaymentMethodOptionsCard {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentPaymentMethodOptionsCard();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["captureMethod"] = this.captureMethod;
        data["installments"] = this.installments ? this.installments.toJSON() : <any>undefined;
        data["mandateOptions"] = this.mandateOptions ? this.mandateOptions.toJSON() : <any>undefined;
        data["network"] = this.network;
        data["requestThreeDSecure"] = this.requestThreeDSecure;
        data["setupFutureUsage"] = this.setupFutureUsage;
        data["statementDescriptorSuffixKana"] = this.statementDescriptorSuffixKana;
        data["statementDescriptorSuffixKanji"] = this.statementDescriptorSuffixKanji;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentPaymentMethodOptionsCard extends IStripeEntityOfPaymentIntentPaymentMethodOptionsCard {
    /** Controls when the funds will be captured from the customer's account. */
    captureMethod?: string | undefined;
    /** Installment details for this payment (Mexico only).
            
For more information, see the installments integration guide. */
    installments?: PaymentIntentPaymentMethodOptionsCardInstallments | undefined;
    /** Configuration options for setting up an eMandate for cards issued in India. */
    mandateOptions?: PaymentIntentPaymentMethodOptionsCardMandateOptions | undefined;
    /** Selected network to process this payment intent on. Depends on the available networks of
the card attached to the payment intent. Can be only set confirm-time.
One of: amex, cartes_bancaires, diners, discover,
eftpos_au, interac, jcb, mastercard, unionpay,
unknown, or visa. */
    network?: string | undefined;
    /** We strongly recommend that you rely on our SCA Engine to automatically prompt your
customers for authentication based on risk level and other requirements.
However, if you wish to request 3D Secure based on logic from your own fraud engine,
provide this option. Permitted values include: automatic or any. If not
provided, defaults to automatic. Read our guide on manually requesting 3D
Secure for more information on how this configuration interacts with Radar and our
SCA Engine.
One of: any, automatic, or challenge_only. */
    requestThreeDSecure?: string | undefined;
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA.
One of: none, off_session, or on_session. */
    setupFutureUsage?: string | undefined;
    /** Provides information about a card payment that customers see on their statements.
Concatenated with the Kana prefix (shortened Kana descriptor) or Kana statement
descriptor that’s set on the account to form the complete statement descriptor. Maximum
22 characters. On card statements, the concatenation of both prefix and suffix
(including separators) will appear truncated to 22 characters. */
    statementDescriptorSuffixKana?: string | undefined;
    /** Provides information about a card payment that customers see on their statements.
Concatenated with the Kanji prefix (shortened Kanji descriptor) or Kanji statement
descriptor that’s set on the account to form the complete statement descriptor. Maximum
17 characters. On card statements, the concatenation of both prefix and suffix
(including separators) will appear truncated to 17 characters. */
    statementDescriptorSuffixKanji?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentPaymentMethodOptionsCardInstallments extends StripeEntity implements IStripeEntityOfPaymentIntentPaymentMethodOptionsCardInstallments {

    constructor(data?: IStripeEntityOfPaymentIntentPaymentMethodOptionsCardInstallments) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentPaymentMethodOptionsCardInstallments {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentPaymentMethodOptionsCardInstallments' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentPaymentMethodOptionsCardInstallments extends IStripeEntity {
}

export class PaymentIntentPaymentMethodOptionsCardInstallments extends StripeEntityOfPaymentIntentPaymentMethodOptionsCardInstallments implements IPaymentIntentPaymentMethodOptionsCardInstallments {
    /** Installment plans that may be selected for this PaymentIntent. */
    availablePlans?: PaymentIntentPaymentMethodOptionsCardInstallmentsPlan[] | undefined;
    /** Whether Installments are enabled for this PaymentIntent. */
    enabled?: boolean;
    /** Installment plan selected for this PaymentIntent. */
    plan?: PaymentIntentPaymentMethodOptionsCardInstallmentsPlan | undefined;

    constructor(data?: IPaymentIntentPaymentMethodOptionsCardInstallments) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["availablePlans"])) {
                this.availablePlans = [] as any;
                for (let item of _data["availablePlans"])
                    this.availablePlans!.push(PaymentIntentPaymentMethodOptionsCardInstallmentsPlan.fromJS(item));
            }
            this.enabled = _data["enabled"];
            this.plan = _data["plan"] ? PaymentIntentPaymentMethodOptionsCardInstallmentsPlan.fromJS(_data["plan"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): PaymentIntentPaymentMethodOptionsCardInstallments {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentPaymentMethodOptionsCardInstallments();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.availablePlans)) {
            data["availablePlans"] = [];
            for (let item of this.availablePlans)
                data["availablePlans"].push(item.toJSON());
        }
        data["enabled"] = this.enabled;
        data["plan"] = this.plan ? this.plan.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentPaymentMethodOptionsCardInstallments extends IStripeEntityOfPaymentIntentPaymentMethodOptionsCardInstallments {
    /** Installment plans that may be selected for this PaymentIntent. */
    availablePlans?: PaymentIntentPaymentMethodOptionsCardInstallmentsPlan[] | undefined;
    /** Whether Installments are enabled for this PaymentIntent. */
    enabled?: boolean;
    /** Installment plan selected for this PaymentIntent. */
    plan?: PaymentIntentPaymentMethodOptionsCardInstallmentsPlan | undefined;
}

export abstract class StripeEntityOfPaymentIntentPaymentMethodOptionsCardInstallmentsPlan extends StripeEntity implements IStripeEntityOfPaymentIntentPaymentMethodOptionsCardInstallmentsPlan {

    constructor(data?: IStripeEntityOfPaymentIntentPaymentMethodOptionsCardInstallmentsPlan) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentPaymentMethodOptionsCardInstallmentsPlan {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentPaymentMethodOptionsCardInstallmentsPlan' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentPaymentMethodOptionsCardInstallmentsPlan extends IStripeEntity {
}

export class PaymentIntentPaymentMethodOptionsCardInstallmentsPlan extends StripeEntityOfPaymentIntentPaymentMethodOptionsCardInstallmentsPlan implements IPaymentIntentPaymentMethodOptionsCardInstallmentsPlan {
    /** For fixed_count installment plans, this is the number of installment payments
your customer will make to their credit card. */
    count?: number | undefined;
    /** For fixed_count installment plans, this is the interval between installment
payments your customer will make to their credit card. One of month. */
    interval?: string | undefined;
    /** Type of installment plan, one of fixed_count. */
    type?: string | undefined;

    constructor(data?: IPaymentIntentPaymentMethodOptionsCardInstallmentsPlan) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.count = _data["count"];
            this.interval = _data["interval"];
            this.type = _data["type"];
        }
    }

    static override fromJS(data: any): PaymentIntentPaymentMethodOptionsCardInstallmentsPlan {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentPaymentMethodOptionsCardInstallmentsPlan();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        data["interval"] = this.interval;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentPaymentMethodOptionsCardInstallmentsPlan extends IStripeEntityOfPaymentIntentPaymentMethodOptionsCardInstallmentsPlan {
    /** For fixed_count installment plans, this is the number of installment payments
your customer will make to their credit card. */
    count?: number | undefined;
    /** For fixed_count installment plans, this is the interval between installment
payments your customer will make to their credit card. One of month. */
    interval?: string | undefined;
    /** Type of installment plan, one of fixed_count. */
    type?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentPaymentMethodOptionsCardMandateOptions extends StripeEntity implements IStripeEntityOfPaymentIntentPaymentMethodOptionsCardMandateOptions {

    constructor(data?: IStripeEntityOfPaymentIntentPaymentMethodOptionsCardMandateOptions) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentPaymentMethodOptionsCardMandateOptions {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentPaymentMethodOptionsCardMandateOptions' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentPaymentMethodOptionsCardMandateOptions extends IStripeEntity {
}

export class PaymentIntentPaymentMethodOptionsCardMandateOptions extends StripeEntityOfPaymentIntentPaymentMethodOptionsCardMandateOptions implements IPaymentIntentPaymentMethodOptionsCardMandateOptions {
    /** Amount to be charged for future payments. */
    amount?: number;
    /** One of fixed or maximum. If fixed, the amount param refers
to the exact amount to be charged in future payments. If maximum, the amount
charged can be up to the value passed for the amount param.
One of: fixed, or maximum. */
    amountType?: string | undefined;
    /** A description of the mandate or subscription that is meant to be displayed to the
customer. */
    description?: string | undefined;
    /** End date of the mandate or subscription. If not provided, the mandate will be active
until canceled. If provided, end date should be after start date. */
    endDate?: Date | undefined;
    /** Specifies payment frequency. One of day, week, month, year,
or sporadic.
One of: day, month, sporadic, week, or year. */
    interval?: string | undefined;
    /** The number of intervals between payments. For example, interval=month and
interval_count=3 indicates one payment every three months. Maximum of one year
interval allowed (1 year, 12 months, or 52 weeks). This parameter is optional when
interval=sporadic. */
    intervalCount?: number | undefined;
    /** Unique identifier for the mandate or subscription. */
    reference?: string | undefined;
    /** Start date of the mandate or subscription. Start date should not be lesser than
yesterday. */
    startDate?: Date;
    /** Specifies the type of mandates supported. Possible values are india. */
    supportedTypes?: string[] | undefined;

    constructor(data?: IPaymentIntentPaymentMethodOptionsCardMandateOptions) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.amount = _data["amount"];
            this.amountType = _data["amountType"];
            this.description = _data["description"];
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.interval = _data["interval"];
            this.intervalCount = _data["intervalCount"];
            this.reference = _data["reference"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["supportedTypes"])) {
                this.supportedTypes = [] as any;
                for (let item of _data["supportedTypes"])
                    this.supportedTypes!.push(item);
            }
        }
    }

    static override fromJS(data: any): PaymentIntentPaymentMethodOptionsCardMandateOptions {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentPaymentMethodOptionsCardMandateOptions();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["amountType"] = this.amountType;
        data["description"] = this.description;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["interval"] = this.interval;
        data["intervalCount"] = this.intervalCount;
        data["reference"] = this.reference;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        if (Array.isArray(this.supportedTypes)) {
            data["supportedTypes"] = [];
            for (let item of this.supportedTypes)
                data["supportedTypes"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentPaymentMethodOptionsCardMandateOptions extends IStripeEntityOfPaymentIntentPaymentMethodOptionsCardMandateOptions {
    /** Amount to be charged for future payments. */
    amount?: number;
    /** One of fixed or maximum. If fixed, the amount param refers
to the exact amount to be charged in future payments. If maximum, the amount
charged can be up to the value passed for the amount param.
One of: fixed, or maximum. */
    amountType?: string | undefined;
    /** A description of the mandate or subscription that is meant to be displayed to the
customer. */
    description?: string | undefined;
    /** End date of the mandate or subscription. If not provided, the mandate will be active
until canceled. If provided, end date should be after start date. */
    endDate?: Date | undefined;
    /** Specifies payment frequency. One of day, week, month, year,
or sporadic.
One of: day, month, sporadic, week, or year. */
    interval?: string | undefined;
    /** The number of intervals between payments. For example, interval=month and
interval_count=3 indicates one payment every three months. Maximum of one year
interval allowed (1 year, 12 months, or 52 weeks). This parameter is optional when
interval=sporadic. */
    intervalCount?: number | undefined;
    /** Unique identifier for the mandate or subscription. */
    reference?: string | undefined;
    /** Start date of the mandate or subscription. Start date should not be lesser than
yesterday. */
    startDate?: Date;
    /** Specifies the type of mandates supported. Possible values are india. */
    supportedTypes?: string[] | undefined;
}

export abstract class StripeEntityOfPaymentIntentPaymentMethodOptionsCardPresent extends StripeEntity implements IStripeEntityOfPaymentIntentPaymentMethodOptionsCardPresent {

    constructor(data?: IStripeEntityOfPaymentIntentPaymentMethodOptionsCardPresent) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentPaymentMethodOptionsCardPresent {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentPaymentMethodOptionsCardPresent' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentPaymentMethodOptionsCardPresent extends IStripeEntity {
}

export class PaymentIntentPaymentMethodOptionsCardPresent extends StripeEntityOfPaymentIntentPaymentMethodOptionsCardPresent implements IPaymentIntentPaymentMethodOptionsCardPresent {
    /** Request ability to capture this payment beyond the standard authorization
validity window. */
    requestExtendedAuthorization?: boolean | undefined;
    /** Request ability to increment
this PaymentIntent if the combination of MCC and card brand is eligible. Check incremental_authorization_supported
in the Confirm
response to verify support. */
    requestIncrementalAuthorizationSupport?: boolean | undefined;

    constructor(data?: IPaymentIntentPaymentMethodOptionsCardPresent) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.requestExtendedAuthorization = _data["requestExtendedAuthorization"];
            this.requestIncrementalAuthorizationSupport = _data["requestIncrementalAuthorizationSupport"];
        }
    }

    static override fromJS(data: any): PaymentIntentPaymentMethodOptionsCardPresent {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentPaymentMethodOptionsCardPresent();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestExtendedAuthorization"] = this.requestExtendedAuthorization;
        data["requestIncrementalAuthorizationSupport"] = this.requestIncrementalAuthorizationSupport;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentPaymentMethodOptionsCardPresent extends IStripeEntityOfPaymentIntentPaymentMethodOptionsCardPresent {
    /** Request ability to capture this payment beyond the standard authorization
validity window. */
    requestExtendedAuthorization?: boolean | undefined;
    /** Request ability to increment
this PaymentIntent if the combination of MCC and card brand is eligible. Check incremental_authorization_supported
in the Confirm
response to verify support. */
    requestIncrementalAuthorizationSupport?: boolean | undefined;
}

export abstract class StripeEntityOfPaymentIntentPaymentMethodOptionsCashapp extends StripeEntity implements IStripeEntityOfPaymentIntentPaymentMethodOptionsCashapp {

    constructor(data?: IStripeEntityOfPaymentIntentPaymentMethodOptionsCashapp) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentPaymentMethodOptionsCashapp {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentPaymentMethodOptionsCashapp' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentPaymentMethodOptionsCashapp extends IStripeEntity {
}

export class PaymentIntentPaymentMethodOptionsCashapp extends StripeEntityOfPaymentIntentPaymentMethodOptionsCashapp implements IPaymentIntentPaymentMethodOptionsCashapp {
    /** Controls when the funds will be captured from the customer's account. */
    captureMethod?: string | undefined;
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA.
One of: none, off_session, or on_session. */
    setupFutureUsage?: string | undefined;

    constructor(data?: IPaymentIntentPaymentMethodOptionsCashapp) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.captureMethod = _data["captureMethod"];
            this.setupFutureUsage = _data["setupFutureUsage"];
        }
    }

    static override fromJS(data: any): PaymentIntentPaymentMethodOptionsCashapp {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentPaymentMethodOptionsCashapp();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["captureMethod"] = this.captureMethod;
        data["setupFutureUsage"] = this.setupFutureUsage;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentPaymentMethodOptionsCashapp extends IStripeEntityOfPaymentIntentPaymentMethodOptionsCashapp {
    /** Controls when the funds will be captured from the customer's account. */
    captureMethod?: string | undefined;
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA.
One of: none, off_session, or on_session. */
    setupFutureUsage?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentPaymentMethodOptionsCustomerBalance extends StripeEntity implements IStripeEntityOfPaymentIntentPaymentMethodOptionsCustomerBalance {

    constructor(data?: IStripeEntityOfPaymentIntentPaymentMethodOptionsCustomerBalance) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentPaymentMethodOptionsCustomerBalance {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentPaymentMethodOptionsCustomerBalance' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentPaymentMethodOptionsCustomerBalance extends IStripeEntity {
}

export class PaymentIntentPaymentMethodOptionsCustomerBalance extends StripeEntityOfPaymentIntentPaymentMethodOptionsCustomerBalance implements IPaymentIntentPaymentMethodOptionsCustomerBalance {
    bankTransfer?: PaymentIntentPaymentMethodOptionsCustomerBalanceBankTransfer | undefined;
    /** The funding method type to be used when there are not enough funds in the customer
balance. Permitted values include: bank_transfer. */
    fundingType?: string | undefined;
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA. */
    setupFutureUsage?: string | undefined;

    constructor(data?: IPaymentIntentPaymentMethodOptionsCustomerBalance) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.bankTransfer = _data["bankTransfer"] ? PaymentIntentPaymentMethodOptionsCustomerBalanceBankTransfer.fromJS(_data["bankTransfer"]) : <any>undefined;
            this.fundingType = _data["fundingType"];
            this.setupFutureUsage = _data["setupFutureUsage"];
        }
    }

    static override fromJS(data: any): PaymentIntentPaymentMethodOptionsCustomerBalance {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentPaymentMethodOptionsCustomerBalance();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankTransfer"] = this.bankTransfer ? this.bankTransfer.toJSON() : <any>undefined;
        data["fundingType"] = this.fundingType;
        data["setupFutureUsage"] = this.setupFutureUsage;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentPaymentMethodOptionsCustomerBalance extends IStripeEntityOfPaymentIntentPaymentMethodOptionsCustomerBalance {
    bankTransfer?: PaymentIntentPaymentMethodOptionsCustomerBalanceBankTransfer | undefined;
    /** The funding method type to be used when there are not enough funds in the customer
balance. Permitted values include: bank_transfer. */
    fundingType?: string | undefined;
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA. */
    setupFutureUsage?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentPaymentMethodOptionsCustomerBalanceBankTransfer extends StripeEntity implements IStripeEntityOfPaymentIntentPaymentMethodOptionsCustomerBalanceBankTransfer {

    constructor(data?: IStripeEntityOfPaymentIntentPaymentMethodOptionsCustomerBalanceBankTransfer) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentPaymentMethodOptionsCustomerBalanceBankTransfer {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentPaymentMethodOptionsCustomerBalanceBankTransfer' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentPaymentMethodOptionsCustomerBalanceBankTransfer extends IStripeEntity {
}

export class PaymentIntentPaymentMethodOptionsCustomerBalanceBankTransfer extends StripeEntityOfPaymentIntentPaymentMethodOptionsCustomerBalanceBankTransfer implements IPaymentIntentPaymentMethodOptionsCustomerBalanceBankTransfer {
    euBankTransfer?: PaymentIntentPaymentMethodOptionsCustomerBalanceBankTransferEuBankTransfer | undefined;
    /** List of address types that should be returned in the financial_addresses response. If
not specified, all valid types will be returned.
            
Permitted values include: sort_code, zengin, iban, or spei. */
    requestedAddressTypes?: string[] | undefined;
    /** The bank transfer type that this PaymentIntent is allowed to use for funding Permitted
values include: eu_bank_transfer, gb_bank_transfer,
jp_bank_transfer, or mx_bank_transfer.
One of: eu_bank_transfer, gb_bank_transfer, jp_bank_transfer, or
mx_bank_transfer. */
    type?: string | undefined;

    constructor(data?: IPaymentIntentPaymentMethodOptionsCustomerBalanceBankTransfer) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.euBankTransfer = _data["euBankTransfer"] ? PaymentIntentPaymentMethodOptionsCustomerBalanceBankTransferEuBankTransfer.fromJS(_data["euBankTransfer"]) : <any>undefined;
            if (Array.isArray(_data["requestedAddressTypes"])) {
                this.requestedAddressTypes = [] as any;
                for (let item of _data["requestedAddressTypes"])
                    this.requestedAddressTypes!.push(item);
            }
            this.type = _data["type"];
        }
    }

    static override fromJS(data: any): PaymentIntentPaymentMethodOptionsCustomerBalanceBankTransfer {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentPaymentMethodOptionsCustomerBalanceBankTransfer();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["euBankTransfer"] = this.euBankTransfer ? this.euBankTransfer.toJSON() : <any>undefined;
        if (Array.isArray(this.requestedAddressTypes)) {
            data["requestedAddressTypes"] = [];
            for (let item of this.requestedAddressTypes)
                data["requestedAddressTypes"].push(item);
        }
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentPaymentMethodOptionsCustomerBalanceBankTransfer extends IStripeEntityOfPaymentIntentPaymentMethodOptionsCustomerBalanceBankTransfer {
    euBankTransfer?: PaymentIntentPaymentMethodOptionsCustomerBalanceBankTransferEuBankTransfer | undefined;
    /** List of address types that should be returned in the financial_addresses response. If
not specified, all valid types will be returned.
            
Permitted values include: sort_code, zengin, iban, or spei. */
    requestedAddressTypes?: string[] | undefined;
    /** The bank transfer type that this PaymentIntent is allowed to use for funding Permitted
values include: eu_bank_transfer, gb_bank_transfer,
jp_bank_transfer, or mx_bank_transfer.
One of: eu_bank_transfer, gb_bank_transfer, jp_bank_transfer, or
mx_bank_transfer. */
    type?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentPaymentMethodOptionsCustomerBalanceBankTransferEuBankTransfer extends StripeEntity implements IStripeEntityOfPaymentIntentPaymentMethodOptionsCustomerBalanceBankTransferEuBankTransfer {

    constructor(data?: IStripeEntityOfPaymentIntentPaymentMethodOptionsCustomerBalanceBankTransferEuBankTransfer) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentPaymentMethodOptionsCustomerBalanceBankTransferEuBankTransfer {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentPaymentMethodOptionsCustomerBalanceBankTransferEuBankTransfer' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentPaymentMethodOptionsCustomerBalanceBankTransferEuBankTransfer extends IStripeEntity {
}

export class PaymentIntentPaymentMethodOptionsCustomerBalanceBankTransferEuBankTransfer extends StripeEntityOfPaymentIntentPaymentMethodOptionsCustomerBalanceBankTransferEuBankTransfer implements IPaymentIntentPaymentMethodOptionsCustomerBalanceBankTransferEuBankTransfer {
    /** The desired country code of the bank account information. Permitted values include:
BE, DE, ES, FR, IE, or NL.
One of: BE, DE, ES, FR, IE, or NL. */
    country?: string | undefined;

    constructor(data?: IPaymentIntentPaymentMethodOptionsCustomerBalanceBankTransferEuBankTransfer) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.country = _data["country"];
        }
    }

    static override fromJS(data: any): PaymentIntentPaymentMethodOptionsCustomerBalanceBankTransferEuBankTransfer {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentPaymentMethodOptionsCustomerBalanceBankTransferEuBankTransfer();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["country"] = this.country;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentPaymentMethodOptionsCustomerBalanceBankTransferEuBankTransfer extends IStripeEntityOfPaymentIntentPaymentMethodOptionsCustomerBalanceBankTransferEuBankTransfer {
    /** The desired country code of the bank account information. Permitted values include:
BE, DE, ES, FR, IE, or NL.
One of: BE, DE, ES, FR, IE, or NL. */
    country?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentPaymentMethodOptionsEps extends StripeEntity implements IStripeEntityOfPaymentIntentPaymentMethodOptionsEps {

    constructor(data?: IStripeEntityOfPaymentIntentPaymentMethodOptionsEps) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentPaymentMethodOptionsEps {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentPaymentMethodOptionsEps' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentPaymentMethodOptionsEps extends IStripeEntity {
}

export class PaymentIntentPaymentMethodOptionsEps extends StripeEntityOfPaymentIntentPaymentMethodOptionsEps implements IPaymentIntentPaymentMethodOptionsEps {
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA. */
    setupFutureUsage?: string | undefined;

    constructor(data?: IPaymentIntentPaymentMethodOptionsEps) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.setupFutureUsage = _data["setupFutureUsage"];
        }
    }

    static override fromJS(data: any): PaymentIntentPaymentMethodOptionsEps {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentPaymentMethodOptionsEps();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setupFutureUsage"] = this.setupFutureUsage;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentPaymentMethodOptionsEps extends IStripeEntityOfPaymentIntentPaymentMethodOptionsEps {
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA. */
    setupFutureUsage?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentPaymentMethodOptionsFpx extends StripeEntity implements IStripeEntityOfPaymentIntentPaymentMethodOptionsFpx {

    constructor(data?: IStripeEntityOfPaymentIntentPaymentMethodOptionsFpx) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentPaymentMethodOptionsFpx {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentPaymentMethodOptionsFpx' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentPaymentMethodOptionsFpx extends IStripeEntity {
}

export class PaymentIntentPaymentMethodOptionsFpx extends StripeEntityOfPaymentIntentPaymentMethodOptionsFpx implements IPaymentIntentPaymentMethodOptionsFpx {
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA. */
    setupFutureUsage?: string | undefined;

    constructor(data?: IPaymentIntentPaymentMethodOptionsFpx) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.setupFutureUsage = _data["setupFutureUsage"];
        }
    }

    static override fromJS(data: any): PaymentIntentPaymentMethodOptionsFpx {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentPaymentMethodOptionsFpx();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setupFutureUsage"] = this.setupFutureUsage;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentPaymentMethodOptionsFpx extends IStripeEntityOfPaymentIntentPaymentMethodOptionsFpx {
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA. */
    setupFutureUsage?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentPaymentMethodOptionsGiropay extends StripeEntity implements IStripeEntityOfPaymentIntentPaymentMethodOptionsGiropay {

    constructor(data?: IStripeEntityOfPaymentIntentPaymentMethodOptionsGiropay) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentPaymentMethodOptionsGiropay {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentPaymentMethodOptionsGiropay' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentPaymentMethodOptionsGiropay extends IStripeEntity {
}

export class PaymentIntentPaymentMethodOptionsGiropay extends StripeEntityOfPaymentIntentPaymentMethodOptionsGiropay implements IPaymentIntentPaymentMethodOptionsGiropay {
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA. */
    setupFutureUsage?: string | undefined;

    constructor(data?: IPaymentIntentPaymentMethodOptionsGiropay) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.setupFutureUsage = _data["setupFutureUsage"];
        }
    }

    static override fromJS(data: any): PaymentIntentPaymentMethodOptionsGiropay {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentPaymentMethodOptionsGiropay();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setupFutureUsage"] = this.setupFutureUsage;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentPaymentMethodOptionsGiropay extends IStripeEntityOfPaymentIntentPaymentMethodOptionsGiropay {
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA. */
    setupFutureUsage?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentPaymentMethodOptionsGrabpay extends StripeEntity implements IStripeEntityOfPaymentIntentPaymentMethodOptionsGrabpay {

    constructor(data?: IStripeEntityOfPaymentIntentPaymentMethodOptionsGrabpay) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentPaymentMethodOptionsGrabpay {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentPaymentMethodOptionsGrabpay' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentPaymentMethodOptionsGrabpay extends IStripeEntity {
}

export class PaymentIntentPaymentMethodOptionsGrabpay extends StripeEntityOfPaymentIntentPaymentMethodOptionsGrabpay implements IPaymentIntentPaymentMethodOptionsGrabpay {
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA. */
    setupFutureUsage?: string | undefined;

    constructor(data?: IPaymentIntentPaymentMethodOptionsGrabpay) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.setupFutureUsage = _data["setupFutureUsage"];
        }
    }

    static override fromJS(data: any): PaymentIntentPaymentMethodOptionsGrabpay {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentPaymentMethodOptionsGrabpay();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setupFutureUsage"] = this.setupFutureUsage;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentPaymentMethodOptionsGrabpay extends IStripeEntityOfPaymentIntentPaymentMethodOptionsGrabpay {
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA. */
    setupFutureUsage?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentPaymentMethodOptionsIdeal extends StripeEntity implements IStripeEntityOfPaymentIntentPaymentMethodOptionsIdeal {

    constructor(data?: IStripeEntityOfPaymentIntentPaymentMethodOptionsIdeal) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentPaymentMethodOptionsIdeal {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentPaymentMethodOptionsIdeal' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentPaymentMethodOptionsIdeal extends IStripeEntity {
}

export class PaymentIntentPaymentMethodOptionsIdeal extends StripeEntityOfPaymentIntentPaymentMethodOptionsIdeal implements IPaymentIntentPaymentMethodOptionsIdeal {
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA.
One of: none, or off_session. */
    setupFutureUsage?: string | undefined;

    constructor(data?: IPaymentIntentPaymentMethodOptionsIdeal) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.setupFutureUsage = _data["setupFutureUsage"];
        }
    }

    static override fromJS(data: any): PaymentIntentPaymentMethodOptionsIdeal {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentPaymentMethodOptionsIdeal();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setupFutureUsage"] = this.setupFutureUsage;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentPaymentMethodOptionsIdeal extends IStripeEntityOfPaymentIntentPaymentMethodOptionsIdeal {
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA.
One of: none, or off_session. */
    setupFutureUsage?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentPaymentMethodOptionsInteracPresent extends StripeEntity implements IStripeEntityOfPaymentIntentPaymentMethodOptionsInteracPresent {

    constructor(data?: IStripeEntityOfPaymentIntentPaymentMethodOptionsInteracPresent) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentPaymentMethodOptionsInteracPresent {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentPaymentMethodOptionsInteracPresent' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentPaymentMethodOptionsInteracPresent extends IStripeEntity {
}

export class PaymentIntentPaymentMethodOptionsInteracPresent extends StripeEntityOfPaymentIntentPaymentMethodOptionsInteracPresent implements IPaymentIntentPaymentMethodOptionsInteracPresent {

    constructor(data?: IPaymentIntentPaymentMethodOptionsInteracPresent) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): PaymentIntentPaymentMethodOptionsInteracPresent {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentPaymentMethodOptionsInteracPresent();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentPaymentMethodOptionsInteracPresent extends IStripeEntityOfPaymentIntentPaymentMethodOptionsInteracPresent {
}

export abstract class StripeEntityOfPaymentIntentPaymentMethodOptionsKlarna extends StripeEntity implements IStripeEntityOfPaymentIntentPaymentMethodOptionsKlarna {

    constructor(data?: IStripeEntityOfPaymentIntentPaymentMethodOptionsKlarna) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentPaymentMethodOptionsKlarna {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentPaymentMethodOptionsKlarna' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentPaymentMethodOptionsKlarna extends IStripeEntity {
}

export class PaymentIntentPaymentMethodOptionsKlarna extends StripeEntityOfPaymentIntentPaymentMethodOptionsKlarna implements IPaymentIntentPaymentMethodOptionsKlarna {
    /** Controls when the funds will be captured from the customer's account. */
    captureMethod?: string | undefined;
    /** Preferred locale of the Klarna checkout page that the customer is redirected to. */
    preferredLocale?: string | undefined;
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA. */
    setupFutureUsage?: string | undefined;

    constructor(data?: IPaymentIntentPaymentMethodOptionsKlarna) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.captureMethod = _data["captureMethod"];
            this.preferredLocale = _data["preferredLocale"];
            this.setupFutureUsage = _data["setupFutureUsage"];
        }
    }

    static override fromJS(data: any): PaymentIntentPaymentMethodOptionsKlarna {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentPaymentMethodOptionsKlarna();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["captureMethod"] = this.captureMethod;
        data["preferredLocale"] = this.preferredLocale;
        data["setupFutureUsage"] = this.setupFutureUsage;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentPaymentMethodOptionsKlarna extends IStripeEntityOfPaymentIntentPaymentMethodOptionsKlarna {
    /** Controls when the funds will be captured from the customer's account. */
    captureMethod?: string | undefined;
    /** Preferred locale of the Klarna checkout page that the customer is redirected to. */
    preferredLocale?: string | undefined;
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA. */
    setupFutureUsage?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentPaymentMethodOptionsKonbini extends StripeEntity implements IStripeEntityOfPaymentIntentPaymentMethodOptionsKonbini {

    constructor(data?: IStripeEntityOfPaymentIntentPaymentMethodOptionsKonbini) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentPaymentMethodOptionsKonbini {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentPaymentMethodOptionsKonbini' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentPaymentMethodOptionsKonbini extends IStripeEntity {
}

export class PaymentIntentPaymentMethodOptionsKonbini extends StripeEntityOfPaymentIntentPaymentMethodOptionsKonbini implements IPaymentIntentPaymentMethodOptionsKonbini {
    /** An optional 10 to 11 digit numeric-only string determining the confirmation code at
applicable convenience stores. */
    confirmationNumber?: string | undefined;
    /** The number of calendar days (between 1 and 60) after which Konbini payment instructions
will expire. For example, if a PaymentIntent is confirmed with Konbini and
expires_after_days set to 2 on Monday JST, the instructions will expire on
Wednesday 23:59:59 JST. */
    expiresAfterDays?: number | undefined;
    /** The timestamp at which the Konbini payment instructions will expire. Only one of
expires_after_days or expires_at may be set. */
    expiresAt?: Date | undefined;
    /** A product descriptor of up to 22 characters, which will appear to customers at the
convenience store. */
    productDescription?: string | undefined;
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA. */
    setupFutureUsage?: string | undefined;

    constructor(data?: IPaymentIntentPaymentMethodOptionsKonbini) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.confirmationNumber = _data["confirmationNumber"];
            this.expiresAfterDays = _data["expiresAfterDays"];
            this.expiresAt = _data["expiresAt"] ? new Date(_data["expiresAt"].toString()) : <any>undefined;
            this.productDescription = _data["productDescription"];
            this.setupFutureUsage = _data["setupFutureUsage"];
        }
    }

    static override fromJS(data: any): PaymentIntentPaymentMethodOptionsKonbini {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentPaymentMethodOptionsKonbini();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["confirmationNumber"] = this.confirmationNumber;
        data["expiresAfterDays"] = this.expiresAfterDays;
        data["expiresAt"] = this.expiresAt ? this.expiresAt.toISOString() : <any>undefined;
        data["productDescription"] = this.productDescription;
        data["setupFutureUsage"] = this.setupFutureUsage;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentPaymentMethodOptionsKonbini extends IStripeEntityOfPaymentIntentPaymentMethodOptionsKonbini {
    /** An optional 10 to 11 digit numeric-only string determining the confirmation code at
applicable convenience stores. */
    confirmationNumber?: string | undefined;
    /** The number of calendar days (between 1 and 60) after which Konbini payment instructions
will expire. For example, if a PaymentIntent is confirmed with Konbini and
expires_after_days set to 2 on Monday JST, the instructions will expire on
Wednesday 23:59:59 JST. */
    expiresAfterDays?: number | undefined;
    /** The timestamp at which the Konbini payment instructions will expire. Only one of
expires_after_days or expires_at may be set. */
    expiresAt?: Date | undefined;
    /** A product descriptor of up to 22 characters, which will appear to customers at the
convenience store. */
    productDescription?: string | undefined;
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA. */
    setupFutureUsage?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentPaymentMethodOptionsLink extends StripeEntity implements IStripeEntityOfPaymentIntentPaymentMethodOptionsLink {

    constructor(data?: IStripeEntityOfPaymentIntentPaymentMethodOptionsLink) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentPaymentMethodOptionsLink {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentPaymentMethodOptionsLink' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentPaymentMethodOptionsLink extends IStripeEntity {
}

export class PaymentIntentPaymentMethodOptionsLink extends StripeEntityOfPaymentIntentPaymentMethodOptionsLink implements IPaymentIntentPaymentMethodOptionsLink {
    /** Controls when the funds will be captured from the customer's account. */
    captureMethod?: string | undefined;
    /** Token used for persistent Link logins. */
    persistentToken?: string | undefined;
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA.
One of: none, or off_session. */
    setupFutureUsage?: string | undefined;

    constructor(data?: IPaymentIntentPaymentMethodOptionsLink) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.captureMethod = _data["captureMethod"];
            this.persistentToken = _data["persistentToken"];
            this.setupFutureUsage = _data["setupFutureUsage"];
        }
    }

    static override fromJS(data: any): PaymentIntentPaymentMethodOptionsLink {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentPaymentMethodOptionsLink();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["captureMethod"] = this.captureMethod;
        data["persistentToken"] = this.persistentToken;
        data["setupFutureUsage"] = this.setupFutureUsage;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentPaymentMethodOptionsLink extends IStripeEntityOfPaymentIntentPaymentMethodOptionsLink {
    /** Controls when the funds will be captured from the customer's account. */
    captureMethod?: string | undefined;
    /** Token used for persistent Link logins. */
    persistentToken?: string | undefined;
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA.
One of: none, or off_session. */
    setupFutureUsage?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentPaymentMethodOptionsOxxo extends StripeEntity implements IStripeEntityOfPaymentIntentPaymentMethodOptionsOxxo {

    constructor(data?: IStripeEntityOfPaymentIntentPaymentMethodOptionsOxxo) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentPaymentMethodOptionsOxxo {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentPaymentMethodOptionsOxxo' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentPaymentMethodOptionsOxxo extends IStripeEntity {
}

export class PaymentIntentPaymentMethodOptionsOxxo extends StripeEntityOfPaymentIntentPaymentMethodOptionsOxxo implements IPaymentIntentPaymentMethodOptionsOxxo {
    /** The number of calendar days before an OXXO invoice expires. For example, if you create
an OXXO invoice on Monday and you set expires_after_days to 2, the OXXO invoice will
expire on Wednesday at 23:59 America/Mexico_City time. */
    expiresAfterDays?: number;
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA. */
    setupFutureUsage?: string | undefined;

    constructor(data?: IPaymentIntentPaymentMethodOptionsOxxo) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.expiresAfterDays = _data["expiresAfterDays"];
            this.setupFutureUsage = _data["setupFutureUsage"];
        }
    }

    static override fromJS(data: any): PaymentIntentPaymentMethodOptionsOxxo {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentPaymentMethodOptionsOxxo();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expiresAfterDays"] = this.expiresAfterDays;
        data["setupFutureUsage"] = this.setupFutureUsage;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentPaymentMethodOptionsOxxo extends IStripeEntityOfPaymentIntentPaymentMethodOptionsOxxo {
    /** The number of calendar days before an OXXO invoice expires. For example, if you create
an OXXO invoice on Monday and you set expires_after_days to 2, the OXXO invoice will
expire on Wednesday at 23:59 America/Mexico_City time. */
    expiresAfterDays?: number;
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA. */
    setupFutureUsage?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentPaymentMethodOptionsP24 extends StripeEntity implements IStripeEntityOfPaymentIntentPaymentMethodOptionsP24 {

    constructor(data?: IStripeEntityOfPaymentIntentPaymentMethodOptionsP24) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentPaymentMethodOptionsP24 {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentPaymentMethodOptionsP24' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentPaymentMethodOptionsP24 extends IStripeEntity {
}

export class PaymentIntentPaymentMethodOptionsP24 extends StripeEntityOfPaymentIntentPaymentMethodOptionsP24 implements IPaymentIntentPaymentMethodOptionsP24 {
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA. */
    setupFutureUsage?: string | undefined;

    constructor(data?: IPaymentIntentPaymentMethodOptionsP24) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.setupFutureUsage = _data["setupFutureUsage"];
        }
    }

    static override fromJS(data: any): PaymentIntentPaymentMethodOptionsP24 {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentPaymentMethodOptionsP24();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setupFutureUsage"] = this.setupFutureUsage;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentPaymentMethodOptionsP24 extends IStripeEntityOfPaymentIntentPaymentMethodOptionsP24 {
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA. */
    setupFutureUsage?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentPaymentMethodOptionsPaynow extends StripeEntity implements IStripeEntityOfPaymentIntentPaymentMethodOptionsPaynow {

    constructor(data?: IStripeEntityOfPaymentIntentPaymentMethodOptionsPaynow) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentPaymentMethodOptionsPaynow {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentPaymentMethodOptionsPaynow' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentPaymentMethodOptionsPaynow extends IStripeEntity {
}

export class PaymentIntentPaymentMethodOptionsPaynow extends StripeEntityOfPaymentIntentPaymentMethodOptionsPaynow implements IPaymentIntentPaymentMethodOptionsPaynow {
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA. */
    setupFutureUsage?: string | undefined;

    constructor(data?: IPaymentIntentPaymentMethodOptionsPaynow) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.setupFutureUsage = _data["setupFutureUsage"];
        }
    }

    static override fromJS(data: any): PaymentIntentPaymentMethodOptionsPaynow {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentPaymentMethodOptionsPaynow();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setupFutureUsage"] = this.setupFutureUsage;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentPaymentMethodOptionsPaynow extends IStripeEntityOfPaymentIntentPaymentMethodOptionsPaynow {
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA. */
    setupFutureUsage?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentPaymentMethodOptionsPaypal extends StripeEntity implements IStripeEntityOfPaymentIntentPaymentMethodOptionsPaypal {

    constructor(data?: IStripeEntityOfPaymentIntentPaymentMethodOptionsPaypal) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentPaymentMethodOptionsPaypal {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentPaymentMethodOptionsPaypal' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentPaymentMethodOptionsPaypal extends IStripeEntity {
}

export class PaymentIntentPaymentMethodOptionsPaypal extends StripeEntityOfPaymentIntentPaymentMethodOptionsPaypal implements IPaymentIntentPaymentMethodOptionsPaypal {
    /** Controls when the funds will be captured from the customer's account. */
    captureMethod?: string | undefined;
    /** Preferred locale of the PayPal checkout page that the customer is redirected to. */
    preferredLocale?: string | undefined;
    /** A reference of the PayPal transaction visible to customer which is mapped to PayPal's
invoice ID. This must be a globally unique ID if you have configured in your PayPal
settings to block multiple payments per invoice ID. */
    reference?: string | undefined;
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA.
One of: none, or off_session. */
    setupFutureUsage?: string | undefined;

    constructor(data?: IPaymentIntentPaymentMethodOptionsPaypal) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.captureMethod = _data["captureMethod"];
            this.preferredLocale = _data["preferredLocale"];
            this.reference = _data["reference"];
            this.setupFutureUsage = _data["setupFutureUsage"];
        }
    }

    static override fromJS(data: any): PaymentIntentPaymentMethodOptionsPaypal {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentPaymentMethodOptionsPaypal();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["captureMethod"] = this.captureMethod;
        data["preferredLocale"] = this.preferredLocale;
        data["reference"] = this.reference;
        data["setupFutureUsage"] = this.setupFutureUsage;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentPaymentMethodOptionsPaypal extends IStripeEntityOfPaymentIntentPaymentMethodOptionsPaypal {
    /** Controls when the funds will be captured from the customer's account. */
    captureMethod?: string | undefined;
    /** Preferred locale of the PayPal checkout page that the customer is redirected to. */
    preferredLocale?: string | undefined;
    /** A reference of the PayPal transaction visible to customer which is mapped to PayPal's
invoice ID. This must be a globally unique ID if you have configured in your PayPal
settings to block multiple payments per invoice ID. */
    reference?: string | undefined;
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA.
One of: none, or off_session. */
    setupFutureUsage?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentPaymentMethodOptionsPix extends StripeEntity implements IStripeEntityOfPaymentIntentPaymentMethodOptionsPix {

    constructor(data?: IStripeEntityOfPaymentIntentPaymentMethodOptionsPix) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentPaymentMethodOptionsPix {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentPaymentMethodOptionsPix' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentPaymentMethodOptionsPix extends IStripeEntity {
}

export class PaymentIntentPaymentMethodOptionsPix extends StripeEntityOfPaymentIntentPaymentMethodOptionsPix implements IPaymentIntentPaymentMethodOptionsPix {
    /** The number of seconds (between 10 and 1209600) after which Pix payment will expire. */
    expiresAfterSeconds?: number | undefined;
    /** The timestamp at which the Pix expires. */
    expiresAt?: number | undefined;
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA. */
    setupFutureUsage?: string | undefined;

    constructor(data?: IPaymentIntentPaymentMethodOptionsPix) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.expiresAfterSeconds = _data["expiresAfterSeconds"];
            this.expiresAt = _data["expiresAt"];
            this.setupFutureUsage = _data["setupFutureUsage"];
        }
    }

    static override fromJS(data: any): PaymentIntentPaymentMethodOptionsPix {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentPaymentMethodOptionsPix();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expiresAfterSeconds"] = this.expiresAfterSeconds;
        data["expiresAt"] = this.expiresAt;
        data["setupFutureUsage"] = this.setupFutureUsage;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentPaymentMethodOptionsPix extends IStripeEntityOfPaymentIntentPaymentMethodOptionsPix {
    /** The number of seconds (between 10 and 1209600) after which Pix payment will expire. */
    expiresAfterSeconds?: number | undefined;
    /** The timestamp at which the Pix expires. */
    expiresAt?: number | undefined;
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA. */
    setupFutureUsage?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentPaymentMethodOptionsPromptpay extends StripeEntity implements IStripeEntityOfPaymentIntentPaymentMethodOptionsPromptpay {

    constructor(data?: IStripeEntityOfPaymentIntentPaymentMethodOptionsPromptpay) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentPaymentMethodOptionsPromptpay {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentPaymentMethodOptionsPromptpay' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentPaymentMethodOptionsPromptpay extends IStripeEntity {
}

export class PaymentIntentPaymentMethodOptionsPromptpay extends StripeEntityOfPaymentIntentPaymentMethodOptionsPromptpay implements IPaymentIntentPaymentMethodOptionsPromptpay {
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA. */
    setupFutureUsage?: string | undefined;

    constructor(data?: IPaymentIntentPaymentMethodOptionsPromptpay) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.setupFutureUsage = _data["setupFutureUsage"];
        }
    }

    static override fromJS(data: any): PaymentIntentPaymentMethodOptionsPromptpay {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentPaymentMethodOptionsPromptpay();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setupFutureUsage"] = this.setupFutureUsage;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentPaymentMethodOptionsPromptpay extends IStripeEntityOfPaymentIntentPaymentMethodOptionsPromptpay {
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA. */
    setupFutureUsage?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentPaymentMethodOptionsSepaDebit extends StripeEntity implements IStripeEntityOfPaymentIntentPaymentMethodOptionsSepaDebit {

    constructor(data?: IStripeEntityOfPaymentIntentPaymentMethodOptionsSepaDebit) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentPaymentMethodOptionsSepaDebit {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentPaymentMethodOptionsSepaDebit' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentPaymentMethodOptionsSepaDebit extends IStripeEntity {
}

export class PaymentIntentPaymentMethodOptionsSepaDebit extends StripeEntityOfPaymentIntentPaymentMethodOptionsSepaDebit implements IPaymentIntentPaymentMethodOptionsSepaDebit {
    mandateOptions?: PaymentIntentPaymentMethodOptionsSepaDebitMandateOptions | undefined;
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA.
One of: none, off_session, or on_session. */
    setupFutureUsage?: string | undefined;

    constructor(data?: IPaymentIntentPaymentMethodOptionsSepaDebit) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.mandateOptions = _data["mandateOptions"] ? PaymentIntentPaymentMethodOptionsSepaDebitMandateOptions.fromJS(_data["mandateOptions"]) : <any>undefined;
            this.setupFutureUsage = _data["setupFutureUsage"];
        }
    }

    static override fromJS(data: any): PaymentIntentPaymentMethodOptionsSepaDebit {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentPaymentMethodOptionsSepaDebit();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mandateOptions"] = this.mandateOptions ? this.mandateOptions.toJSON() : <any>undefined;
        data["setupFutureUsage"] = this.setupFutureUsage;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentPaymentMethodOptionsSepaDebit extends IStripeEntityOfPaymentIntentPaymentMethodOptionsSepaDebit {
    mandateOptions?: PaymentIntentPaymentMethodOptionsSepaDebitMandateOptions | undefined;
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA.
One of: none, off_session, or on_session. */
    setupFutureUsage?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentPaymentMethodOptionsSepaDebitMandateOptions extends StripeEntity implements IStripeEntityOfPaymentIntentPaymentMethodOptionsSepaDebitMandateOptions {

    constructor(data?: IStripeEntityOfPaymentIntentPaymentMethodOptionsSepaDebitMandateOptions) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentPaymentMethodOptionsSepaDebitMandateOptions {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentPaymentMethodOptionsSepaDebitMandateOptions' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentPaymentMethodOptionsSepaDebitMandateOptions extends IStripeEntity {
}

export class PaymentIntentPaymentMethodOptionsSepaDebitMandateOptions extends StripeEntityOfPaymentIntentPaymentMethodOptionsSepaDebitMandateOptions implements IPaymentIntentPaymentMethodOptionsSepaDebitMandateOptions {

    constructor(data?: IPaymentIntentPaymentMethodOptionsSepaDebitMandateOptions) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): PaymentIntentPaymentMethodOptionsSepaDebitMandateOptions {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentPaymentMethodOptionsSepaDebitMandateOptions();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentPaymentMethodOptionsSepaDebitMandateOptions extends IStripeEntityOfPaymentIntentPaymentMethodOptionsSepaDebitMandateOptions {
}

export abstract class StripeEntityOfPaymentIntentPaymentMethodOptionsSofort extends StripeEntity implements IStripeEntityOfPaymentIntentPaymentMethodOptionsSofort {

    constructor(data?: IStripeEntityOfPaymentIntentPaymentMethodOptionsSofort) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentPaymentMethodOptionsSofort {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentPaymentMethodOptionsSofort' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentPaymentMethodOptionsSofort extends IStripeEntity {
}

export class PaymentIntentPaymentMethodOptionsSofort extends StripeEntityOfPaymentIntentPaymentMethodOptionsSofort implements IPaymentIntentPaymentMethodOptionsSofort {
    /** Preferred language of the SOFORT authorization page that the customer is redirected to.
One of: de, en, es, fr, it, nl, or pl. */
    preferredLanguage?: string | undefined;
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA.
One of: none, or off_session. */
    setupFutureUsage?: string | undefined;

    constructor(data?: IPaymentIntentPaymentMethodOptionsSofort) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.preferredLanguage = _data["preferredLanguage"];
            this.setupFutureUsage = _data["setupFutureUsage"];
        }
    }

    static override fromJS(data: any): PaymentIntentPaymentMethodOptionsSofort {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentPaymentMethodOptionsSofort();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["preferredLanguage"] = this.preferredLanguage;
        data["setupFutureUsage"] = this.setupFutureUsage;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentPaymentMethodOptionsSofort extends IStripeEntityOfPaymentIntentPaymentMethodOptionsSofort {
    /** Preferred language of the SOFORT authorization page that the customer is redirected to.
One of: de, en, es, fr, it, nl, or pl. */
    preferredLanguage?: string | undefined;
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA.
One of: none, or off_session. */
    setupFutureUsage?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentPaymentMethodOptionsUsBankAccount extends StripeEntity implements IStripeEntityOfPaymentIntentPaymentMethodOptionsUsBankAccount {

    constructor(data?: IStripeEntityOfPaymentIntentPaymentMethodOptionsUsBankAccount) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentPaymentMethodOptionsUsBankAccount {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentPaymentMethodOptionsUsBankAccount' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentPaymentMethodOptionsUsBankAccount extends IStripeEntity {
}

export class PaymentIntentPaymentMethodOptionsUsBankAccount extends StripeEntityOfPaymentIntentPaymentMethodOptionsUsBankAccount implements IPaymentIntentPaymentMethodOptionsUsBankAccount {
    financialConnections?: PaymentIntentPaymentMethodOptionsUsBankAccountFinancialConnections | undefined;
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA.
One of: none, off_session, or on_session. */
    setupFutureUsage?: string | undefined;
    /** Bank account verification method.
One of: automatic, instant, or microdeposits. */
    verificationMethod?: string | undefined;

    constructor(data?: IPaymentIntentPaymentMethodOptionsUsBankAccount) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.financialConnections = _data["financialConnections"] ? PaymentIntentPaymentMethodOptionsUsBankAccountFinancialConnections.fromJS(_data["financialConnections"]) : <any>undefined;
            this.setupFutureUsage = _data["setupFutureUsage"];
            this.verificationMethod = _data["verificationMethod"];
        }
    }

    static override fromJS(data: any): PaymentIntentPaymentMethodOptionsUsBankAccount {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentPaymentMethodOptionsUsBankAccount();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["financialConnections"] = this.financialConnections ? this.financialConnections.toJSON() : <any>undefined;
        data["setupFutureUsage"] = this.setupFutureUsage;
        data["verificationMethod"] = this.verificationMethod;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentPaymentMethodOptionsUsBankAccount extends IStripeEntityOfPaymentIntentPaymentMethodOptionsUsBankAccount {
    financialConnections?: PaymentIntentPaymentMethodOptionsUsBankAccountFinancialConnections | undefined;
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA.
One of: none, off_session, or on_session. */
    setupFutureUsage?: string | undefined;
    /** Bank account verification method.
One of: automatic, instant, or microdeposits. */
    verificationMethod?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentPaymentMethodOptionsUsBankAccountFinancialConnections extends StripeEntity implements IStripeEntityOfPaymentIntentPaymentMethodOptionsUsBankAccountFinancialConnections {

    constructor(data?: IStripeEntityOfPaymentIntentPaymentMethodOptionsUsBankAccountFinancialConnections) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentPaymentMethodOptionsUsBankAccountFinancialConnections {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentPaymentMethodOptionsUsBankAccountFinancialConnections' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentPaymentMethodOptionsUsBankAccountFinancialConnections extends IStripeEntity {
}

export class PaymentIntentPaymentMethodOptionsUsBankAccountFinancialConnections extends StripeEntityOfPaymentIntentPaymentMethodOptionsUsBankAccountFinancialConnections implements IPaymentIntentPaymentMethodOptionsUsBankAccountFinancialConnections {
    /** The list of permissions to request. The payment_method permission must be
included. */
    permissions?: string[] | undefined;
    /** For webview integrations only. Upon completing OAuth login in the native browser, the
user will be redirected to this URL to return to your app. */
    returnUrl?: string | undefined;

    constructor(data?: IPaymentIntentPaymentMethodOptionsUsBankAccountFinancialConnections) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(item);
            }
            this.returnUrl = _data["returnUrl"];
        }
    }

    static override fromJS(data: any): PaymentIntentPaymentMethodOptionsUsBankAccountFinancialConnections {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentPaymentMethodOptionsUsBankAccountFinancialConnections();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        data["returnUrl"] = this.returnUrl;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentPaymentMethodOptionsUsBankAccountFinancialConnections extends IStripeEntityOfPaymentIntentPaymentMethodOptionsUsBankAccountFinancialConnections {
    /** The list of permissions to request. The payment_method permission must be
included. */
    permissions?: string[] | undefined;
    /** For webview integrations only. Upon completing OAuth login in the native browser, the
user will be redirected to this URL to return to your app. */
    returnUrl?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentPaymentMethodOptionsWechatPay extends StripeEntity implements IStripeEntityOfPaymentIntentPaymentMethodOptionsWechatPay {

    constructor(data?: IStripeEntityOfPaymentIntentPaymentMethodOptionsWechatPay) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentPaymentMethodOptionsWechatPay {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentPaymentMethodOptionsWechatPay' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentPaymentMethodOptionsWechatPay extends IStripeEntity {
}

export class PaymentIntentPaymentMethodOptionsWechatPay extends StripeEntityOfPaymentIntentPaymentMethodOptionsWechatPay implements IPaymentIntentPaymentMethodOptionsWechatPay {
    /** The app ID registered with WeChat Pay. Only required when client is ios or android. */
    appId?: string | undefined;
    /** The client type that the end customer will pay from.
One of: android, ios, or web. */
    client?: string | undefined;
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA. */
    setupFutureUsage?: string | undefined;

    constructor(data?: IPaymentIntentPaymentMethodOptionsWechatPay) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.appId = _data["appId"];
            this.client = _data["client"];
            this.setupFutureUsage = _data["setupFutureUsage"];
        }
    }

    static override fromJS(data: any): PaymentIntentPaymentMethodOptionsWechatPay {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentPaymentMethodOptionsWechatPay();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appId"] = this.appId;
        data["client"] = this.client;
        data["setupFutureUsage"] = this.setupFutureUsage;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentPaymentMethodOptionsWechatPay extends IStripeEntityOfPaymentIntentPaymentMethodOptionsWechatPay {
    /** The app ID registered with WeChat Pay. Only required when client is ios or android. */
    appId?: string | undefined;
    /** The client type that the end customer will pay from.
One of: android, ios, or web. */
    client?: string | undefined;
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA. */
    setupFutureUsage?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentPaymentMethodOptionsZip extends StripeEntity implements IStripeEntityOfPaymentIntentPaymentMethodOptionsZip {

    constructor(data?: IStripeEntityOfPaymentIntentPaymentMethodOptionsZip) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentPaymentMethodOptionsZip {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentPaymentMethodOptionsZip' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentPaymentMethodOptionsZip extends IStripeEntity {
}

export class PaymentIntentPaymentMethodOptionsZip extends StripeEntityOfPaymentIntentPaymentMethodOptionsZip implements IPaymentIntentPaymentMethodOptionsZip {
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA. */
    setupFutureUsage?: string | undefined;

    constructor(data?: IPaymentIntentPaymentMethodOptionsZip) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.setupFutureUsage = _data["setupFutureUsage"];
        }
    }

    static override fromJS(data: any): PaymentIntentPaymentMethodOptionsZip {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentPaymentMethodOptionsZip();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setupFutureUsage"] = this.setupFutureUsage;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentPaymentMethodOptionsZip extends IStripeEntityOfPaymentIntentPaymentMethodOptionsZip {
    /** Indicates that you intend to make future payments with this PaymentIntent's payment
method.
            
Providing this parameter will attach the payment
method to the PaymentIntent's Customer, if present, after the PaymentIntent is
confirmed and any required actions from the user are complete. If no Customer was
provided, the payment method can still be attached to a Customer
after the transaction completes.
            
When processing card payments, Stripe also uses setup_future_usage to dynamically
optimize your payment flow and comply with regional legislation and network rules, such
as SCA. */
    setupFutureUsage?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentProcessing extends StripeEntity implements IStripeEntityOfPaymentIntentProcessing {

    constructor(data?: IStripeEntityOfPaymentIntentProcessing) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentProcessing {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentProcessing' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentProcessing extends IStripeEntity {
}

export class PaymentIntentProcessing extends StripeEntityOfPaymentIntentProcessing implements IPaymentIntentProcessing {
    card?: PaymentIntentProcessingCard | undefined;
    /** Type of the payment method for which payment is in processing state, one of
card. */
    type?: string | undefined;

    constructor(data?: IPaymentIntentProcessing) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.card = _data["card"] ? PaymentIntentProcessingCard.fromJS(_data["card"]) : <any>undefined;
            this.type = _data["type"];
        }
    }

    static override fromJS(data: any): PaymentIntentProcessing {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentProcessing();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["card"] = this.card ? this.card.toJSON() : <any>undefined;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentProcessing extends IStripeEntityOfPaymentIntentProcessing {
    card?: PaymentIntentProcessingCard | undefined;
    /** Type of the payment method for which payment is in processing state, one of
card. */
    type?: string | undefined;
}

export abstract class StripeEntityOfPaymentIntentProcessingCard extends StripeEntity implements IStripeEntityOfPaymentIntentProcessingCard {

    constructor(data?: IStripeEntityOfPaymentIntentProcessingCard) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentProcessingCard {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentProcessingCard' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentProcessingCard extends IStripeEntity {
}

export class PaymentIntentProcessingCard extends StripeEntityOfPaymentIntentProcessingCard implements IPaymentIntentProcessingCard {
    customerNotification?: PaymentIntentProcessingCardCustomerNotification | undefined;

    constructor(data?: IPaymentIntentProcessingCard) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.customerNotification = _data["customerNotification"] ? PaymentIntentProcessingCardCustomerNotification.fromJS(_data["customerNotification"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): PaymentIntentProcessingCard {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentProcessingCard();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerNotification"] = this.customerNotification ? this.customerNotification.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentProcessingCard extends IStripeEntityOfPaymentIntentProcessingCard {
    customerNotification?: PaymentIntentProcessingCardCustomerNotification | undefined;
}

export abstract class StripeEntityOfPaymentIntentProcessingCardCustomerNotification extends StripeEntity implements IStripeEntityOfPaymentIntentProcessingCardCustomerNotification {

    constructor(data?: IStripeEntityOfPaymentIntentProcessingCardCustomerNotification) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentProcessingCardCustomerNotification {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentProcessingCardCustomerNotification' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentProcessingCardCustomerNotification extends IStripeEntity {
}

export class PaymentIntentProcessingCardCustomerNotification extends StripeEntityOfPaymentIntentProcessingCardCustomerNotification implements IPaymentIntentProcessingCardCustomerNotification {
    /** Whether customer approval has been requested for this payment. For payments greater than
INR 15000 or mandate amount, the customer must provide explicit approval of the payment
with their bank. */
    approvalRequested?: boolean | undefined;
    /** If customer approval is required, they need to provide approval before this time. */
    completesAt?: Date | undefined;

    constructor(data?: IPaymentIntentProcessingCardCustomerNotification) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.approvalRequested = _data["approvalRequested"];
            this.completesAt = _data["completesAt"] ? new Date(_data["completesAt"].toString()) : <any>undefined;
        }
    }

    static override fromJS(data: any): PaymentIntentProcessingCardCustomerNotification {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentProcessingCardCustomerNotification();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["approvalRequested"] = this.approvalRequested;
        data["completesAt"] = this.completesAt ? this.completesAt.toISOString() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentProcessingCardCustomerNotification extends IStripeEntityOfPaymentIntentProcessingCardCustomerNotification {
    /** Whether customer approval has been requested for this payment. For payments greater than
INR 15000 or mandate amount, the customer must provide explicit approval of the payment
with their bank. */
    approvalRequested?: boolean | undefined;
    /** If customer approval is required, they need to provide approval before this time. */
    completesAt?: Date | undefined;
}

export abstract class StripeEntityOfReview extends StripeEntity implements IStripeEntityOfReview {

    constructor(data?: IStripeEntityOfReview) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfReview {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfReview' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfReview extends IStripeEntity {
}

/** Reviews can be used to supplement automated fraud detection with human expertise.            Learn more about Radar and reviewing payments here. */
export class Review2 extends StripeEntityOfReview implements IReview2 {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** The ZIP or postal code of the card used, if applicable. */
    billingZip?: string | undefined;
    /** (ID of the Charge)
The charge associated with this review. */
    chargeId?: string | undefined;
    /** (Expanded)
The charge associated with this review.
            
For more information, see the expand documentation. */
    charge?: Charge | undefined;
    internalCharge?: ExpandableFieldOfCharge | undefined;
    /** The reason the review was closed, or null if it has not yet been closed. One of
approved, refunded, refunded_as_fraud, disputed, or
redacted.
One of: approved, disputed, redacted, refunded, or
refunded_as_fraud. */
    closedReason?: string | undefined;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** The IP address where the payment originated. */
    ipAddress?: string | undefined;
    /** Information related to the location of the payment. Note that this information is an
approximation and attempts to locate the nearest population center - it should not be
used to determine a specific address. */
    ipAddressLocation?: ReviewLocation | undefined;
    /** Has the value true if the object exists in live mode or the value false if
the object exists in test mode. */
    livemode?: boolean;
    /** If true, the review needs action. */
    open?: boolean;
    /** The reason the review was opened. One of rule or manual.
One of: manual, or rule. */
    openedReason?: string | undefined;
    /** (ID of the PaymentIntent)
The PaymentIntent ID associated with this review, if one exists. */
    paymentIntentId?: string | undefined;
    /** (Expanded)
The PaymentIntent ID associated with this review, if one exists.
            
For more information, see the expand documentation. */
    paymentIntent?: PaymentIntent | undefined;
    internalPaymentIntent?: ExpandableFieldOfPaymentIntent | undefined;
    /** The reason the review is currently open or closed. One of rule, manual,
approved, refunded, refunded_as_fraud, disputed, or
redacted. */
    reason?: string | undefined;
    /** Information related to the browsing session of the user who initiated the payment. */
    session?: ReviewSession | undefined;

    constructor(data?: IReview2) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.object = _data["object"];
            this.billingZip = _data["billingZip"];
            this.chargeId = _data["chargeId"];
            this.charge = _data["charge"] ? Charge.fromJS(_data["charge"]) : <any>undefined;
            this.internalCharge = _data["internalCharge"] ? ExpandableFieldOfCharge.fromJS(_data["internalCharge"]) : <any>undefined;
            this.closedReason = _data["closedReason"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.ipAddress = _data["ipAddress"];
            this.ipAddressLocation = _data["ipAddressLocation"] ? ReviewLocation.fromJS(_data["ipAddressLocation"]) : <any>undefined;
            this.livemode = _data["livemode"];
            this.open = _data["open"];
            this.openedReason = _data["openedReason"];
            this.paymentIntentId = _data["paymentIntentId"];
            this.paymentIntent = _data["paymentIntent"] ? PaymentIntent.fromJS(_data["paymentIntent"]) : <any>undefined;
            this.internalPaymentIntent = _data["internalPaymentIntent"] ? ExpandableFieldOfPaymentIntent.fromJS(_data["internalPaymentIntent"]) : <any>undefined;
            this.reason = _data["reason"];
            this.session = _data["session"] ? ReviewSession.fromJS(_data["session"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): Review2 {
        data = typeof data === 'object' ? data : {};
        let result = new Review2();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["object"] = this.object;
        data["billingZip"] = this.billingZip;
        data["chargeId"] = this.chargeId;
        data["charge"] = this.charge ? this.charge.toJSON() : <any>undefined;
        data["internalCharge"] = this.internalCharge ? this.internalCharge.toJSON() : <any>undefined;
        data["closedReason"] = this.closedReason;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["ipAddress"] = this.ipAddress;
        data["ipAddressLocation"] = this.ipAddressLocation ? this.ipAddressLocation.toJSON() : <any>undefined;
        data["livemode"] = this.livemode;
        data["open"] = this.open;
        data["openedReason"] = this.openedReason;
        data["paymentIntentId"] = this.paymentIntentId;
        data["paymentIntent"] = this.paymentIntent ? this.paymentIntent.toJSON() : <any>undefined;
        data["internalPaymentIntent"] = this.internalPaymentIntent ? this.internalPaymentIntent.toJSON() : <any>undefined;
        data["reason"] = this.reason;
        data["session"] = this.session ? this.session.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** Reviews can be used to supplement automated fraud detection with human expertise.            Learn more about Radar and reviewing payments here. */
export interface IReview2 extends IStripeEntityOfReview {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** The ZIP or postal code of the card used, if applicable. */
    billingZip?: string | undefined;
    /** (ID of the Charge)
The charge associated with this review. */
    chargeId?: string | undefined;
    /** (Expanded)
The charge associated with this review.
            
For more information, see the expand documentation. */
    charge?: Charge | undefined;
    internalCharge?: ExpandableFieldOfCharge | undefined;
    /** The reason the review was closed, or null if it has not yet been closed. One of
approved, refunded, refunded_as_fraud, disputed, or
redacted.
One of: approved, disputed, redacted, refunded, or
refunded_as_fraud. */
    closedReason?: string | undefined;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** The IP address where the payment originated. */
    ipAddress?: string | undefined;
    /** Information related to the location of the payment. Note that this information is an
approximation and attempts to locate the nearest population center - it should not be
used to determine a specific address. */
    ipAddressLocation?: ReviewLocation | undefined;
    /** Has the value true if the object exists in live mode or the value false if
the object exists in test mode. */
    livemode?: boolean;
    /** If true, the review needs action. */
    open?: boolean;
    /** The reason the review was opened. One of rule or manual.
One of: manual, or rule. */
    openedReason?: string | undefined;
    /** (ID of the PaymentIntent)
The PaymentIntent ID associated with this review, if one exists. */
    paymentIntentId?: string | undefined;
    /** (Expanded)
The PaymentIntent ID associated with this review, if one exists.
            
For more information, see the expand documentation. */
    paymentIntent?: PaymentIntent | undefined;
    internalPaymentIntent?: ExpandableFieldOfPaymentIntent | undefined;
    /** The reason the review is currently open or closed. One of rule, manual,
approved, refunded, refunded_as_fraud, disputed, or
redacted. */
    reason?: string | undefined;
    /** Information related to the browsing session of the user who initiated the payment. */
    session?: ReviewSession | undefined;
}

export abstract class StripeEntityOfReviewLocation extends StripeEntity implements IStripeEntityOfReviewLocation {

    constructor(data?: IStripeEntityOfReviewLocation) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfReviewLocation {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfReviewLocation' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfReviewLocation extends IStripeEntity {
}

export class ReviewLocation extends StripeEntityOfReviewLocation implements IReviewLocation {
    city?: string | undefined;
    country?: string | undefined;
    latitude?: number | undefined;
    longitude?: number | undefined;
    region?: string | undefined;

    constructor(data?: IReviewLocation) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.city = _data["city"];
            this.country = _data["country"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.region = _data["region"];
        }
    }

    static override fromJS(data: any): ReviewLocation {
        data = typeof data === 'object' ? data : {};
        let result = new ReviewLocation();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["city"] = this.city;
        data["country"] = this.country;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["region"] = this.region;
        super.toJSON(data);
        return data;
    }
}

export interface IReviewLocation extends IStripeEntityOfReviewLocation {
    city?: string | undefined;
    country?: string | undefined;
    latitude?: number | undefined;
    longitude?: number | undefined;
    region?: string | undefined;
}

export abstract class StripeEntityOfReviewSession extends StripeEntity implements IStripeEntityOfReviewSession {

    constructor(data?: IStripeEntityOfReviewSession) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfReviewSession {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfReviewSession' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfReviewSession extends IStripeEntity {
}

export class ReviewSession extends StripeEntityOfReviewSession implements IReviewSession {
    /** The browser used in this browser session (e.g., Chrome). */
    browser?: string | undefined;
    /** Information about the device used for the browser session (e.g., Samsung
SM-G930T). */
    device?: string | undefined;
    /** The platform for the browser session (e.g., Macintosh). */
    platform?: string | undefined;
    /** The version for the browser session (e.g., 61.0.3163.100). */
    version?: string | undefined;

    constructor(data?: IReviewSession) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.browser = _data["browser"];
            this.device = _data["device"];
            this.platform = _data["platform"];
            this.version = _data["version"];
        }
    }

    static override fromJS(data: any): ReviewSession {
        data = typeof data === 'object' ? data : {};
        let result = new ReviewSession();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["browser"] = this.browser;
        data["device"] = this.device;
        data["platform"] = this.platform;
        data["version"] = this.version;
        super.toJSON(data);
        return data;
    }
}

export interface IReviewSession extends IStripeEntityOfReviewSession {
    /** The browser used in this browser session (e.g., Chrome). */
    browser?: string | undefined;
    /** Information about the device used for the browser session (e.g., Samsung
SM-G930T). */
    device?: string | undefined;
    /** The platform for the browser session (e.g., Macintosh). */
    platform?: string | undefined;
    /** The version for the browser session (e.g., 61.0.3163.100). */
    version?: string | undefined;
}

/** Represents a generic expandable field. */
export class ExpandableFieldOfReview implements IExpandableFieldOfReview {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: Review2 | undefined;

    constructor(data?: IExpandableFieldOfReview) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.expandedObject = _data["expandedObject"] ? Review2.fromJS(_data["expandedObject"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExpandableFieldOfReview {
        data = typeof data === 'object' ? data : {};
        let result = new ExpandableFieldOfReview();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["expandedObject"] = this.expandedObject ? this.expandedObject.toJSON() : <any>undefined;
        return data;
    }
}

/** Represents a generic expandable field. */
export interface IExpandableFieldOfReview {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: Review2 | undefined;
}

export abstract class StripeEntityOfPaymentIntentTransferData extends StripeEntity implements IStripeEntityOfPaymentIntentTransferData {

    constructor(data?: IStripeEntityOfPaymentIntentTransferData) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentIntentTransferData {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentIntentTransferData' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentIntentTransferData extends IStripeEntity {
}

export class PaymentIntentTransferData extends StripeEntityOfPaymentIntentTransferData implements IPaymentIntentTransferData {
    /** Amount intended to be collected by this PaymentIntent. A positive integer representing
how much to charge in the smallest currency unit (e.g.,
100 cents to charge $1.00 or 100 to charge ¥100, a zero-decimal currency). The minimum
amount is $0.50 US or equivalent
in charge currency. The amount value supports up to eight digits (e.g., a value of
99999999 for a USD charge of $999,999.99). */
    amount?: number;
    /** (ID of the Account)
The account (if any) the payment will be attributed to for tax reporting, and where
funds from the payment will be transferred to upon payment success. */
    destinationId?: string | undefined;
    /** (Expanded)
The account (if any) the payment will be attributed to for tax reporting, and where
funds from the payment will be transferred to upon payment success.
            
For more information, see the expand documentation. */
    destination?: Account | undefined;
    internalDestination?: ExpandableFieldOfAccount | undefined;

    constructor(data?: IPaymentIntentTransferData) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.amount = _data["amount"];
            this.destinationId = _data["destinationId"];
            this.destination = _data["destination"] ? Account.fromJS(_data["destination"]) : <any>undefined;
            this.internalDestination = _data["internalDestination"] ? ExpandableFieldOfAccount.fromJS(_data["internalDestination"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): PaymentIntentTransferData {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentTransferData();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["destinationId"] = this.destinationId;
        data["destination"] = this.destination ? this.destination.toJSON() : <any>undefined;
        data["internalDestination"] = this.internalDestination ? this.internalDestination.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentIntentTransferData extends IStripeEntityOfPaymentIntentTransferData {
    /** Amount intended to be collected by this PaymentIntent. A positive integer representing
how much to charge in the smallest currency unit (e.g.,
100 cents to charge $1.00 or 100 to charge ¥100, a zero-decimal currency). The minimum
amount is $0.50 US or equivalent
in charge currency. The amount value supports up to eight digits (e.g., a value of
99999999 for a USD charge of $999,999.99). */
    amount?: number;
    /** (ID of the Account)
The account (if any) the payment will be attributed to for tax reporting, and where
funds from the payment will be transferred to upon payment success. */
    destinationId?: string | undefined;
    /** (Expanded)
The account (if any) the payment will be attributed to for tax reporting, and where
funds from the payment will be transferred to upon payment success.
            
For more information, see the expand documentation. */
    destination?: Account | undefined;
    internalDestination?: ExpandableFieldOfAccount | undefined;
}

/** Represents a generic expandable field. */
export class ExpandableFieldOfDispute implements IExpandableFieldOfDispute {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: Dispute | undefined;

    constructor(data?: IExpandableFieldOfDispute) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.expandedObject = _data["expandedObject"] ? Dispute.fromJS(_data["expandedObject"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExpandableFieldOfDispute {
        data = typeof data === 'object' ? data : {};
        let result = new ExpandableFieldOfDispute();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["expandedObject"] = this.expandedObject ? this.expandedObject.toJSON() : <any>undefined;
        return data;
    }
}

/** Represents a generic expandable field. */
export interface IExpandableFieldOfDispute {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: Dispute | undefined;
}

export abstract class StripeEntityOfChargeFraudDetails extends StripeEntity implements IStripeEntityOfChargeFraudDetails {

    constructor(data?: IStripeEntityOfChargeFraudDetails) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargeFraudDetails {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargeFraudDetails' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargeFraudDetails extends IStripeEntity {
}

export class ChargeFraudDetails extends StripeEntityOfChargeFraudDetails implements IChargeFraudDetails {
    /** Assessments from Stripe. If set, the value is fraudulent. */
    stripeReport?: string | undefined;
    /** Assessments reported by you. If set, possible values of are safe and
fraudulent. */
    userReport?: string | undefined;

    constructor(data?: IChargeFraudDetails) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.stripeReport = _data["stripeReport"];
            this.userReport = _data["userReport"];
        }
    }

    static override fromJS(data: any): ChargeFraudDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ChargeFraudDetails();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stripeReport"] = this.stripeReport;
        data["userReport"] = this.userReport;
        super.toJSON(data);
        return data;
    }
}

export interface IChargeFraudDetails extends IStripeEntityOfChargeFraudDetails {
    /** Assessments from Stripe. If set, the value is fraudulent. */
    stripeReport?: string | undefined;
    /** Assessments reported by you. If set, possible values of are safe and
fraudulent. */
    userReport?: string | undefined;
}

export abstract class StripeEntityOfChargeLevel3 extends StripeEntity implements IStripeEntityOfChargeLevel3 {

    constructor(data?: IStripeEntityOfChargeLevel3) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargeLevel3 {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargeLevel3' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargeLevel3 extends IStripeEntity {
}

export class ChargeLevel3 extends StripeEntityOfChargeLevel3 implements IChargeLevel3 {
    customerReference?: string | undefined;
    lineItems?: ChargeLevel3LineItem[] | undefined;
    merchantReference?: string | undefined;
    shippingAddressZip?: string | undefined;
    shippingAmount?: number;
    shippingFromZip?: string | undefined;

    constructor(data?: IChargeLevel3) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.customerReference = _data["customerReference"];
            if (Array.isArray(_data["lineItems"])) {
                this.lineItems = [] as any;
                for (let item of _data["lineItems"])
                    this.lineItems!.push(ChargeLevel3LineItem.fromJS(item));
            }
            this.merchantReference = _data["merchantReference"];
            this.shippingAddressZip = _data["shippingAddressZip"];
            this.shippingAmount = _data["shippingAmount"];
            this.shippingFromZip = _data["shippingFromZip"];
        }
    }

    static override fromJS(data: any): ChargeLevel3 {
        data = typeof data === 'object' ? data : {};
        let result = new ChargeLevel3();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerReference"] = this.customerReference;
        if (Array.isArray(this.lineItems)) {
            data["lineItems"] = [];
            for (let item of this.lineItems)
                data["lineItems"].push(item.toJSON());
        }
        data["merchantReference"] = this.merchantReference;
        data["shippingAddressZip"] = this.shippingAddressZip;
        data["shippingAmount"] = this.shippingAmount;
        data["shippingFromZip"] = this.shippingFromZip;
        super.toJSON(data);
        return data;
    }
}

export interface IChargeLevel3 extends IStripeEntityOfChargeLevel3 {
    customerReference?: string | undefined;
    lineItems?: ChargeLevel3LineItem[] | undefined;
    merchantReference?: string | undefined;
    shippingAddressZip?: string | undefined;
    shippingAmount?: number;
    shippingFromZip?: string | undefined;
}

export abstract class StripeEntityOfChargeLevel3LineItem extends StripeEntity implements IStripeEntityOfChargeLevel3LineItem {

    constructor(data?: IStripeEntityOfChargeLevel3LineItem) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargeLevel3LineItem {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargeLevel3LineItem' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargeLevel3LineItem extends IStripeEntity {
}

export class ChargeLevel3LineItem extends StripeEntityOfChargeLevel3LineItem implements IChargeLevel3LineItem {
    discountAmount?: number | undefined;
    productCode?: string | undefined;
    productDescription?: string | undefined;
    quantity?: number | undefined;
    taxAmount?: number | undefined;
    unitCost?: number | undefined;

    constructor(data?: IChargeLevel3LineItem) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.discountAmount = _data["discountAmount"];
            this.productCode = _data["productCode"];
            this.productDescription = _data["productDescription"];
            this.quantity = _data["quantity"];
            this.taxAmount = _data["taxAmount"];
            this.unitCost = _data["unitCost"];
        }
    }

    static override fromJS(data: any): ChargeLevel3LineItem {
        data = typeof data === 'object' ? data : {};
        let result = new ChargeLevel3LineItem();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["discountAmount"] = this.discountAmount;
        data["productCode"] = this.productCode;
        data["productDescription"] = this.productDescription;
        data["quantity"] = this.quantity;
        data["taxAmount"] = this.taxAmount;
        data["unitCost"] = this.unitCost;
        super.toJSON(data);
        return data;
    }
}

export interface IChargeLevel3LineItem extends IStripeEntityOfChargeLevel3LineItem {
    discountAmount?: number | undefined;
    productCode?: string | undefined;
    productDescription?: string | undefined;
    quantity?: number | undefined;
    taxAmount?: number | undefined;
    unitCost?: number | undefined;
}

export abstract class StripeEntityOfChargeOutcome extends StripeEntity implements IStripeEntityOfChargeOutcome {

    constructor(data?: IStripeEntityOfChargeOutcome) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargeOutcome {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargeOutcome' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargeOutcome extends IStripeEntity {
}

export class ChargeOutcome extends StripeEntityOfChargeOutcome implements IChargeOutcome {
    /** Possible values are approved_by_network, declined_by_network,
not_sent_to_network, and reversed_after_approval. The value
reversed_after_approval indicates the payment was blocked by Stripe after
bank authorization, and may temporarily appear as "pending" on a cardholder's statement. */
    networkStatus?: string | undefined;
    /** An enumerated value providing a more detailed explanation of the outcome's type.
Charges blocked by Radar's default block rule have the value highest_risk_level.
Charges placed in review by Radar's default review rule have the value
elevated_risk_level. Charges authorized, blocked, or placed in review by custom
rules have the value rule. See understanding declines for more details. */
    reason?: string | undefined;
    /** Stripe Radar's evaluation of the riskiness of the payment. Possible values for evaluated
payments are normal, elevated, highest. For non-card payments, and
card-based payments predating the public assignment of risk levels, this field will have
the value not_assessed. In the event of an error in the evaluation, this field
will have the value unknown. This field is only available with Radar. */
    riskLevel?: string | undefined;
    /** Stripe Radar's evaluation of the riskiness of the payment. Possible values for evaluated
payments are between 0 and 100. For non-card payments, card-based payments predating the
public assignment of risk scores, or in the event of an error during evaluation, this
field will not be present. This field is only available with Radar for Fraud Teams. */
    riskScore?: number;
    /** (ID of the Radar.Rule)
The ID of the Radar rule that matched the payment, if applicable. */
    ruleId?: string | undefined;
    /** (Expanded)
The ID of the Radar rule that matched the payment, if applicable.
            
For more information, see the expand documentation. */
    rule?: Rule | undefined;
    internalRule?: ExpandableFieldOfRule | undefined;
    /** A human-readable description of the outcome type and reason, designed for you (the
recipient of the payment), not your customer. */
    sellerMessage?: string | undefined;
    /** Possible values are authorized, manual_review, issuer_declined,
blocked, and invalid. See understanding declines and Radar reviews for details. */
    type?: string | undefined;

    constructor(data?: IChargeOutcome) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.networkStatus = _data["networkStatus"];
            this.reason = _data["reason"];
            this.riskLevel = _data["riskLevel"];
            this.riskScore = _data["riskScore"];
            this.ruleId = _data["ruleId"];
            this.rule = _data["rule"] ? Rule.fromJS(_data["rule"]) : <any>undefined;
            this.internalRule = _data["internalRule"] ? ExpandableFieldOfRule.fromJS(_data["internalRule"]) : <any>undefined;
            this.sellerMessage = _data["sellerMessage"];
            this.type = _data["type"];
        }
    }

    static override fromJS(data: any): ChargeOutcome {
        data = typeof data === 'object' ? data : {};
        let result = new ChargeOutcome();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["networkStatus"] = this.networkStatus;
        data["reason"] = this.reason;
        data["riskLevel"] = this.riskLevel;
        data["riskScore"] = this.riskScore;
        data["ruleId"] = this.ruleId;
        data["rule"] = this.rule ? this.rule.toJSON() : <any>undefined;
        data["internalRule"] = this.internalRule ? this.internalRule.toJSON() : <any>undefined;
        data["sellerMessage"] = this.sellerMessage;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

export interface IChargeOutcome extends IStripeEntityOfChargeOutcome {
    /** Possible values are approved_by_network, declined_by_network,
not_sent_to_network, and reversed_after_approval. The value
reversed_after_approval indicates the payment was blocked by Stripe after
bank authorization, and may temporarily appear as "pending" on a cardholder's statement. */
    networkStatus?: string | undefined;
    /** An enumerated value providing a more detailed explanation of the outcome's type.
Charges blocked by Radar's default block rule have the value highest_risk_level.
Charges placed in review by Radar's default review rule have the value
elevated_risk_level. Charges authorized, blocked, or placed in review by custom
rules have the value rule. See understanding declines for more details. */
    reason?: string | undefined;
    /** Stripe Radar's evaluation of the riskiness of the payment. Possible values for evaluated
payments are normal, elevated, highest. For non-card payments, and
card-based payments predating the public assignment of risk levels, this field will have
the value not_assessed. In the event of an error in the evaluation, this field
will have the value unknown. This field is only available with Radar. */
    riskLevel?: string | undefined;
    /** Stripe Radar's evaluation of the riskiness of the payment. Possible values for evaluated
payments are between 0 and 100. For non-card payments, card-based payments predating the
public assignment of risk scores, or in the event of an error during evaluation, this
field will not be present. This field is only available with Radar for Fraud Teams. */
    riskScore?: number;
    /** (ID of the Radar.Rule)
The ID of the Radar rule that matched the payment, if applicable. */
    ruleId?: string | undefined;
    /** (Expanded)
The ID of the Radar rule that matched the payment, if applicable.
            
For more information, see the expand documentation. */
    rule?: Rule | undefined;
    internalRule?: ExpandableFieldOfRule | undefined;
    /** A human-readable description of the outcome type and reason, designed for you (the
recipient of the payment), not your customer. */
    sellerMessage?: string | undefined;
    /** Possible values are authorized, manual_review, issuer_declined,
blocked, and invalid. See understanding declines and Radar reviews for details. */
    type?: string | undefined;
}

export abstract class StripeEntityOfRule extends StripeEntity implements IStripeEntityOfRule {

    constructor(data?: IStripeEntityOfRule) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfRule {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfRule' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfRule extends IStripeEntity {
}

export class Rule extends StripeEntityOfRule implements IRule {
    id?: string | undefined;
    action?: string | undefined;
    deleted?: boolean | undefined;
    predicate?: string | undefined;

    constructor(data?: IRule) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.action = _data["action"];
            this.deleted = _data["deleted"];
            this.predicate = _data["predicate"];
        }
    }

    static override fromJS(data: any): Rule {
        data = typeof data === 'object' ? data : {};
        let result = new Rule();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["action"] = this.action;
        data["deleted"] = this.deleted;
        data["predicate"] = this.predicate;
        super.toJSON(data);
        return data;
    }
}

export interface IRule extends IStripeEntityOfRule {
    id?: string | undefined;
    action?: string | undefined;
    deleted?: boolean | undefined;
    predicate?: string | undefined;
}

/** Represents a generic expandable field. */
export class ExpandableFieldOfRule implements IExpandableFieldOfRule {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: Rule | undefined;

    constructor(data?: IExpandableFieldOfRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.expandedObject = _data["expandedObject"] ? Rule.fromJS(_data["expandedObject"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExpandableFieldOfRule {
        data = typeof data === 'object' ? data : {};
        let result = new ExpandableFieldOfRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["expandedObject"] = this.expandedObject ? this.expandedObject.toJSON() : <any>undefined;
        return data;
    }
}

/** Represents a generic expandable field. */
export interface IExpandableFieldOfRule {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: Rule | undefined;
}

export abstract class StripeEntityOfChargePaymentMethodDetails extends StripeEntity implements IStripeEntityOfChargePaymentMethodDetails {

    constructor(data?: IStripeEntityOfChargePaymentMethodDetails) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargePaymentMethodDetails {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargePaymentMethodDetails' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargePaymentMethodDetails extends IStripeEntity {
}

export class ChargePaymentMethodDetails extends StripeEntityOfChargePaymentMethodDetails implements IChargePaymentMethodDetails {
    achCreditTransfer?: ChargePaymentMethodDetailsAchCreditTransfer | undefined;
    achDebit?: ChargePaymentMethodDetailsAchDebit | undefined;
    acssDebit?: ChargePaymentMethodDetailsAcssDebit | undefined;
    affirm?: ChargePaymentMethodDetailsAffirm | undefined;
    afterpayClearpay?: ChargePaymentMethodDetailsAfterpayClearpay | undefined;
    alipay?: ChargePaymentMethodDetailsAlipay | undefined;
    auBecsDebit?: ChargePaymentMethodDetailsAuBecsDebit | undefined;
    bacsDebit?: ChargePaymentMethodDetailsBacsDebit | undefined;
    bancontact?: ChargePaymentMethodDetailsBancontact | undefined;
    blik?: ChargePaymentMethodDetailsBlik | undefined;
    boleto?: ChargePaymentMethodDetailsBoleto | undefined;
    card?: ChargePaymentMethodDetailsCard | undefined;
    cardPresent?: ChargePaymentMethodDetailsCardPresent | undefined;
    cashapp?: ChargePaymentMethodDetailsCashapp | undefined;
    customerBalance?: ChargePaymentMethodDetailsCustomerBalance | undefined;
    eps?: ChargePaymentMethodDetailsEps | undefined;
    fpx?: ChargePaymentMethodDetailsFpx | undefined;
    giropay?: ChargePaymentMethodDetailsGiropay | undefined;
    grabpay?: ChargePaymentMethodDetailsGrabpay | undefined;
    ideal?: ChargePaymentMethodDetailsIdeal | undefined;
    interacPresent?: ChargePaymentMethodDetailsInteracPresent | undefined;
    klarna?: ChargePaymentMethodDetailsKlarna | undefined;
    konbini?: ChargePaymentMethodDetailsKonbini | undefined;
    link?: ChargePaymentMethodDetailsLink | undefined;
    multibanco?: ChargePaymentMethodDetailsMultibanco | undefined;
    oxxo?: ChargePaymentMethodDetailsOxxo | undefined;
    p24?: ChargePaymentMethodDetailsP24 | undefined;
    paynow?: ChargePaymentMethodDetailsPaynow | undefined;
    paypal?: ChargePaymentMethodDetailsPaypal | undefined;
    pix?: ChargePaymentMethodDetailsPix | undefined;
    promptpay?: ChargePaymentMethodDetailsPromptpay | undefined;
    sepaDebit?: ChargePaymentMethodDetailsSepaDebit | undefined;
    sofort?: ChargePaymentMethodDetailsSofort | undefined;
    stripeAccount?: ChargePaymentMethodDetailsStripeAccount | undefined;
    /** The type of transaction-specific details of the payment method used in the payment, one
of ach_credit_transfer, ach_debit, acss_debit, alipay,
au_becs_debit, bancontact, card, card_present, eps,
giropay, ideal, klarna, multibanco, p24,
sepa_debit, sofort, stripe_account, or wechat. An additional
hash is included on payment_method_details with a name matching this value. It
contains information specific to the payment method. */
    type?: string | undefined;
    usBankAccount?: ChargePaymentMethodDetailsUsBankAccount | undefined;
    wechat?: ChargePaymentMethodDetailsWechat | undefined;
    wechatPay?: ChargePaymentMethodDetailsWechatPay | undefined;
    zip?: ChargePaymentMethodDetailsZip | undefined;

    constructor(data?: IChargePaymentMethodDetails) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.achCreditTransfer = _data["achCreditTransfer"] ? ChargePaymentMethodDetailsAchCreditTransfer.fromJS(_data["achCreditTransfer"]) : <any>undefined;
            this.achDebit = _data["achDebit"] ? ChargePaymentMethodDetailsAchDebit.fromJS(_data["achDebit"]) : <any>undefined;
            this.acssDebit = _data["acssDebit"] ? ChargePaymentMethodDetailsAcssDebit.fromJS(_data["acssDebit"]) : <any>undefined;
            this.affirm = _data["affirm"] ? ChargePaymentMethodDetailsAffirm.fromJS(_data["affirm"]) : <any>undefined;
            this.afterpayClearpay = _data["afterpayClearpay"] ? ChargePaymentMethodDetailsAfterpayClearpay.fromJS(_data["afterpayClearpay"]) : <any>undefined;
            this.alipay = _data["alipay"] ? ChargePaymentMethodDetailsAlipay.fromJS(_data["alipay"]) : <any>undefined;
            this.auBecsDebit = _data["auBecsDebit"] ? ChargePaymentMethodDetailsAuBecsDebit.fromJS(_data["auBecsDebit"]) : <any>undefined;
            this.bacsDebit = _data["bacsDebit"] ? ChargePaymentMethodDetailsBacsDebit.fromJS(_data["bacsDebit"]) : <any>undefined;
            this.bancontact = _data["bancontact"] ? ChargePaymentMethodDetailsBancontact.fromJS(_data["bancontact"]) : <any>undefined;
            this.blik = _data["blik"] ? ChargePaymentMethodDetailsBlik.fromJS(_data["blik"]) : <any>undefined;
            this.boleto = _data["boleto"] ? ChargePaymentMethodDetailsBoleto.fromJS(_data["boleto"]) : <any>undefined;
            this.card = _data["card"] ? ChargePaymentMethodDetailsCard.fromJS(_data["card"]) : <any>undefined;
            this.cardPresent = _data["cardPresent"] ? ChargePaymentMethodDetailsCardPresent.fromJS(_data["cardPresent"]) : <any>undefined;
            this.cashapp = _data["cashapp"] ? ChargePaymentMethodDetailsCashapp.fromJS(_data["cashapp"]) : <any>undefined;
            this.customerBalance = _data["customerBalance"] ? ChargePaymentMethodDetailsCustomerBalance.fromJS(_data["customerBalance"]) : <any>undefined;
            this.eps = _data["eps"] ? ChargePaymentMethodDetailsEps.fromJS(_data["eps"]) : <any>undefined;
            this.fpx = _data["fpx"] ? ChargePaymentMethodDetailsFpx.fromJS(_data["fpx"]) : <any>undefined;
            this.giropay = _data["giropay"] ? ChargePaymentMethodDetailsGiropay.fromJS(_data["giropay"]) : <any>undefined;
            this.grabpay = _data["grabpay"] ? ChargePaymentMethodDetailsGrabpay.fromJS(_data["grabpay"]) : <any>undefined;
            this.ideal = _data["ideal"] ? ChargePaymentMethodDetailsIdeal.fromJS(_data["ideal"]) : <any>undefined;
            this.interacPresent = _data["interacPresent"] ? ChargePaymentMethodDetailsInteracPresent.fromJS(_data["interacPresent"]) : <any>undefined;
            this.klarna = _data["klarna"] ? ChargePaymentMethodDetailsKlarna.fromJS(_data["klarna"]) : <any>undefined;
            this.konbini = _data["konbini"] ? ChargePaymentMethodDetailsKonbini.fromJS(_data["konbini"]) : <any>undefined;
            this.link = _data["link"] ? ChargePaymentMethodDetailsLink.fromJS(_data["link"]) : <any>undefined;
            this.multibanco = _data["multibanco"] ? ChargePaymentMethodDetailsMultibanco.fromJS(_data["multibanco"]) : <any>undefined;
            this.oxxo = _data["oxxo"] ? ChargePaymentMethodDetailsOxxo.fromJS(_data["oxxo"]) : <any>undefined;
            this.p24 = _data["p24"] ? ChargePaymentMethodDetailsP24.fromJS(_data["p24"]) : <any>undefined;
            this.paynow = _data["paynow"] ? ChargePaymentMethodDetailsPaynow.fromJS(_data["paynow"]) : <any>undefined;
            this.paypal = _data["paypal"] ? ChargePaymentMethodDetailsPaypal.fromJS(_data["paypal"]) : <any>undefined;
            this.pix = _data["pix"] ? ChargePaymentMethodDetailsPix.fromJS(_data["pix"]) : <any>undefined;
            this.promptpay = _data["promptpay"] ? ChargePaymentMethodDetailsPromptpay.fromJS(_data["promptpay"]) : <any>undefined;
            this.sepaDebit = _data["sepaDebit"] ? ChargePaymentMethodDetailsSepaDebit.fromJS(_data["sepaDebit"]) : <any>undefined;
            this.sofort = _data["sofort"] ? ChargePaymentMethodDetailsSofort.fromJS(_data["sofort"]) : <any>undefined;
            this.stripeAccount = _data["stripeAccount"] ? ChargePaymentMethodDetailsStripeAccount.fromJS(_data["stripeAccount"]) : <any>undefined;
            this.type = _data["type"];
            this.usBankAccount = _data["usBankAccount"] ? ChargePaymentMethodDetailsUsBankAccount.fromJS(_data["usBankAccount"]) : <any>undefined;
            this.wechat = _data["wechat"] ? ChargePaymentMethodDetailsWechat.fromJS(_data["wechat"]) : <any>undefined;
            this.wechatPay = _data["wechatPay"] ? ChargePaymentMethodDetailsWechatPay.fromJS(_data["wechatPay"]) : <any>undefined;
            this.zip = _data["zip"] ? ChargePaymentMethodDetailsZip.fromJS(_data["zip"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): ChargePaymentMethodDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ChargePaymentMethodDetails();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["achCreditTransfer"] = this.achCreditTransfer ? this.achCreditTransfer.toJSON() : <any>undefined;
        data["achDebit"] = this.achDebit ? this.achDebit.toJSON() : <any>undefined;
        data["acssDebit"] = this.acssDebit ? this.acssDebit.toJSON() : <any>undefined;
        data["affirm"] = this.affirm ? this.affirm.toJSON() : <any>undefined;
        data["afterpayClearpay"] = this.afterpayClearpay ? this.afterpayClearpay.toJSON() : <any>undefined;
        data["alipay"] = this.alipay ? this.alipay.toJSON() : <any>undefined;
        data["auBecsDebit"] = this.auBecsDebit ? this.auBecsDebit.toJSON() : <any>undefined;
        data["bacsDebit"] = this.bacsDebit ? this.bacsDebit.toJSON() : <any>undefined;
        data["bancontact"] = this.bancontact ? this.bancontact.toJSON() : <any>undefined;
        data["blik"] = this.blik ? this.blik.toJSON() : <any>undefined;
        data["boleto"] = this.boleto ? this.boleto.toJSON() : <any>undefined;
        data["card"] = this.card ? this.card.toJSON() : <any>undefined;
        data["cardPresent"] = this.cardPresent ? this.cardPresent.toJSON() : <any>undefined;
        data["cashapp"] = this.cashapp ? this.cashapp.toJSON() : <any>undefined;
        data["customerBalance"] = this.customerBalance ? this.customerBalance.toJSON() : <any>undefined;
        data["eps"] = this.eps ? this.eps.toJSON() : <any>undefined;
        data["fpx"] = this.fpx ? this.fpx.toJSON() : <any>undefined;
        data["giropay"] = this.giropay ? this.giropay.toJSON() : <any>undefined;
        data["grabpay"] = this.grabpay ? this.grabpay.toJSON() : <any>undefined;
        data["ideal"] = this.ideal ? this.ideal.toJSON() : <any>undefined;
        data["interacPresent"] = this.interacPresent ? this.interacPresent.toJSON() : <any>undefined;
        data["klarna"] = this.klarna ? this.klarna.toJSON() : <any>undefined;
        data["konbini"] = this.konbini ? this.konbini.toJSON() : <any>undefined;
        data["link"] = this.link ? this.link.toJSON() : <any>undefined;
        data["multibanco"] = this.multibanco ? this.multibanco.toJSON() : <any>undefined;
        data["oxxo"] = this.oxxo ? this.oxxo.toJSON() : <any>undefined;
        data["p24"] = this.p24 ? this.p24.toJSON() : <any>undefined;
        data["paynow"] = this.paynow ? this.paynow.toJSON() : <any>undefined;
        data["paypal"] = this.paypal ? this.paypal.toJSON() : <any>undefined;
        data["pix"] = this.pix ? this.pix.toJSON() : <any>undefined;
        data["promptpay"] = this.promptpay ? this.promptpay.toJSON() : <any>undefined;
        data["sepaDebit"] = this.sepaDebit ? this.sepaDebit.toJSON() : <any>undefined;
        data["sofort"] = this.sofort ? this.sofort.toJSON() : <any>undefined;
        data["stripeAccount"] = this.stripeAccount ? this.stripeAccount.toJSON() : <any>undefined;
        data["type"] = this.type;
        data["usBankAccount"] = this.usBankAccount ? this.usBankAccount.toJSON() : <any>undefined;
        data["wechat"] = this.wechat ? this.wechat.toJSON() : <any>undefined;
        data["wechatPay"] = this.wechatPay ? this.wechatPay.toJSON() : <any>undefined;
        data["zip"] = this.zip ? this.zip.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IChargePaymentMethodDetails extends IStripeEntityOfChargePaymentMethodDetails {
    achCreditTransfer?: ChargePaymentMethodDetailsAchCreditTransfer | undefined;
    achDebit?: ChargePaymentMethodDetailsAchDebit | undefined;
    acssDebit?: ChargePaymentMethodDetailsAcssDebit | undefined;
    affirm?: ChargePaymentMethodDetailsAffirm | undefined;
    afterpayClearpay?: ChargePaymentMethodDetailsAfterpayClearpay | undefined;
    alipay?: ChargePaymentMethodDetailsAlipay | undefined;
    auBecsDebit?: ChargePaymentMethodDetailsAuBecsDebit | undefined;
    bacsDebit?: ChargePaymentMethodDetailsBacsDebit | undefined;
    bancontact?: ChargePaymentMethodDetailsBancontact | undefined;
    blik?: ChargePaymentMethodDetailsBlik | undefined;
    boleto?: ChargePaymentMethodDetailsBoleto | undefined;
    card?: ChargePaymentMethodDetailsCard | undefined;
    cardPresent?: ChargePaymentMethodDetailsCardPresent | undefined;
    cashapp?: ChargePaymentMethodDetailsCashapp | undefined;
    customerBalance?: ChargePaymentMethodDetailsCustomerBalance | undefined;
    eps?: ChargePaymentMethodDetailsEps | undefined;
    fpx?: ChargePaymentMethodDetailsFpx | undefined;
    giropay?: ChargePaymentMethodDetailsGiropay | undefined;
    grabpay?: ChargePaymentMethodDetailsGrabpay | undefined;
    ideal?: ChargePaymentMethodDetailsIdeal | undefined;
    interacPresent?: ChargePaymentMethodDetailsInteracPresent | undefined;
    klarna?: ChargePaymentMethodDetailsKlarna | undefined;
    konbini?: ChargePaymentMethodDetailsKonbini | undefined;
    link?: ChargePaymentMethodDetailsLink | undefined;
    multibanco?: ChargePaymentMethodDetailsMultibanco | undefined;
    oxxo?: ChargePaymentMethodDetailsOxxo | undefined;
    p24?: ChargePaymentMethodDetailsP24 | undefined;
    paynow?: ChargePaymentMethodDetailsPaynow | undefined;
    paypal?: ChargePaymentMethodDetailsPaypal | undefined;
    pix?: ChargePaymentMethodDetailsPix | undefined;
    promptpay?: ChargePaymentMethodDetailsPromptpay | undefined;
    sepaDebit?: ChargePaymentMethodDetailsSepaDebit | undefined;
    sofort?: ChargePaymentMethodDetailsSofort | undefined;
    stripeAccount?: ChargePaymentMethodDetailsStripeAccount | undefined;
    /** The type of transaction-specific details of the payment method used in the payment, one
of ach_credit_transfer, ach_debit, acss_debit, alipay,
au_becs_debit, bancontact, card, card_present, eps,
giropay, ideal, klarna, multibanco, p24,
sepa_debit, sofort, stripe_account, or wechat. An additional
hash is included on payment_method_details with a name matching this value. It
contains information specific to the payment method. */
    type?: string | undefined;
    usBankAccount?: ChargePaymentMethodDetailsUsBankAccount | undefined;
    wechat?: ChargePaymentMethodDetailsWechat | undefined;
    wechatPay?: ChargePaymentMethodDetailsWechatPay | undefined;
    zip?: ChargePaymentMethodDetailsZip | undefined;
}

export abstract class StripeEntityOfChargePaymentMethodDetailsAchCreditTransfer extends StripeEntity implements IStripeEntityOfChargePaymentMethodDetailsAchCreditTransfer {

    constructor(data?: IStripeEntityOfChargePaymentMethodDetailsAchCreditTransfer) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargePaymentMethodDetailsAchCreditTransfer {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargePaymentMethodDetailsAchCreditTransfer' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargePaymentMethodDetailsAchCreditTransfer extends IStripeEntity {
}

export class ChargePaymentMethodDetailsAchCreditTransfer extends StripeEntityOfChargePaymentMethodDetailsAchCreditTransfer implements IChargePaymentMethodDetailsAchCreditTransfer {
    /** Account number to transfer funds to. */
    accountNumber?: string | undefined;
    /** Name of the bank associated with the routing number. */
    bankName?: string | undefined;
    /** Routing transit number for the bank account to transfer funds to. */
    routingNumber?: string | undefined;
    /** SWIFT code of the bank associated with the routing number. */
    swiftCode?: string | undefined;

    constructor(data?: IChargePaymentMethodDetailsAchCreditTransfer) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.accountNumber = _data["accountNumber"];
            this.bankName = _data["bankName"];
            this.routingNumber = _data["routingNumber"];
            this.swiftCode = _data["swiftCode"];
        }
    }

    static override fromJS(data: any): ChargePaymentMethodDetailsAchCreditTransfer {
        data = typeof data === 'object' ? data : {};
        let result = new ChargePaymentMethodDetailsAchCreditTransfer();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountNumber"] = this.accountNumber;
        data["bankName"] = this.bankName;
        data["routingNumber"] = this.routingNumber;
        data["swiftCode"] = this.swiftCode;
        super.toJSON(data);
        return data;
    }
}

export interface IChargePaymentMethodDetailsAchCreditTransfer extends IStripeEntityOfChargePaymentMethodDetailsAchCreditTransfer {
    /** Account number to transfer funds to. */
    accountNumber?: string | undefined;
    /** Name of the bank associated with the routing number. */
    bankName?: string | undefined;
    /** Routing transit number for the bank account to transfer funds to. */
    routingNumber?: string | undefined;
    /** SWIFT code of the bank associated with the routing number. */
    swiftCode?: string | undefined;
}

export abstract class StripeEntityOfChargePaymentMethodDetailsAchDebit extends StripeEntity implements IStripeEntityOfChargePaymentMethodDetailsAchDebit {

    constructor(data?: IStripeEntityOfChargePaymentMethodDetailsAchDebit) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargePaymentMethodDetailsAchDebit {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargePaymentMethodDetailsAchDebit' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargePaymentMethodDetailsAchDebit extends IStripeEntity {
}

export class ChargePaymentMethodDetailsAchDebit extends StripeEntityOfChargePaymentMethodDetailsAchDebit implements IChargePaymentMethodDetailsAchDebit {
    /** Type of entity that holds the account. This can be either individual or
company.
One of: company, or individual. */
    accountHolderType?: string | undefined;
    /** Name of the bank associated with the bank account. */
    bankName?: string | undefined;
    /** Two-letter ISO code representing the country the bank account is located in. */
    country?: string | undefined;
    /** Uniquely identifies this particular bank account. You can use this attribute to check
whether two bank accounts are the same. */
    fingerprint?: string | undefined;
    /** Last four digits of the bank account number. */
    last4?: string | undefined;
    /** Routing transit number of the bank account. */
    routingNumber?: string | undefined;

    constructor(data?: IChargePaymentMethodDetailsAchDebit) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.accountHolderType = _data["accountHolderType"];
            this.bankName = _data["bankName"];
            this.country = _data["country"];
            this.fingerprint = _data["fingerprint"];
            this.last4 = _data["last4"];
            this.routingNumber = _data["routingNumber"];
        }
    }

    static override fromJS(data: any): ChargePaymentMethodDetailsAchDebit {
        data = typeof data === 'object' ? data : {};
        let result = new ChargePaymentMethodDetailsAchDebit();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountHolderType"] = this.accountHolderType;
        data["bankName"] = this.bankName;
        data["country"] = this.country;
        data["fingerprint"] = this.fingerprint;
        data["last4"] = this.last4;
        data["routingNumber"] = this.routingNumber;
        super.toJSON(data);
        return data;
    }
}

export interface IChargePaymentMethodDetailsAchDebit extends IStripeEntityOfChargePaymentMethodDetailsAchDebit {
    /** Type of entity that holds the account. This can be either individual or
company.
One of: company, or individual. */
    accountHolderType?: string | undefined;
    /** Name of the bank associated with the bank account. */
    bankName?: string | undefined;
    /** Two-letter ISO code representing the country the bank account is located in. */
    country?: string | undefined;
    /** Uniquely identifies this particular bank account. You can use this attribute to check
whether two bank accounts are the same. */
    fingerprint?: string | undefined;
    /** Last four digits of the bank account number. */
    last4?: string | undefined;
    /** Routing transit number of the bank account. */
    routingNumber?: string | undefined;
}

export abstract class StripeEntityOfChargePaymentMethodDetailsAcssDebit extends StripeEntity implements IStripeEntityOfChargePaymentMethodDetailsAcssDebit {

    constructor(data?: IStripeEntityOfChargePaymentMethodDetailsAcssDebit) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargePaymentMethodDetailsAcssDebit {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargePaymentMethodDetailsAcssDebit' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargePaymentMethodDetailsAcssDebit extends IStripeEntity {
}

export class ChargePaymentMethodDetailsAcssDebit extends StripeEntityOfChargePaymentMethodDetailsAcssDebit implements IChargePaymentMethodDetailsAcssDebit {
    /** Name of the bank associated with the bank account. */
    bankName?: string | undefined;
    /** Uniquely identifies this particular bank account. You can use this attribute to check
whether two bank accounts are the same. */
    fingerprint?: string | undefined;
    /** Institution number of the bank account. */
    institutionNumber?: string | undefined;
    /** Last four digits of the bank account number. */
    last4?: string | undefined;
    /** ID of the mandate used to make this payment. */
    mandate?: string | undefined;
    /** Transit number of the bank account. */
    transitNumber?: string | undefined;

    constructor(data?: IChargePaymentMethodDetailsAcssDebit) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.bankName = _data["bankName"];
            this.fingerprint = _data["fingerprint"];
            this.institutionNumber = _data["institutionNumber"];
            this.last4 = _data["last4"];
            this.mandate = _data["mandate"];
            this.transitNumber = _data["transitNumber"];
        }
    }

    static override fromJS(data: any): ChargePaymentMethodDetailsAcssDebit {
        data = typeof data === 'object' ? data : {};
        let result = new ChargePaymentMethodDetailsAcssDebit();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankName"] = this.bankName;
        data["fingerprint"] = this.fingerprint;
        data["institutionNumber"] = this.institutionNumber;
        data["last4"] = this.last4;
        data["mandate"] = this.mandate;
        data["transitNumber"] = this.transitNumber;
        super.toJSON(data);
        return data;
    }
}

export interface IChargePaymentMethodDetailsAcssDebit extends IStripeEntityOfChargePaymentMethodDetailsAcssDebit {
    /** Name of the bank associated with the bank account. */
    bankName?: string | undefined;
    /** Uniquely identifies this particular bank account. You can use this attribute to check
whether two bank accounts are the same. */
    fingerprint?: string | undefined;
    /** Institution number of the bank account. */
    institutionNumber?: string | undefined;
    /** Last four digits of the bank account number. */
    last4?: string | undefined;
    /** ID of the mandate used to make this payment. */
    mandate?: string | undefined;
    /** Transit number of the bank account. */
    transitNumber?: string | undefined;
}

export abstract class StripeEntityOfChargePaymentMethodDetailsAffirm extends StripeEntity implements IStripeEntityOfChargePaymentMethodDetailsAffirm {

    constructor(data?: IStripeEntityOfChargePaymentMethodDetailsAffirm) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargePaymentMethodDetailsAffirm {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargePaymentMethodDetailsAffirm' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargePaymentMethodDetailsAffirm extends IStripeEntity {
}

export class ChargePaymentMethodDetailsAffirm extends StripeEntityOfChargePaymentMethodDetailsAffirm implements IChargePaymentMethodDetailsAffirm {

    constructor(data?: IChargePaymentMethodDetailsAffirm) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ChargePaymentMethodDetailsAffirm {
        data = typeof data === 'object' ? data : {};
        let result = new ChargePaymentMethodDetailsAffirm();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IChargePaymentMethodDetailsAffirm extends IStripeEntityOfChargePaymentMethodDetailsAffirm {
}

export abstract class StripeEntityOfChargePaymentMethodDetailsAfterpayClearpay extends StripeEntity implements IStripeEntityOfChargePaymentMethodDetailsAfterpayClearpay {

    constructor(data?: IStripeEntityOfChargePaymentMethodDetailsAfterpayClearpay) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargePaymentMethodDetailsAfterpayClearpay {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargePaymentMethodDetailsAfterpayClearpay' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargePaymentMethodDetailsAfterpayClearpay extends IStripeEntity {
}

export class ChargePaymentMethodDetailsAfterpayClearpay extends StripeEntityOfChargePaymentMethodDetailsAfterpayClearpay implements IChargePaymentMethodDetailsAfterpayClearpay {
    /** Order identifier shown to the merchant in Afterpay’s online portal. */
    reference?: string | undefined;

    constructor(data?: IChargePaymentMethodDetailsAfterpayClearpay) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.reference = _data["reference"];
        }
    }

    static override fromJS(data: any): ChargePaymentMethodDetailsAfterpayClearpay {
        data = typeof data === 'object' ? data : {};
        let result = new ChargePaymentMethodDetailsAfterpayClearpay();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reference"] = this.reference;
        super.toJSON(data);
        return data;
    }
}

export interface IChargePaymentMethodDetailsAfterpayClearpay extends IStripeEntityOfChargePaymentMethodDetailsAfterpayClearpay {
    /** Order identifier shown to the merchant in Afterpay’s online portal. */
    reference?: string | undefined;
}

export abstract class StripeEntityOfChargePaymentMethodDetailsAlipay extends StripeEntity implements IStripeEntityOfChargePaymentMethodDetailsAlipay {

    constructor(data?: IStripeEntityOfChargePaymentMethodDetailsAlipay) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargePaymentMethodDetailsAlipay {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargePaymentMethodDetailsAlipay' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargePaymentMethodDetailsAlipay extends IStripeEntity {
}

export class ChargePaymentMethodDetailsAlipay extends StripeEntityOfChargePaymentMethodDetailsAlipay implements IChargePaymentMethodDetailsAlipay {
    /** Uniquely identifies this particular Alipay account. You can use this attribute to check
whether two Alipay accounts are the same. */
    buyerId?: string | undefined;
    /** Uniquely identifies this particular Alipay account. You can use this attribute to check
whether two Alipay accounts are the same. */
    fingerprint?: string | undefined;
    /** Transaction ID of this particular Alipay transaction. */
    transactionId?: string | undefined;

    constructor(data?: IChargePaymentMethodDetailsAlipay) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.buyerId = _data["buyerId"];
            this.fingerprint = _data["fingerprint"];
            this.transactionId = _data["transactionId"];
        }
    }

    static override fromJS(data: any): ChargePaymentMethodDetailsAlipay {
        data = typeof data === 'object' ? data : {};
        let result = new ChargePaymentMethodDetailsAlipay();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["buyerId"] = this.buyerId;
        data["fingerprint"] = this.fingerprint;
        data["transactionId"] = this.transactionId;
        super.toJSON(data);
        return data;
    }
}

export interface IChargePaymentMethodDetailsAlipay extends IStripeEntityOfChargePaymentMethodDetailsAlipay {
    /** Uniquely identifies this particular Alipay account. You can use this attribute to check
whether two Alipay accounts are the same. */
    buyerId?: string | undefined;
    /** Uniquely identifies this particular Alipay account. You can use this attribute to check
whether two Alipay accounts are the same. */
    fingerprint?: string | undefined;
    /** Transaction ID of this particular Alipay transaction. */
    transactionId?: string | undefined;
}

export abstract class StripeEntityOfChargePaymentMethodDetailsAuBecsDebit extends StripeEntity implements IStripeEntityOfChargePaymentMethodDetailsAuBecsDebit {

    constructor(data?: IStripeEntityOfChargePaymentMethodDetailsAuBecsDebit) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargePaymentMethodDetailsAuBecsDebit {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargePaymentMethodDetailsAuBecsDebit' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargePaymentMethodDetailsAuBecsDebit extends IStripeEntity {
}

export class ChargePaymentMethodDetailsAuBecsDebit extends StripeEntityOfChargePaymentMethodDetailsAuBecsDebit implements IChargePaymentMethodDetailsAuBecsDebit {
    /** Bank-State-Branch number of the bank account. */
    bsbNumber?: string | undefined;
    /** Uniquely identifies this particular bank account. You can use this attribute to check
whether two bank accounts are the same. */
    fingerprint?: string | undefined;
    /** Last four digits of the bank account number. */
    last4?: string | undefined;
    /** ID of the mandate used to make this payment. */
    mandate?: string | undefined;

    constructor(data?: IChargePaymentMethodDetailsAuBecsDebit) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.bsbNumber = _data["bsbNumber"];
            this.fingerprint = _data["fingerprint"];
            this.last4 = _data["last4"];
            this.mandate = _data["mandate"];
        }
    }

    static override fromJS(data: any): ChargePaymentMethodDetailsAuBecsDebit {
        data = typeof data === 'object' ? data : {};
        let result = new ChargePaymentMethodDetailsAuBecsDebit();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bsbNumber"] = this.bsbNumber;
        data["fingerprint"] = this.fingerprint;
        data["last4"] = this.last4;
        data["mandate"] = this.mandate;
        super.toJSON(data);
        return data;
    }
}

export interface IChargePaymentMethodDetailsAuBecsDebit extends IStripeEntityOfChargePaymentMethodDetailsAuBecsDebit {
    /** Bank-State-Branch number of the bank account. */
    bsbNumber?: string | undefined;
    /** Uniquely identifies this particular bank account. You can use this attribute to check
whether two bank accounts are the same. */
    fingerprint?: string | undefined;
    /** Last four digits of the bank account number. */
    last4?: string | undefined;
    /** ID of the mandate used to make this payment. */
    mandate?: string | undefined;
}

export abstract class StripeEntityOfChargePaymentMethodDetailsBacsDebit extends StripeEntity implements IStripeEntityOfChargePaymentMethodDetailsBacsDebit {

    constructor(data?: IStripeEntityOfChargePaymentMethodDetailsBacsDebit) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargePaymentMethodDetailsBacsDebit {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargePaymentMethodDetailsBacsDebit' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargePaymentMethodDetailsBacsDebit extends IStripeEntity {
}

export class ChargePaymentMethodDetailsBacsDebit extends StripeEntityOfChargePaymentMethodDetailsBacsDebit implements IChargePaymentMethodDetailsBacsDebit {
    /** Uniquely identifies this particular bank account. You can use this attribute to check
whether two bank accounts are the same. */
    fingerprint?: string | undefined;
    /** Last four digits of the bank account number. */
    last4?: string | undefined;
    /** ID of the mandate used to make this payment. */
    mandate?: string | undefined;
    /** Sort code of the bank account. (e.g., 10-20-30). */
    sortCode?: string | undefined;

    constructor(data?: IChargePaymentMethodDetailsBacsDebit) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.fingerprint = _data["fingerprint"];
            this.last4 = _data["last4"];
            this.mandate = _data["mandate"];
            this.sortCode = _data["sortCode"];
        }
    }

    static override fromJS(data: any): ChargePaymentMethodDetailsBacsDebit {
        data = typeof data === 'object' ? data : {};
        let result = new ChargePaymentMethodDetailsBacsDebit();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fingerprint"] = this.fingerprint;
        data["last4"] = this.last4;
        data["mandate"] = this.mandate;
        data["sortCode"] = this.sortCode;
        super.toJSON(data);
        return data;
    }
}

export interface IChargePaymentMethodDetailsBacsDebit extends IStripeEntityOfChargePaymentMethodDetailsBacsDebit {
    /** Uniquely identifies this particular bank account. You can use this attribute to check
whether two bank accounts are the same. */
    fingerprint?: string | undefined;
    /** Last four digits of the bank account number. */
    last4?: string | undefined;
    /** ID of the mandate used to make this payment. */
    mandate?: string | undefined;
    /** Sort code of the bank account. (e.g., 10-20-30). */
    sortCode?: string | undefined;
}

export abstract class StripeEntityOfChargePaymentMethodDetailsBancontact extends StripeEntity implements IStripeEntityOfChargePaymentMethodDetailsBancontact {

    constructor(data?: IStripeEntityOfChargePaymentMethodDetailsBancontact) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargePaymentMethodDetailsBancontact {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargePaymentMethodDetailsBancontact' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargePaymentMethodDetailsBancontact extends IStripeEntity {
}

export class ChargePaymentMethodDetailsBancontact extends StripeEntityOfChargePaymentMethodDetailsBancontact implements IChargePaymentMethodDetailsBancontact {
    /** Bank code of bank associated with the bank account. */
    bankCode?: string | undefined;
    /** Name of the bank associated with the bank account. */
    bankName?: string | undefined;
    /** Bank Identifier Code of the bank associated with the bank account. */
    bic?: string | undefined;
    /** (ID of the PaymentMethod)
The ID of the SEPA Direct Debit PaymentMethod which was generated by this Charge. */
    generatedSepaDebitId?: string | undefined;
    /** (Expanded)
The ID of the SEPA Direct Debit PaymentMethod which was generated by this Charge.
            
For more information, see the expand documentation. */
    generatedSepaDebit?: PaymentMethod | undefined;
    internalGeneratedSepaDebit?: ExpandableFieldOfPaymentMethod | undefined;
    /** (ID of the Mandate)
The mandate for the SEPA Direct Debit PaymentMethod which was generated by this Charge. */
    generatedSepaDebitMandateId?: string | undefined;
    /** (Expanded)
The mandate for the SEPA Direct Debit PaymentMethod which was generated by this Charge.
            
For more information, see the expand documentation. */
    generatedSepaDebitMandate?: Mandate | undefined;
    internalGeneratedSepaDebitMandate?: ExpandableFieldOfMandate | undefined;
    /** Last four characters of the IBAN. */
    ibanLast4?: string | undefined;
    /** Preferred language of the Bancontact authorization page that the customer is redirected
to. Can be one of en, de, fr, or nl.
One of: de, en, fr, or nl. */
    preferredLanguage?: string | undefined;
    /** Owner's verified full name. Values are verified or provided by Bancontact directly (if
supported) at the time of authorization or settlement. They cannot be set or mutated. */
    verifiedName?: string | undefined;

    constructor(data?: IChargePaymentMethodDetailsBancontact) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.bankCode = _data["bankCode"];
            this.bankName = _data["bankName"];
            this.bic = _data["bic"];
            this.generatedSepaDebitId = _data["generatedSepaDebitId"];
            this.generatedSepaDebit = _data["generatedSepaDebit"] ? PaymentMethod.fromJS(_data["generatedSepaDebit"]) : <any>undefined;
            this.internalGeneratedSepaDebit = _data["internalGeneratedSepaDebit"] ? ExpandableFieldOfPaymentMethod.fromJS(_data["internalGeneratedSepaDebit"]) : <any>undefined;
            this.generatedSepaDebitMandateId = _data["generatedSepaDebitMandateId"];
            this.generatedSepaDebitMandate = _data["generatedSepaDebitMandate"] ? Mandate.fromJS(_data["generatedSepaDebitMandate"]) : <any>undefined;
            this.internalGeneratedSepaDebitMandate = _data["internalGeneratedSepaDebitMandate"] ? ExpandableFieldOfMandate.fromJS(_data["internalGeneratedSepaDebitMandate"]) : <any>undefined;
            this.ibanLast4 = _data["ibanLast4"];
            this.preferredLanguage = _data["preferredLanguage"];
            this.verifiedName = _data["verifiedName"];
        }
    }

    static override fromJS(data: any): ChargePaymentMethodDetailsBancontact {
        data = typeof data === 'object' ? data : {};
        let result = new ChargePaymentMethodDetailsBancontact();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankCode"] = this.bankCode;
        data["bankName"] = this.bankName;
        data["bic"] = this.bic;
        data["generatedSepaDebitId"] = this.generatedSepaDebitId;
        data["generatedSepaDebit"] = this.generatedSepaDebit ? this.generatedSepaDebit.toJSON() : <any>undefined;
        data["internalGeneratedSepaDebit"] = this.internalGeneratedSepaDebit ? this.internalGeneratedSepaDebit.toJSON() : <any>undefined;
        data["generatedSepaDebitMandateId"] = this.generatedSepaDebitMandateId;
        data["generatedSepaDebitMandate"] = this.generatedSepaDebitMandate ? this.generatedSepaDebitMandate.toJSON() : <any>undefined;
        data["internalGeneratedSepaDebitMandate"] = this.internalGeneratedSepaDebitMandate ? this.internalGeneratedSepaDebitMandate.toJSON() : <any>undefined;
        data["ibanLast4"] = this.ibanLast4;
        data["preferredLanguage"] = this.preferredLanguage;
        data["verifiedName"] = this.verifiedName;
        super.toJSON(data);
        return data;
    }
}

export interface IChargePaymentMethodDetailsBancontact extends IStripeEntityOfChargePaymentMethodDetailsBancontact {
    /** Bank code of bank associated with the bank account. */
    bankCode?: string | undefined;
    /** Name of the bank associated with the bank account. */
    bankName?: string | undefined;
    /** Bank Identifier Code of the bank associated with the bank account. */
    bic?: string | undefined;
    /** (ID of the PaymentMethod)
The ID of the SEPA Direct Debit PaymentMethod which was generated by this Charge. */
    generatedSepaDebitId?: string | undefined;
    /** (Expanded)
The ID of the SEPA Direct Debit PaymentMethod which was generated by this Charge.
            
For more information, see the expand documentation. */
    generatedSepaDebit?: PaymentMethod | undefined;
    internalGeneratedSepaDebit?: ExpandableFieldOfPaymentMethod | undefined;
    /** (ID of the Mandate)
The mandate for the SEPA Direct Debit PaymentMethod which was generated by this Charge. */
    generatedSepaDebitMandateId?: string | undefined;
    /** (Expanded)
The mandate for the SEPA Direct Debit PaymentMethod which was generated by this Charge.
            
For more information, see the expand documentation. */
    generatedSepaDebitMandate?: Mandate | undefined;
    internalGeneratedSepaDebitMandate?: ExpandableFieldOfMandate | undefined;
    /** Last four characters of the IBAN. */
    ibanLast4?: string | undefined;
    /** Preferred language of the Bancontact authorization page that the customer is redirected
to. Can be one of en, de, fr, or nl.
One of: de, en, fr, or nl. */
    preferredLanguage?: string | undefined;
    /** Owner's verified full name. Values are verified or provided by Bancontact directly (if
supported) at the time of authorization or settlement. They cannot be set or mutated. */
    verifiedName?: string | undefined;
}

export abstract class StripeEntityOfChargePaymentMethodDetailsBlik extends StripeEntity implements IStripeEntityOfChargePaymentMethodDetailsBlik {

    constructor(data?: IStripeEntityOfChargePaymentMethodDetailsBlik) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargePaymentMethodDetailsBlik {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargePaymentMethodDetailsBlik' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargePaymentMethodDetailsBlik extends IStripeEntity {
}

export class ChargePaymentMethodDetailsBlik extends StripeEntityOfChargePaymentMethodDetailsBlik implements IChargePaymentMethodDetailsBlik {

    constructor(data?: IChargePaymentMethodDetailsBlik) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ChargePaymentMethodDetailsBlik {
        data = typeof data === 'object' ? data : {};
        let result = new ChargePaymentMethodDetailsBlik();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IChargePaymentMethodDetailsBlik extends IStripeEntityOfChargePaymentMethodDetailsBlik {
}

export abstract class StripeEntityOfChargePaymentMethodDetailsBoleto extends StripeEntity implements IStripeEntityOfChargePaymentMethodDetailsBoleto {

    constructor(data?: IStripeEntityOfChargePaymentMethodDetailsBoleto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargePaymentMethodDetailsBoleto {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargePaymentMethodDetailsBoleto' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargePaymentMethodDetailsBoleto extends IStripeEntity {
}

export class ChargePaymentMethodDetailsBoleto extends StripeEntityOfChargePaymentMethodDetailsBoleto implements IChargePaymentMethodDetailsBoleto {
    /** The tax ID of the customer (CPF for individuals consumers or CNPJ for businesses
consumers). */
    taxId?: string | undefined;

    constructor(data?: IChargePaymentMethodDetailsBoleto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.taxId = _data["taxId"];
        }
    }

    static override fromJS(data: any): ChargePaymentMethodDetailsBoleto {
        data = typeof data === 'object' ? data : {};
        let result = new ChargePaymentMethodDetailsBoleto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taxId"] = this.taxId;
        super.toJSON(data);
        return data;
    }
}

export interface IChargePaymentMethodDetailsBoleto extends IStripeEntityOfChargePaymentMethodDetailsBoleto {
    /** The tax ID of the customer (CPF for individuals consumers or CNPJ for businesses
consumers). */
    taxId?: string | undefined;
}

export abstract class StripeEntityOfChargePaymentMethodDetailsCard extends StripeEntity implements IStripeEntityOfChargePaymentMethodDetailsCard {

    constructor(data?: IStripeEntityOfChargePaymentMethodDetailsCard) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargePaymentMethodDetailsCard {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargePaymentMethodDetailsCard' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargePaymentMethodDetailsCard extends IStripeEntity {
}

export class ChargePaymentMethodDetailsCard extends StripeEntityOfChargePaymentMethodDetailsCard implements IChargePaymentMethodDetailsCard {
    /** Card brand. Can be amex, diners, discover, eftpos_au,
jcb, mastercard, unionpay, visa, or unknown. */
    brand?: string | undefined;
    /** Check results by Card networks on Card address and CVC at time of payment. */
    checks?: ChargePaymentMethodDetailsCardChecks | undefined;
    /** Two-letter ISO code representing the country of the card. You could use this attribute
to get a sense of the international breakdown of cards you've collected. */
    country?: string | undefined;
    /** A high-level description of the type of cards issued in this range. (For internal use
only and not typically available in standard API requests.). */
    description?: string | undefined;
    /** Two-digit number representing the card's expiration month. */
    expMonth?: number;
    /** Four-digit number representing the card's expiration year. */
    expYear?: number;
    /** Uniquely identifies this particular card number. You can use this attribute to check
whether two customers who’ve signed up with you are using the same card number, for
example. For payment methods that tokenize card information (Apple Pay, Google Pay), the
tokenized number might be provided instead of the underlying card number.
            
Starting May 1, 2021, card fingerprint in India for Connect will change to allow two
fingerprints for the same card --- one for India and one for the rest of the world.. */
    fingerprint?: string | undefined;
    /** Card funding type. Can be credit, debit, prepaid, or
unknown. */
    funding?: string | undefined;
    /** Issuer identification number of the card. (For internal use only and not typically
available in standard API requests.). */
    iin?: string | undefined;
    /** Installment details for this payment (Mexico only).
            
For more information, see the installments integration guide. */
    installments?: ChargePaymentMethodDetailsCardInstallments | undefined;
    /** The name of the card's issuing bank. (For internal use only and not typically available
in standard API requests.). */
    issuer?: string | undefined;
    /** The last four digits of the card. */
    last4?: string | undefined;
    /** ID of the mandate used to make this payment or created by it. */
    mandate?: string | undefined;
    /** True if this payment was marked as MOTO and out of scope for SCA. */
    moto?: boolean | undefined;
    /** Identifies which network this charge was processed on. Can be amex,
cartes_bancaires, diners, discover, eftpos_au,
interac, jcb, mastercard, unionpay, visa, or
unknown. */
    network?: string | undefined;
    /** If this card has network token credentials, this contains the details of the network
token credentials. */
    networkToken?: ChargePaymentMethodDetailsCardNetworkToken | undefined;
    /** Populated if this transaction used 3D Secure authentication. */
    threeDSecure?: ChargePaymentMethodDetailsCardThreeDSecure | undefined;
    /** If this Card is part of a card wallet, this contains the details of the card wallet. */
    wallet?: ChargePaymentMethodDetailsCardWallet | undefined;

    constructor(data?: IChargePaymentMethodDetailsCard) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.brand = _data["brand"];
            this.checks = _data["checks"] ? ChargePaymentMethodDetailsCardChecks.fromJS(_data["checks"]) : <any>undefined;
            this.country = _data["country"];
            this.description = _data["description"];
            this.expMonth = _data["expMonth"];
            this.expYear = _data["expYear"];
            this.fingerprint = _data["fingerprint"];
            this.funding = _data["funding"];
            this.iin = _data["iin"];
            this.installments = _data["installments"] ? ChargePaymentMethodDetailsCardInstallments.fromJS(_data["installments"]) : <any>undefined;
            this.issuer = _data["issuer"];
            this.last4 = _data["last4"];
            this.mandate = _data["mandate"];
            this.moto = _data["moto"];
            this.network = _data["network"];
            this.networkToken = _data["networkToken"] ? ChargePaymentMethodDetailsCardNetworkToken.fromJS(_data["networkToken"]) : <any>undefined;
            this.threeDSecure = _data["threeDSecure"] ? ChargePaymentMethodDetailsCardThreeDSecure.fromJS(_data["threeDSecure"]) : <any>undefined;
            this.wallet = _data["wallet"] ? ChargePaymentMethodDetailsCardWallet.fromJS(_data["wallet"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): ChargePaymentMethodDetailsCard {
        data = typeof data === 'object' ? data : {};
        let result = new ChargePaymentMethodDetailsCard();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brand"] = this.brand;
        data["checks"] = this.checks ? this.checks.toJSON() : <any>undefined;
        data["country"] = this.country;
        data["description"] = this.description;
        data["expMonth"] = this.expMonth;
        data["expYear"] = this.expYear;
        data["fingerprint"] = this.fingerprint;
        data["funding"] = this.funding;
        data["iin"] = this.iin;
        data["installments"] = this.installments ? this.installments.toJSON() : <any>undefined;
        data["issuer"] = this.issuer;
        data["last4"] = this.last4;
        data["mandate"] = this.mandate;
        data["moto"] = this.moto;
        data["network"] = this.network;
        data["networkToken"] = this.networkToken ? this.networkToken.toJSON() : <any>undefined;
        data["threeDSecure"] = this.threeDSecure ? this.threeDSecure.toJSON() : <any>undefined;
        data["wallet"] = this.wallet ? this.wallet.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IChargePaymentMethodDetailsCard extends IStripeEntityOfChargePaymentMethodDetailsCard {
    /** Card brand. Can be amex, diners, discover, eftpos_au,
jcb, mastercard, unionpay, visa, or unknown. */
    brand?: string | undefined;
    /** Check results by Card networks on Card address and CVC at time of payment. */
    checks?: ChargePaymentMethodDetailsCardChecks | undefined;
    /** Two-letter ISO code representing the country of the card. You could use this attribute
to get a sense of the international breakdown of cards you've collected. */
    country?: string | undefined;
    /** A high-level description of the type of cards issued in this range. (For internal use
only and not typically available in standard API requests.). */
    description?: string | undefined;
    /** Two-digit number representing the card's expiration month. */
    expMonth?: number;
    /** Four-digit number representing the card's expiration year. */
    expYear?: number;
    /** Uniquely identifies this particular card number. You can use this attribute to check
whether two customers who’ve signed up with you are using the same card number, for
example. For payment methods that tokenize card information (Apple Pay, Google Pay), the
tokenized number might be provided instead of the underlying card number.
            
Starting May 1, 2021, card fingerprint in India for Connect will change to allow two
fingerprints for the same card --- one for India and one for the rest of the world.. */
    fingerprint?: string | undefined;
    /** Card funding type. Can be credit, debit, prepaid, or
unknown. */
    funding?: string | undefined;
    /** Issuer identification number of the card. (For internal use only and not typically
available in standard API requests.). */
    iin?: string | undefined;
    /** Installment details for this payment (Mexico only).
            
For more information, see the installments integration guide. */
    installments?: ChargePaymentMethodDetailsCardInstallments | undefined;
    /** The name of the card's issuing bank. (For internal use only and not typically available
in standard API requests.). */
    issuer?: string | undefined;
    /** The last four digits of the card. */
    last4?: string | undefined;
    /** ID of the mandate used to make this payment or created by it. */
    mandate?: string | undefined;
    /** True if this payment was marked as MOTO and out of scope for SCA. */
    moto?: boolean | undefined;
    /** Identifies which network this charge was processed on. Can be amex,
cartes_bancaires, diners, discover, eftpos_au,
interac, jcb, mastercard, unionpay, visa, or
unknown. */
    network?: string | undefined;
    /** If this card has network token credentials, this contains the details of the network
token credentials. */
    networkToken?: ChargePaymentMethodDetailsCardNetworkToken | undefined;
    /** Populated if this transaction used 3D Secure authentication. */
    threeDSecure?: ChargePaymentMethodDetailsCardThreeDSecure | undefined;
    /** If this Card is part of a card wallet, this contains the details of the card wallet. */
    wallet?: ChargePaymentMethodDetailsCardWallet | undefined;
}

export abstract class StripeEntityOfChargePaymentMethodDetailsCardChecks extends StripeEntity implements IStripeEntityOfChargePaymentMethodDetailsCardChecks {

    constructor(data?: IStripeEntityOfChargePaymentMethodDetailsCardChecks) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargePaymentMethodDetailsCardChecks {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargePaymentMethodDetailsCardChecks' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargePaymentMethodDetailsCardChecks extends IStripeEntity {
}

export class ChargePaymentMethodDetailsCardChecks extends StripeEntityOfChargePaymentMethodDetailsCardChecks implements IChargePaymentMethodDetailsCardChecks {
    /** If a address line1 was provided, results of the check, one of pass, fail,
unavailable, or unchecked. */
    addressLine1Check?: string | undefined;
    /** If a address postal code was provided, results of the check, one of pass,
fail, unavailable, or unchecked. */
    addressPostalCodeCheck?: string | undefined;
    /** If a CVC was provided, results of the check, one of pass, fail,
unavailable, or unchecked. */
    cvcCheck?: string | undefined;

    constructor(data?: IChargePaymentMethodDetailsCardChecks) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.addressLine1Check = _data["addressLine1Check"];
            this.addressPostalCodeCheck = _data["addressPostalCodeCheck"];
            this.cvcCheck = _data["cvcCheck"];
        }
    }

    static override fromJS(data: any): ChargePaymentMethodDetailsCardChecks {
        data = typeof data === 'object' ? data : {};
        let result = new ChargePaymentMethodDetailsCardChecks();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["addressLine1Check"] = this.addressLine1Check;
        data["addressPostalCodeCheck"] = this.addressPostalCodeCheck;
        data["cvcCheck"] = this.cvcCheck;
        super.toJSON(data);
        return data;
    }
}

export interface IChargePaymentMethodDetailsCardChecks extends IStripeEntityOfChargePaymentMethodDetailsCardChecks {
    /** If a address line1 was provided, results of the check, one of pass, fail,
unavailable, or unchecked. */
    addressLine1Check?: string | undefined;
    /** If a address postal code was provided, results of the check, one of pass,
fail, unavailable, or unchecked. */
    addressPostalCodeCheck?: string | undefined;
    /** If a CVC was provided, results of the check, one of pass, fail,
unavailable, or unchecked. */
    cvcCheck?: string | undefined;
}

export abstract class StripeEntityOfChargePaymentMethodDetailsCardInstallments extends StripeEntity implements IStripeEntityOfChargePaymentMethodDetailsCardInstallments {

    constructor(data?: IStripeEntityOfChargePaymentMethodDetailsCardInstallments) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargePaymentMethodDetailsCardInstallments {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargePaymentMethodDetailsCardInstallments' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargePaymentMethodDetailsCardInstallments extends IStripeEntity {
}

export class ChargePaymentMethodDetailsCardInstallments extends StripeEntityOfChargePaymentMethodDetailsCardInstallments implements IChargePaymentMethodDetailsCardInstallments {
    /** Installment plan selected for the payment. */
    plan?: PaymentIntentPaymentMethodOptionsCardInstallmentsPlan | undefined;

    constructor(data?: IChargePaymentMethodDetailsCardInstallments) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.plan = _data["plan"] ? PaymentIntentPaymentMethodOptionsCardInstallmentsPlan.fromJS(_data["plan"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): ChargePaymentMethodDetailsCardInstallments {
        data = typeof data === 'object' ? data : {};
        let result = new ChargePaymentMethodDetailsCardInstallments();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["plan"] = this.plan ? this.plan.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IChargePaymentMethodDetailsCardInstallments extends IStripeEntityOfChargePaymentMethodDetailsCardInstallments {
    /** Installment plan selected for the payment. */
    plan?: PaymentIntentPaymentMethodOptionsCardInstallmentsPlan | undefined;
}

export abstract class StripeEntityOfChargePaymentMethodDetailsCardNetworkToken extends StripeEntity implements IStripeEntityOfChargePaymentMethodDetailsCardNetworkToken {

    constructor(data?: IStripeEntityOfChargePaymentMethodDetailsCardNetworkToken) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargePaymentMethodDetailsCardNetworkToken {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargePaymentMethodDetailsCardNetworkToken' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargePaymentMethodDetailsCardNetworkToken extends IStripeEntity {
}

export class ChargePaymentMethodDetailsCardNetworkToken extends StripeEntityOfChargePaymentMethodDetailsCardNetworkToken implements IChargePaymentMethodDetailsCardNetworkToken {
    /** Indicates if Stripe used a network token, either user provided or Stripe managed when
processing the transaction. */
    used?: boolean;

    constructor(data?: IChargePaymentMethodDetailsCardNetworkToken) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.used = _data["used"];
        }
    }

    static override fromJS(data: any): ChargePaymentMethodDetailsCardNetworkToken {
        data = typeof data === 'object' ? data : {};
        let result = new ChargePaymentMethodDetailsCardNetworkToken();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["used"] = this.used;
        super.toJSON(data);
        return data;
    }
}

export interface IChargePaymentMethodDetailsCardNetworkToken extends IStripeEntityOfChargePaymentMethodDetailsCardNetworkToken {
    /** Indicates if Stripe used a network token, either user provided or Stripe managed when
processing the transaction. */
    used?: boolean;
}

export abstract class StripeEntityOfChargePaymentMethodDetailsCardThreeDSecure extends StripeEntity implements IStripeEntityOfChargePaymentMethodDetailsCardThreeDSecure {

    constructor(data?: IStripeEntityOfChargePaymentMethodDetailsCardThreeDSecure) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargePaymentMethodDetailsCardThreeDSecure {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargePaymentMethodDetailsCardThreeDSecure' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargePaymentMethodDetailsCardThreeDSecure extends IStripeEntity {
}

export class ChargePaymentMethodDetailsCardThreeDSecure extends StripeEntityOfChargePaymentMethodDetailsCardThreeDSecure implements IChargePaymentMethodDetailsCardThreeDSecure {
    /** For authenticated transactions: how the customer was authenticated by the issuing bank.
One of: challenge, or frictionless. */
    authenticationFlow?: string | undefined;
    /** Indicates the outcome of 3D Secure authentication.
One of: attempt_acknowledged, authenticated, exempted,
failed, not_supported, or processing_error. */
    result?: string | undefined;
    /** Additional information about why 3D Secure succeeded or failed based on the
result.
One of: abandoned, bypassed, canceled, card_not_enrolled,
network_not_supported, protocol_error, or rejected. */
    resultReason?: string | undefined;
    /** The version of 3D Secure that was used.
One of: 1.0.2, 2.1.0, or 2.2.0. */
    version?: string | undefined;

    constructor(data?: IChargePaymentMethodDetailsCardThreeDSecure) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.authenticationFlow = _data["authenticationFlow"];
            this.result = _data["result"];
            this.resultReason = _data["resultReason"];
            this.version = _data["version"];
        }
    }

    static override fromJS(data: any): ChargePaymentMethodDetailsCardThreeDSecure {
        data = typeof data === 'object' ? data : {};
        let result = new ChargePaymentMethodDetailsCardThreeDSecure();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authenticationFlow"] = this.authenticationFlow;
        data["result"] = this.result;
        data["resultReason"] = this.resultReason;
        data["version"] = this.version;
        super.toJSON(data);
        return data;
    }
}

export interface IChargePaymentMethodDetailsCardThreeDSecure extends IStripeEntityOfChargePaymentMethodDetailsCardThreeDSecure {
    /** For authenticated transactions: how the customer was authenticated by the issuing bank.
One of: challenge, or frictionless. */
    authenticationFlow?: string | undefined;
    /** Indicates the outcome of 3D Secure authentication.
One of: attempt_acknowledged, authenticated, exempted,
failed, not_supported, or processing_error. */
    result?: string | undefined;
    /** Additional information about why 3D Secure succeeded or failed based on the
result.
One of: abandoned, bypassed, canceled, card_not_enrolled,
network_not_supported, protocol_error, or rejected. */
    resultReason?: string | undefined;
    /** The version of 3D Secure that was used.
One of: 1.0.2, 2.1.0, or 2.2.0. */
    version?: string | undefined;
}

export abstract class StripeEntityOfChargePaymentMethodDetailsCardWallet extends StripeEntity implements IStripeEntityOfChargePaymentMethodDetailsCardWallet {

    constructor(data?: IStripeEntityOfChargePaymentMethodDetailsCardWallet) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargePaymentMethodDetailsCardWallet {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargePaymentMethodDetailsCardWallet' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargePaymentMethodDetailsCardWallet extends IStripeEntity {
}

export class ChargePaymentMethodDetailsCardWallet extends StripeEntityOfChargePaymentMethodDetailsCardWallet implements IChargePaymentMethodDetailsCardWallet {
    amexExpressCheckout?: ChargePaymentMethodDetailsCardWalletAmexExpressCheckout | undefined;
    applePay?: ChargePaymentMethodDetailsCardWalletApplePay | undefined;
    /** (For tokenized numbers only.) The last four digits of the device account number. */
    dynamicLast4?: string | undefined;
    googlePay?: ChargePaymentMethodDetailsCardWalletGooglePay | undefined;
    link?: ChargePaymentMethodDetailsCardWalletLink | undefined;
    masterpass?: ChargePaymentMethodDetailsCardWalletMasterpass | undefined;
    samsungPay?: ChargePaymentMethodDetailsCardWalletSamsungPay | undefined;
    /** The type of the card wallet, one of amex_express_checkout, apple_pay,
google_pay, masterpass, samsung_pay, visa_checkout, or
link. An additional hash is included on the Wallet subhash with a name matching
this value. It contains additional information specific to the card wallet type.
One of: amex_express_checkout, apple_pay, google_pay, link,
masterpass, samsung_pay, or visa_checkout. */
    type?: string | undefined;
    visaCheckout?: ChargePaymentMethodDetailsCardWalletVisaCheckout | undefined;

    constructor(data?: IChargePaymentMethodDetailsCardWallet) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.amexExpressCheckout = _data["amexExpressCheckout"] ? ChargePaymentMethodDetailsCardWalletAmexExpressCheckout.fromJS(_data["amexExpressCheckout"]) : <any>undefined;
            this.applePay = _data["applePay"] ? ChargePaymentMethodDetailsCardWalletApplePay.fromJS(_data["applePay"]) : <any>undefined;
            this.dynamicLast4 = _data["dynamicLast4"];
            this.googlePay = _data["googlePay"] ? ChargePaymentMethodDetailsCardWalletGooglePay.fromJS(_data["googlePay"]) : <any>undefined;
            this.link = _data["link"] ? ChargePaymentMethodDetailsCardWalletLink.fromJS(_data["link"]) : <any>undefined;
            this.masterpass = _data["masterpass"] ? ChargePaymentMethodDetailsCardWalletMasterpass.fromJS(_data["masterpass"]) : <any>undefined;
            this.samsungPay = _data["samsungPay"] ? ChargePaymentMethodDetailsCardWalletSamsungPay.fromJS(_data["samsungPay"]) : <any>undefined;
            this.type = _data["type"];
            this.visaCheckout = _data["visaCheckout"] ? ChargePaymentMethodDetailsCardWalletVisaCheckout.fromJS(_data["visaCheckout"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): ChargePaymentMethodDetailsCardWallet {
        data = typeof data === 'object' ? data : {};
        let result = new ChargePaymentMethodDetailsCardWallet();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amexExpressCheckout"] = this.amexExpressCheckout ? this.amexExpressCheckout.toJSON() : <any>undefined;
        data["applePay"] = this.applePay ? this.applePay.toJSON() : <any>undefined;
        data["dynamicLast4"] = this.dynamicLast4;
        data["googlePay"] = this.googlePay ? this.googlePay.toJSON() : <any>undefined;
        data["link"] = this.link ? this.link.toJSON() : <any>undefined;
        data["masterpass"] = this.masterpass ? this.masterpass.toJSON() : <any>undefined;
        data["samsungPay"] = this.samsungPay ? this.samsungPay.toJSON() : <any>undefined;
        data["type"] = this.type;
        data["visaCheckout"] = this.visaCheckout ? this.visaCheckout.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IChargePaymentMethodDetailsCardWallet extends IStripeEntityOfChargePaymentMethodDetailsCardWallet {
    amexExpressCheckout?: ChargePaymentMethodDetailsCardWalletAmexExpressCheckout | undefined;
    applePay?: ChargePaymentMethodDetailsCardWalletApplePay | undefined;
    /** (For tokenized numbers only.) The last four digits of the device account number. */
    dynamicLast4?: string | undefined;
    googlePay?: ChargePaymentMethodDetailsCardWalletGooglePay | undefined;
    link?: ChargePaymentMethodDetailsCardWalletLink | undefined;
    masterpass?: ChargePaymentMethodDetailsCardWalletMasterpass | undefined;
    samsungPay?: ChargePaymentMethodDetailsCardWalletSamsungPay | undefined;
    /** The type of the card wallet, one of amex_express_checkout, apple_pay,
google_pay, masterpass, samsung_pay, visa_checkout, or
link. An additional hash is included on the Wallet subhash with a name matching
this value. It contains additional information specific to the card wallet type.
One of: amex_express_checkout, apple_pay, google_pay, link,
masterpass, samsung_pay, or visa_checkout. */
    type?: string | undefined;
    visaCheckout?: ChargePaymentMethodDetailsCardWalletVisaCheckout | undefined;
}

export abstract class StripeEntityOfChargePaymentMethodDetailsCardWalletAmexExpressCheckout extends StripeEntity implements IStripeEntityOfChargePaymentMethodDetailsCardWalletAmexExpressCheckout {

    constructor(data?: IStripeEntityOfChargePaymentMethodDetailsCardWalletAmexExpressCheckout) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargePaymentMethodDetailsCardWalletAmexExpressCheckout {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargePaymentMethodDetailsCardWalletAmexExpressCheckout' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargePaymentMethodDetailsCardWalletAmexExpressCheckout extends IStripeEntity {
}

export class ChargePaymentMethodDetailsCardWalletAmexExpressCheckout extends StripeEntityOfChargePaymentMethodDetailsCardWalletAmexExpressCheckout implements IChargePaymentMethodDetailsCardWalletAmexExpressCheckout {

    constructor(data?: IChargePaymentMethodDetailsCardWalletAmexExpressCheckout) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ChargePaymentMethodDetailsCardWalletAmexExpressCheckout {
        data = typeof data === 'object' ? data : {};
        let result = new ChargePaymentMethodDetailsCardWalletAmexExpressCheckout();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IChargePaymentMethodDetailsCardWalletAmexExpressCheckout extends IStripeEntityOfChargePaymentMethodDetailsCardWalletAmexExpressCheckout {
}

export abstract class StripeEntityOfChargePaymentMethodDetailsCardWalletApplePay extends StripeEntity implements IStripeEntityOfChargePaymentMethodDetailsCardWalletApplePay {

    constructor(data?: IStripeEntityOfChargePaymentMethodDetailsCardWalletApplePay) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargePaymentMethodDetailsCardWalletApplePay {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargePaymentMethodDetailsCardWalletApplePay' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargePaymentMethodDetailsCardWalletApplePay extends IStripeEntity {
}

export class ChargePaymentMethodDetailsCardWalletApplePay extends StripeEntityOfChargePaymentMethodDetailsCardWalletApplePay implements IChargePaymentMethodDetailsCardWalletApplePay {

    constructor(data?: IChargePaymentMethodDetailsCardWalletApplePay) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ChargePaymentMethodDetailsCardWalletApplePay {
        data = typeof data === 'object' ? data : {};
        let result = new ChargePaymentMethodDetailsCardWalletApplePay();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IChargePaymentMethodDetailsCardWalletApplePay extends IStripeEntityOfChargePaymentMethodDetailsCardWalletApplePay {
}

export abstract class StripeEntityOfChargePaymentMethodDetailsCardWalletGooglePay extends StripeEntity implements IStripeEntityOfChargePaymentMethodDetailsCardWalletGooglePay {

    constructor(data?: IStripeEntityOfChargePaymentMethodDetailsCardWalletGooglePay) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargePaymentMethodDetailsCardWalletGooglePay {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargePaymentMethodDetailsCardWalletGooglePay' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargePaymentMethodDetailsCardWalletGooglePay extends IStripeEntity {
}

export class ChargePaymentMethodDetailsCardWalletGooglePay extends StripeEntityOfChargePaymentMethodDetailsCardWalletGooglePay implements IChargePaymentMethodDetailsCardWalletGooglePay {

    constructor(data?: IChargePaymentMethodDetailsCardWalletGooglePay) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ChargePaymentMethodDetailsCardWalletGooglePay {
        data = typeof data === 'object' ? data : {};
        let result = new ChargePaymentMethodDetailsCardWalletGooglePay();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IChargePaymentMethodDetailsCardWalletGooglePay extends IStripeEntityOfChargePaymentMethodDetailsCardWalletGooglePay {
}

export abstract class StripeEntityOfChargePaymentMethodDetailsCardWalletLink extends StripeEntity implements IStripeEntityOfChargePaymentMethodDetailsCardWalletLink {

    constructor(data?: IStripeEntityOfChargePaymentMethodDetailsCardWalletLink) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargePaymentMethodDetailsCardWalletLink {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargePaymentMethodDetailsCardWalletLink' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargePaymentMethodDetailsCardWalletLink extends IStripeEntity {
}

export class ChargePaymentMethodDetailsCardWalletLink extends StripeEntityOfChargePaymentMethodDetailsCardWalletLink implements IChargePaymentMethodDetailsCardWalletLink {

    constructor(data?: IChargePaymentMethodDetailsCardWalletLink) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ChargePaymentMethodDetailsCardWalletLink {
        data = typeof data === 'object' ? data : {};
        let result = new ChargePaymentMethodDetailsCardWalletLink();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IChargePaymentMethodDetailsCardWalletLink extends IStripeEntityOfChargePaymentMethodDetailsCardWalletLink {
}

export abstract class StripeEntityOfChargePaymentMethodDetailsCardWalletMasterpass extends StripeEntity implements IStripeEntityOfChargePaymentMethodDetailsCardWalletMasterpass {

    constructor(data?: IStripeEntityOfChargePaymentMethodDetailsCardWalletMasterpass) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargePaymentMethodDetailsCardWalletMasterpass {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargePaymentMethodDetailsCardWalletMasterpass' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargePaymentMethodDetailsCardWalletMasterpass extends IStripeEntity {
}

export class ChargePaymentMethodDetailsCardWalletMasterpass extends StripeEntityOfChargePaymentMethodDetailsCardWalletMasterpass implements IChargePaymentMethodDetailsCardWalletMasterpass {
    /** Owner's verified billing address. Values are verified or provided by the wallet directly
(if supported) at the time of authorization or settlement. They cannot be set or
mutated. */
    billingAddress?: Address | undefined;
    /** Owner's verified email. Values are verified or provided by the wallet directly (if
supported) at the time of authorization or settlement. They cannot be set or mutated. */
    email?: string | undefined;
    /** Owner's verified full name. Values are verified or provided by the wallet directly (if
supported) at the time of authorization or settlement. They cannot be set or mutated. */
    name?: string | undefined;
    /** Owner's verified shipping address. Values are verified or provided by the wallet
directly (if supported) at the time of authorization or settlement. They cannot be set
or mutated. */
    shippingAddress?: Address | undefined;

    constructor(data?: IChargePaymentMethodDetailsCardWalletMasterpass) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.billingAddress = _data["billingAddress"] ? Address.fromJS(_data["billingAddress"]) : <any>undefined;
            this.email = _data["email"];
            this.name = _data["name"];
            this.shippingAddress = _data["shippingAddress"] ? Address.fromJS(_data["shippingAddress"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): ChargePaymentMethodDetailsCardWalletMasterpass {
        data = typeof data === 'object' ? data : {};
        let result = new ChargePaymentMethodDetailsCardWalletMasterpass();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["billingAddress"] = this.billingAddress ? this.billingAddress.toJSON() : <any>undefined;
        data["email"] = this.email;
        data["name"] = this.name;
        data["shippingAddress"] = this.shippingAddress ? this.shippingAddress.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IChargePaymentMethodDetailsCardWalletMasterpass extends IStripeEntityOfChargePaymentMethodDetailsCardWalletMasterpass {
    /** Owner's verified billing address. Values are verified or provided by the wallet directly
(if supported) at the time of authorization or settlement. They cannot be set or
mutated. */
    billingAddress?: Address | undefined;
    /** Owner's verified email. Values are verified or provided by the wallet directly (if
supported) at the time of authorization or settlement. They cannot be set or mutated. */
    email?: string | undefined;
    /** Owner's verified full name. Values are verified or provided by the wallet directly (if
supported) at the time of authorization or settlement. They cannot be set or mutated. */
    name?: string | undefined;
    /** Owner's verified shipping address. Values are verified or provided by the wallet
directly (if supported) at the time of authorization or settlement. They cannot be set
or mutated. */
    shippingAddress?: Address | undefined;
}

export abstract class StripeEntityOfChargePaymentMethodDetailsCardWalletSamsungPay extends StripeEntity implements IStripeEntityOfChargePaymentMethodDetailsCardWalletSamsungPay {

    constructor(data?: IStripeEntityOfChargePaymentMethodDetailsCardWalletSamsungPay) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargePaymentMethodDetailsCardWalletSamsungPay {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargePaymentMethodDetailsCardWalletSamsungPay' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargePaymentMethodDetailsCardWalletSamsungPay extends IStripeEntity {
}

export class ChargePaymentMethodDetailsCardWalletSamsungPay extends StripeEntityOfChargePaymentMethodDetailsCardWalletSamsungPay implements IChargePaymentMethodDetailsCardWalletSamsungPay {

    constructor(data?: IChargePaymentMethodDetailsCardWalletSamsungPay) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ChargePaymentMethodDetailsCardWalletSamsungPay {
        data = typeof data === 'object' ? data : {};
        let result = new ChargePaymentMethodDetailsCardWalletSamsungPay();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IChargePaymentMethodDetailsCardWalletSamsungPay extends IStripeEntityOfChargePaymentMethodDetailsCardWalletSamsungPay {
}

export abstract class StripeEntityOfChargePaymentMethodDetailsCardWalletVisaCheckout extends StripeEntity implements IStripeEntityOfChargePaymentMethodDetailsCardWalletVisaCheckout {

    constructor(data?: IStripeEntityOfChargePaymentMethodDetailsCardWalletVisaCheckout) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargePaymentMethodDetailsCardWalletVisaCheckout {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargePaymentMethodDetailsCardWalletVisaCheckout' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargePaymentMethodDetailsCardWalletVisaCheckout extends IStripeEntity {
}

export class ChargePaymentMethodDetailsCardWalletVisaCheckout extends StripeEntityOfChargePaymentMethodDetailsCardWalletVisaCheckout implements IChargePaymentMethodDetailsCardWalletVisaCheckout {
    /** Owner's verified billing address. Values are verified or provided by the wallet directly
(if supported) at the time of authorization or settlement. They cannot be set or
mutated. */
    billingAddress?: Address | undefined;
    /** Owner's verified email. Values are verified or provided by the wallet directly (if
supported) at the time of authorization or settlement. They cannot be set or mutated. */
    email?: string | undefined;
    /** Owner's verified full name. Values are verified or provided by the wallet directly (if
supported) at the time of authorization or settlement. They cannot be set or mutated. */
    name?: string | undefined;
    /** Owner's verified shipping address. Values are verified or provided by the wallet
directly (if supported) at the time of authorization or settlement. They cannot be set
or mutated. */
    shippingAddress?: Address | undefined;

    constructor(data?: IChargePaymentMethodDetailsCardWalletVisaCheckout) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.billingAddress = _data["billingAddress"] ? Address.fromJS(_data["billingAddress"]) : <any>undefined;
            this.email = _data["email"];
            this.name = _data["name"];
            this.shippingAddress = _data["shippingAddress"] ? Address.fromJS(_data["shippingAddress"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): ChargePaymentMethodDetailsCardWalletVisaCheckout {
        data = typeof data === 'object' ? data : {};
        let result = new ChargePaymentMethodDetailsCardWalletVisaCheckout();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["billingAddress"] = this.billingAddress ? this.billingAddress.toJSON() : <any>undefined;
        data["email"] = this.email;
        data["name"] = this.name;
        data["shippingAddress"] = this.shippingAddress ? this.shippingAddress.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IChargePaymentMethodDetailsCardWalletVisaCheckout extends IStripeEntityOfChargePaymentMethodDetailsCardWalletVisaCheckout {
    /** Owner's verified billing address. Values are verified or provided by the wallet directly
(if supported) at the time of authorization or settlement. They cannot be set or
mutated. */
    billingAddress?: Address | undefined;
    /** Owner's verified email. Values are verified or provided by the wallet directly (if
supported) at the time of authorization or settlement. They cannot be set or mutated. */
    email?: string | undefined;
    /** Owner's verified full name. Values are verified or provided by the wallet directly (if
supported) at the time of authorization or settlement. They cannot be set or mutated. */
    name?: string | undefined;
    /** Owner's verified shipping address. Values are verified or provided by the wallet
directly (if supported) at the time of authorization or settlement. They cannot be set
or mutated. */
    shippingAddress?: Address | undefined;
}

export abstract class StripeEntityOfChargePaymentMethodDetailsCardPresent extends StripeEntity implements IStripeEntityOfChargePaymentMethodDetailsCardPresent {

    constructor(data?: IStripeEntityOfChargePaymentMethodDetailsCardPresent) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargePaymentMethodDetailsCardPresent {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargePaymentMethodDetailsCardPresent' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargePaymentMethodDetailsCardPresent extends IStripeEntity {
}

export class ChargePaymentMethodDetailsCardPresent extends StripeEntityOfChargePaymentMethodDetailsCardPresent implements IChargePaymentMethodDetailsCardPresent {
    /** The authorized amount. */
    amountAuthorized?: number | undefined;
    /** Card brand. Can be amex, diners, discover, eftpos_au,
jcb, mastercard, unionpay, visa, or unknown. */
    brand?: string | undefined;
    /** When using manual capture, a future timestamp after which the charge will be
automatically refunded if uncaptured. */
    captureBefore?: Date;
    /** The cardholder name as read from the card, in ISO 7813 format. May include
alphanumeric characters, special characters and first/last name separator (/). In
some cases, the cardholder name may not be available depending on how the issuer has
configured the card. Cardholder name is typically not available on swipe or contactless
payments, such as those made with Apple Pay and Google Pay. */
    cardholderName?: string | undefined;
    /** Two-letter ISO code representing the country of the card. You could use this attribute
to get a sense of the international breakdown of cards you've collected. */
    country?: string | undefined;
    /** A high-level description of the type of cards issued in this range. (For internal use
only and not typically available in standard API requests.). */
    description?: string | undefined;
    /** Authorization response cryptogram. */
    emvAuthData?: string | undefined;
    /** Two-digit number representing the card's expiration month. */
    expMonth?: number;
    /** Four-digit number representing the card's expiration year. */
    expYear?: number;
    /** Uniquely identifies this particular card number. You can use this attribute to check
whether two customers who’ve signed up with you are using the same card number, for
example. For payment methods that tokenize card information (Apple Pay, Google Pay), the
tokenized number might be provided instead of the underlying card number.
            
Starting May 1, 2021, card fingerprint in India for Connect will change to allow two
fingerprints for the same card --- one for India and one for the rest of the world.. */
    fingerprint?: string | undefined;
    /** Card funding type. Can be credit, debit, prepaid, or
unknown. */
    funding?: string | undefined;
    /** ID of a card PaymentMethod generated from the card_present PaymentMethod that may be
attached to a Customer for future transactions. Only present if it was possible to
generate a card PaymentMethod. */
    generatedCard?: string | undefined;
    /** Issuer identification number of the card. (For internal use only and not typically
available in standard API requests.). */
    iin?: string | undefined;
    /** Whether this PaymentIntent is
eligible for incremental authorizations. Request support using request_incremental_authorization_support. */
    incrementalAuthorizationSupported?: boolean;
    /** The name of the card's issuing bank. (For internal use only and not typically available
in standard API requests.). */
    issuer?: string | undefined;
    /** The last four digits of the card. */
    last4?: string | undefined;
    /** Identifies which network this charge was processed on. Can be amex,
cartes_bancaires, diners, discover, eftpos_au,
interac, jcb, mastercard, unionpay, visa, or
unknown. */
    network?: string | undefined;
    /** Defines whether the authorized amount can be over-captured or not. */
    overcaptureSupported?: boolean;
    /** How card details were read in this transaction.
One of: contact_emv, contactless_emv, contactless_magstripe_mode,
magnetic_stripe_fallback, or magnetic_stripe_track2. */
    readMethod?: string | undefined;
    /** A collection of fields required to be displayed on receipts. Only required for EMV
transactions. */
    receipt?: ChargePaymentMethodDetailsCardPresentReceipt | undefined;

    constructor(data?: IChargePaymentMethodDetailsCardPresent) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.amountAuthorized = _data["amountAuthorized"];
            this.brand = _data["brand"];
            this.captureBefore = _data["captureBefore"] ? new Date(_data["captureBefore"].toString()) : <any>undefined;
            this.cardholderName = _data["cardholderName"];
            this.country = _data["country"];
            this.description = _data["description"];
            this.emvAuthData = _data["emvAuthData"];
            this.expMonth = _data["expMonth"];
            this.expYear = _data["expYear"];
            this.fingerprint = _data["fingerprint"];
            this.funding = _data["funding"];
            this.generatedCard = _data["generatedCard"];
            this.iin = _data["iin"];
            this.incrementalAuthorizationSupported = _data["incrementalAuthorizationSupported"];
            this.issuer = _data["issuer"];
            this.last4 = _data["last4"];
            this.network = _data["network"];
            this.overcaptureSupported = _data["overcaptureSupported"];
            this.readMethod = _data["readMethod"];
            this.receipt = _data["receipt"] ? ChargePaymentMethodDetailsCardPresentReceipt.fromJS(_data["receipt"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): ChargePaymentMethodDetailsCardPresent {
        data = typeof data === 'object' ? data : {};
        let result = new ChargePaymentMethodDetailsCardPresent();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amountAuthorized"] = this.amountAuthorized;
        data["brand"] = this.brand;
        data["captureBefore"] = this.captureBefore ? this.captureBefore.toISOString() : <any>undefined;
        data["cardholderName"] = this.cardholderName;
        data["country"] = this.country;
        data["description"] = this.description;
        data["emvAuthData"] = this.emvAuthData;
        data["expMonth"] = this.expMonth;
        data["expYear"] = this.expYear;
        data["fingerprint"] = this.fingerprint;
        data["funding"] = this.funding;
        data["generatedCard"] = this.generatedCard;
        data["iin"] = this.iin;
        data["incrementalAuthorizationSupported"] = this.incrementalAuthorizationSupported;
        data["issuer"] = this.issuer;
        data["last4"] = this.last4;
        data["network"] = this.network;
        data["overcaptureSupported"] = this.overcaptureSupported;
        data["readMethod"] = this.readMethod;
        data["receipt"] = this.receipt ? this.receipt.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IChargePaymentMethodDetailsCardPresent extends IStripeEntityOfChargePaymentMethodDetailsCardPresent {
    /** The authorized amount. */
    amountAuthorized?: number | undefined;
    /** Card brand. Can be amex, diners, discover, eftpos_au,
jcb, mastercard, unionpay, visa, or unknown. */
    brand?: string | undefined;
    /** When using manual capture, a future timestamp after which the charge will be
automatically refunded if uncaptured. */
    captureBefore?: Date;
    /** The cardholder name as read from the card, in ISO 7813 format. May include
alphanumeric characters, special characters and first/last name separator (/). In
some cases, the cardholder name may not be available depending on how the issuer has
configured the card. Cardholder name is typically not available on swipe or contactless
payments, such as those made with Apple Pay and Google Pay. */
    cardholderName?: string | undefined;
    /** Two-letter ISO code representing the country of the card. You could use this attribute
to get a sense of the international breakdown of cards you've collected. */
    country?: string | undefined;
    /** A high-level description of the type of cards issued in this range. (For internal use
only and not typically available in standard API requests.). */
    description?: string | undefined;
    /** Authorization response cryptogram. */
    emvAuthData?: string | undefined;
    /** Two-digit number representing the card's expiration month. */
    expMonth?: number;
    /** Four-digit number representing the card's expiration year. */
    expYear?: number;
    /** Uniquely identifies this particular card number. You can use this attribute to check
whether two customers who’ve signed up with you are using the same card number, for
example. For payment methods that tokenize card information (Apple Pay, Google Pay), the
tokenized number might be provided instead of the underlying card number.
            
Starting May 1, 2021, card fingerprint in India for Connect will change to allow two
fingerprints for the same card --- one for India and one for the rest of the world.. */
    fingerprint?: string | undefined;
    /** Card funding type. Can be credit, debit, prepaid, or
unknown. */
    funding?: string | undefined;
    /** ID of a card PaymentMethod generated from the card_present PaymentMethod that may be
attached to a Customer for future transactions. Only present if it was possible to
generate a card PaymentMethod. */
    generatedCard?: string | undefined;
    /** Issuer identification number of the card. (For internal use only and not typically
available in standard API requests.). */
    iin?: string | undefined;
    /** Whether this PaymentIntent is
eligible for incremental authorizations. Request support using request_incremental_authorization_support. */
    incrementalAuthorizationSupported?: boolean;
    /** The name of the card's issuing bank. (For internal use only and not typically available
in standard API requests.). */
    issuer?: string | undefined;
    /** The last four digits of the card. */
    last4?: string | undefined;
    /** Identifies which network this charge was processed on. Can be amex,
cartes_bancaires, diners, discover, eftpos_au,
interac, jcb, mastercard, unionpay, visa, or
unknown. */
    network?: string | undefined;
    /** Defines whether the authorized amount can be over-captured or not. */
    overcaptureSupported?: boolean;
    /** How card details were read in this transaction.
One of: contact_emv, contactless_emv, contactless_magstripe_mode,
magnetic_stripe_fallback, or magnetic_stripe_track2. */
    readMethod?: string | undefined;
    /** A collection of fields required to be displayed on receipts. Only required for EMV
transactions. */
    receipt?: ChargePaymentMethodDetailsCardPresentReceipt | undefined;
}

export abstract class StripeEntityOfChargePaymentMethodDetailsCardPresentReceipt extends StripeEntity implements IStripeEntityOfChargePaymentMethodDetailsCardPresentReceipt {

    constructor(data?: IStripeEntityOfChargePaymentMethodDetailsCardPresentReceipt) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargePaymentMethodDetailsCardPresentReceipt {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargePaymentMethodDetailsCardPresentReceipt' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargePaymentMethodDetailsCardPresentReceipt extends IStripeEntity {
}

export class ChargePaymentMethodDetailsCardPresentReceipt extends StripeEntityOfChargePaymentMethodDetailsCardPresentReceipt implements IChargePaymentMethodDetailsCardPresentReceipt {
    /** The type of account being debited or credited.
One of: checking, credit, prepaid, or unknown. */
    accountType?: string | undefined;
    /** EMV tag 9F26, cryptogram generated by the integrated circuit chip. */
    applicationCryptogram?: string | undefined;
    /** Mnenomic of the Application Identifier. */
    applicationPreferredName?: string | undefined;
    /** Identifier for this transaction. */
    authorizationCode?: string | undefined;
    /** EMV tag 8A. A code returned by the card issuer. */
    authorizationResponseCode?: string | undefined;
    /** How the cardholder verified ownership of the card. */
    cardholderVerificationMethod?: string | undefined;
    /** EMV tag 84. Similar to the application identifier stored on the integrated circuit chip. */
    dedicatedFileName?: string | undefined;
    /** The outcome of a series of EMV functions performed by the card reader. */
    terminalVerificationResults?: string | undefined;
    /** An indication of various EMV functions performed during the transaction. */
    transactionStatusInformation?: string | undefined;

    constructor(data?: IChargePaymentMethodDetailsCardPresentReceipt) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.accountType = _data["accountType"];
            this.applicationCryptogram = _data["applicationCryptogram"];
            this.applicationPreferredName = _data["applicationPreferredName"];
            this.authorizationCode = _data["authorizationCode"];
            this.authorizationResponseCode = _data["authorizationResponseCode"];
            this.cardholderVerificationMethod = _data["cardholderVerificationMethod"];
            this.dedicatedFileName = _data["dedicatedFileName"];
            this.terminalVerificationResults = _data["terminalVerificationResults"];
            this.transactionStatusInformation = _data["transactionStatusInformation"];
        }
    }

    static override fromJS(data: any): ChargePaymentMethodDetailsCardPresentReceipt {
        data = typeof data === 'object' ? data : {};
        let result = new ChargePaymentMethodDetailsCardPresentReceipt();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountType"] = this.accountType;
        data["applicationCryptogram"] = this.applicationCryptogram;
        data["applicationPreferredName"] = this.applicationPreferredName;
        data["authorizationCode"] = this.authorizationCode;
        data["authorizationResponseCode"] = this.authorizationResponseCode;
        data["cardholderVerificationMethod"] = this.cardholderVerificationMethod;
        data["dedicatedFileName"] = this.dedicatedFileName;
        data["terminalVerificationResults"] = this.terminalVerificationResults;
        data["transactionStatusInformation"] = this.transactionStatusInformation;
        super.toJSON(data);
        return data;
    }
}

export interface IChargePaymentMethodDetailsCardPresentReceipt extends IStripeEntityOfChargePaymentMethodDetailsCardPresentReceipt {
    /** The type of account being debited or credited.
One of: checking, credit, prepaid, or unknown. */
    accountType?: string | undefined;
    /** EMV tag 9F26, cryptogram generated by the integrated circuit chip. */
    applicationCryptogram?: string | undefined;
    /** Mnenomic of the Application Identifier. */
    applicationPreferredName?: string | undefined;
    /** Identifier for this transaction. */
    authorizationCode?: string | undefined;
    /** EMV tag 8A. A code returned by the card issuer. */
    authorizationResponseCode?: string | undefined;
    /** How the cardholder verified ownership of the card. */
    cardholderVerificationMethod?: string | undefined;
    /** EMV tag 84. Similar to the application identifier stored on the integrated circuit chip. */
    dedicatedFileName?: string | undefined;
    /** The outcome of a series of EMV functions performed by the card reader. */
    terminalVerificationResults?: string | undefined;
    /** An indication of various EMV functions performed during the transaction. */
    transactionStatusInformation?: string | undefined;
}

export abstract class StripeEntityOfChargePaymentMethodDetailsCashapp extends StripeEntity implements IStripeEntityOfChargePaymentMethodDetailsCashapp {

    constructor(data?: IStripeEntityOfChargePaymentMethodDetailsCashapp) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargePaymentMethodDetailsCashapp {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargePaymentMethodDetailsCashapp' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargePaymentMethodDetailsCashapp extends IStripeEntity {
}

export class ChargePaymentMethodDetailsCashapp extends StripeEntityOfChargePaymentMethodDetailsCashapp implements IChargePaymentMethodDetailsCashapp {
    /** A unique and immutable identifier assigned by Cash App to every buyer. */
    buyerId?: string | undefined;
    /** A public identifier for buyers using Cash App. */
    cashtag?: string | undefined;

    constructor(data?: IChargePaymentMethodDetailsCashapp) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.buyerId = _data["buyerId"];
            this.cashtag = _data["cashtag"];
        }
    }

    static override fromJS(data: any): ChargePaymentMethodDetailsCashapp {
        data = typeof data === 'object' ? data : {};
        let result = new ChargePaymentMethodDetailsCashapp();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["buyerId"] = this.buyerId;
        data["cashtag"] = this.cashtag;
        super.toJSON(data);
        return data;
    }
}

export interface IChargePaymentMethodDetailsCashapp extends IStripeEntityOfChargePaymentMethodDetailsCashapp {
    /** A unique and immutable identifier assigned by Cash App to every buyer. */
    buyerId?: string | undefined;
    /** A public identifier for buyers using Cash App. */
    cashtag?: string | undefined;
}

export abstract class StripeEntityOfChargePaymentMethodDetailsCustomerBalance extends StripeEntity implements IStripeEntityOfChargePaymentMethodDetailsCustomerBalance {

    constructor(data?: IStripeEntityOfChargePaymentMethodDetailsCustomerBalance) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargePaymentMethodDetailsCustomerBalance {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargePaymentMethodDetailsCustomerBalance' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargePaymentMethodDetailsCustomerBalance extends IStripeEntity {
}

export class ChargePaymentMethodDetailsCustomerBalance extends StripeEntityOfChargePaymentMethodDetailsCustomerBalance implements IChargePaymentMethodDetailsCustomerBalance {

    constructor(data?: IChargePaymentMethodDetailsCustomerBalance) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ChargePaymentMethodDetailsCustomerBalance {
        data = typeof data === 'object' ? data : {};
        let result = new ChargePaymentMethodDetailsCustomerBalance();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IChargePaymentMethodDetailsCustomerBalance extends IStripeEntityOfChargePaymentMethodDetailsCustomerBalance {
}

export abstract class StripeEntityOfChargePaymentMethodDetailsEps extends StripeEntity implements IStripeEntityOfChargePaymentMethodDetailsEps {

    constructor(data?: IStripeEntityOfChargePaymentMethodDetailsEps) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargePaymentMethodDetailsEps {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargePaymentMethodDetailsEps' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargePaymentMethodDetailsEps extends IStripeEntity {
}

export class ChargePaymentMethodDetailsEps extends StripeEntityOfChargePaymentMethodDetailsEps implements IChargePaymentMethodDetailsEps {
    /** The customer's bank. Should be one of arzte_und_apotheker_bank,
austrian_anadi_bank_ag, bank_austria, bankhaus_carl_spangler,
bankhaus_schelhammer_und_schattera_ag, bawag_psk_ag, bks_bank_ag,
brull_kallmus_bank_ag, btv_vier_lander_bank,
capital_bank_grawe_gruppe_ag, deutsche_bank_ag, dolomitenbank,
easybank_ag, erste_bank_und_sparkassen,
hypo_alpeadriabank_international_ag,
hypo_noe_lb_fur_niederosterreich_u_wien,
hypo_oberosterreich_salzburg_steiermark, hypo_tirol_bank_ag,
hypo_vorarlberg_bank_ag, hypo_bank_burgenland_aktiengesellschaft,
marchfelder_bank, oberbank_ag, raiffeisen_bankengruppe_osterreich,
schoellerbank_ag, sparda_bank_wien, volksbank_gruppe,
volkskreditbank_ag, or vr_bank_braunau.
One of: arzte_und_apotheker_bank, austrian_anadi_bank_ag,
bank_austria, bankhaus_carl_spangler,
bankhaus_schelhammer_und_schattera_ag, bawag_psk_ag, bks_bank_ag,
brull_kallmus_bank_ag, btv_vier_lander_bank,
capital_bank_grawe_gruppe_ag, deutsche_bank_ag, dolomitenbank,
easybank_ag, erste_bank_und_sparkassen,
hypo_alpeadriabank_international_ag,
hypo_bank_burgenland_aktiengesellschaft,
hypo_noe_lb_fur_niederosterreich_u_wien,
hypo_oberosterreich_salzburg_steiermark, hypo_tirol_bank_ag,
hypo_vorarlberg_bank_ag, marchfelder_bank, oberbank_ag,
raiffeisen_bankengruppe_osterreich, schoellerbank_ag,
sparda_bank_wien, volksbank_gruppe, volkskreditbank_ag, or
vr_bank_braunau. */
    bank?: string | undefined;
    /** Owner's verified full name. Values are verified or provided by EPS directly (if
supported) at the time of authorization or settlement. They cannot be set or mutated.
EPS rarely provides this information so the attribute is usually empty. */
    verifiedName?: string | undefined;

    constructor(data?: IChargePaymentMethodDetailsEps) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.bank = _data["bank"];
            this.verifiedName = _data["verifiedName"];
        }
    }

    static override fromJS(data: any): ChargePaymentMethodDetailsEps {
        data = typeof data === 'object' ? data : {};
        let result = new ChargePaymentMethodDetailsEps();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bank"] = this.bank;
        data["verifiedName"] = this.verifiedName;
        super.toJSON(data);
        return data;
    }
}

export interface IChargePaymentMethodDetailsEps extends IStripeEntityOfChargePaymentMethodDetailsEps {
    /** The customer's bank. Should be one of arzte_und_apotheker_bank,
austrian_anadi_bank_ag, bank_austria, bankhaus_carl_spangler,
bankhaus_schelhammer_und_schattera_ag, bawag_psk_ag, bks_bank_ag,
brull_kallmus_bank_ag, btv_vier_lander_bank,
capital_bank_grawe_gruppe_ag, deutsche_bank_ag, dolomitenbank,
easybank_ag, erste_bank_und_sparkassen,
hypo_alpeadriabank_international_ag,
hypo_noe_lb_fur_niederosterreich_u_wien,
hypo_oberosterreich_salzburg_steiermark, hypo_tirol_bank_ag,
hypo_vorarlberg_bank_ag, hypo_bank_burgenland_aktiengesellschaft,
marchfelder_bank, oberbank_ag, raiffeisen_bankengruppe_osterreich,
schoellerbank_ag, sparda_bank_wien, volksbank_gruppe,
volkskreditbank_ag, or vr_bank_braunau.
One of: arzte_und_apotheker_bank, austrian_anadi_bank_ag,
bank_austria, bankhaus_carl_spangler,
bankhaus_schelhammer_und_schattera_ag, bawag_psk_ag, bks_bank_ag,
brull_kallmus_bank_ag, btv_vier_lander_bank,
capital_bank_grawe_gruppe_ag, deutsche_bank_ag, dolomitenbank,
easybank_ag, erste_bank_und_sparkassen,
hypo_alpeadriabank_international_ag,
hypo_bank_burgenland_aktiengesellschaft,
hypo_noe_lb_fur_niederosterreich_u_wien,
hypo_oberosterreich_salzburg_steiermark, hypo_tirol_bank_ag,
hypo_vorarlberg_bank_ag, marchfelder_bank, oberbank_ag,
raiffeisen_bankengruppe_osterreich, schoellerbank_ag,
sparda_bank_wien, volksbank_gruppe, volkskreditbank_ag, or
vr_bank_braunau. */
    bank?: string | undefined;
    /** Owner's verified full name. Values are verified or provided by EPS directly (if
supported) at the time of authorization or settlement. They cannot be set or mutated.
EPS rarely provides this information so the attribute is usually empty. */
    verifiedName?: string | undefined;
}

export abstract class StripeEntityOfChargePaymentMethodDetailsFpx extends StripeEntity implements IStripeEntityOfChargePaymentMethodDetailsFpx {

    constructor(data?: IStripeEntityOfChargePaymentMethodDetailsFpx) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargePaymentMethodDetailsFpx {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargePaymentMethodDetailsFpx' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargePaymentMethodDetailsFpx extends IStripeEntity {
}

export class ChargePaymentMethodDetailsFpx extends StripeEntityOfChargePaymentMethodDetailsFpx implements IChargePaymentMethodDetailsFpx {
    /** Account holder type, if provided. Can be one of individual or company.
One of: company, or individual. */
    accountHolderType?: string | undefined;
    /** The customer's bank. Can be one of affin_bank, agrobank,
alliance_bank, ambank, bank_islam, bank_muamalat,
bank_rakyat, bsn, cimb, hong_leong_bank, hsbc,
kfh, maybank2u, ocbc, public_bank, rhb,
standard_chartered, uob, deutsche_bank, maybank2e,
pb_enterprise, or bank_of_china.
One of: affin_bank, agrobank, alliance_bank, ambank,
bank_islam, bank_muamalat, bank_of_china, bank_rakyat,
bsn, cimb, deutsche_bank, hong_leong_bank, hsbc,
kfh, maybank2e, maybank2u, ocbc, pb_enterprise,
public_bank, rhb, standard_chartered, or uob. */
    bank?: string | undefined;
    /** Unique transaction id generated by FPX for every request from the merchant. */
    transactionId?: string | undefined;

    constructor(data?: IChargePaymentMethodDetailsFpx) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.accountHolderType = _data["accountHolderType"];
            this.bank = _data["bank"];
            this.transactionId = _data["transactionId"];
        }
    }

    static override fromJS(data: any): ChargePaymentMethodDetailsFpx {
        data = typeof data === 'object' ? data : {};
        let result = new ChargePaymentMethodDetailsFpx();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountHolderType"] = this.accountHolderType;
        data["bank"] = this.bank;
        data["transactionId"] = this.transactionId;
        super.toJSON(data);
        return data;
    }
}

export interface IChargePaymentMethodDetailsFpx extends IStripeEntityOfChargePaymentMethodDetailsFpx {
    /** Account holder type, if provided. Can be one of individual or company.
One of: company, or individual. */
    accountHolderType?: string | undefined;
    /** The customer's bank. Can be one of affin_bank, agrobank,
alliance_bank, ambank, bank_islam, bank_muamalat,
bank_rakyat, bsn, cimb, hong_leong_bank, hsbc,
kfh, maybank2u, ocbc, public_bank, rhb,
standard_chartered, uob, deutsche_bank, maybank2e,
pb_enterprise, or bank_of_china.
One of: affin_bank, agrobank, alliance_bank, ambank,
bank_islam, bank_muamalat, bank_of_china, bank_rakyat,
bsn, cimb, deutsche_bank, hong_leong_bank, hsbc,
kfh, maybank2e, maybank2u, ocbc, pb_enterprise,
public_bank, rhb, standard_chartered, or uob. */
    bank?: string | undefined;
    /** Unique transaction id generated by FPX for every request from the merchant. */
    transactionId?: string | undefined;
}

export abstract class StripeEntityOfChargePaymentMethodDetailsGiropay extends StripeEntity implements IStripeEntityOfChargePaymentMethodDetailsGiropay {

    constructor(data?: IStripeEntityOfChargePaymentMethodDetailsGiropay) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargePaymentMethodDetailsGiropay {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargePaymentMethodDetailsGiropay' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargePaymentMethodDetailsGiropay extends IStripeEntity {
}

export class ChargePaymentMethodDetailsGiropay extends StripeEntityOfChargePaymentMethodDetailsGiropay implements IChargePaymentMethodDetailsGiropay {
    /** Bank code of bank associated with the bank account. */
    bankCode?: string | undefined;
    /** Name of the bank associated with the bank account. */
    bankName?: string | undefined;
    /** Bank Identifier Code of the bank associated with the bank account. */
    bic?: string | undefined;
    /** Owner's verified full name. Values are verified or provided by Giropay directly (if
supported) at the time of authorization or settlement. They cannot be set or mutated.
Giropay rarely provides this information so the attribute is usually empty. */
    verifiedName?: string | undefined;

    constructor(data?: IChargePaymentMethodDetailsGiropay) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.bankCode = _data["bankCode"];
            this.bankName = _data["bankName"];
            this.bic = _data["bic"];
            this.verifiedName = _data["verifiedName"];
        }
    }

    static override fromJS(data: any): ChargePaymentMethodDetailsGiropay {
        data = typeof data === 'object' ? data : {};
        let result = new ChargePaymentMethodDetailsGiropay();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankCode"] = this.bankCode;
        data["bankName"] = this.bankName;
        data["bic"] = this.bic;
        data["verifiedName"] = this.verifiedName;
        super.toJSON(data);
        return data;
    }
}

export interface IChargePaymentMethodDetailsGiropay extends IStripeEntityOfChargePaymentMethodDetailsGiropay {
    /** Bank code of bank associated with the bank account. */
    bankCode?: string | undefined;
    /** Name of the bank associated with the bank account. */
    bankName?: string | undefined;
    /** Bank Identifier Code of the bank associated with the bank account. */
    bic?: string | undefined;
    /** Owner's verified full name. Values are verified or provided by Giropay directly (if
supported) at the time of authorization or settlement. They cannot be set or mutated.
Giropay rarely provides this information so the attribute is usually empty. */
    verifiedName?: string | undefined;
}

export abstract class StripeEntityOfChargePaymentMethodDetailsGrabpay extends StripeEntity implements IStripeEntityOfChargePaymentMethodDetailsGrabpay {

    constructor(data?: IStripeEntityOfChargePaymentMethodDetailsGrabpay) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargePaymentMethodDetailsGrabpay {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargePaymentMethodDetailsGrabpay' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargePaymentMethodDetailsGrabpay extends IStripeEntity {
}

export class ChargePaymentMethodDetailsGrabpay extends StripeEntityOfChargePaymentMethodDetailsGrabpay implements IChargePaymentMethodDetailsGrabpay {
    /** Unique transaction id generated by GrabPay. */
    transactionId?: string | undefined;

    constructor(data?: IChargePaymentMethodDetailsGrabpay) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.transactionId = _data["transactionId"];
        }
    }

    static override fromJS(data: any): ChargePaymentMethodDetailsGrabpay {
        data = typeof data === 'object' ? data : {};
        let result = new ChargePaymentMethodDetailsGrabpay();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionId"] = this.transactionId;
        super.toJSON(data);
        return data;
    }
}

export interface IChargePaymentMethodDetailsGrabpay extends IStripeEntityOfChargePaymentMethodDetailsGrabpay {
    /** Unique transaction id generated by GrabPay. */
    transactionId?: string | undefined;
}

export abstract class StripeEntityOfChargePaymentMethodDetailsIdeal extends StripeEntity implements IStripeEntityOfChargePaymentMethodDetailsIdeal {

    constructor(data?: IStripeEntityOfChargePaymentMethodDetailsIdeal) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargePaymentMethodDetailsIdeal {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargePaymentMethodDetailsIdeal' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargePaymentMethodDetailsIdeal extends IStripeEntity {
}

export class ChargePaymentMethodDetailsIdeal extends StripeEntityOfChargePaymentMethodDetailsIdeal implements IChargePaymentMethodDetailsIdeal {
    /** The customer's bank. Can be one of abn_amro, asn_bank, bunq,
handelsbanken, ing, knab, moneyou, rabobank,
regiobank, revolut, sns_bank, triodos_bank,
van_lanschot, or yoursafe.
One of: abn_amro, asn_bank, bunq, handelsbanken, ing,
knab, moneyou, rabobank, regiobank, revolut,
sns_bank, triodos_bank, van_lanschot, or yoursafe. */
    bank?: string | undefined;
    /** The Bank Identifier Code of the customer's bank.
One of: ABNANL2A, ASNBNL21, BITSNL2A, BUNQNL2A,
FVLBNL22, HANDNL2A, INGBNL2A, KNABNL2H, MOYONL21,
RABONL2U, RBRBNL21, REVOIE23, REVOLT21, SNSBNL2A, or
TRIONL2U. */
    bic?: string | undefined;
    /** (ID of the PaymentMethod)
The ID of the SEPA Direct Debit PaymentMethod which was generated by this Charge. */
    generatedSepaDebitId?: string | undefined;
    /** (Expanded)
The ID of the SEPA Direct Debit PaymentMethod which was generated by this Charge.
            
For more information, see the expand documentation. */
    generatedSepaDebit?: PaymentMethod | undefined;
    internalGeneratedSepaDebit?: ExpandableFieldOfPaymentMethod | undefined;
    /** (ID of the Mandate)
The mandate for the SEPA Direct Debit PaymentMethod which was generated by this Charge. */
    generatedSepaDebitMandateId?: string | undefined;
    /** (Expanded)
The mandate for the SEPA Direct Debit PaymentMethod which was generated by this Charge.
            
For more information, see the expand documentation. */
    generatedSepaDebitMandate?: Mandate | undefined;
    internalGeneratedSepaDebitMandate?: ExpandableFieldOfMandate | undefined;
    /** Last four characters of the IBAN. */
    ibanLast4?: string | undefined;
    /** Owner's verified full name. Values are verified or provided by iDEAL directly (if
supported) at the time of authorization or settlement. They cannot be set or mutated. */
    verifiedName?: string | undefined;

    constructor(data?: IChargePaymentMethodDetailsIdeal) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.bank = _data["bank"];
            this.bic = _data["bic"];
            this.generatedSepaDebitId = _data["generatedSepaDebitId"];
            this.generatedSepaDebit = _data["generatedSepaDebit"] ? PaymentMethod.fromJS(_data["generatedSepaDebit"]) : <any>undefined;
            this.internalGeneratedSepaDebit = _data["internalGeneratedSepaDebit"] ? ExpandableFieldOfPaymentMethod.fromJS(_data["internalGeneratedSepaDebit"]) : <any>undefined;
            this.generatedSepaDebitMandateId = _data["generatedSepaDebitMandateId"];
            this.generatedSepaDebitMandate = _data["generatedSepaDebitMandate"] ? Mandate.fromJS(_data["generatedSepaDebitMandate"]) : <any>undefined;
            this.internalGeneratedSepaDebitMandate = _data["internalGeneratedSepaDebitMandate"] ? ExpandableFieldOfMandate.fromJS(_data["internalGeneratedSepaDebitMandate"]) : <any>undefined;
            this.ibanLast4 = _data["ibanLast4"];
            this.verifiedName = _data["verifiedName"];
        }
    }

    static override fromJS(data: any): ChargePaymentMethodDetailsIdeal {
        data = typeof data === 'object' ? data : {};
        let result = new ChargePaymentMethodDetailsIdeal();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bank"] = this.bank;
        data["bic"] = this.bic;
        data["generatedSepaDebitId"] = this.generatedSepaDebitId;
        data["generatedSepaDebit"] = this.generatedSepaDebit ? this.generatedSepaDebit.toJSON() : <any>undefined;
        data["internalGeneratedSepaDebit"] = this.internalGeneratedSepaDebit ? this.internalGeneratedSepaDebit.toJSON() : <any>undefined;
        data["generatedSepaDebitMandateId"] = this.generatedSepaDebitMandateId;
        data["generatedSepaDebitMandate"] = this.generatedSepaDebitMandate ? this.generatedSepaDebitMandate.toJSON() : <any>undefined;
        data["internalGeneratedSepaDebitMandate"] = this.internalGeneratedSepaDebitMandate ? this.internalGeneratedSepaDebitMandate.toJSON() : <any>undefined;
        data["ibanLast4"] = this.ibanLast4;
        data["verifiedName"] = this.verifiedName;
        super.toJSON(data);
        return data;
    }
}

export interface IChargePaymentMethodDetailsIdeal extends IStripeEntityOfChargePaymentMethodDetailsIdeal {
    /** The customer's bank. Can be one of abn_amro, asn_bank, bunq,
handelsbanken, ing, knab, moneyou, rabobank,
regiobank, revolut, sns_bank, triodos_bank,
van_lanschot, or yoursafe.
One of: abn_amro, asn_bank, bunq, handelsbanken, ing,
knab, moneyou, rabobank, regiobank, revolut,
sns_bank, triodos_bank, van_lanschot, or yoursafe. */
    bank?: string | undefined;
    /** The Bank Identifier Code of the customer's bank.
One of: ABNANL2A, ASNBNL21, BITSNL2A, BUNQNL2A,
FVLBNL22, HANDNL2A, INGBNL2A, KNABNL2H, MOYONL21,
RABONL2U, RBRBNL21, REVOIE23, REVOLT21, SNSBNL2A, or
TRIONL2U. */
    bic?: string | undefined;
    /** (ID of the PaymentMethod)
The ID of the SEPA Direct Debit PaymentMethod which was generated by this Charge. */
    generatedSepaDebitId?: string | undefined;
    /** (Expanded)
The ID of the SEPA Direct Debit PaymentMethod which was generated by this Charge.
            
For more information, see the expand documentation. */
    generatedSepaDebit?: PaymentMethod | undefined;
    internalGeneratedSepaDebit?: ExpandableFieldOfPaymentMethod | undefined;
    /** (ID of the Mandate)
The mandate for the SEPA Direct Debit PaymentMethod which was generated by this Charge. */
    generatedSepaDebitMandateId?: string | undefined;
    /** (Expanded)
The mandate for the SEPA Direct Debit PaymentMethod which was generated by this Charge.
            
For more information, see the expand documentation. */
    generatedSepaDebitMandate?: Mandate | undefined;
    internalGeneratedSepaDebitMandate?: ExpandableFieldOfMandate | undefined;
    /** Last four characters of the IBAN. */
    ibanLast4?: string | undefined;
    /** Owner's verified full name. Values are verified or provided by iDEAL directly (if
supported) at the time of authorization or settlement. They cannot be set or mutated. */
    verifiedName?: string | undefined;
}

export abstract class StripeEntityOfChargePaymentMethodDetailsInteracPresent extends StripeEntity implements IStripeEntityOfChargePaymentMethodDetailsInteracPresent {

    constructor(data?: IStripeEntityOfChargePaymentMethodDetailsInteracPresent) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargePaymentMethodDetailsInteracPresent {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargePaymentMethodDetailsInteracPresent' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargePaymentMethodDetailsInteracPresent extends IStripeEntity {
}

export class ChargePaymentMethodDetailsInteracPresent extends StripeEntityOfChargePaymentMethodDetailsInteracPresent implements IChargePaymentMethodDetailsInteracPresent {
    /** Card brand. Can be interac, mastercard or visa. */
    brand?: string | undefined;
    /** The cardholder name as read from the card, in ISO 7813 format. May include
alphanumeric characters, special characters and first/last name separator (/). In
some cases, the cardholder name may not be available depending on how the issuer has
configured the card. Cardholder name is typically not available on swipe or contactless
payments, such as those made with Apple Pay and Google Pay. */
    cardholderName?: string | undefined;
    /** Two-letter ISO code representing the country of the card. You could use this attribute
to get a sense of the international breakdown of cards you've collected. */
    country?: string | undefined;
    /** A high-level description of the type of cards issued in this range. (For internal use
only and not typically available in standard API requests.). */
    description?: string | undefined;
    /** Authorization response cryptogram. */
    emvAuthData?: string | undefined;
    /** Two-digit number representing the card's expiration month. */
    expMonth?: number;
    /** Four-digit number representing the card's expiration year. */
    expYear?: number;
    /** Uniquely identifies this particular card number. You can use this attribute to check
whether two customers who’ve signed up with you are using the same card number, for
example. For payment methods that tokenize card information (Apple Pay, Google Pay), the
tokenized number might be provided instead of the underlying card number.
            
Starting May 1, 2021, card fingerprint in India for Connect will change to allow two
fingerprints for the same card --- one for India and one for the rest of the world.. */
    fingerprint?: string | undefined;
    /** Card funding type. Can be credit, debit, prepaid, or
unknown. */
    funding?: string | undefined;
    /** ID of a card PaymentMethod generated from the card_present PaymentMethod that may be
attached to a Customer for future transactions. Only present if it was possible to
generate a card PaymentMethod. */
    generatedCard?: string | undefined;
    /** Issuer identification number of the card. (For internal use only and not typically
available in standard API requests.). */
    iin?: string | undefined;
    /** The name of the card's issuing bank. (For internal use only and not typically available
in standard API requests.). */
    issuer?: string | undefined;
    /** The last four digits of the card. */
    last4?: string | undefined;
    /** Identifies which network this charge was processed on. Can be amex,
cartes_bancaires, diners, discover, eftpos_au,
interac, jcb, mastercard, unionpay, visa, or
unknown. */
    network?: string | undefined;
    /** EMV tag 5F2D. Preferred languages specified by the integrated circuit chip. */
    preferredLocales?: string[] | undefined;
    /** How card details were read in this transaction.
One of: contact_emv, contactless_emv, contactless_magstripe_mode,
magnetic_stripe_fallback, or magnetic_stripe_track2. */
    readMethod?: string | undefined;
    /** A collection of fields required to be displayed on receipts. Only required for EMV
transactions. */
    receipt?: ChargePaymentMethodDetailsInteracPresentReceipt | undefined;

    constructor(data?: IChargePaymentMethodDetailsInteracPresent) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.brand = _data["brand"];
            this.cardholderName = _data["cardholderName"];
            this.country = _data["country"];
            this.description = _data["description"];
            this.emvAuthData = _data["emvAuthData"];
            this.expMonth = _data["expMonth"];
            this.expYear = _data["expYear"];
            this.fingerprint = _data["fingerprint"];
            this.funding = _data["funding"];
            this.generatedCard = _data["generatedCard"];
            this.iin = _data["iin"];
            this.issuer = _data["issuer"];
            this.last4 = _data["last4"];
            this.network = _data["network"];
            if (Array.isArray(_data["preferredLocales"])) {
                this.preferredLocales = [] as any;
                for (let item of _data["preferredLocales"])
                    this.preferredLocales!.push(item);
            }
            this.readMethod = _data["readMethod"];
            this.receipt = _data["receipt"] ? ChargePaymentMethodDetailsInteracPresentReceipt.fromJS(_data["receipt"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): ChargePaymentMethodDetailsInteracPresent {
        data = typeof data === 'object' ? data : {};
        let result = new ChargePaymentMethodDetailsInteracPresent();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brand"] = this.brand;
        data["cardholderName"] = this.cardholderName;
        data["country"] = this.country;
        data["description"] = this.description;
        data["emvAuthData"] = this.emvAuthData;
        data["expMonth"] = this.expMonth;
        data["expYear"] = this.expYear;
        data["fingerprint"] = this.fingerprint;
        data["funding"] = this.funding;
        data["generatedCard"] = this.generatedCard;
        data["iin"] = this.iin;
        data["issuer"] = this.issuer;
        data["last4"] = this.last4;
        data["network"] = this.network;
        if (Array.isArray(this.preferredLocales)) {
            data["preferredLocales"] = [];
            for (let item of this.preferredLocales)
                data["preferredLocales"].push(item);
        }
        data["readMethod"] = this.readMethod;
        data["receipt"] = this.receipt ? this.receipt.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IChargePaymentMethodDetailsInteracPresent extends IStripeEntityOfChargePaymentMethodDetailsInteracPresent {
    /** Card brand. Can be interac, mastercard or visa. */
    brand?: string | undefined;
    /** The cardholder name as read from the card, in ISO 7813 format. May include
alphanumeric characters, special characters and first/last name separator (/). In
some cases, the cardholder name may not be available depending on how the issuer has
configured the card. Cardholder name is typically not available on swipe or contactless
payments, such as those made with Apple Pay and Google Pay. */
    cardholderName?: string | undefined;
    /** Two-letter ISO code representing the country of the card. You could use this attribute
to get a sense of the international breakdown of cards you've collected. */
    country?: string | undefined;
    /** A high-level description of the type of cards issued in this range. (For internal use
only and not typically available in standard API requests.). */
    description?: string | undefined;
    /** Authorization response cryptogram. */
    emvAuthData?: string | undefined;
    /** Two-digit number representing the card's expiration month. */
    expMonth?: number;
    /** Four-digit number representing the card's expiration year. */
    expYear?: number;
    /** Uniquely identifies this particular card number. You can use this attribute to check
whether two customers who’ve signed up with you are using the same card number, for
example. For payment methods that tokenize card information (Apple Pay, Google Pay), the
tokenized number might be provided instead of the underlying card number.
            
Starting May 1, 2021, card fingerprint in India for Connect will change to allow two
fingerprints for the same card --- one for India and one for the rest of the world.. */
    fingerprint?: string | undefined;
    /** Card funding type. Can be credit, debit, prepaid, or
unknown. */
    funding?: string | undefined;
    /** ID of a card PaymentMethod generated from the card_present PaymentMethod that may be
attached to a Customer for future transactions. Only present if it was possible to
generate a card PaymentMethod. */
    generatedCard?: string | undefined;
    /** Issuer identification number of the card. (For internal use only and not typically
available in standard API requests.). */
    iin?: string | undefined;
    /** The name of the card's issuing bank. (For internal use only and not typically available
in standard API requests.). */
    issuer?: string | undefined;
    /** The last four digits of the card. */
    last4?: string | undefined;
    /** Identifies which network this charge was processed on. Can be amex,
cartes_bancaires, diners, discover, eftpos_au,
interac, jcb, mastercard, unionpay, visa, or
unknown. */
    network?: string | undefined;
    /** EMV tag 5F2D. Preferred languages specified by the integrated circuit chip. */
    preferredLocales?: string[] | undefined;
    /** How card details were read in this transaction.
One of: contact_emv, contactless_emv, contactless_magstripe_mode,
magnetic_stripe_fallback, or magnetic_stripe_track2. */
    readMethod?: string | undefined;
    /** A collection of fields required to be displayed on receipts. Only required for EMV
transactions. */
    receipt?: ChargePaymentMethodDetailsInteracPresentReceipt | undefined;
}

export abstract class StripeEntityOfChargePaymentMethodDetailsInteracPresentReceipt extends StripeEntity implements IStripeEntityOfChargePaymentMethodDetailsInteracPresentReceipt {

    constructor(data?: IStripeEntityOfChargePaymentMethodDetailsInteracPresentReceipt) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargePaymentMethodDetailsInteracPresentReceipt {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargePaymentMethodDetailsInteracPresentReceipt' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargePaymentMethodDetailsInteracPresentReceipt extends IStripeEntity {
}

export class ChargePaymentMethodDetailsInteracPresentReceipt extends StripeEntityOfChargePaymentMethodDetailsInteracPresentReceipt implements IChargePaymentMethodDetailsInteracPresentReceipt {
    /** The type of account being debited or credited.
One of: checking, savings, or unknown. */
    accountType?: string | undefined;
    /** EMV tag 9F26, cryptogram generated by the integrated circuit chip. */
    applicationCryptogram?: string | undefined;
    /** Mnenomic of the Application Identifier. */
    applicationPreferredName?: string | undefined;
    /** Identifier for this transaction. */
    authorizationCode?: string | undefined;
    /** EMV tag 8A. A code returned by the card issuer. */
    authorizationResponseCode?: string | undefined;
    /** How the cardholder verified ownership of the card. */
    cardholderVerificationMethod?: string | undefined;
    /** EMV tag 84. Similar to the application identifier stored on the integrated circuit chip. */
    dedicatedFileName?: string | undefined;
    /** The outcome of a series of EMV functions performed by the card reader. */
    terminalVerificationResults?: string | undefined;
    /** An indication of various EMV functions performed during the transaction. */
    transactionStatusInformation?: string | undefined;

    constructor(data?: IChargePaymentMethodDetailsInteracPresentReceipt) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.accountType = _data["accountType"];
            this.applicationCryptogram = _data["applicationCryptogram"];
            this.applicationPreferredName = _data["applicationPreferredName"];
            this.authorizationCode = _data["authorizationCode"];
            this.authorizationResponseCode = _data["authorizationResponseCode"];
            this.cardholderVerificationMethod = _data["cardholderVerificationMethod"];
            this.dedicatedFileName = _data["dedicatedFileName"];
            this.terminalVerificationResults = _data["terminalVerificationResults"];
            this.transactionStatusInformation = _data["transactionStatusInformation"];
        }
    }

    static override fromJS(data: any): ChargePaymentMethodDetailsInteracPresentReceipt {
        data = typeof data === 'object' ? data : {};
        let result = new ChargePaymentMethodDetailsInteracPresentReceipt();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountType"] = this.accountType;
        data["applicationCryptogram"] = this.applicationCryptogram;
        data["applicationPreferredName"] = this.applicationPreferredName;
        data["authorizationCode"] = this.authorizationCode;
        data["authorizationResponseCode"] = this.authorizationResponseCode;
        data["cardholderVerificationMethod"] = this.cardholderVerificationMethod;
        data["dedicatedFileName"] = this.dedicatedFileName;
        data["terminalVerificationResults"] = this.terminalVerificationResults;
        data["transactionStatusInformation"] = this.transactionStatusInformation;
        super.toJSON(data);
        return data;
    }
}

export interface IChargePaymentMethodDetailsInteracPresentReceipt extends IStripeEntityOfChargePaymentMethodDetailsInteracPresentReceipt {
    /** The type of account being debited or credited.
One of: checking, savings, or unknown. */
    accountType?: string | undefined;
    /** EMV tag 9F26, cryptogram generated by the integrated circuit chip. */
    applicationCryptogram?: string | undefined;
    /** Mnenomic of the Application Identifier. */
    applicationPreferredName?: string | undefined;
    /** Identifier for this transaction. */
    authorizationCode?: string | undefined;
    /** EMV tag 8A. A code returned by the card issuer. */
    authorizationResponseCode?: string | undefined;
    /** How the cardholder verified ownership of the card. */
    cardholderVerificationMethod?: string | undefined;
    /** EMV tag 84. Similar to the application identifier stored on the integrated circuit chip. */
    dedicatedFileName?: string | undefined;
    /** The outcome of a series of EMV functions performed by the card reader. */
    terminalVerificationResults?: string | undefined;
    /** An indication of various EMV functions performed during the transaction. */
    transactionStatusInformation?: string | undefined;
}

export abstract class StripeEntityOfChargePaymentMethodDetailsKlarna extends StripeEntity implements IStripeEntityOfChargePaymentMethodDetailsKlarna {

    constructor(data?: IStripeEntityOfChargePaymentMethodDetailsKlarna) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargePaymentMethodDetailsKlarna {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargePaymentMethodDetailsKlarna' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargePaymentMethodDetailsKlarna extends IStripeEntity {
}

export class ChargePaymentMethodDetailsKlarna extends StripeEntityOfChargePaymentMethodDetailsKlarna implements IChargePaymentMethodDetailsKlarna {
    /** The Klarna payment method used for this transaction. Can be one of pay_later,
pay_now, pay_with_financing, or pay_in_installments. */
    paymentMethodCategory?: string | undefined;
    /** Preferred language of the Klarna authorization page that the customer is redirected to.
Can be one of de-AT, en-AT, nl-BE, fr-BE, en-BE,
de-DE, en-DE, da-DK, en-DK, es-ES, en-ES,
fi-FI, sv-FI, en-FI, en-GB, en-IE, it-IT,
en-IT, nl-NL, en-NL, nb-NO, en-NO, sv-SE,
en-SE, en-US, es-US, fr-FR, en-FR, cs-CZ,
en-CZ, el-GR, en-GR, en-AU, en-NZ, en-CA,
fr-CA, pl-PL, en-PL, pt-PT, en-PT, de-CH,
fr-CH, it-CH, or en-CH. */
    preferredLocale?: string | undefined;

    constructor(data?: IChargePaymentMethodDetailsKlarna) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.paymentMethodCategory = _data["paymentMethodCategory"];
            this.preferredLocale = _data["preferredLocale"];
        }
    }

    static override fromJS(data: any): ChargePaymentMethodDetailsKlarna {
        data = typeof data === 'object' ? data : {};
        let result = new ChargePaymentMethodDetailsKlarna();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentMethodCategory"] = this.paymentMethodCategory;
        data["preferredLocale"] = this.preferredLocale;
        super.toJSON(data);
        return data;
    }
}

export interface IChargePaymentMethodDetailsKlarna extends IStripeEntityOfChargePaymentMethodDetailsKlarna {
    /** The Klarna payment method used for this transaction. Can be one of pay_later,
pay_now, pay_with_financing, or pay_in_installments. */
    paymentMethodCategory?: string | undefined;
    /** Preferred language of the Klarna authorization page that the customer is redirected to.
Can be one of de-AT, en-AT, nl-BE, fr-BE, en-BE,
de-DE, en-DE, da-DK, en-DK, es-ES, en-ES,
fi-FI, sv-FI, en-FI, en-GB, en-IE, it-IT,
en-IT, nl-NL, en-NL, nb-NO, en-NO, sv-SE,
en-SE, en-US, es-US, fr-FR, en-FR, cs-CZ,
en-CZ, el-GR, en-GR, en-AU, en-NZ, en-CA,
fr-CA, pl-PL, en-PL, pt-PT, en-PT, de-CH,
fr-CH, it-CH, or en-CH. */
    preferredLocale?: string | undefined;
}

export abstract class StripeEntityOfChargePaymentMethodDetailsKonbini extends StripeEntity implements IStripeEntityOfChargePaymentMethodDetailsKonbini {

    constructor(data?: IStripeEntityOfChargePaymentMethodDetailsKonbini) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargePaymentMethodDetailsKonbini {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargePaymentMethodDetailsKonbini' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargePaymentMethodDetailsKonbini extends IStripeEntity {
}

export class ChargePaymentMethodDetailsKonbini extends StripeEntityOfChargePaymentMethodDetailsKonbini implements IChargePaymentMethodDetailsKonbini {
    /** If the payment succeeded, this contains the details of the convenience store where the
payment was completed. */
    store?: ChargePaymentMethodDetailsKonbiniStore | undefined;

    constructor(data?: IChargePaymentMethodDetailsKonbini) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.store = _data["store"] ? ChargePaymentMethodDetailsKonbiniStore.fromJS(_data["store"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): ChargePaymentMethodDetailsKonbini {
        data = typeof data === 'object' ? data : {};
        let result = new ChargePaymentMethodDetailsKonbini();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["store"] = this.store ? this.store.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IChargePaymentMethodDetailsKonbini extends IStripeEntityOfChargePaymentMethodDetailsKonbini {
    /** If the payment succeeded, this contains the details of the convenience store where the
payment was completed. */
    store?: ChargePaymentMethodDetailsKonbiniStore | undefined;
}

export abstract class StripeEntityOfChargePaymentMethodDetailsKonbiniStore extends StripeEntity implements IStripeEntityOfChargePaymentMethodDetailsKonbiniStore {

    constructor(data?: IStripeEntityOfChargePaymentMethodDetailsKonbiniStore) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargePaymentMethodDetailsKonbiniStore {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargePaymentMethodDetailsKonbiniStore' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargePaymentMethodDetailsKonbiniStore extends IStripeEntity {
}

export class ChargePaymentMethodDetailsKonbiniStore extends StripeEntityOfChargePaymentMethodDetailsKonbiniStore implements IChargePaymentMethodDetailsKonbiniStore {
    /** The name of the convenience store chain where the payment was completed.
One of: familymart, lawson, ministop, or seicomart. */
    chain?: string | undefined;

    constructor(data?: IChargePaymentMethodDetailsKonbiniStore) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.chain = _data["chain"];
        }
    }

    static override fromJS(data: any): ChargePaymentMethodDetailsKonbiniStore {
        data = typeof data === 'object' ? data : {};
        let result = new ChargePaymentMethodDetailsKonbiniStore();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["chain"] = this.chain;
        super.toJSON(data);
        return data;
    }
}

export interface IChargePaymentMethodDetailsKonbiniStore extends IStripeEntityOfChargePaymentMethodDetailsKonbiniStore {
    /** The name of the convenience store chain where the payment was completed.
One of: familymart, lawson, ministop, or seicomart. */
    chain?: string | undefined;
}

export abstract class StripeEntityOfChargePaymentMethodDetailsLink extends StripeEntity implements IStripeEntityOfChargePaymentMethodDetailsLink {

    constructor(data?: IStripeEntityOfChargePaymentMethodDetailsLink) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargePaymentMethodDetailsLink {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargePaymentMethodDetailsLink' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargePaymentMethodDetailsLink extends IStripeEntity {
}

export class ChargePaymentMethodDetailsLink extends StripeEntityOfChargePaymentMethodDetailsLink implements IChargePaymentMethodDetailsLink {
    /** Two-letter ISO code representing the funding source country beneath the Link payment.
You could use this attribute to get a sense of international fees. */
    country?: string | undefined;

    constructor(data?: IChargePaymentMethodDetailsLink) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.country = _data["country"];
        }
    }

    static override fromJS(data: any): ChargePaymentMethodDetailsLink {
        data = typeof data === 'object' ? data : {};
        let result = new ChargePaymentMethodDetailsLink();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["country"] = this.country;
        super.toJSON(data);
        return data;
    }
}

export interface IChargePaymentMethodDetailsLink extends IStripeEntityOfChargePaymentMethodDetailsLink {
    /** Two-letter ISO code representing the funding source country beneath the Link payment.
You could use this attribute to get a sense of international fees. */
    country?: string | undefined;
}

export abstract class StripeEntityOfChargePaymentMethodDetailsMultibanco extends StripeEntity implements IStripeEntityOfChargePaymentMethodDetailsMultibanco {

    constructor(data?: IStripeEntityOfChargePaymentMethodDetailsMultibanco) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargePaymentMethodDetailsMultibanco {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargePaymentMethodDetailsMultibanco' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargePaymentMethodDetailsMultibanco extends IStripeEntity {
}

export class ChargePaymentMethodDetailsMultibanco extends StripeEntityOfChargePaymentMethodDetailsMultibanco implements IChargePaymentMethodDetailsMultibanco {
    /** Entity number associated with this Multibanco payment. */
    entity?: string | undefined;
    /** Reference number associated with this Multibanco payment. */
    reference?: string | undefined;

    constructor(data?: IChargePaymentMethodDetailsMultibanco) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.entity = _data["entity"];
            this.reference = _data["reference"];
        }
    }

    static override fromJS(data: any): ChargePaymentMethodDetailsMultibanco {
        data = typeof data === 'object' ? data : {};
        let result = new ChargePaymentMethodDetailsMultibanco();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entity"] = this.entity;
        data["reference"] = this.reference;
        super.toJSON(data);
        return data;
    }
}

export interface IChargePaymentMethodDetailsMultibanco extends IStripeEntityOfChargePaymentMethodDetailsMultibanco {
    /** Entity number associated with this Multibanco payment. */
    entity?: string | undefined;
    /** Reference number associated with this Multibanco payment. */
    reference?: string | undefined;
}

export abstract class StripeEntityOfChargePaymentMethodDetailsOxxo extends StripeEntity implements IStripeEntityOfChargePaymentMethodDetailsOxxo {

    constructor(data?: IStripeEntityOfChargePaymentMethodDetailsOxxo) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargePaymentMethodDetailsOxxo {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargePaymentMethodDetailsOxxo' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargePaymentMethodDetailsOxxo extends IStripeEntity {
}

export class ChargePaymentMethodDetailsOxxo extends StripeEntityOfChargePaymentMethodDetailsOxxo implements IChargePaymentMethodDetailsOxxo {
    /** OXXO reference number. */
    number?: string | undefined;

    constructor(data?: IChargePaymentMethodDetailsOxxo) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.number = _data["number"];
        }
    }

    static override fromJS(data: any): ChargePaymentMethodDetailsOxxo {
        data = typeof data === 'object' ? data : {};
        let result = new ChargePaymentMethodDetailsOxxo();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["number"] = this.number;
        super.toJSON(data);
        return data;
    }
}

export interface IChargePaymentMethodDetailsOxxo extends IStripeEntityOfChargePaymentMethodDetailsOxxo {
    /** OXXO reference number. */
    number?: string | undefined;
}

export abstract class StripeEntityOfChargePaymentMethodDetailsP24 extends StripeEntity implements IStripeEntityOfChargePaymentMethodDetailsP24 {

    constructor(data?: IStripeEntityOfChargePaymentMethodDetailsP24) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargePaymentMethodDetailsP24 {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargePaymentMethodDetailsP24' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargePaymentMethodDetailsP24 extends IStripeEntity {
}

export class ChargePaymentMethodDetailsP24 extends StripeEntityOfChargePaymentMethodDetailsP24 implements IChargePaymentMethodDetailsP24 {
    /** The customer's bank. Can be one of ing, citi_handlowy,
tmobile_usbugi_bankowe, plus_bank, etransfer_pocztowy24,
banki_spbdzielcze, bank_nowy_bfg_sa, getin_bank, blik,
noble_pay, ideabank, envelobank, santander_przelew24,
nest_przelew, mbank_mtransfer, inteligo, pbac_z_ipko,
bnp_paribas, credit_agricole, toyota_bank, bank_pekao_sa,
volkswagen_bank, bank_millennium, alior_bank, or boz.
One of: alior_bank, bank_millennium, bank_nowy_bfg_sa,
bank_pekao_sa, banki_spbdzielcze, blik, bnp_paribas,
boz, citi_handlowy, credit_agricole, envelobank,
etransfer_pocztowy24, getin_bank, ideabank, ing,
inteligo, mbank_mtransfer, nest_przelew, noble_pay,
pbac_z_ipko, plus_bank, santander_przelew24,
tmobile_usbugi_bankowe, toyota_bank, or volkswagen_bank. */
    bank?: string | undefined;
    /** Unique reference for this Przelewy24 payment. */
    reference?: string | undefined;
    /** Owner's verified full name. Values are verified or provided by Przelewy24 directly (if
supported) at the time of authorization or settlement. They cannot be set or mutated.
Przelewy24 rarely provides this information so the attribute is usually empty. */
    verifiedName?: string | undefined;

    constructor(data?: IChargePaymentMethodDetailsP24) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.bank = _data["bank"];
            this.reference = _data["reference"];
            this.verifiedName = _data["verifiedName"];
        }
    }

    static override fromJS(data: any): ChargePaymentMethodDetailsP24 {
        data = typeof data === 'object' ? data : {};
        let result = new ChargePaymentMethodDetailsP24();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bank"] = this.bank;
        data["reference"] = this.reference;
        data["verifiedName"] = this.verifiedName;
        super.toJSON(data);
        return data;
    }
}

export interface IChargePaymentMethodDetailsP24 extends IStripeEntityOfChargePaymentMethodDetailsP24 {
    /** The customer's bank. Can be one of ing, citi_handlowy,
tmobile_usbugi_bankowe, plus_bank, etransfer_pocztowy24,
banki_spbdzielcze, bank_nowy_bfg_sa, getin_bank, blik,
noble_pay, ideabank, envelobank, santander_przelew24,
nest_przelew, mbank_mtransfer, inteligo, pbac_z_ipko,
bnp_paribas, credit_agricole, toyota_bank, bank_pekao_sa,
volkswagen_bank, bank_millennium, alior_bank, or boz.
One of: alior_bank, bank_millennium, bank_nowy_bfg_sa,
bank_pekao_sa, banki_spbdzielcze, blik, bnp_paribas,
boz, citi_handlowy, credit_agricole, envelobank,
etransfer_pocztowy24, getin_bank, ideabank, ing,
inteligo, mbank_mtransfer, nest_przelew, noble_pay,
pbac_z_ipko, plus_bank, santander_przelew24,
tmobile_usbugi_bankowe, toyota_bank, or volkswagen_bank. */
    bank?: string | undefined;
    /** Unique reference for this Przelewy24 payment. */
    reference?: string | undefined;
    /** Owner's verified full name. Values are verified or provided by Przelewy24 directly (if
supported) at the time of authorization or settlement. They cannot be set or mutated.
Przelewy24 rarely provides this information so the attribute is usually empty. */
    verifiedName?: string | undefined;
}

export abstract class StripeEntityOfChargePaymentMethodDetailsPaynow extends StripeEntity implements IStripeEntityOfChargePaymentMethodDetailsPaynow {

    constructor(data?: IStripeEntityOfChargePaymentMethodDetailsPaynow) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargePaymentMethodDetailsPaynow {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargePaymentMethodDetailsPaynow' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargePaymentMethodDetailsPaynow extends IStripeEntity {
}

export class ChargePaymentMethodDetailsPaynow extends StripeEntityOfChargePaymentMethodDetailsPaynow implements IChargePaymentMethodDetailsPaynow {
    /** Reference number associated with this PayNow payment. */
    reference?: string | undefined;

    constructor(data?: IChargePaymentMethodDetailsPaynow) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.reference = _data["reference"];
        }
    }

    static override fromJS(data: any): ChargePaymentMethodDetailsPaynow {
        data = typeof data === 'object' ? data : {};
        let result = new ChargePaymentMethodDetailsPaynow();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reference"] = this.reference;
        super.toJSON(data);
        return data;
    }
}

export interface IChargePaymentMethodDetailsPaynow extends IStripeEntityOfChargePaymentMethodDetailsPaynow {
    /** Reference number associated with this PayNow payment. */
    reference?: string | undefined;
}

export abstract class StripeEntityOfChargePaymentMethodDetailsPaypal extends StripeEntity implements IStripeEntityOfChargePaymentMethodDetailsPaypal {

    constructor(data?: IStripeEntityOfChargePaymentMethodDetailsPaypal) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargePaymentMethodDetailsPaypal {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargePaymentMethodDetailsPaypal' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargePaymentMethodDetailsPaypal extends IStripeEntity {
}

export class ChargePaymentMethodDetailsPaypal extends StripeEntityOfChargePaymentMethodDetailsPaypal implements IChargePaymentMethodDetailsPaypal {
    /** Owner's email. Values are provided by PayPal directly (if supported) at the time of
authorization or settlement. They cannot be set or mutated. */
    payerEmail?: string | undefined;
    /** PayPal account PayerID. This identifier uniquely identifies the PayPal customer. */
    payerId?: string | undefined;
    /** Owner's full name. Values provided by PayPal directly (if supported) at the time of
authorization or settlement. They cannot be set or mutated. */
    payerName?: string | undefined;
    /** The level of protection offered as defined by PayPal Seller Protection for Merchants,
for this transaction. */
    sellerProtection?: ChargePaymentMethodDetailsPaypalSellerProtection | undefined;
    /** A unique ID generated by PayPal for this transaction. */
    transactionId?: string | undefined;

    constructor(data?: IChargePaymentMethodDetailsPaypal) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.payerEmail = _data["payerEmail"];
            this.payerId = _data["payerId"];
            this.payerName = _data["payerName"];
            this.sellerProtection = _data["sellerProtection"] ? ChargePaymentMethodDetailsPaypalSellerProtection.fromJS(_data["sellerProtection"]) : <any>undefined;
            this.transactionId = _data["transactionId"];
        }
    }

    static override fromJS(data: any): ChargePaymentMethodDetailsPaypal {
        data = typeof data === 'object' ? data : {};
        let result = new ChargePaymentMethodDetailsPaypal();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["payerEmail"] = this.payerEmail;
        data["payerId"] = this.payerId;
        data["payerName"] = this.payerName;
        data["sellerProtection"] = this.sellerProtection ? this.sellerProtection.toJSON() : <any>undefined;
        data["transactionId"] = this.transactionId;
        super.toJSON(data);
        return data;
    }
}

export interface IChargePaymentMethodDetailsPaypal extends IStripeEntityOfChargePaymentMethodDetailsPaypal {
    /** Owner's email. Values are provided by PayPal directly (if supported) at the time of
authorization or settlement. They cannot be set or mutated. */
    payerEmail?: string | undefined;
    /** PayPal account PayerID. This identifier uniquely identifies the PayPal customer. */
    payerId?: string | undefined;
    /** Owner's full name. Values provided by PayPal directly (if supported) at the time of
authorization or settlement. They cannot be set or mutated. */
    payerName?: string | undefined;
    /** The level of protection offered as defined by PayPal Seller Protection for Merchants,
for this transaction. */
    sellerProtection?: ChargePaymentMethodDetailsPaypalSellerProtection | undefined;
    /** A unique ID generated by PayPal for this transaction. */
    transactionId?: string | undefined;
}

export abstract class StripeEntityOfChargePaymentMethodDetailsPaypalSellerProtection extends StripeEntity implements IStripeEntityOfChargePaymentMethodDetailsPaypalSellerProtection {

    constructor(data?: IStripeEntityOfChargePaymentMethodDetailsPaypalSellerProtection) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargePaymentMethodDetailsPaypalSellerProtection {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargePaymentMethodDetailsPaypalSellerProtection' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargePaymentMethodDetailsPaypalSellerProtection extends IStripeEntity {
}

export class ChargePaymentMethodDetailsPaypalSellerProtection extends StripeEntityOfChargePaymentMethodDetailsPaypalSellerProtection implements IChargePaymentMethodDetailsPaypalSellerProtection {
    /** An array of conditions that are covered for the transaction, if applicable. */
    disputeCategories?: string[] | undefined;
    /** Indicates whether the transaction is eligible for PayPal's seller protection.
One of: eligible, not_eligible, or partially_eligible. */
    status?: string | undefined;

    constructor(data?: IChargePaymentMethodDetailsPaypalSellerProtection) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["disputeCategories"])) {
                this.disputeCategories = [] as any;
                for (let item of _data["disputeCategories"])
                    this.disputeCategories!.push(item);
            }
            this.status = _data["status"];
        }
    }

    static override fromJS(data: any): ChargePaymentMethodDetailsPaypalSellerProtection {
        data = typeof data === 'object' ? data : {};
        let result = new ChargePaymentMethodDetailsPaypalSellerProtection();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.disputeCategories)) {
            data["disputeCategories"] = [];
            for (let item of this.disputeCategories)
                data["disputeCategories"].push(item);
        }
        data["status"] = this.status;
        super.toJSON(data);
        return data;
    }
}

export interface IChargePaymentMethodDetailsPaypalSellerProtection extends IStripeEntityOfChargePaymentMethodDetailsPaypalSellerProtection {
    /** An array of conditions that are covered for the transaction, if applicable. */
    disputeCategories?: string[] | undefined;
    /** Indicates whether the transaction is eligible for PayPal's seller protection.
One of: eligible, not_eligible, or partially_eligible. */
    status?: string | undefined;
}

export abstract class StripeEntityOfChargePaymentMethodDetailsPix extends StripeEntity implements IStripeEntityOfChargePaymentMethodDetailsPix {

    constructor(data?: IStripeEntityOfChargePaymentMethodDetailsPix) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargePaymentMethodDetailsPix {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargePaymentMethodDetailsPix' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargePaymentMethodDetailsPix extends IStripeEntity {
}

export class ChargePaymentMethodDetailsPix extends StripeEntityOfChargePaymentMethodDetailsPix implements IChargePaymentMethodDetailsPix {
    /** Unique transaction id generated by BCB. */
    bankTransactionId?: string | undefined;

    constructor(data?: IChargePaymentMethodDetailsPix) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.bankTransactionId = _data["bankTransactionId"];
        }
    }

    static override fromJS(data: any): ChargePaymentMethodDetailsPix {
        data = typeof data === 'object' ? data : {};
        let result = new ChargePaymentMethodDetailsPix();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankTransactionId"] = this.bankTransactionId;
        super.toJSON(data);
        return data;
    }
}

export interface IChargePaymentMethodDetailsPix extends IStripeEntityOfChargePaymentMethodDetailsPix {
    /** Unique transaction id generated by BCB. */
    bankTransactionId?: string | undefined;
}

export abstract class StripeEntityOfChargePaymentMethodDetailsPromptpay extends StripeEntity implements IStripeEntityOfChargePaymentMethodDetailsPromptpay {

    constructor(data?: IStripeEntityOfChargePaymentMethodDetailsPromptpay) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargePaymentMethodDetailsPromptpay {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargePaymentMethodDetailsPromptpay' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargePaymentMethodDetailsPromptpay extends IStripeEntity {
}

export class ChargePaymentMethodDetailsPromptpay extends StripeEntityOfChargePaymentMethodDetailsPromptpay implements IChargePaymentMethodDetailsPromptpay {
    /** Bill reference generated by PromptPay. */
    reference?: string | undefined;

    constructor(data?: IChargePaymentMethodDetailsPromptpay) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.reference = _data["reference"];
        }
    }

    static override fromJS(data: any): ChargePaymentMethodDetailsPromptpay {
        data = typeof data === 'object' ? data : {};
        let result = new ChargePaymentMethodDetailsPromptpay();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reference"] = this.reference;
        super.toJSON(data);
        return data;
    }
}

export interface IChargePaymentMethodDetailsPromptpay extends IStripeEntityOfChargePaymentMethodDetailsPromptpay {
    /** Bill reference generated by PromptPay. */
    reference?: string | undefined;
}

export abstract class StripeEntityOfChargePaymentMethodDetailsSepaDebit extends StripeEntity implements IStripeEntityOfChargePaymentMethodDetailsSepaDebit {

    constructor(data?: IStripeEntityOfChargePaymentMethodDetailsSepaDebit) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargePaymentMethodDetailsSepaDebit {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargePaymentMethodDetailsSepaDebit' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargePaymentMethodDetailsSepaDebit extends IStripeEntity {
}

export class ChargePaymentMethodDetailsSepaDebit extends StripeEntityOfChargePaymentMethodDetailsSepaDebit implements IChargePaymentMethodDetailsSepaDebit {
    /** Bank code of bank associated with the bank account. */
    bankCode?: string | undefined;
    /** Branch code of bank associated with the bank account. */
    branchCode?: string | undefined;
    /** Two-letter ISO code representing the country the bank account is located in. */
    country?: string | undefined;
    /** Uniquely identifies this particular bank account. You can use this attribute to check
whether two bank accounts are the same. */
    fingerprint?: string | undefined;
    /** Last four characters of the IBAN. */
    last4?: string | undefined;
    /** ID of the mandate used to make this payment. */
    mandate?: string | undefined;

    constructor(data?: IChargePaymentMethodDetailsSepaDebit) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.bankCode = _data["bankCode"];
            this.branchCode = _data["branchCode"];
            this.country = _data["country"];
            this.fingerprint = _data["fingerprint"];
            this.last4 = _data["last4"];
            this.mandate = _data["mandate"];
        }
    }

    static override fromJS(data: any): ChargePaymentMethodDetailsSepaDebit {
        data = typeof data === 'object' ? data : {};
        let result = new ChargePaymentMethodDetailsSepaDebit();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankCode"] = this.bankCode;
        data["branchCode"] = this.branchCode;
        data["country"] = this.country;
        data["fingerprint"] = this.fingerprint;
        data["last4"] = this.last4;
        data["mandate"] = this.mandate;
        super.toJSON(data);
        return data;
    }
}

export interface IChargePaymentMethodDetailsSepaDebit extends IStripeEntityOfChargePaymentMethodDetailsSepaDebit {
    /** Bank code of bank associated with the bank account. */
    bankCode?: string | undefined;
    /** Branch code of bank associated with the bank account. */
    branchCode?: string | undefined;
    /** Two-letter ISO code representing the country the bank account is located in. */
    country?: string | undefined;
    /** Uniquely identifies this particular bank account. You can use this attribute to check
whether two bank accounts are the same. */
    fingerprint?: string | undefined;
    /** Last four characters of the IBAN. */
    last4?: string | undefined;
    /** ID of the mandate used to make this payment. */
    mandate?: string | undefined;
}

export abstract class StripeEntityOfChargePaymentMethodDetailsSofort extends StripeEntity implements IStripeEntityOfChargePaymentMethodDetailsSofort {

    constructor(data?: IStripeEntityOfChargePaymentMethodDetailsSofort) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargePaymentMethodDetailsSofort {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargePaymentMethodDetailsSofort' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargePaymentMethodDetailsSofort extends IStripeEntity {
}

export class ChargePaymentMethodDetailsSofort extends StripeEntityOfChargePaymentMethodDetailsSofort implements IChargePaymentMethodDetailsSofort {
    /** Bank code of bank associated with the bank account. */
    bankCode?: string | undefined;
    /** Name of the bank associated with the bank account. */
    bankName?: string | undefined;
    /** Bank Identifier Code of the bank associated with the bank account. */
    bic?: string | undefined;
    /** Two-letter ISO code representing the country the bank account is located in. */
    country?: string | undefined;
    /** (ID of the PaymentMethod)
The ID of the SEPA Direct Debit PaymentMethod which was generated by this Charge. */
    generatedSepaDebitId?: string | undefined;
    /** (Expanded)
The ID of the SEPA Direct Debit PaymentMethod which was generated by this Charge.
            
For more information, see the expand documentation. */
    generatedSepaDebit?: PaymentMethod | undefined;
    internalGeneratedSepaDebit?: ExpandableFieldOfPaymentMethod | undefined;
    /** (ID of the Mandate)
The mandate for the SEPA Direct Debit PaymentMethod which was generated by this Charge. */
    generatedSepaDebitMandateId?: string | undefined;
    /** (Expanded)
The mandate for the SEPA Direct Debit PaymentMethod which was generated by this Charge.
            
For more information, see the expand documentation. */
    generatedSepaDebitMandate?: Mandate | undefined;
    internalGeneratedSepaDebitMandate?: ExpandableFieldOfMandate | undefined;
    /** Last four characters of the IBAN. */
    ibanLast4?: string | undefined;
    /** Preferred language of the SOFORT authorization page that the customer is redirected to.
Can be one of de, en, es, fr, it, nl, or
pl.
One of: de, en, es, fr, it, nl, or pl. */
    preferredLanguage?: string | undefined;
    /** Owner's verified full name. Values are verified or provided by SOFORT directly (if
supported) at the time of authorization or settlement. They cannot be set or mutated. */
    verifiedName?: string | undefined;

    constructor(data?: IChargePaymentMethodDetailsSofort) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.bankCode = _data["bankCode"];
            this.bankName = _data["bankName"];
            this.bic = _data["bic"];
            this.country = _data["country"];
            this.generatedSepaDebitId = _data["generatedSepaDebitId"];
            this.generatedSepaDebit = _data["generatedSepaDebit"] ? PaymentMethod.fromJS(_data["generatedSepaDebit"]) : <any>undefined;
            this.internalGeneratedSepaDebit = _data["internalGeneratedSepaDebit"] ? ExpandableFieldOfPaymentMethod.fromJS(_data["internalGeneratedSepaDebit"]) : <any>undefined;
            this.generatedSepaDebitMandateId = _data["generatedSepaDebitMandateId"];
            this.generatedSepaDebitMandate = _data["generatedSepaDebitMandate"] ? Mandate.fromJS(_data["generatedSepaDebitMandate"]) : <any>undefined;
            this.internalGeneratedSepaDebitMandate = _data["internalGeneratedSepaDebitMandate"] ? ExpandableFieldOfMandate.fromJS(_data["internalGeneratedSepaDebitMandate"]) : <any>undefined;
            this.ibanLast4 = _data["ibanLast4"];
            this.preferredLanguage = _data["preferredLanguage"];
            this.verifiedName = _data["verifiedName"];
        }
    }

    static override fromJS(data: any): ChargePaymentMethodDetailsSofort {
        data = typeof data === 'object' ? data : {};
        let result = new ChargePaymentMethodDetailsSofort();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankCode"] = this.bankCode;
        data["bankName"] = this.bankName;
        data["bic"] = this.bic;
        data["country"] = this.country;
        data["generatedSepaDebitId"] = this.generatedSepaDebitId;
        data["generatedSepaDebit"] = this.generatedSepaDebit ? this.generatedSepaDebit.toJSON() : <any>undefined;
        data["internalGeneratedSepaDebit"] = this.internalGeneratedSepaDebit ? this.internalGeneratedSepaDebit.toJSON() : <any>undefined;
        data["generatedSepaDebitMandateId"] = this.generatedSepaDebitMandateId;
        data["generatedSepaDebitMandate"] = this.generatedSepaDebitMandate ? this.generatedSepaDebitMandate.toJSON() : <any>undefined;
        data["internalGeneratedSepaDebitMandate"] = this.internalGeneratedSepaDebitMandate ? this.internalGeneratedSepaDebitMandate.toJSON() : <any>undefined;
        data["ibanLast4"] = this.ibanLast4;
        data["preferredLanguage"] = this.preferredLanguage;
        data["verifiedName"] = this.verifiedName;
        super.toJSON(data);
        return data;
    }
}

export interface IChargePaymentMethodDetailsSofort extends IStripeEntityOfChargePaymentMethodDetailsSofort {
    /** Bank code of bank associated with the bank account. */
    bankCode?: string | undefined;
    /** Name of the bank associated with the bank account. */
    bankName?: string | undefined;
    /** Bank Identifier Code of the bank associated with the bank account. */
    bic?: string | undefined;
    /** Two-letter ISO code representing the country the bank account is located in. */
    country?: string | undefined;
    /** (ID of the PaymentMethod)
The ID of the SEPA Direct Debit PaymentMethod which was generated by this Charge. */
    generatedSepaDebitId?: string | undefined;
    /** (Expanded)
The ID of the SEPA Direct Debit PaymentMethod which was generated by this Charge.
            
For more information, see the expand documentation. */
    generatedSepaDebit?: PaymentMethod | undefined;
    internalGeneratedSepaDebit?: ExpandableFieldOfPaymentMethod | undefined;
    /** (ID of the Mandate)
The mandate for the SEPA Direct Debit PaymentMethod which was generated by this Charge. */
    generatedSepaDebitMandateId?: string | undefined;
    /** (Expanded)
The mandate for the SEPA Direct Debit PaymentMethod which was generated by this Charge.
            
For more information, see the expand documentation. */
    generatedSepaDebitMandate?: Mandate | undefined;
    internalGeneratedSepaDebitMandate?: ExpandableFieldOfMandate | undefined;
    /** Last four characters of the IBAN. */
    ibanLast4?: string | undefined;
    /** Preferred language of the SOFORT authorization page that the customer is redirected to.
Can be one of de, en, es, fr, it, nl, or
pl.
One of: de, en, es, fr, it, nl, or pl. */
    preferredLanguage?: string | undefined;
    /** Owner's verified full name. Values are verified or provided by SOFORT directly (if
supported) at the time of authorization or settlement. They cannot be set or mutated. */
    verifiedName?: string | undefined;
}

export abstract class StripeEntityOfChargePaymentMethodDetailsStripeAccount extends StripeEntity implements IStripeEntityOfChargePaymentMethodDetailsStripeAccount {

    constructor(data?: IStripeEntityOfChargePaymentMethodDetailsStripeAccount) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargePaymentMethodDetailsStripeAccount {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargePaymentMethodDetailsStripeAccount' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargePaymentMethodDetailsStripeAccount extends IStripeEntity {
}

export class ChargePaymentMethodDetailsStripeAccount extends StripeEntityOfChargePaymentMethodDetailsStripeAccount implements IChargePaymentMethodDetailsStripeAccount {

    constructor(data?: IChargePaymentMethodDetailsStripeAccount) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ChargePaymentMethodDetailsStripeAccount {
        data = typeof data === 'object' ? data : {};
        let result = new ChargePaymentMethodDetailsStripeAccount();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IChargePaymentMethodDetailsStripeAccount extends IStripeEntityOfChargePaymentMethodDetailsStripeAccount {
}

export abstract class StripeEntityOfChargePaymentMethodDetailsUsBankAccount extends StripeEntity implements IStripeEntityOfChargePaymentMethodDetailsUsBankAccount {

    constructor(data?: IStripeEntityOfChargePaymentMethodDetailsUsBankAccount) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargePaymentMethodDetailsUsBankAccount {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargePaymentMethodDetailsUsBankAccount' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargePaymentMethodDetailsUsBankAccount extends IStripeEntity {
}

export class ChargePaymentMethodDetailsUsBankAccount extends StripeEntityOfChargePaymentMethodDetailsUsBankAccount implements IChargePaymentMethodDetailsUsBankAccount {
    /** Account holder type: individual or company.
One of: company, or individual. */
    accountHolderType?: string | undefined;
    /** Account type: checkings or savings. Defaults to checking if omitted.
One of: checking, or savings. */
    accountType?: string | undefined;
    /** Name of the bank associated with the bank account. */
    bankName?: string | undefined;
    /** Uniquely identifies this particular bank account. You can use this attribute to check
whether two bank accounts are the same. */
    fingerprint?: string | undefined;
    /** Last four digits of the bank account number. */
    last4?: string | undefined;
    /** Routing number of the bank account. */
    routingNumber?: string | undefined;

    constructor(data?: IChargePaymentMethodDetailsUsBankAccount) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.accountHolderType = _data["accountHolderType"];
            this.accountType = _data["accountType"];
            this.bankName = _data["bankName"];
            this.fingerprint = _data["fingerprint"];
            this.last4 = _data["last4"];
            this.routingNumber = _data["routingNumber"];
        }
    }

    static override fromJS(data: any): ChargePaymentMethodDetailsUsBankAccount {
        data = typeof data === 'object' ? data : {};
        let result = new ChargePaymentMethodDetailsUsBankAccount();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountHolderType"] = this.accountHolderType;
        data["accountType"] = this.accountType;
        data["bankName"] = this.bankName;
        data["fingerprint"] = this.fingerprint;
        data["last4"] = this.last4;
        data["routingNumber"] = this.routingNumber;
        super.toJSON(data);
        return data;
    }
}

export interface IChargePaymentMethodDetailsUsBankAccount extends IStripeEntityOfChargePaymentMethodDetailsUsBankAccount {
    /** Account holder type: individual or company.
One of: company, or individual. */
    accountHolderType?: string | undefined;
    /** Account type: checkings or savings. Defaults to checking if omitted.
One of: checking, or savings. */
    accountType?: string | undefined;
    /** Name of the bank associated with the bank account. */
    bankName?: string | undefined;
    /** Uniquely identifies this particular bank account. You can use this attribute to check
whether two bank accounts are the same. */
    fingerprint?: string | undefined;
    /** Last four digits of the bank account number. */
    last4?: string | undefined;
    /** Routing number of the bank account. */
    routingNumber?: string | undefined;
}

export abstract class StripeEntityOfChargePaymentMethodDetailsWechat extends StripeEntity implements IStripeEntityOfChargePaymentMethodDetailsWechat {

    constructor(data?: IStripeEntityOfChargePaymentMethodDetailsWechat) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargePaymentMethodDetailsWechat {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargePaymentMethodDetailsWechat' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargePaymentMethodDetailsWechat extends IStripeEntity {
}

export class ChargePaymentMethodDetailsWechat extends StripeEntityOfChargePaymentMethodDetailsWechat implements IChargePaymentMethodDetailsWechat {

    constructor(data?: IChargePaymentMethodDetailsWechat) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ChargePaymentMethodDetailsWechat {
        data = typeof data === 'object' ? data : {};
        let result = new ChargePaymentMethodDetailsWechat();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IChargePaymentMethodDetailsWechat extends IStripeEntityOfChargePaymentMethodDetailsWechat {
}

export abstract class StripeEntityOfChargePaymentMethodDetailsWechatPay extends StripeEntity implements IStripeEntityOfChargePaymentMethodDetailsWechatPay {

    constructor(data?: IStripeEntityOfChargePaymentMethodDetailsWechatPay) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargePaymentMethodDetailsWechatPay {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargePaymentMethodDetailsWechatPay' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargePaymentMethodDetailsWechatPay extends IStripeEntity {
}

export class ChargePaymentMethodDetailsWechatPay extends StripeEntityOfChargePaymentMethodDetailsWechatPay implements IChargePaymentMethodDetailsWechatPay {
    /** Uniquely identifies this particular WeChat Pay account. You can use this attribute to
check whether two WeChat accounts are the same. */
    fingerprint?: string | undefined;
    /** Transaction ID of this particular WeChat Pay transaction. */
    transactionId?: string | undefined;

    constructor(data?: IChargePaymentMethodDetailsWechatPay) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.fingerprint = _data["fingerprint"];
            this.transactionId = _data["transactionId"];
        }
    }

    static override fromJS(data: any): ChargePaymentMethodDetailsWechatPay {
        data = typeof data === 'object' ? data : {};
        let result = new ChargePaymentMethodDetailsWechatPay();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fingerprint"] = this.fingerprint;
        data["transactionId"] = this.transactionId;
        super.toJSON(data);
        return data;
    }
}

export interface IChargePaymentMethodDetailsWechatPay extends IStripeEntityOfChargePaymentMethodDetailsWechatPay {
    /** Uniquely identifies this particular WeChat Pay account. You can use this attribute to
check whether two WeChat accounts are the same. */
    fingerprint?: string | undefined;
    /** Transaction ID of this particular WeChat Pay transaction. */
    transactionId?: string | undefined;
}

export abstract class StripeEntityOfChargePaymentMethodDetailsZip extends StripeEntity implements IStripeEntityOfChargePaymentMethodDetailsZip {

    constructor(data?: IStripeEntityOfChargePaymentMethodDetailsZip) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargePaymentMethodDetailsZip {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargePaymentMethodDetailsZip' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargePaymentMethodDetailsZip extends IStripeEntity {
}

export class ChargePaymentMethodDetailsZip extends StripeEntityOfChargePaymentMethodDetailsZip implements IChargePaymentMethodDetailsZip {

    constructor(data?: IChargePaymentMethodDetailsZip) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ChargePaymentMethodDetailsZip {
        data = typeof data === 'object' ? data : {};
        let result = new ChargePaymentMethodDetailsZip();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IChargePaymentMethodDetailsZip extends IStripeEntityOfChargePaymentMethodDetailsZip {
}

export abstract class StripeEntityOfChargeRadarOptions extends StripeEntity implements IStripeEntityOfChargeRadarOptions {

    constructor(data?: IStripeEntityOfChargeRadarOptions) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargeRadarOptions {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargeRadarOptions' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargeRadarOptions extends IStripeEntity {
}

export class ChargeRadarOptions extends StripeEntityOfChargeRadarOptions implements IChargeRadarOptions {
    /** A Radar Session is a snapshot
of the browser metadata and device details that help Radar make more accurate
predictions on your payments. */
    session?: string | undefined;

    constructor(data?: IChargeRadarOptions) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.session = _data["session"];
        }
    }

    static override fromJS(data: any): ChargeRadarOptions {
        data = typeof data === 'object' ? data : {};
        let result = new ChargeRadarOptions();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["session"] = this.session;
        super.toJSON(data);
        return data;
    }
}

export interface IChargeRadarOptions extends IStripeEntityOfChargeRadarOptions {
    /** A Radar Session is a snapshot
of the browser metadata and device details that help Radar make more accurate
predictions on your payments. */
    session?: string | undefined;
}

export abstract class StripeEntityOfStripeListOfRefund extends StripeEntity implements IStripeEntityOfStripeListOfRefund {

    constructor(data?: IStripeEntityOfStripeListOfRefund) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfStripeListOfRefund {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfStripeListOfRefund' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfStripeListOfRefund extends IStripeEntity {
}

export class StripeListOfRefund extends StripeEntityOfStripeListOfRefund implements IStripeListOfRefund {
    /** A string describing the object type returned. */
    object?: string | undefined;
    /** A list containing the actual response elements, paginated by any request parameters. */
    data?: Refund[] | undefined;
    /** Whether or not there are more elements available after this set. If false,
this set comprises the end of the list. */
    hasMore?: boolean;
    /** The URL for accessing this list. */
    url?: string | undefined;

    constructor(data?: IStripeListOfRefund) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.object = _data["object"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(Refund.fromJS(item));
            }
            this.hasMore = _data["hasMore"];
            this.url = _data["url"];
        }
    }

    static override fromJS(data: any): StripeListOfRefund {
        data = typeof data === 'object' ? data : {};
        let result = new StripeListOfRefund();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["object"] = this.object;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["hasMore"] = this.hasMore;
        data["url"] = this.url;
        super.toJSON(data);
        return data;
    }
}

export interface IStripeListOfRefund extends IStripeEntityOfStripeListOfRefund {
    /** A string describing the object type returned. */
    object?: string | undefined;
    /** A list containing the actual response elements, paginated by any request parameters. */
    data?: Refund[] | undefined;
    /** Whether or not there are more elements available after this set. If false,
this set comprises the end of the list. */
    hasMore?: boolean;
    /** The URL for accessing this list. */
    url?: string | undefined;
}

export abstract class StripeEntityOfRefund extends StripeEntity implements IStripeEntityOfRefund {

    constructor(data?: IStripeEntityOfRefund) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfRefund {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfRefund' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfRefund extends IStripeEntity {
}

/** Refund objects allow you to refund a charge that has previously been created but not yet refunded. Funds will be refunded to the credit or debit card that was originally charged.            Related guide: Refunds. */
export class Refund extends StripeEntityOfRefund implements IRefund {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** Amount, in %s. */
    amount?: number;
    /** (ID of the BalanceTransaction)
Balance transaction that describes the impact on your account balance. */
    balanceTransactionId?: string | undefined;
    /** (Expanded)
Balance transaction that describes the impact on your account balance.
            
For more information, see the expand documentation. */
    balanceTransaction?: BalanceTransaction | undefined;
    internalBalanceTransaction?: ExpandableFieldOfBalanceTransaction | undefined;
    /** (ID of the Charge)
ID of the charge that was refunded. */
    chargeId?: string | undefined;
    /** (Expanded)
ID of the charge that was refunded.
            
For more information, see the expand documentation. */
    charge?: Charge | undefined;
    internalCharge?: ExpandableFieldOfCharge | undefined;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** Three-letter ISO currency
code, in lowercase. Must be a supported
currency. */
    currency?: string | undefined;
    /** An arbitrary string attached to the object. Often useful for displaying to users.
(Available on non-card refunds only). */
    description?: string | undefined;
    /** (ID of the BalanceTransaction)
If the refund failed, this balance transaction describes the adjustment made on your
account balance that reverses the initial balance transaction. */
    failureBalanceTransactionId?: string | undefined;
    /** (Expanded)
If the refund failed, this balance transaction describes the adjustment made on your
account balance that reverses the initial balance transaction.
            
For more information, see the expand documentation. */
    failureBalanceTransaction?: BalanceTransaction | undefined;
    internalFailureBalanceTransaction?: ExpandableFieldOfBalanceTransaction | undefined;
    /** If the refund failed, the reason for refund failure if known. Possible values are
lost_or_stolen_card, expired_or_canceled_card,
charge_for_pending_refund_disputed, insufficient_funds, declined,
merchant_request or unknown. */
    failureReason?: string | undefined;
    /** For payment methods without native refund support (e.g., Konbini, PromptPay), email for
the customer to receive refund instructions. */
    instructionsEmail?: string | undefined;
    /** Set of key-value pairs that you can
attach to an object. This can be useful for storing additional information about the
object in a structured format. */
    metadata?: { [key: string]: string; } | undefined;
    nextAction?: RefundNextAction | undefined;
    /** (ID of the PaymentIntent)
ID of the PaymentIntent that was refunded. */
    paymentIntentId?: string | undefined;
    /** (Expanded)
ID of the PaymentIntent that was refunded.
            
For more information, see the expand documentation. */
    paymentIntent?: PaymentIntent | undefined;
    internalPaymentIntent?: ExpandableFieldOfPaymentIntent | undefined;
    /** Reason for the refund, either user-provided (duplicate, fraudulent, or
requested_by_customer) or generated by Stripe internally
(expired_uncaptured_charge).
One of: duplicate, expired_uncaptured_charge, fraudulent, or
requested_by_customer. */
    reason?: string | undefined;
    /** This is the transaction number that appears on email receipts sent for this refund. */
    receiptNumber?: string | undefined;
    /** (ID of the TransferReversal)
The transfer reversal that is associated with the refund. Only present if the charge
came from another Stripe account. See the Connect documentation for details. */
    sourceTransferReversalId?: string | undefined;
    /** (Expanded)
The transfer reversal that is associated with the refund. Only present if the charge
came from another Stripe account. See the Connect documentation for details.
            
For more information, see the expand documentation. */
    sourceTransferReversal?: TransferReversal | undefined;
    internalSourceTransferReversal?: ExpandableFieldOfTransferReversal | undefined;
    /** Status of the refund. For credit card refunds, this can be pending,
succeeded, or failed. For other types of refunds, it can be
pending, requires_action, succeeded, failed, or
canceled. Refer to our refunds documentation for more
details. */
    status?: string | undefined;
    /** (ID of the TransferReversal)
If the accompanying transfer was reversed, the transfer reversal object. Only applicable
if the charge was created using the destination parameter. */
    transferReversalId?: string | undefined;
    /** (Expanded)
If the accompanying transfer was reversed, the transfer reversal object. Only applicable
if the charge was created using the destination parameter.
            
For more information, see the expand documentation. */
    transferReversal?: TransferReversal | undefined;
    internalTransferReversal?: ExpandableFieldOfTransferReversal | undefined;

    constructor(data?: IRefund) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.object = _data["object"];
            this.amount = _data["amount"];
            this.balanceTransactionId = _data["balanceTransactionId"];
            this.balanceTransaction = _data["balanceTransaction"] ? BalanceTransaction.fromJS(_data["balanceTransaction"]) : <any>undefined;
            this.internalBalanceTransaction = _data["internalBalanceTransaction"] ? ExpandableFieldOfBalanceTransaction.fromJS(_data["internalBalanceTransaction"]) : <any>undefined;
            this.chargeId = _data["chargeId"];
            this.charge = _data["charge"] ? Charge.fromJS(_data["charge"]) : <any>undefined;
            this.internalCharge = _data["internalCharge"] ? ExpandableFieldOfCharge.fromJS(_data["internalCharge"]) : <any>undefined;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.currency = _data["currency"];
            this.description = _data["description"];
            this.failureBalanceTransactionId = _data["failureBalanceTransactionId"];
            this.failureBalanceTransaction = _data["failureBalanceTransaction"] ? BalanceTransaction.fromJS(_data["failureBalanceTransaction"]) : <any>undefined;
            this.internalFailureBalanceTransaction = _data["internalFailureBalanceTransaction"] ? ExpandableFieldOfBalanceTransaction.fromJS(_data["internalFailureBalanceTransaction"]) : <any>undefined;
            this.failureReason = _data["failureReason"];
            this.instructionsEmail = _data["instructionsEmail"];
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
            this.nextAction = _data["nextAction"] ? RefundNextAction.fromJS(_data["nextAction"]) : <any>undefined;
            this.paymentIntentId = _data["paymentIntentId"];
            this.paymentIntent = _data["paymentIntent"] ? PaymentIntent.fromJS(_data["paymentIntent"]) : <any>undefined;
            this.internalPaymentIntent = _data["internalPaymentIntent"] ? ExpandableFieldOfPaymentIntent.fromJS(_data["internalPaymentIntent"]) : <any>undefined;
            this.reason = _data["reason"];
            this.receiptNumber = _data["receiptNumber"];
            this.sourceTransferReversalId = _data["sourceTransferReversalId"];
            this.sourceTransferReversal = _data["sourceTransferReversal"] ? TransferReversal.fromJS(_data["sourceTransferReversal"]) : <any>undefined;
            this.internalSourceTransferReversal = _data["internalSourceTransferReversal"] ? ExpandableFieldOfTransferReversal.fromJS(_data["internalSourceTransferReversal"]) : <any>undefined;
            this.status = _data["status"];
            this.transferReversalId = _data["transferReversalId"];
            this.transferReversal = _data["transferReversal"] ? TransferReversal.fromJS(_data["transferReversal"]) : <any>undefined;
            this.internalTransferReversal = _data["internalTransferReversal"] ? ExpandableFieldOfTransferReversal.fromJS(_data["internalTransferReversal"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): Refund {
        data = typeof data === 'object' ? data : {};
        let result = new Refund();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["object"] = this.object;
        data["amount"] = this.amount;
        data["balanceTransactionId"] = this.balanceTransactionId;
        data["balanceTransaction"] = this.balanceTransaction ? this.balanceTransaction.toJSON() : <any>undefined;
        data["internalBalanceTransaction"] = this.internalBalanceTransaction ? this.internalBalanceTransaction.toJSON() : <any>undefined;
        data["chargeId"] = this.chargeId;
        data["charge"] = this.charge ? this.charge.toJSON() : <any>undefined;
        data["internalCharge"] = this.internalCharge ? this.internalCharge.toJSON() : <any>undefined;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["currency"] = this.currency;
        data["description"] = this.description;
        data["failureBalanceTransactionId"] = this.failureBalanceTransactionId;
        data["failureBalanceTransaction"] = this.failureBalanceTransaction ? this.failureBalanceTransaction.toJSON() : <any>undefined;
        data["internalFailureBalanceTransaction"] = this.internalFailureBalanceTransaction ? this.internalFailureBalanceTransaction.toJSON() : <any>undefined;
        data["failureReason"] = this.failureReason;
        data["instructionsEmail"] = this.instructionsEmail;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        data["nextAction"] = this.nextAction ? this.nextAction.toJSON() : <any>undefined;
        data["paymentIntentId"] = this.paymentIntentId;
        data["paymentIntent"] = this.paymentIntent ? this.paymentIntent.toJSON() : <any>undefined;
        data["internalPaymentIntent"] = this.internalPaymentIntent ? this.internalPaymentIntent.toJSON() : <any>undefined;
        data["reason"] = this.reason;
        data["receiptNumber"] = this.receiptNumber;
        data["sourceTransferReversalId"] = this.sourceTransferReversalId;
        data["sourceTransferReversal"] = this.sourceTransferReversal ? this.sourceTransferReversal.toJSON() : <any>undefined;
        data["internalSourceTransferReversal"] = this.internalSourceTransferReversal ? this.internalSourceTransferReversal.toJSON() : <any>undefined;
        data["status"] = this.status;
        data["transferReversalId"] = this.transferReversalId;
        data["transferReversal"] = this.transferReversal ? this.transferReversal.toJSON() : <any>undefined;
        data["internalTransferReversal"] = this.internalTransferReversal ? this.internalTransferReversal.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** Refund objects allow you to refund a charge that has previously been created but not yet refunded. Funds will be refunded to the credit or debit card that was originally charged.            Related guide: Refunds. */
export interface IRefund extends IStripeEntityOfRefund {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** Amount, in %s. */
    amount?: number;
    /** (ID of the BalanceTransaction)
Balance transaction that describes the impact on your account balance. */
    balanceTransactionId?: string | undefined;
    /** (Expanded)
Balance transaction that describes the impact on your account balance.
            
For more information, see the expand documentation. */
    balanceTransaction?: BalanceTransaction | undefined;
    internalBalanceTransaction?: ExpandableFieldOfBalanceTransaction | undefined;
    /** (ID of the Charge)
ID of the charge that was refunded. */
    chargeId?: string | undefined;
    /** (Expanded)
ID of the charge that was refunded.
            
For more information, see the expand documentation. */
    charge?: Charge | undefined;
    internalCharge?: ExpandableFieldOfCharge | undefined;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** Three-letter ISO currency
code, in lowercase. Must be a supported
currency. */
    currency?: string | undefined;
    /** An arbitrary string attached to the object. Often useful for displaying to users.
(Available on non-card refunds only). */
    description?: string | undefined;
    /** (ID of the BalanceTransaction)
If the refund failed, this balance transaction describes the adjustment made on your
account balance that reverses the initial balance transaction. */
    failureBalanceTransactionId?: string | undefined;
    /** (Expanded)
If the refund failed, this balance transaction describes the adjustment made on your
account balance that reverses the initial balance transaction.
            
For more information, see the expand documentation. */
    failureBalanceTransaction?: BalanceTransaction | undefined;
    internalFailureBalanceTransaction?: ExpandableFieldOfBalanceTransaction | undefined;
    /** If the refund failed, the reason for refund failure if known. Possible values are
lost_or_stolen_card, expired_or_canceled_card,
charge_for_pending_refund_disputed, insufficient_funds, declined,
merchant_request or unknown. */
    failureReason?: string | undefined;
    /** For payment methods without native refund support (e.g., Konbini, PromptPay), email for
the customer to receive refund instructions. */
    instructionsEmail?: string | undefined;
    /** Set of key-value pairs that you can
attach to an object. This can be useful for storing additional information about the
object in a structured format. */
    metadata?: { [key: string]: string; } | undefined;
    nextAction?: RefundNextAction | undefined;
    /** (ID of the PaymentIntent)
ID of the PaymentIntent that was refunded. */
    paymentIntentId?: string | undefined;
    /** (Expanded)
ID of the PaymentIntent that was refunded.
            
For more information, see the expand documentation. */
    paymentIntent?: PaymentIntent | undefined;
    internalPaymentIntent?: ExpandableFieldOfPaymentIntent | undefined;
    /** Reason for the refund, either user-provided (duplicate, fraudulent, or
requested_by_customer) or generated by Stripe internally
(expired_uncaptured_charge).
One of: duplicate, expired_uncaptured_charge, fraudulent, or
requested_by_customer. */
    reason?: string | undefined;
    /** This is the transaction number that appears on email receipts sent for this refund. */
    receiptNumber?: string | undefined;
    /** (ID of the TransferReversal)
The transfer reversal that is associated with the refund. Only present if the charge
came from another Stripe account. See the Connect documentation for details. */
    sourceTransferReversalId?: string | undefined;
    /** (Expanded)
The transfer reversal that is associated with the refund. Only present if the charge
came from another Stripe account. See the Connect documentation for details.
            
For more information, see the expand documentation. */
    sourceTransferReversal?: TransferReversal | undefined;
    internalSourceTransferReversal?: ExpandableFieldOfTransferReversal | undefined;
    /** Status of the refund. For credit card refunds, this can be pending,
succeeded, or failed. For other types of refunds, it can be
pending, requires_action, succeeded, failed, or
canceled. Refer to our refunds documentation for more
details. */
    status?: string | undefined;
    /** (ID of the TransferReversal)
If the accompanying transfer was reversed, the transfer reversal object. Only applicable
if the charge was created using the destination parameter. */
    transferReversalId?: string | undefined;
    /** (Expanded)
If the accompanying transfer was reversed, the transfer reversal object. Only applicable
if the charge was created using the destination parameter.
            
For more information, see the expand documentation. */
    transferReversal?: TransferReversal | undefined;
    internalTransferReversal?: ExpandableFieldOfTransferReversal | undefined;
}

export abstract class StripeEntityOfRefundNextAction extends StripeEntity implements IStripeEntityOfRefundNextAction {

    constructor(data?: IStripeEntityOfRefundNextAction) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfRefundNextAction {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfRefundNextAction' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfRefundNextAction extends IStripeEntity {
}

export class RefundNextAction extends StripeEntityOfRefundNextAction implements IRefundNextAction {
    /** Contains the refund details. */
    displayDetails?: RefundNextActionDisplayDetails | undefined;
    /** Type of the next action to perform. */
    type?: string | undefined;

    constructor(data?: IRefundNextAction) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.displayDetails = _data["displayDetails"] ? RefundNextActionDisplayDetails.fromJS(_data["displayDetails"]) : <any>undefined;
            this.type = _data["type"];
        }
    }

    static override fromJS(data: any): RefundNextAction {
        data = typeof data === 'object' ? data : {};
        let result = new RefundNextAction();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayDetails"] = this.displayDetails ? this.displayDetails.toJSON() : <any>undefined;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

export interface IRefundNextAction extends IStripeEntityOfRefundNextAction {
    /** Contains the refund details. */
    displayDetails?: RefundNextActionDisplayDetails | undefined;
    /** Type of the next action to perform. */
    type?: string | undefined;
}

export abstract class StripeEntityOfRefundNextActionDisplayDetails extends StripeEntity implements IStripeEntityOfRefundNextActionDisplayDetails {

    constructor(data?: IStripeEntityOfRefundNextActionDisplayDetails) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfRefundNextActionDisplayDetails {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfRefundNextActionDisplayDetails' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfRefundNextActionDisplayDetails extends IStripeEntity {
}

export class RefundNextActionDisplayDetails extends StripeEntityOfRefundNextActionDisplayDetails implements IRefundNextActionDisplayDetails {
    emailSent?: RefundNextActionDisplayDetailsEmailSent | undefined;
    /** The expiry timestamp. */
    expiresAt?: Date;

    constructor(data?: IRefundNextActionDisplayDetails) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.emailSent = _data["emailSent"] ? RefundNextActionDisplayDetailsEmailSent.fromJS(_data["emailSent"]) : <any>undefined;
            this.expiresAt = _data["expiresAt"] ? new Date(_data["expiresAt"].toString()) : <any>undefined;
        }
    }

    static override fromJS(data: any): RefundNextActionDisplayDetails {
        data = typeof data === 'object' ? data : {};
        let result = new RefundNextActionDisplayDetails();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailSent"] = this.emailSent ? this.emailSent.toJSON() : <any>undefined;
        data["expiresAt"] = this.expiresAt ? this.expiresAt.toISOString() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IRefundNextActionDisplayDetails extends IStripeEntityOfRefundNextActionDisplayDetails {
    emailSent?: RefundNextActionDisplayDetailsEmailSent | undefined;
    /** The expiry timestamp. */
    expiresAt?: Date;
}

export abstract class StripeEntityOfRefundNextActionDisplayDetailsEmailSent extends StripeEntity implements IStripeEntityOfRefundNextActionDisplayDetailsEmailSent {

    constructor(data?: IStripeEntityOfRefundNextActionDisplayDetailsEmailSent) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfRefundNextActionDisplayDetailsEmailSent {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfRefundNextActionDisplayDetailsEmailSent' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfRefundNextActionDisplayDetailsEmailSent extends IStripeEntity {
}

export class RefundNextActionDisplayDetailsEmailSent extends StripeEntityOfRefundNextActionDisplayDetailsEmailSent implements IRefundNextActionDisplayDetailsEmailSent {
    /** The timestamp when the email was sent. */
    emailSentAt?: Date;
    /** The recipient's email address. */
    emailSentTo?: string | undefined;

    constructor(data?: IRefundNextActionDisplayDetailsEmailSent) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.emailSentAt = _data["emailSentAt"] ? new Date(_data["emailSentAt"].toString()) : <any>undefined;
            this.emailSentTo = _data["emailSentTo"];
        }
    }

    static override fromJS(data: any): RefundNextActionDisplayDetailsEmailSent {
        data = typeof data === 'object' ? data : {};
        let result = new RefundNextActionDisplayDetailsEmailSent();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailSentAt"] = this.emailSentAt ? this.emailSentAt.toISOString() : <any>undefined;
        data["emailSentTo"] = this.emailSentTo;
        super.toJSON(data);
        return data;
    }
}

export interface IRefundNextActionDisplayDetailsEmailSent extends IStripeEntityOfRefundNextActionDisplayDetailsEmailSent {
    /** The timestamp when the email was sent. */
    emailSentAt?: Date;
    /** The recipient's email address. */
    emailSentTo?: string | undefined;
}

export abstract class StripeEntityOfTransferReversal extends StripeEntity implements IStripeEntityOfTransferReversal {

    constructor(data?: IStripeEntityOfTransferReversal) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfTransferReversal {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfTransferReversal' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfTransferReversal extends IStripeEntity {
}

/** Stripe Connect platforms can reverse transfers made to a connected account, either entirely or partially, and can also specify whether to refund any related application fees. Transfer reversals add to the platform's balance and subtract from the destination account's balance.            Reversing a transfer that was made for a destination charge is allowed only up to the amount of the charge. It is possible to reverse a transfer_group transfer only if the destination account has enough balance to cover the reversal.            Related guide: Reversing transfers. */
export class TransferReversal extends StripeEntityOfTransferReversal implements ITransferReversal {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** Amount, in %s. */
    amount?: number;
    /** (ID of the BalanceTransaction)
Balance transaction that describes the impact on your account balance. */
    balanceTransactionId?: string | undefined;
    /** (Expanded)
Balance transaction that describes the impact on your account balance.
            
For more information, see the expand documentation. */
    balanceTransaction?: BalanceTransaction | undefined;
    internalBalanceTransaction?: ExpandableFieldOfBalanceTransaction | undefined;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** Three-letter ISO currency
code, in lowercase. Must be a supported
currency. */
    currency?: string | undefined;
    /** (ID of the Refund)
Linked payment refund for the transfer reversal. */
    destinationPaymentRefundId?: string | undefined;
    /** (Expanded)
Linked payment refund for the transfer reversal.
            
For more information, see the expand documentation. */
    destinationPaymentRefund?: Refund | undefined;
    internalDestinationPaymentRefund?: ExpandableFieldOfRefund | undefined;
    /** Set of key-value pairs that you can
attach to an object. This can be useful for storing additional information about the
object in a structured format. */
    metadata?: { [key: string]: string; } | undefined;
    /** (ID of the Refund)
ID of the refund responsible for the transfer reversal. */
    sourceRefundId?: string | undefined;
    /** (Expanded)
ID of the refund responsible for the transfer reversal.
            
For more information, see the expand documentation. */
    sourceRefund?: Refund | undefined;
    internalSourceRefund?: ExpandableFieldOfRefund | undefined;
    /** (ID of the Transfer)
ID of the transfer that was reversed. */
    transferId?: string | undefined;
    /** (Expanded)
ID of the transfer that was reversed.
            
For more information, see the expand documentation. */
    transfer?: Transfer | undefined;
    internalTransfer?: ExpandableFieldOfTransfer | undefined;

    constructor(data?: ITransferReversal) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.object = _data["object"];
            this.amount = _data["amount"];
            this.balanceTransactionId = _data["balanceTransactionId"];
            this.balanceTransaction = _data["balanceTransaction"] ? BalanceTransaction.fromJS(_data["balanceTransaction"]) : <any>undefined;
            this.internalBalanceTransaction = _data["internalBalanceTransaction"] ? ExpandableFieldOfBalanceTransaction.fromJS(_data["internalBalanceTransaction"]) : <any>undefined;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.currency = _data["currency"];
            this.destinationPaymentRefundId = _data["destinationPaymentRefundId"];
            this.destinationPaymentRefund = _data["destinationPaymentRefund"] ? Refund.fromJS(_data["destinationPaymentRefund"]) : <any>undefined;
            this.internalDestinationPaymentRefund = _data["internalDestinationPaymentRefund"] ? ExpandableFieldOfRefund.fromJS(_data["internalDestinationPaymentRefund"]) : <any>undefined;
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
            this.sourceRefundId = _data["sourceRefundId"];
            this.sourceRefund = _data["sourceRefund"] ? Refund.fromJS(_data["sourceRefund"]) : <any>undefined;
            this.internalSourceRefund = _data["internalSourceRefund"] ? ExpandableFieldOfRefund.fromJS(_data["internalSourceRefund"]) : <any>undefined;
            this.transferId = _data["transferId"];
            this.transfer = _data["transfer"] ? Transfer.fromJS(_data["transfer"]) : <any>undefined;
            this.internalTransfer = _data["internalTransfer"] ? ExpandableFieldOfTransfer.fromJS(_data["internalTransfer"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): TransferReversal {
        data = typeof data === 'object' ? data : {};
        let result = new TransferReversal();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["object"] = this.object;
        data["amount"] = this.amount;
        data["balanceTransactionId"] = this.balanceTransactionId;
        data["balanceTransaction"] = this.balanceTransaction ? this.balanceTransaction.toJSON() : <any>undefined;
        data["internalBalanceTransaction"] = this.internalBalanceTransaction ? this.internalBalanceTransaction.toJSON() : <any>undefined;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["currency"] = this.currency;
        data["destinationPaymentRefundId"] = this.destinationPaymentRefundId;
        data["destinationPaymentRefund"] = this.destinationPaymentRefund ? this.destinationPaymentRefund.toJSON() : <any>undefined;
        data["internalDestinationPaymentRefund"] = this.internalDestinationPaymentRefund ? this.internalDestinationPaymentRefund.toJSON() : <any>undefined;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        data["sourceRefundId"] = this.sourceRefundId;
        data["sourceRefund"] = this.sourceRefund ? this.sourceRefund.toJSON() : <any>undefined;
        data["internalSourceRefund"] = this.internalSourceRefund ? this.internalSourceRefund.toJSON() : <any>undefined;
        data["transferId"] = this.transferId;
        data["transfer"] = this.transfer ? this.transfer.toJSON() : <any>undefined;
        data["internalTransfer"] = this.internalTransfer ? this.internalTransfer.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** Stripe Connect platforms can reverse transfers made to a connected account, either entirely or partially, and can also specify whether to refund any related application fees. Transfer reversals add to the platform's balance and subtract from the destination account's balance.            Reversing a transfer that was made for a destination charge is allowed only up to the amount of the charge. It is possible to reverse a transfer_group transfer only if the destination account has enough balance to cover the reversal.            Related guide: Reversing transfers. */
export interface ITransferReversal extends IStripeEntityOfTransferReversal {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** Amount, in %s. */
    amount?: number;
    /** (ID of the BalanceTransaction)
Balance transaction that describes the impact on your account balance. */
    balanceTransactionId?: string | undefined;
    /** (Expanded)
Balance transaction that describes the impact on your account balance.
            
For more information, see the expand documentation. */
    balanceTransaction?: BalanceTransaction | undefined;
    internalBalanceTransaction?: ExpandableFieldOfBalanceTransaction | undefined;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** Three-letter ISO currency
code, in lowercase. Must be a supported
currency. */
    currency?: string | undefined;
    /** (ID of the Refund)
Linked payment refund for the transfer reversal. */
    destinationPaymentRefundId?: string | undefined;
    /** (Expanded)
Linked payment refund for the transfer reversal.
            
For more information, see the expand documentation. */
    destinationPaymentRefund?: Refund | undefined;
    internalDestinationPaymentRefund?: ExpandableFieldOfRefund | undefined;
    /** Set of key-value pairs that you can
attach to an object. This can be useful for storing additional information about the
object in a structured format. */
    metadata?: { [key: string]: string; } | undefined;
    /** (ID of the Refund)
ID of the refund responsible for the transfer reversal. */
    sourceRefundId?: string | undefined;
    /** (Expanded)
ID of the refund responsible for the transfer reversal.
            
For more information, see the expand documentation. */
    sourceRefund?: Refund | undefined;
    internalSourceRefund?: ExpandableFieldOfRefund | undefined;
    /** (ID of the Transfer)
ID of the transfer that was reversed. */
    transferId?: string | undefined;
    /** (Expanded)
ID of the transfer that was reversed.
            
For more information, see the expand documentation. */
    transfer?: Transfer | undefined;
    internalTransfer?: ExpandableFieldOfTransfer | undefined;
}

/** Represents a generic expandable field. */
export class ExpandableFieldOfRefund implements IExpandableFieldOfRefund {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: Refund | undefined;

    constructor(data?: IExpandableFieldOfRefund) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.expandedObject = _data["expandedObject"] ? Refund.fromJS(_data["expandedObject"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExpandableFieldOfRefund {
        data = typeof data === 'object' ? data : {};
        let result = new ExpandableFieldOfRefund();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["expandedObject"] = this.expandedObject ? this.expandedObject.toJSON() : <any>undefined;
        return data;
    }
}

/** Represents a generic expandable field. */
export interface IExpandableFieldOfRefund {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: Refund | undefined;
}

export abstract class StripeEntityOfTransfer extends StripeEntity implements IStripeEntityOfTransfer {

    constructor(data?: IStripeEntityOfTransfer) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfTransfer {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfTransfer' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfTransfer extends IStripeEntity {
}

/** A Transfer object is created when you move funds between Stripe accounts as part of Connect.            Before April 6, 2017, transfers also represented movement of funds from a Stripe account to a card or bank account. This behavior has since been split out into a Payout object, with corresponding payout endpoints. For more information, read about the transfer/payout split.            Related guide: Creating separate charges and transfers. */
export class Transfer extends StripeEntityOfTransfer implements ITransfer {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** Amount in %s to be transferred. */
    amount?: number;
    /** Amount in %s reversed (can be less than the amount attribute on the transfer if a
partial reversal was issued). */
    amountReversed?: number;
    /** (ID of the BalanceTransaction)
Balance transaction that describes the impact of this transfer on your account balance. */
    balanceTransactionId?: string | undefined;
    /** (Expanded)
Balance transaction that describes the impact of this transfer on your account balance.
            
For more information, see the expand documentation. */
    balanceTransaction?: BalanceTransaction | undefined;
    internalBalanceTransaction?: ExpandableFieldOfBalanceTransaction | undefined;
    /** Time that this record of the transfer was first created. */
    created?: Date;
    /** Three-letter ISO currency
code, in lowercase. Must be a supported
currency. */
    currency?: string | undefined;
    /** An arbitrary string attached to the object. Often useful for displaying to users. */
    description?: string | undefined;
    /** (ID of the Account)
ID of the Stripe account the transfer was sent to. */
    destinationId?: string | undefined;
    /** (Expanded)
ID of the Stripe account the transfer was sent to.
            
For more information, see the expand documentation. */
    destination?: Account | undefined;
    internalDestination?: ExpandableFieldOfAccount | undefined;
    /** (ID of the Charge)
If the destination is a Stripe account, this will be the ID of the payment that the
destination account received for the transfer. */
    destinationPaymentId?: string | undefined;
    /** (Expanded)
If the destination is a Stripe account, this will be the ID of the payment that the
destination account received for the transfer.
            
For more information, see the expand documentation. */
    destinationPayment?: Charge | undefined;
    internalDestinationPayment?: ExpandableFieldOfCharge | undefined;
    /** Has the value true if the object exists in live mode or the value false if
the object exists in test mode. */
    livemode?: boolean;
    /** Set of key-value pairs that you can
attach to an object. This can be useful for storing additional information about the
object in a structured format. */
    metadata?: { [key: string]: string; } | undefined;
    /** A list of reversals that have been applied to the transfer. */
    reversals?: StripeListOfTransferReversal | undefined;
    /** Whether the transfer has been fully reversed. If the transfer is only partially
reversed, this attribute will still be false. */
    reversed?: boolean;
    /** (ID of the Charge)
ID of the charge or payment that was used to fund the transfer. If null, the transfer
was funded from the available balance. */
    sourceTransactionId?: string | undefined;
    /** (Expanded)
ID of the charge or payment that was used to fund the transfer. If null, the transfer
was funded from the available balance.
            
For more information, see the expand documentation. */
    sourceTransaction?: Charge | undefined;
    internalSourceTransaction?: ExpandableFieldOfCharge | undefined;
    /** The source balance this transfer came from. One of card, fpx, or
bank_account. */
    sourceType?: string | undefined;
    /** A string that identifies this transaction as part of a group. See the Connect
documentation for details. */
    transferGroup?: string | undefined;

    constructor(data?: ITransfer) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.object = _data["object"];
            this.amount = _data["amount"];
            this.amountReversed = _data["amountReversed"];
            this.balanceTransactionId = _data["balanceTransactionId"];
            this.balanceTransaction = _data["balanceTransaction"] ? BalanceTransaction.fromJS(_data["balanceTransaction"]) : <any>undefined;
            this.internalBalanceTransaction = _data["internalBalanceTransaction"] ? ExpandableFieldOfBalanceTransaction.fromJS(_data["internalBalanceTransaction"]) : <any>undefined;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.currency = _data["currency"];
            this.description = _data["description"];
            this.destinationId = _data["destinationId"];
            this.destination = _data["destination"] ? Account.fromJS(_data["destination"]) : <any>undefined;
            this.internalDestination = _data["internalDestination"] ? ExpandableFieldOfAccount.fromJS(_data["internalDestination"]) : <any>undefined;
            this.destinationPaymentId = _data["destinationPaymentId"];
            this.destinationPayment = _data["destinationPayment"] ? Charge.fromJS(_data["destinationPayment"]) : <any>undefined;
            this.internalDestinationPayment = _data["internalDestinationPayment"] ? ExpandableFieldOfCharge.fromJS(_data["internalDestinationPayment"]) : <any>undefined;
            this.livemode = _data["livemode"];
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
            this.reversals = _data["reversals"] ? StripeListOfTransferReversal.fromJS(_data["reversals"]) : <any>undefined;
            this.reversed = _data["reversed"];
            this.sourceTransactionId = _data["sourceTransactionId"];
            this.sourceTransaction = _data["sourceTransaction"] ? Charge.fromJS(_data["sourceTransaction"]) : <any>undefined;
            this.internalSourceTransaction = _data["internalSourceTransaction"] ? ExpandableFieldOfCharge.fromJS(_data["internalSourceTransaction"]) : <any>undefined;
            this.sourceType = _data["sourceType"];
            this.transferGroup = _data["transferGroup"];
        }
    }

    static override fromJS(data: any): Transfer {
        data = typeof data === 'object' ? data : {};
        let result = new Transfer();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["object"] = this.object;
        data["amount"] = this.amount;
        data["amountReversed"] = this.amountReversed;
        data["balanceTransactionId"] = this.balanceTransactionId;
        data["balanceTransaction"] = this.balanceTransaction ? this.balanceTransaction.toJSON() : <any>undefined;
        data["internalBalanceTransaction"] = this.internalBalanceTransaction ? this.internalBalanceTransaction.toJSON() : <any>undefined;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["currency"] = this.currency;
        data["description"] = this.description;
        data["destinationId"] = this.destinationId;
        data["destination"] = this.destination ? this.destination.toJSON() : <any>undefined;
        data["internalDestination"] = this.internalDestination ? this.internalDestination.toJSON() : <any>undefined;
        data["destinationPaymentId"] = this.destinationPaymentId;
        data["destinationPayment"] = this.destinationPayment ? this.destinationPayment.toJSON() : <any>undefined;
        data["internalDestinationPayment"] = this.internalDestinationPayment ? this.internalDestinationPayment.toJSON() : <any>undefined;
        data["livemode"] = this.livemode;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        data["reversals"] = this.reversals ? this.reversals.toJSON() : <any>undefined;
        data["reversed"] = this.reversed;
        data["sourceTransactionId"] = this.sourceTransactionId;
        data["sourceTransaction"] = this.sourceTransaction ? this.sourceTransaction.toJSON() : <any>undefined;
        data["internalSourceTransaction"] = this.internalSourceTransaction ? this.internalSourceTransaction.toJSON() : <any>undefined;
        data["sourceType"] = this.sourceType;
        data["transferGroup"] = this.transferGroup;
        super.toJSON(data);
        return data;
    }
}

/** A Transfer object is created when you move funds between Stripe accounts as part of Connect.            Before April 6, 2017, transfers also represented movement of funds from a Stripe account to a card or bank account. This behavior has since been split out into a Payout object, with corresponding payout endpoints. For more information, read about the transfer/payout split.            Related guide: Creating separate charges and transfers. */
export interface ITransfer extends IStripeEntityOfTransfer {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** Amount in %s to be transferred. */
    amount?: number;
    /** Amount in %s reversed (can be less than the amount attribute on the transfer if a
partial reversal was issued). */
    amountReversed?: number;
    /** (ID of the BalanceTransaction)
Balance transaction that describes the impact of this transfer on your account balance. */
    balanceTransactionId?: string | undefined;
    /** (Expanded)
Balance transaction that describes the impact of this transfer on your account balance.
            
For more information, see the expand documentation. */
    balanceTransaction?: BalanceTransaction | undefined;
    internalBalanceTransaction?: ExpandableFieldOfBalanceTransaction | undefined;
    /** Time that this record of the transfer was first created. */
    created?: Date;
    /** Three-letter ISO currency
code, in lowercase. Must be a supported
currency. */
    currency?: string | undefined;
    /** An arbitrary string attached to the object. Often useful for displaying to users. */
    description?: string | undefined;
    /** (ID of the Account)
ID of the Stripe account the transfer was sent to. */
    destinationId?: string | undefined;
    /** (Expanded)
ID of the Stripe account the transfer was sent to.
            
For more information, see the expand documentation. */
    destination?: Account | undefined;
    internalDestination?: ExpandableFieldOfAccount | undefined;
    /** (ID of the Charge)
If the destination is a Stripe account, this will be the ID of the payment that the
destination account received for the transfer. */
    destinationPaymentId?: string | undefined;
    /** (Expanded)
If the destination is a Stripe account, this will be the ID of the payment that the
destination account received for the transfer.
            
For more information, see the expand documentation. */
    destinationPayment?: Charge | undefined;
    internalDestinationPayment?: ExpandableFieldOfCharge | undefined;
    /** Has the value true if the object exists in live mode or the value false if
the object exists in test mode. */
    livemode?: boolean;
    /** Set of key-value pairs that you can
attach to an object. This can be useful for storing additional information about the
object in a structured format. */
    metadata?: { [key: string]: string; } | undefined;
    /** A list of reversals that have been applied to the transfer. */
    reversals?: StripeListOfTransferReversal | undefined;
    /** Whether the transfer has been fully reversed. If the transfer is only partially
reversed, this attribute will still be false. */
    reversed?: boolean;
    /** (ID of the Charge)
ID of the charge or payment that was used to fund the transfer. If null, the transfer
was funded from the available balance. */
    sourceTransactionId?: string | undefined;
    /** (Expanded)
ID of the charge or payment that was used to fund the transfer. If null, the transfer
was funded from the available balance.
            
For more information, see the expand documentation. */
    sourceTransaction?: Charge | undefined;
    internalSourceTransaction?: ExpandableFieldOfCharge | undefined;
    /** The source balance this transfer came from. One of card, fpx, or
bank_account. */
    sourceType?: string | undefined;
    /** A string that identifies this transaction as part of a group. See the Connect
documentation for details. */
    transferGroup?: string | undefined;
}

export abstract class StripeEntityOfStripeListOfTransferReversal extends StripeEntity implements IStripeEntityOfStripeListOfTransferReversal {

    constructor(data?: IStripeEntityOfStripeListOfTransferReversal) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfStripeListOfTransferReversal {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfStripeListOfTransferReversal' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfStripeListOfTransferReversal extends IStripeEntity {
}

export class StripeListOfTransferReversal extends StripeEntityOfStripeListOfTransferReversal implements IStripeListOfTransferReversal {
    /** A string describing the object type returned. */
    object?: string | undefined;
    /** A list containing the actual response elements, paginated by any request parameters. */
    data?: TransferReversal[] | undefined;
    /** Whether or not there are more elements available after this set. If false,
this set comprises the end of the list. */
    hasMore?: boolean;
    /** The URL for accessing this list. */
    url?: string | undefined;

    constructor(data?: IStripeListOfTransferReversal) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.object = _data["object"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(TransferReversal.fromJS(item));
            }
            this.hasMore = _data["hasMore"];
            this.url = _data["url"];
        }
    }

    static override fromJS(data: any): StripeListOfTransferReversal {
        data = typeof data === 'object' ? data : {};
        let result = new StripeListOfTransferReversal();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["object"] = this.object;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["hasMore"] = this.hasMore;
        data["url"] = this.url;
        super.toJSON(data);
        return data;
    }
}

export interface IStripeListOfTransferReversal extends IStripeEntityOfStripeListOfTransferReversal {
    /** A string describing the object type returned. */
    object?: string | undefined;
    /** A list containing the actual response elements, paginated by any request parameters. */
    data?: TransferReversal[] | undefined;
    /** Whether or not there are more elements available after this set. If false,
this set comprises the end of the list. */
    hasMore?: boolean;
    /** The URL for accessing this list. */
    url?: string | undefined;
}

/** Represents a generic expandable field. */
export class ExpandableFieldOfTransfer implements IExpandableFieldOfTransfer {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: Transfer | undefined;

    constructor(data?: IExpandableFieldOfTransfer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.expandedObject = _data["expandedObject"] ? Transfer.fromJS(_data["expandedObject"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExpandableFieldOfTransfer {
        data = typeof data === 'object' ? data : {};
        let result = new ExpandableFieldOfTransfer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["expandedObject"] = this.expandedObject ? this.expandedObject.toJSON() : <any>undefined;
        return data;
    }
}

/** Represents a generic expandable field. */
export interface IExpandableFieldOfTransfer {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: Transfer | undefined;
}

/** Represents a generic expandable field. */
export class ExpandableFieldOfTransferReversal implements IExpandableFieldOfTransferReversal {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: TransferReversal | undefined;

    constructor(data?: IExpandableFieldOfTransferReversal) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.expandedObject = _data["expandedObject"] ? TransferReversal.fromJS(_data["expandedObject"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExpandableFieldOfTransferReversal {
        data = typeof data === 'object' ? data : {};
        let result = new ExpandableFieldOfTransferReversal();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["expandedObject"] = this.expandedObject ? this.expandedObject.toJSON() : <any>undefined;
        return data;
    }
}

/** Represents a generic expandable field. */
export interface IExpandableFieldOfTransferReversal {
    /** Gets or sets the ID. */
    id?: string | undefined;
    /** Gets or sets the expanded object. */
    expandedObject?: TransferReversal | undefined;
}

export abstract class StripeEntityOfChargeTransferData extends StripeEntity implements IStripeEntityOfChargeTransferData {

    constructor(data?: IStripeEntityOfChargeTransferData) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfChargeTransferData {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfChargeTransferData' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfChargeTransferData extends IStripeEntity {
}

export class ChargeTransferData extends StripeEntityOfChargeTransferData implements IChargeTransferData {
    /** The amount transferred to the destination account, if specified. By default, the entire
charge amount is transferred to the destination account. */
    amount?: number | undefined;
    /** (ID of the Account)
ID of an existing, connected Stripe account to transfer funds to if transfer_data
was specified in the charge request. */
    destinationId?: string | undefined;
    /** (Expanded)
ID of an existing, connected Stripe account to transfer funds to if transfer_data
was specified in the charge request.
            
For more information, see the expand documentation. */
    destination?: Account | undefined;
    internalDestination?: ExpandableFieldOfAccount | undefined;

    constructor(data?: IChargeTransferData) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.amount = _data["amount"];
            this.destinationId = _data["destinationId"];
            this.destination = _data["destination"] ? Account.fromJS(_data["destination"]) : <any>undefined;
            this.internalDestination = _data["internalDestination"] ? ExpandableFieldOfAccount.fromJS(_data["internalDestination"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): ChargeTransferData {
        data = typeof data === 'object' ? data : {};
        let result = new ChargeTransferData();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["destinationId"] = this.destinationId;
        data["destination"] = this.destination ? this.destination.toJSON() : <any>undefined;
        data["internalDestination"] = this.internalDestination ? this.internalDestination.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IChargeTransferData extends IStripeEntityOfChargeTransferData {
    /** The amount transferred to the destination account, if specified. By default, the entire
charge amount is transferred to the destination account. */
    amount?: number | undefined;
    /** (ID of the Account)
ID of an existing, connected Stripe account to transfer funds to if transfer_data
was specified in the charge request. */
    destinationId?: string | undefined;
    /** (Expanded)
ID of an existing, connected Stripe account to transfer funds to if transfer_data
was specified in the charge request.
            
For more information, see the expand documentation. */
    destination?: Account | undefined;
    internalDestination?: ExpandableFieldOfAccount | undefined;
}

export abstract class StripeEntityOfPaymentMethodSofort extends StripeEntity implements IStripeEntityOfPaymentMethodSofort {

    constructor(data?: IStripeEntityOfPaymentMethodSofort) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentMethodSofort {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentMethodSofort' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentMethodSofort extends IStripeEntity {
}

export class PaymentMethodSofort extends StripeEntityOfPaymentMethodSofort implements IPaymentMethodSofort {
    /** Two-letter ISO code representing the country the bank account is located in. */
    country?: string | undefined;

    constructor(data?: IPaymentMethodSofort) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.country = _data["country"];
        }
    }

    static override fromJS(data: any): PaymentMethodSofort {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodSofort();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["country"] = this.country;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentMethodSofort extends IStripeEntityOfPaymentMethodSofort {
    /** Two-letter ISO code representing the country the bank account is located in. */
    country?: string | undefined;
}

export abstract class StripeEntityOfPaymentMethodUsBankAccount extends StripeEntity implements IStripeEntityOfPaymentMethodUsBankAccount {

    constructor(data?: IStripeEntityOfPaymentMethodUsBankAccount) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentMethodUsBankAccount {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentMethodUsBankAccount' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentMethodUsBankAccount extends IStripeEntity {
}

export class PaymentMethodUsBankAccount extends StripeEntityOfPaymentMethodUsBankAccount implements IPaymentMethodUsBankAccount {
    /** Account holder type: individual or company.
One of: company, or individual. */
    accountHolderType?: string | undefined;
    /** Account type: checkings or savings. Defaults to checking if omitted.
One of: checking, or savings. */
    accountType?: string | undefined;
    /** The name of the bank. */
    bankName?: string | undefined;
    /** The ID of the Financial Connections Account used to create the payment method. */
    financialConnectionsAccount?: string | undefined;
    /** Uniquely identifies this particular bank account. You can use this attribute to check
whether two bank accounts are the same. */
    fingerprint?: string | undefined;
    /** Last four digits of the bank account number. */
    last4?: string | undefined;
    /** Contains information about US bank account networks that can be used. */
    networks?: PaymentMethodUsBankAccountNetworks | undefined;
    /** Routing number of the bank account. */
    routingNumber?: string | undefined;
    /** Contains information about the future reusability of this PaymentMethod. */
    statusDetails?: PaymentMethodUsBankAccountStatusDetails | undefined;

    constructor(data?: IPaymentMethodUsBankAccount) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.accountHolderType = _data["accountHolderType"];
            this.accountType = _data["accountType"];
            this.bankName = _data["bankName"];
            this.financialConnectionsAccount = _data["financialConnectionsAccount"];
            this.fingerprint = _data["fingerprint"];
            this.last4 = _data["last4"];
            this.networks = _data["networks"] ? PaymentMethodUsBankAccountNetworks.fromJS(_data["networks"]) : <any>undefined;
            this.routingNumber = _data["routingNumber"];
            this.statusDetails = _data["statusDetails"] ? PaymentMethodUsBankAccountStatusDetails.fromJS(_data["statusDetails"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): PaymentMethodUsBankAccount {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodUsBankAccount();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountHolderType"] = this.accountHolderType;
        data["accountType"] = this.accountType;
        data["bankName"] = this.bankName;
        data["financialConnectionsAccount"] = this.financialConnectionsAccount;
        data["fingerprint"] = this.fingerprint;
        data["last4"] = this.last4;
        data["networks"] = this.networks ? this.networks.toJSON() : <any>undefined;
        data["routingNumber"] = this.routingNumber;
        data["statusDetails"] = this.statusDetails ? this.statusDetails.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentMethodUsBankAccount extends IStripeEntityOfPaymentMethodUsBankAccount {
    /** Account holder type: individual or company.
One of: company, or individual. */
    accountHolderType?: string | undefined;
    /** Account type: checkings or savings. Defaults to checking if omitted.
One of: checking, or savings. */
    accountType?: string | undefined;
    /** The name of the bank. */
    bankName?: string | undefined;
    /** The ID of the Financial Connections Account used to create the payment method. */
    financialConnectionsAccount?: string | undefined;
    /** Uniquely identifies this particular bank account. You can use this attribute to check
whether two bank accounts are the same. */
    fingerprint?: string | undefined;
    /** Last four digits of the bank account number. */
    last4?: string | undefined;
    /** Contains information about US bank account networks that can be used. */
    networks?: PaymentMethodUsBankAccountNetworks | undefined;
    /** Routing number of the bank account. */
    routingNumber?: string | undefined;
    /** Contains information about the future reusability of this PaymentMethod. */
    statusDetails?: PaymentMethodUsBankAccountStatusDetails | undefined;
}

export abstract class StripeEntityOfPaymentMethodUsBankAccountNetworks extends StripeEntity implements IStripeEntityOfPaymentMethodUsBankAccountNetworks {

    constructor(data?: IStripeEntityOfPaymentMethodUsBankAccountNetworks) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentMethodUsBankAccountNetworks {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentMethodUsBankAccountNetworks' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentMethodUsBankAccountNetworks extends IStripeEntity {
}

export class PaymentMethodUsBankAccountNetworks extends StripeEntityOfPaymentMethodUsBankAccountNetworks implements IPaymentMethodUsBankAccountNetworks {
    /** The preferred network. */
    preferred?: string | undefined;
    /** All supported networks. */
    supported?: string[] | undefined;

    constructor(data?: IPaymentMethodUsBankAccountNetworks) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.preferred = _data["preferred"];
            if (Array.isArray(_data["supported"])) {
                this.supported = [] as any;
                for (let item of _data["supported"])
                    this.supported!.push(item);
            }
        }
    }

    static override fromJS(data: any): PaymentMethodUsBankAccountNetworks {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodUsBankAccountNetworks();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["preferred"] = this.preferred;
        if (Array.isArray(this.supported)) {
            data["supported"] = [];
            for (let item of this.supported)
                data["supported"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentMethodUsBankAccountNetworks extends IStripeEntityOfPaymentMethodUsBankAccountNetworks {
    /** The preferred network. */
    preferred?: string | undefined;
    /** All supported networks. */
    supported?: string[] | undefined;
}

export abstract class StripeEntityOfPaymentMethodUsBankAccountStatusDetails extends StripeEntity implements IStripeEntityOfPaymentMethodUsBankAccountStatusDetails {

    constructor(data?: IStripeEntityOfPaymentMethodUsBankAccountStatusDetails) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentMethodUsBankAccountStatusDetails {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentMethodUsBankAccountStatusDetails' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentMethodUsBankAccountStatusDetails extends IStripeEntity {
}

export class PaymentMethodUsBankAccountStatusDetails extends StripeEntityOfPaymentMethodUsBankAccountStatusDetails implements IPaymentMethodUsBankAccountStatusDetails {
    blocked?: PaymentMethodUsBankAccountStatusDetailsBlocked | undefined;

    constructor(data?: IPaymentMethodUsBankAccountStatusDetails) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.blocked = _data["blocked"] ? PaymentMethodUsBankAccountStatusDetailsBlocked.fromJS(_data["blocked"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): PaymentMethodUsBankAccountStatusDetails {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodUsBankAccountStatusDetails();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["blocked"] = this.blocked ? this.blocked.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentMethodUsBankAccountStatusDetails extends IStripeEntityOfPaymentMethodUsBankAccountStatusDetails {
    blocked?: PaymentMethodUsBankAccountStatusDetailsBlocked | undefined;
}

export abstract class StripeEntityOfPaymentMethodUsBankAccountStatusDetailsBlocked extends StripeEntity implements IStripeEntityOfPaymentMethodUsBankAccountStatusDetailsBlocked {

    constructor(data?: IStripeEntityOfPaymentMethodUsBankAccountStatusDetailsBlocked) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentMethodUsBankAccountStatusDetailsBlocked {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentMethodUsBankAccountStatusDetailsBlocked' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentMethodUsBankAccountStatusDetailsBlocked extends IStripeEntity {
}

export class PaymentMethodUsBankAccountStatusDetailsBlocked extends StripeEntityOfPaymentMethodUsBankAccountStatusDetailsBlocked implements IPaymentMethodUsBankAccountStatusDetailsBlocked {
    /** The ACH network code that resulted in this block.
One of: R02, R03, R04, R05, R07, R08,
R10, R11, R16, R20, R29, or R31. */
    networkCode?: string | undefined;
    /** The reason why this PaymentMethod's fingerprint has been blocked.
One of: bank_account_closed, bank_account_frozen,
bank_account_invalid_details, bank_account_restricted,
bank_account_unusable, or debit_not_authorized. */
    reason?: string | undefined;

    constructor(data?: IPaymentMethodUsBankAccountStatusDetailsBlocked) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.networkCode = _data["networkCode"];
            this.reason = _data["reason"];
        }
    }

    static override fromJS(data: any): PaymentMethodUsBankAccountStatusDetailsBlocked {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodUsBankAccountStatusDetailsBlocked();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["networkCode"] = this.networkCode;
        data["reason"] = this.reason;
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentMethodUsBankAccountStatusDetailsBlocked extends IStripeEntityOfPaymentMethodUsBankAccountStatusDetailsBlocked {
    /** The ACH network code that resulted in this block.
One of: R02, R03, R04, R05, R07, R08,
R10, R11, R16, R20, R29, or R31. */
    networkCode?: string | undefined;
    /** The reason why this PaymentMethod's fingerprint has been blocked.
One of: bank_account_closed, bank_account_frozen,
bank_account_invalid_details, bank_account_restricted,
bank_account_unusable, or debit_not_authorized. */
    reason?: string | undefined;
}

export abstract class StripeEntityOfPaymentMethodWechatPay extends StripeEntity implements IStripeEntityOfPaymentMethodWechatPay {

    constructor(data?: IStripeEntityOfPaymentMethodWechatPay) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentMethodWechatPay {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentMethodWechatPay' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentMethodWechatPay extends IStripeEntity {
}

export class PaymentMethodWechatPay extends StripeEntityOfPaymentMethodWechatPay implements IPaymentMethodWechatPay {

    constructor(data?: IPaymentMethodWechatPay) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): PaymentMethodWechatPay {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodWechatPay();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentMethodWechatPay extends IStripeEntityOfPaymentMethodWechatPay {
}

export abstract class StripeEntityOfPaymentMethodZip extends StripeEntity implements IStripeEntityOfPaymentMethodZip {

    constructor(data?: IStripeEntityOfPaymentMethodZip) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfPaymentMethodZip {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfPaymentMethodZip' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfPaymentMethodZip extends IStripeEntity {
}

export class PaymentMethodZip extends StripeEntityOfPaymentMethodZip implements IPaymentMethodZip {

    constructor(data?: IPaymentMethodZip) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): PaymentMethodZip {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodZip();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IPaymentMethodZip extends IStripeEntityOfPaymentMethodZip {
}

export abstract class StripeEntityOfStripeListOfSubscriptionItem extends StripeEntity implements IStripeEntityOfStripeListOfSubscriptionItem {

    constructor(data?: IStripeEntityOfStripeListOfSubscriptionItem) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfStripeListOfSubscriptionItem {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfStripeListOfSubscriptionItem' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfStripeListOfSubscriptionItem extends IStripeEntity {
}

export class StripeListOfSubscriptionItem extends StripeEntityOfStripeListOfSubscriptionItem implements IStripeListOfSubscriptionItem {
    /** A string describing the object type returned. */
    object?: string | undefined;
    /** A list containing the actual response elements, paginated by any request parameters. */
    data?: SubscriptionItem[] | undefined;
    /** Whether or not there are more elements available after this set. If false,
this set comprises the end of the list. */
    hasMore?: boolean;
    /** The URL for accessing this list. */
    url?: string | undefined;

    constructor(data?: IStripeListOfSubscriptionItem) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.object = _data["object"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(SubscriptionItem.fromJS(item));
            }
            this.hasMore = _data["hasMore"];
            this.url = _data["url"];
        }
    }

    static override fromJS(data: any): StripeListOfSubscriptionItem {
        data = typeof data === 'object' ? data : {};
        let result = new StripeListOfSubscriptionItem();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["object"] = this.object;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["hasMore"] = this.hasMore;
        data["url"] = this.url;
        super.toJSON(data);
        return data;
    }
}

export interface IStripeListOfSubscriptionItem extends IStripeEntityOfStripeListOfSubscriptionItem {
    /** A string describing the object type returned. */
    object?: string | undefined;
    /** A list containing the actual response elements, paginated by any request parameters. */
    data?: SubscriptionItem[] | undefined;
    /** Whether or not there are more elements available after this set. If false,
this set comprises the end of the list. */
    hasMore?: boolean;
    /** The URL for accessing this list. */
    url?: string | undefined;
}

export abstract class StripeEntityOfSubscriptionItem extends StripeEntity implements IStripeEntityOfSubscriptionItem {

    constructor(data?: IStripeEntityOfSubscriptionItem) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSubscriptionItem {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSubscriptionItem' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSubscriptionItem extends IStripeEntity {
}

/** Subscription items allow you to create customer subscriptions with more than one plan, making it easy to represent complex billing relationships. */
export class SubscriptionItem extends StripeEntityOfSubscriptionItem implements ISubscriptionItem {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** Define thresholds at which an invoice will be sent, and the related subscription
advanced to a new billing period. */
    billingThresholds?: SubscriptionItemBillingThresholds | undefined;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** Whether this object is deleted or not. */
    deleted?: boolean | undefined;
    /** Set of key-value pairs that you can
attach to an object. This can be useful for storing additional information about the
object in a structured format. */
    metadata?: { [key: string]: string; } | undefined;
    /** You can now model subscriptions more flexibly using the Prices API. It replaces the Plans API and
is backwards compatible to simplify your migration.
            
Plans define the base price, currency, and billing cycle for recurring purchases of
products. Products help you track
inventory or provisioning, and plans help you track pricing. Different physical goods or
levels of service should be represented by products, and pricing options should be
represented by plans. This approach lets you change prices without having to change your
provisioning scheme.
            
For example, you might have a single "gold" product that has plans for $10/month,
$100/year, €9/month, and €90/year.
            
Related guides: Set up a
subscription and more about products and prices. */
    plan?: Plan | undefined;
    /** Prices define the unit cost, currency, and (optional) billing cycle for both recurring
and one-time purchases of products. Products help you track inventory or
provisioning, and prices help you track payment terms. Different physical goods or
levels of service should be represented by products, and pricing options should be
represented by prices. This approach lets you change prices without having to change
your provisioning scheme.
            
For example, you might have a single "gold" product that has prices for $10/month,
$100/year, and €9 once.
            
Related guides: Set up a
subscription, create an
invoice, and more about products and prices. */
    price?: Price | undefined;
    /** The quantity of the plan
to which the customer should be subscribed. */
    quantity?: number;
    /** The subscription this subscription_item belongs to. */
    subscription?: string | undefined;
    /** The tax rates which apply to this subscription_item. When set, the
default_tax_rates on the subscription do not apply to this
subscription_item. */
    taxRates?: TaxRate[] | undefined;

    constructor(data?: ISubscriptionItem) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.object = _data["object"];
            this.billingThresholds = _data["billingThresholds"] ? SubscriptionItemBillingThresholds.fromJS(_data["billingThresholds"]) : <any>undefined;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.deleted = _data["deleted"];
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
            this.plan = _data["plan"] ? Plan.fromJS(_data["plan"]) : <any>undefined;
            this.price = _data["price"] ? Price.fromJS(_data["price"]) : <any>undefined;
            this.quantity = _data["quantity"];
            this.subscription = _data["subscription"];
            if (Array.isArray(_data["taxRates"])) {
                this.taxRates = [] as any;
                for (let item of _data["taxRates"])
                    this.taxRates!.push(TaxRate.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): SubscriptionItem {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionItem();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["object"] = this.object;
        data["billingThresholds"] = this.billingThresholds ? this.billingThresholds.toJSON() : <any>undefined;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["deleted"] = this.deleted;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        data["plan"] = this.plan ? this.plan.toJSON() : <any>undefined;
        data["price"] = this.price ? this.price.toJSON() : <any>undefined;
        data["quantity"] = this.quantity;
        data["subscription"] = this.subscription;
        if (Array.isArray(this.taxRates)) {
            data["taxRates"] = [];
            for (let item of this.taxRates)
                data["taxRates"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Subscription items allow you to create customer subscriptions with more than one plan, making it easy to represent complex billing relationships. */
export interface ISubscriptionItem extends IStripeEntityOfSubscriptionItem {
    /** Unique identifier for the object. */
    id?: string | undefined;
    /** String representing the object's type. Objects of the same type share the same value. */
    object?: string | undefined;
    /** Define thresholds at which an invoice will be sent, and the related subscription
advanced to a new billing period. */
    billingThresholds?: SubscriptionItemBillingThresholds | undefined;
    /** Time at which the object was created. Measured in seconds since the Unix epoch. */
    created?: Date;
    /** Whether this object is deleted or not. */
    deleted?: boolean | undefined;
    /** Set of key-value pairs that you can
attach to an object. This can be useful for storing additional information about the
object in a structured format. */
    metadata?: { [key: string]: string; } | undefined;
    /** You can now model subscriptions more flexibly using the Prices API. It replaces the Plans API and
is backwards compatible to simplify your migration.
            
Plans define the base price, currency, and billing cycle for recurring purchases of
products. Products help you track
inventory or provisioning, and plans help you track pricing. Different physical goods or
levels of service should be represented by products, and pricing options should be
represented by plans. This approach lets you change prices without having to change your
provisioning scheme.
            
For example, you might have a single "gold" product that has plans for $10/month,
$100/year, €9/month, and €90/year.
            
Related guides: Set up a
subscription and more about products and prices. */
    plan?: Plan | undefined;
    /** Prices define the unit cost, currency, and (optional) billing cycle for both recurring
and one-time purchases of products. Products help you track inventory or
provisioning, and prices help you track payment terms. Different physical goods or
levels of service should be represented by products, and pricing options should be
represented by prices. This approach lets you change prices without having to change
your provisioning scheme.
            
For example, you might have a single "gold" product that has prices for $10/month,
$100/year, and €9 once.
            
Related guides: Set up a
subscription, create an
invoice, and more about products and prices. */
    price?: Price | undefined;
    /** The quantity of the plan
to which the customer should be subscribed. */
    quantity?: number;
    /** The subscription this subscription_item belongs to. */
    subscription?: string | undefined;
    /** The tax rates which apply to this subscription_item. When set, the
default_tax_rates on the subscription do not apply to this
subscription_item. */
    taxRates?: TaxRate[] | undefined;
}

export abstract class StripeEntityOfSubscriptionItemBillingThresholds extends StripeEntity implements IStripeEntityOfSubscriptionItemBillingThresholds {

    constructor(data?: IStripeEntityOfSubscriptionItemBillingThresholds) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSubscriptionItemBillingThresholds {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSubscriptionItemBillingThresholds' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSubscriptionItemBillingThresholds extends IStripeEntity {
}

export class SubscriptionItemBillingThresholds extends StripeEntityOfSubscriptionItemBillingThresholds implements ISubscriptionItemBillingThresholds {
    /** Usage threshold that triggers the subscription to create an invoice. */
    usageGte?: number | undefined;

    constructor(data?: ISubscriptionItemBillingThresholds) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.usageGte = _data["usageGte"];
        }
    }

    static override fromJS(data: any): SubscriptionItemBillingThresholds {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionItemBillingThresholds();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["usageGte"] = this.usageGte;
        super.toJSON(data);
        return data;
    }
}

export interface ISubscriptionItemBillingThresholds extends IStripeEntityOfSubscriptionItemBillingThresholds {
    /** Usage threshold that triggers the subscription to create an invoice. */
    usageGte?: number | undefined;
}

export abstract class StripeEntityOfSubscriptionPauseCollection extends StripeEntity implements IStripeEntityOfSubscriptionPauseCollection {

    constructor(data?: IStripeEntityOfSubscriptionPauseCollection) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSubscriptionPauseCollection {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSubscriptionPauseCollection' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSubscriptionPauseCollection extends IStripeEntity {
}

export class SubscriptionPauseCollection extends StripeEntityOfSubscriptionPauseCollection implements ISubscriptionPauseCollection {
    /** The payment collection behavior for this subscription while paused. One of
keep_as_draft, mark_uncollectible, or void.
One of: keep_as_draft, mark_uncollectible, or void. */
    behavior?: string | undefined;
    /** The time after which the subscription will resume collecting payments. */
    resumesAt?: Date | undefined;

    constructor(data?: ISubscriptionPauseCollection) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.behavior = _data["behavior"];
            this.resumesAt = _data["resumesAt"] ? new Date(_data["resumesAt"].toString()) : <any>undefined;
        }
    }

    static override fromJS(data: any): SubscriptionPauseCollection {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPauseCollection();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["behavior"] = this.behavior;
        data["resumesAt"] = this.resumesAt ? this.resumesAt.toISOString() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface ISubscriptionPauseCollection extends IStripeEntityOfSubscriptionPauseCollection {
    /** The payment collection behavior for this subscription while paused. One of
keep_as_draft, mark_uncollectible, or void.
One of: keep_as_draft, mark_uncollectible, or void. */
    behavior?: string | undefined;
    /** The time after which the subscription will resume collecting payments. */
    resumesAt?: Date | undefined;
}

export abstract class StripeEntityOfSubscriptionPaymentSettings extends StripeEntity implements IStripeEntityOfSubscriptionPaymentSettings {

    constructor(data?: IStripeEntityOfSubscriptionPaymentSettings) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSubscriptionPaymentSettings {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSubscriptionPaymentSettings' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSubscriptionPaymentSettings extends IStripeEntity {
}

export class SubscriptionPaymentSettings extends StripeEntityOfSubscriptionPaymentSettings implements ISubscriptionPaymentSettings {
    /** Payment-method-specific configuration to provide to invoices created by the
subscription. */
    paymentMethodOptions?: SubscriptionPaymentSettingsPaymentMethodOptions | undefined;
    /** The list of payment method types to provide to every invoice created by the
subscription. If not set, Stripe attempts to automatically determine the types to use by
looking at the invoice’s default payment method, the subscription’s default payment
method, the customer’s default payment method, and your invoice template
settings. */
    paymentMethodTypes?: string[] | undefined;
    /** Either off, or on_subscription. With on_subscription Stripe updates
subscription.default_payment_method when a subscription payment succeeds.
One of: off, or on_subscription. */
    saveDefaultPaymentMethod?: string | undefined;

    constructor(data?: ISubscriptionPaymentSettings) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.paymentMethodOptions = _data["paymentMethodOptions"] ? SubscriptionPaymentSettingsPaymentMethodOptions.fromJS(_data["paymentMethodOptions"]) : <any>undefined;
            if (Array.isArray(_data["paymentMethodTypes"])) {
                this.paymentMethodTypes = [] as any;
                for (let item of _data["paymentMethodTypes"])
                    this.paymentMethodTypes!.push(item);
            }
            this.saveDefaultPaymentMethod = _data["saveDefaultPaymentMethod"];
        }
    }

    static override fromJS(data: any): SubscriptionPaymentSettings {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPaymentSettings();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentMethodOptions"] = this.paymentMethodOptions ? this.paymentMethodOptions.toJSON() : <any>undefined;
        if (Array.isArray(this.paymentMethodTypes)) {
            data["paymentMethodTypes"] = [];
            for (let item of this.paymentMethodTypes)
                data["paymentMethodTypes"].push(item);
        }
        data["saveDefaultPaymentMethod"] = this.saveDefaultPaymentMethod;
        super.toJSON(data);
        return data;
    }
}

export interface ISubscriptionPaymentSettings extends IStripeEntityOfSubscriptionPaymentSettings {
    /** Payment-method-specific configuration to provide to invoices created by the
subscription. */
    paymentMethodOptions?: SubscriptionPaymentSettingsPaymentMethodOptions | undefined;
    /** The list of payment method types to provide to every invoice created by the
subscription. If not set, Stripe attempts to automatically determine the types to use by
looking at the invoice’s default payment method, the subscription’s default payment
method, the customer’s default payment method, and your invoice template
settings. */
    paymentMethodTypes?: string[] | undefined;
    /** Either off, or on_subscription. With on_subscription Stripe updates
subscription.default_payment_method when a subscription payment succeeds.
One of: off, or on_subscription. */
    saveDefaultPaymentMethod?: string | undefined;
}

export abstract class StripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptions extends StripeEntity implements IStripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptions {

    constructor(data?: IStripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptions) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptions {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptions' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptions extends IStripeEntity {
}

export class SubscriptionPaymentSettingsPaymentMethodOptions extends StripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptions implements ISubscriptionPaymentSettingsPaymentMethodOptions {
    /** This sub-hash contains details about the Canadian pre-authorized debit payment method
options to pass to invoices created by the subscription. */
    acssDebit?: SubscriptionPaymentSettingsPaymentMethodOptionsAcssDebit | undefined;
    /** This sub-hash contains details about the Bancontact payment method options to pass to
invoices created by the subscription. */
    bancontact?: SubscriptionPaymentSettingsPaymentMethodOptionsBancontact | undefined;
    /** This sub-hash contains details about the Card payment method options to pass to invoices
created by the subscription. */
    card?: SubscriptionPaymentSettingsPaymentMethodOptionsCard | undefined;
    /** This sub-hash contains details about the Bank transfer payment method options to pass to
invoices created by the subscription. */
    customerBalance?: SubscriptionPaymentSettingsPaymentMethodOptionsCustomerBalance | undefined;
    /** This sub-hash contains details about the Konbini payment method options to pass to
invoices created by the subscription. */
    konbini?: SubscriptionPaymentSettingsPaymentMethodOptionsKonbini | undefined;
    /** This sub-hash contains details about the ACH direct debit payment method options to pass
to invoices created by the subscription. */
    usBankAccount?: SubscriptionPaymentSettingsPaymentMethodOptionsUsBankAccount | undefined;

    constructor(data?: ISubscriptionPaymentSettingsPaymentMethodOptions) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.acssDebit = _data["acssDebit"] ? SubscriptionPaymentSettingsPaymentMethodOptionsAcssDebit.fromJS(_data["acssDebit"]) : <any>undefined;
            this.bancontact = _data["bancontact"] ? SubscriptionPaymentSettingsPaymentMethodOptionsBancontact.fromJS(_data["bancontact"]) : <any>undefined;
            this.card = _data["card"] ? SubscriptionPaymentSettingsPaymentMethodOptionsCard.fromJS(_data["card"]) : <any>undefined;
            this.customerBalance = _data["customerBalance"] ? SubscriptionPaymentSettingsPaymentMethodOptionsCustomerBalance.fromJS(_data["customerBalance"]) : <any>undefined;
            this.konbini = _data["konbini"] ? SubscriptionPaymentSettingsPaymentMethodOptionsKonbini.fromJS(_data["konbini"]) : <any>undefined;
            this.usBankAccount = _data["usBankAccount"] ? SubscriptionPaymentSettingsPaymentMethodOptionsUsBankAccount.fromJS(_data["usBankAccount"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): SubscriptionPaymentSettingsPaymentMethodOptions {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPaymentSettingsPaymentMethodOptions();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["acssDebit"] = this.acssDebit ? this.acssDebit.toJSON() : <any>undefined;
        data["bancontact"] = this.bancontact ? this.bancontact.toJSON() : <any>undefined;
        data["card"] = this.card ? this.card.toJSON() : <any>undefined;
        data["customerBalance"] = this.customerBalance ? this.customerBalance.toJSON() : <any>undefined;
        data["konbini"] = this.konbini ? this.konbini.toJSON() : <any>undefined;
        data["usBankAccount"] = this.usBankAccount ? this.usBankAccount.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface ISubscriptionPaymentSettingsPaymentMethodOptions extends IStripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptions {
    /** This sub-hash contains details about the Canadian pre-authorized debit payment method
options to pass to invoices created by the subscription. */
    acssDebit?: SubscriptionPaymentSettingsPaymentMethodOptionsAcssDebit | undefined;
    /** This sub-hash contains details about the Bancontact payment method options to pass to
invoices created by the subscription. */
    bancontact?: SubscriptionPaymentSettingsPaymentMethodOptionsBancontact | undefined;
    /** This sub-hash contains details about the Card payment method options to pass to invoices
created by the subscription. */
    card?: SubscriptionPaymentSettingsPaymentMethodOptionsCard | undefined;
    /** This sub-hash contains details about the Bank transfer payment method options to pass to
invoices created by the subscription. */
    customerBalance?: SubscriptionPaymentSettingsPaymentMethodOptionsCustomerBalance | undefined;
    /** This sub-hash contains details about the Konbini payment method options to pass to
invoices created by the subscription. */
    konbini?: SubscriptionPaymentSettingsPaymentMethodOptionsKonbini | undefined;
    /** This sub-hash contains details about the ACH direct debit payment method options to pass
to invoices created by the subscription. */
    usBankAccount?: SubscriptionPaymentSettingsPaymentMethodOptionsUsBankAccount | undefined;
}

export abstract class StripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsAcssDebit extends StripeEntity implements IStripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsAcssDebit {

    constructor(data?: IStripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsAcssDebit) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsAcssDebit {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsAcssDebit' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsAcssDebit extends IStripeEntity {
}

export class SubscriptionPaymentSettingsPaymentMethodOptionsAcssDebit extends StripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsAcssDebit implements ISubscriptionPaymentSettingsPaymentMethodOptionsAcssDebit {
    mandateOptions?: SubscriptionPaymentSettingsPaymentMethodOptionsAcssDebitMandateOptions | undefined;
    /** Bank account verification method.
One of: automatic, instant, or microdeposits. */
    verificationMethod?: string | undefined;

    constructor(data?: ISubscriptionPaymentSettingsPaymentMethodOptionsAcssDebit) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.mandateOptions = _data["mandateOptions"] ? SubscriptionPaymentSettingsPaymentMethodOptionsAcssDebitMandateOptions.fromJS(_data["mandateOptions"]) : <any>undefined;
            this.verificationMethod = _data["verificationMethod"];
        }
    }

    static override fromJS(data: any): SubscriptionPaymentSettingsPaymentMethodOptionsAcssDebit {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPaymentSettingsPaymentMethodOptionsAcssDebit();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mandateOptions"] = this.mandateOptions ? this.mandateOptions.toJSON() : <any>undefined;
        data["verificationMethod"] = this.verificationMethod;
        super.toJSON(data);
        return data;
    }
}

export interface ISubscriptionPaymentSettingsPaymentMethodOptionsAcssDebit extends IStripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsAcssDebit {
    mandateOptions?: SubscriptionPaymentSettingsPaymentMethodOptionsAcssDebitMandateOptions | undefined;
    /** Bank account verification method.
One of: automatic, instant, or microdeposits. */
    verificationMethod?: string | undefined;
}

export abstract class StripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsAcssDebitMandateOptions extends StripeEntity implements IStripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsAcssDebitMandateOptions {

    constructor(data?: IStripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsAcssDebitMandateOptions) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsAcssDebitMandateOptions {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsAcssDebitMandateOptions' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsAcssDebitMandateOptions extends IStripeEntity {
}

export class SubscriptionPaymentSettingsPaymentMethodOptionsAcssDebitMandateOptions extends StripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsAcssDebitMandateOptions implements ISubscriptionPaymentSettingsPaymentMethodOptionsAcssDebitMandateOptions {
    /** Transaction type of the mandate.
One of: business, or personal. */
    transactionType?: string | undefined;

    constructor(data?: ISubscriptionPaymentSettingsPaymentMethodOptionsAcssDebitMandateOptions) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.transactionType = _data["transactionType"];
        }
    }

    static override fromJS(data: any): SubscriptionPaymentSettingsPaymentMethodOptionsAcssDebitMandateOptions {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPaymentSettingsPaymentMethodOptionsAcssDebitMandateOptions();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionType"] = this.transactionType;
        super.toJSON(data);
        return data;
    }
}

export interface ISubscriptionPaymentSettingsPaymentMethodOptionsAcssDebitMandateOptions extends IStripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsAcssDebitMandateOptions {
    /** Transaction type of the mandate.
One of: business, or personal. */
    transactionType?: string | undefined;
}

export abstract class StripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsBancontact extends StripeEntity implements IStripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsBancontact {

    constructor(data?: IStripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsBancontact) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsBancontact {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsBancontact' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsBancontact extends IStripeEntity {
}

export class SubscriptionPaymentSettingsPaymentMethodOptionsBancontact extends StripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsBancontact implements ISubscriptionPaymentSettingsPaymentMethodOptionsBancontact {
    /** Preferred language of the Bancontact authorization page that the customer is redirected
to.
One of: de, en, fr, or nl. */
    preferredLanguage?: string | undefined;

    constructor(data?: ISubscriptionPaymentSettingsPaymentMethodOptionsBancontact) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.preferredLanguage = _data["preferredLanguage"];
        }
    }

    static override fromJS(data: any): SubscriptionPaymentSettingsPaymentMethodOptionsBancontact {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPaymentSettingsPaymentMethodOptionsBancontact();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["preferredLanguage"] = this.preferredLanguage;
        super.toJSON(data);
        return data;
    }
}

export interface ISubscriptionPaymentSettingsPaymentMethodOptionsBancontact extends IStripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsBancontact {
    /** Preferred language of the Bancontact authorization page that the customer is redirected
to.
One of: de, en, fr, or nl. */
    preferredLanguage?: string | undefined;
}

export abstract class StripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsCard extends StripeEntity implements IStripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsCard {

    constructor(data?: IStripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsCard) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsCard {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsCard' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsCard extends IStripeEntity {
}

export class SubscriptionPaymentSettingsPaymentMethodOptionsCard extends StripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsCard implements ISubscriptionPaymentSettingsPaymentMethodOptionsCard {
    mandateOptions?: SubscriptionPaymentSettingsPaymentMethodOptionsCardMandateOptions | undefined;
    /** Selected network to process this Subscription on. Depends on the available networks of
the card attached to the Subscription. Can be only set confirm-time.
One of: amex, cartes_bancaires, diners, discover,
eftpos_au, interac, jcb, mastercard, unionpay,
unknown, or visa. */
    network?: string | undefined;
    /** We strongly recommend that you rely on our SCA Engine to automatically prompt your
customers for authentication based on risk level and other requirements.
However, if you wish to request 3D Secure based on logic from your own fraud engine,
provide this option. Read our guide on manually requesting 3D
Secure for more information on how this configuration interacts with Radar and our
SCA Engine.
One of: any, or automatic. */
    requestThreeDSecure?: string | undefined;

    constructor(data?: ISubscriptionPaymentSettingsPaymentMethodOptionsCard) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.mandateOptions = _data["mandateOptions"] ? SubscriptionPaymentSettingsPaymentMethodOptionsCardMandateOptions.fromJS(_data["mandateOptions"]) : <any>undefined;
            this.network = _data["network"];
            this.requestThreeDSecure = _data["requestThreeDSecure"];
        }
    }

    static override fromJS(data: any): SubscriptionPaymentSettingsPaymentMethodOptionsCard {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPaymentSettingsPaymentMethodOptionsCard();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mandateOptions"] = this.mandateOptions ? this.mandateOptions.toJSON() : <any>undefined;
        data["network"] = this.network;
        data["requestThreeDSecure"] = this.requestThreeDSecure;
        super.toJSON(data);
        return data;
    }
}

export interface ISubscriptionPaymentSettingsPaymentMethodOptionsCard extends IStripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsCard {
    mandateOptions?: SubscriptionPaymentSettingsPaymentMethodOptionsCardMandateOptions | undefined;
    /** Selected network to process this Subscription on. Depends on the available networks of
the card attached to the Subscription. Can be only set confirm-time.
One of: amex, cartes_bancaires, diners, discover,
eftpos_au, interac, jcb, mastercard, unionpay,
unknown, or visa. */
    network?: string | undefined;
    /** We strongly recommend that you rely on our SCA Engine to automatically prompt your
customers for authentication based on risk level and other requirements.
However, if you wish to request 3D Secure based on logic from your own fraud engine,
provide this option. Read our guide on manually requesting 3D
Secure for more information on how this configuration interacts with Radar and our
SCA Engine.
One of: any, or automatic. */
    requestThreeDSecure?: string | undefined;
}

export abstract class StripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsCardMandateOptions extends StripeEntity implements IStripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsCardMandateOptions {

    constructor(data?: IStripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsCardMandateOptions) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsCardMandateOptions {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsCardMandateOptions' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsCardMandateOptions extends IStripeEntity {
}

export class SubscriptionPaymentSettingsPaymentMethodOptionsCardMandateOptions extends StripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsCardMandateOptions implements ISubscriptionPaymentSettingsPaymentMethodOptionsCardMandateOptions {
    /** Amount to be charged for future payments. */
    amount?: number | undefined;
    /** One of fixed or maximum. If fixed, the amount param refers
to the exact amount to be charged in future payments. If maximum, the amount
charged can be up to the value passed for the amount param.
One of: fixed, or maximum. */
    amountType?: string | undefined;
    /** A description of the mandate or subscription that is meant to be displayed to the
customer. */
    description?: string | undefined;

    constructor(data?: ISubscriptionPaymentSettingsPaymentMethodOptionsCardMandateOptions) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.amount = _data["amount"];
            this.amountType = _data["amountType"];
            this.description = _data["description"];
        }
    }

    static override fromJS(data: any): SubscriptionPaymentSettingsPaymentMethodOptionsCardMandateOptions {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPaymentSettingsPaymentMethodOptionsCardMandateOptions();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["amountType"] = this.amountType;
        data["description"] = this.description;
        super.toJSON(data);
        return data;
    }
}

export interface ISubscriptionPaymentSettingsPaymentMethodOptionsCardMandateOptions extends IStripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsCardMandateOptions {
    /** Amount to be charged for future payments. */
    amount?: number | undefined;
    /** One of fixed or maximum. If fixed, the amount param refers
to the exact amount to be charged in future payments. If maximum, the amount
charged can be up to the value passed for the amount param.
One of: fixed, or maximum. */
    amountType?: string | undefined;
    /** A description of the mandate or subscription that is meant to be displayed to the
customer. */
    description?: string | undefined;
}

export abstract class StripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsCustomerBalance extends StripeEntity implements IStripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsCustomerBalance {

    constructor(data?: IStripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsCustomerBalance) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsCustomerBalance {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsCustomerBalance' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsCustomerBalance extends IStripeEntity {
}

export class SubscriptionPaymentSettingsPaymentMethodOptionsCustomerBalance extends StripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsCustomerBalance implements ISubscriptionPaymentSettingsPaymentMethodOptionsCustomerBalance {
    bankTransfer?: SubscriptionPaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransfer | undefined;
    /** The funding method type to be used when there are not enough funds in the customer
balance. Permitted values include: bank_transfer. */
    fundingType?: string | undefined;

    constructor(data?: ISubscriptionPaymentSettingsPaymentMethodOptionsCustomerBalance) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.bankTransfer = _data["bankTransfer"] ? SubscriptionPaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransfer.fromJS(_data["bankTransfer"]) : <any>undefined;
            this.fundingType = _data["fundingType"];
        }
    }

    static override fromJS(data: any): SubscriptionPaymentSettingsPaymentMethodOptionsCustomerBalance {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPaymentSettingsPaymentMethodOptionsCustomerBalance();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankTransfer"] = this.bankTransfer ? this.bankTransfer.toJSON() : <any>undefined;
        data["fundingType"] = this.fundingType;
        super.toJSON(data);
        return data;
    }
}

export interface ISubscriptionPaymentSettingsPaymentMethodOptionsCustomerBalance extends IStripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsCustomerBalance {
    bankTransfer?: SubscriptionPaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransfer | undefined;
    /** The funding method type to be used when there are not enough funds in the customer
balance. Permitted values include: bank_transfer. */
    fundingType?: string | undefined;
}

export abstract class StripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransfer extends StripeEntity implements IStripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransfer {

    constructor(data?: IStripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransfer) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransfer {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransfer' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransfer extends IStripeEntity {
}

export class SubscriptionPaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransfer extends StripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransfer implements ISubscriptionPaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransfer {
    euBankTransfer?: SubscriptionPaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransferEuBankTransfer | undefined;
    /** The bank transfer type that can be used for funding. Permitted values include:
eu_bank_transfer, gb_bank_transfer, jp_bank_transfer, or
mx_bank_transfer. */
    type?: string | undefined;

    constructor(data?: ISubscriptionPaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransfer) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.euBankTransfer = _data["euBankTransfer"] ? SubscriptionPaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransferEuBankTransfer.fromJS(_data["euBankTransfer"]) : <any>undefined;
            this.type = _data["type"];
        }
    }

    static override fromJS(data: any): SubscriptionPaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransfer {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransfer();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["euBankTransfer"] = this.euBankTransfer ? this.euBankTransfer.toJSON() : <any>undefined;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

export interface ISubscriptionPaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransfer extends IStripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransfer {
    euBankTransfer?: SubscriptionPaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransferEuBankTransfer | undefined;
    /** The bank transfer type that can be used for funding. Permitted values include:
eu_bank_transfer, gb_bank_transfer, jp_bank_transfer, or
mx_bank_transfer. */
    type?: string | undefined;
}

export abstract class StripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransferEuBankTransfer extends StripeEntity implements IStripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransferEuBankTransfer {

    constructor(data?: IStripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransferEuBankTransfer) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransferEuBankTransfer {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransferEuBankTransfer' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransferEuBankTransfer extends IStripeEntity {
}

export class SubscriptionPaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransferEuBankTransfer extends StripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransferEuBankTransfer implements ISubscriptionPaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransferEuBankTransfer {
    /** The desired country code of the bank account information. Permitted values include:
BE, DE, ES, FR, IE, or NL.
One of: BE, DE, ES, FR, IE, or NL. */
    country?: string | undefined;

    constructor(data?: ISubscriptionPaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransferEuBankTransfer) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.country = _data["country"];
        }
    }

    static override fromJS(data: any): SubscriptionPaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransferEuBankTransfer {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransferEuBankTransfer();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["country"] = this.country;
        super.toJSON(data);
        return data;
    }
}

export interface ISubscriptionPaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransferEuBankTransfer extends IStripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsCustomerBalanceBankTransferEuBankTransfer {
    /** The desired country code of the bank account information. Permitted values include:
BE, DE, ES, FR, IE, or NL.
One of: BE, DE, ES, FR, IE, or NL. */
    country?: string | undefined;
}

export abstract class StripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsKonbini extends StripeEntity implements IStripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsKonbini {

    constructor(data?: IStripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsKonbini) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsKonbini {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsKonbini' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsKonbini extends IStripeEntity {
}

export class SubscriptionPaymentSettingsPaymentMethodOptionsKonbini extends StripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsKonbini implements ISubscriptionPaymentSettingsPaymentMethodOptionsKonbini {

    constructor(data?: ISubscriptionPaymentSettingsPaymentMethodOptionsKonbini) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): SubscriptionPaymentSettingsPaymentMethodOptionsKonbini {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPaymentSettingsPaymentMethodOptionsKonbini();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ISubscriptionPaymentSettingsPaymentMethodOptionsKonbini extends IStripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsKonbini {
}

export abstract class StripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsUsBankAccount extends StripeEntity implements IStripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsUsBankAccount {

    constructor(data?: IStripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsUsBankAccount) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsUsBankAccount {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsUsBankAccount' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsUsBankAccount extends IStripeEntity {
}

export class SubscriptionPaymentSettingsPaymentMethodOptionsUsBankAccount extends StripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsUsBankAccount implements ISubscriptionPaymentSettingsPaymentMethodOptionsUsBankAccount {
    financialConnections?: SubscriptionPaymentSettingsPaymentMethodOptionsUsBankAccountFinancialConnections | undefined;
    /** Bank account verification method.
One of: automatic, instant, or microdeposits. */
    verificationMethod?: string | undefined;

    constructor(data?: ISubscriptionPaymentSettingsPaymentMethodOptionsUsBankAccount) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.financialConnections = _data["financialConnections"] ? SubscriptionPaymentSettingsPaymentMethodOptionsUsBankAccountFinancialConnections.fromJS(_data["financialConnections"]) : <any>undefined;
            this.verificationMethod = _data["verificationMethod"];
        }
    }

    static override fromJS(data: any): SubscriptionPaymentSettingsPaymentMethodOptionsUsBankAccount {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPaymentSettingsPaymentMethodOptionsUsBankAccount();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["financialConnections"] = this.financialConnections ? this.financialConnections.toJSON() : <any>undefined;
        data["verificationMethod"] = this.verificationMethod;
        super.toJSON(data);
        return data;
    }
}

export interface ISubscriptionPaymentSettingsPaymentMethodOptionsUsBankAccount extends IStripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsUsBankAccount {
    financialConnections?: SubscriptionPaymentSettingsPaymentMethodOptionsUsBankAccountFinancialConnections | undefined;
    /** Bank account verification method.
One of: automatic, instant, or microdeposits. */
    verificationMethod?: string | undefined;
}

export abstract class StripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsUsBankAccountFinancialConnections extends StripeEntity implements IStripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsUsBankAccountFinancialConnections {

    constructor(data?: IStripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsUsBankAccountFinancialConnections) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsUsBankAccountFinancialConnections {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsUsBankAccountFinancialConnections' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsUsBankAccountFinancialConnections extends IStripeEntity {
}

export class SubscriptionPaymentSettingsPaymentMethodOptionsUsBankAccountFinancialConnections extends StripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsUsBankAccountFinancialConnections implements ISubscriptionPaymentSettingsPaymentMethodOptionsUsBankAccountFinancialConnections {
    /** The list of permissions to request. The payment_method permission must be
included. */
    permissions?: string[] | undefined;

    constructor(data?: ISubscriptionPaymentSettingsPaymentMethodOptionsUsBankAccountFinancialConnections) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(item);
            }
        }
    }

    static override fromJS(data: any): SubscriptionPaymentSettingsPaymentMethodOptionsUsBankAccountFinancialConnections {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPaymentSettingsPaymentMethodOptionsUsBankAccountFinancialConnections();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface ISubscriptionPaymentSettingsPaymentMethodOptionsUsBankAccountFinancialConnections extends IStripeEntityOfSubscriptionPaymentSettingsPaymentMethodOptionsUsBankAccountFinancialConnections {
    /** The list of permissions to request. The payment_method permission must be
included. */
    permissions?: string[] | undefined;
}

export abstract class StripeEntityOfSubscriptionPendingInvoiceItemInterval extends StripeEntity implements IStripeEntityOfSubscriptionPendingInvoiceItemInterval {

    constructor(data?: IStripeEntityOfSubscriptionPendingInvoiceItemInterval) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSubscriptionPendingInvoiceItemInterval {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSubscriptionPendingInvoiceItemInterval' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSubscriptionPendingInvoiceItemInterval extends IStripeEntity {
}

export class SubscriptionPendingInvoiceItemInterval extends StripeEntityOfSubscriptionPendingInvoiceItemInterval implements ISubscriptionPendingInvoiceItemInterval {
    /** Specifies invoicing frequency. Either day, week, month or
year.
One of: day, month, week, or year. */
    interval?: string | undefined;
    /** The number of intervals between invoices. For example, interval=month and
interval_count=3 bills every 3 months. Maximum of one year interval allowed (1
year, 12 months, or 52 weeks). */
    intervalCount?: number;

    constructor(data?: ISubscriptionPendingInvoiceItemInterval) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.interval = _data["interval"];
            this.intervalCount = _data["intervalCount"];
        }
    }

    static override fromJS(data: any): SubscriptionPendingInvoiceItemInterval {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPendingInvoiceItemInterval();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["interval"] = this.interval;
        data["intervalCount"] = this.intervalCount;
        super.toJSON(data);
        return data;
    }
}

export interface ISubscriptionPendingInvoiceItemInterval extends IStripeEntityOfSubscriptionPendingInvoiceItemInterval {
    /** Specifies invoicing frequency. Either day, week, month or
year.
One of: day, month, week, or year. */
    interval?: string | undefined;
    /** The number of intervals between invoices. For example, interval=month and
interval_count=3 bills every 3 months. Maximum of one year interval allowed (1
year, 12 months, or 52 weeks). */
    intervalCount?: number;
}

export abstract class StripeEntityOfSubscriptionPendingUpdate extends StripeEntity implements IStripeEntityOfSubscriptionPendingUpdate {

    constructor(data?: IStripeEntityOfSubscriptionPendingUpdate) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSubscriptionPendingUpdate {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSubscriptionPendingUpdate' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSubscriptionPendingUpdate extends IStripeEntity {
}

export class SubscriptionPendingUpdate extends StripeEntityOfSubscriptionPendingUpdate implements ISubscriptionPendingUpdate {
    /** If the update is applied, determines the date of the first full invoice, and, for plans
with month or year intervals, the day of the month for subsequent
invoices. The timestamp is in UTC format. */
    billingCycleAnchor?: Date | undefined;
    /** The point after which the changes reflected by this update will be discarded and no
longer applied. */
    expiresAt?: Date;
    /** List of subscription items, each with an attached plan, that will be set if the update
is applied. */
    subscriptionItems?: SubscriptionItem[] | undefined;
    /** Unix timestamp representing the end of the trial period the customer will get before
being charged for the first time, if the update is applied. */
    trialEnd?: Date | undefined;
    /** Indicates if a plan's trial_period_days should be applied to the subscription.
Setting trial_end per subscription is preferred, and this defaults to
false. Setting this flag to true together with trial_end is not
allowed. See Using trial
periods on subscriptions to learn more. */
    trialFromPlan?: boolean | undefined;

    constructor(data?: ISubscriptionPendingUpdate) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.billingCycleAnchor = _data["billingCycleAnchor"] ? new Date(_data["billingCycleAnchor"].toString()) : <any>undefined;
            this.expiresAt = _data["expiresAt"] ? new Date(_data["expiresAt"].toString()) : <any>undefined;
            if (Array.isArray(_data["subscriptionItems"])) {
                this.subscriptionItems = [] as any;
                for (let item of _data["subscriptionItems"])
                    this.subscriptionItems!.push(SubscriptionItem.fromJS(item));
            }
            this.trialEnd = _data["trialEnd"] ? new Date(_data["trialEnd"].toString()) : <any>undefined;
            this.trialFromPlan = _data["trialFromPlan"];
        }
    }

    static override fromJS(data: any): SubscriptionPendingUpdate {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPendingUpdate();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["billingCycleAnchor"] = this.billingCycleAnchor ? this.billingCycleAnchor.toISOString() : <any>undefined;
        data["expiresAt"] = this.expiresAt ? this.expiresAt.toISOString() : <any>undefined;
        if (Array.isArray(this.subscriptionItems)) {
            data["subscriptionItems"] = [];
            for (let item of this.subscriptionItems)
                data["subscriptionItems"].push(item.toJSON());
        }
        data["trialEnd"] = this.trialEnd ? this.trialEnd.toISOString() : <any>undefined;
        data["trialFromPlan"] = this.trialFromPlan;
        super.toJSON(data);
        return data;
    }
}

export interface ISubscriptionPendingUpdate extends IStripeEntityOfSubscriptionPendingUpdate {
    /** If the update is applied, determines the date of the first full invoice, and, for plans
with month or year intervals, the day of the month for subsequent
invoices. The timestamp is in UTC format. */
    billingCycleAnchor?: Date | undefined;
    /** The point after which the changes reflected by this update will be discarded and no
longer applied. */
    expiresAt?: Date;
    /** List of subscription items, each with an attached plan, that will be set if the update
is applied. */
    subscriptionItems?: SubscriptionItem[] | undefined;
    /** Unix timestamp representing the end of the trial period the customer will get before
being charged for the first time, if the update is applied. */
    trialEnd?: Date | undefined;
    /** Indicates if a plan's trial_period_days should be applied to the subscription.
Setting trial_end per subscription is preferred, and this defaults to
false. Setting this flag to true together with trial_end is not
allowed. See Using trial
periods on subscriptions to learn more. */
    trialFromPlan?: boolean | undefined;
}

export abstract class StripeEntityOfSubscriptionTransferData extends StripeEntity implements IStripeEntityOfSubscriptionTransferData {

    constructor(data?: IStripeEntityOfSubscriptionTransferData) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSubscriptionTransferData {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSubscriptionTransferData' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSubscriptionTransferData extends IStripeEntity {
}

export class SubscriptionTransferData extends StripeEntityOfSubscriptionTransferData implements ISubscriptionTransferData {
    /** A non-negative decimal between 0 and 100, with at most two decimal places. This
represents the percentage of the subscription invoice subtotal that will be transferred
to the destination account. By default, the entire amount is transferred to the
destination. */
    amountPercent?: number | undefined;
    /** (ID of the Account)
The account where funds from the payment will be transferred to upon payment success. */
    destinationId?: string | undefined;
    /** (Expanded)
The account where funds from the payment will be transferred to upon payment success.
            
For more information, see the expand documentation. */
    destination?: Account | undefined;
    internalDestination?: ExpandableFieldOfAccount | undefined;

    constructor(data?: ISubscriptionTransferData) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.amountPercent = _data["amountPercent"];
            this.destinationId = _data["destinationId"];
            this.destination = _data["destination"] ? Account.fromJS(_data["destination"]) : <any>undefined;
            this.internalDestination = _data["internalDestination"] ? ExpandableFieldOfAccount.fromJS(_data["internalDestination"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): SubscriptionTransferData {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionTransferData();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amountPercent"] = this.amountPercent;
        data["destinationId"] = this.destinationId;
        data["destination"] = this.destination ? this.destination.toJSON() : <any>undefined;
        data["internalDestination"] = this.internalDestination ? this.internalDestination.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface ISubscriptionTransferData extends IStripeEntityOfSubscriptionTransferData {
    /** A non-negative decimal between 0 and 100, with at most two decimal places. This
represents the percentage of the subscription invoice subtotal that will be transferred
to the destination account. By default, the entire amount is transferred to the
destination. */
    amountPercent?: number | undefined;
    /** (ID of the Account)
The account where funds from the payment will be transferred to upon payment success. */
    destinationId?: string | undefined;
    /** (Expanded)
The account where funds from the payment will be transferred to upon payment success.
            
For more information, see the expand documentation. */
    destination?: Account | undefined;
    internalDestination?: ExpandableFieldOfAccount | undefined;
}

export abstract class StripeEntityOfSubscriptionTrialSettings extends StripeEntity implements IStripeEntityOfSubscriptionTrialSettings {

    constructor(data?: IStripeEntityOfSubscriptionTrialSettings) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSubscriptionTrialSettings {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSubscriptionTrialSettings' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSubscriptionTrialSettings extends IStripeEntity {
}

export class SubscriptionTrialSettings extends StripeEntityOfSubscriptionTrialSettings implements ISubscriptionTrialSettings {
    /** Defines how a subscription behaves when a free trial ends. */
    endBehavior?: SubscriptionTrialSettingsEndBehavior | undefined;

    constructor(data?: ISubscriptionTrialSettings) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.endBehavior = _data["endBehavior"] ? SubscriptionTrialSettingsEndBehavior.fromJS(_data["endBehavior"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): SubscriptionTrialSettings {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionTrialSettings();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["endBehavior"] = this.endBehavior ? this.endBehavior.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface ISubscriptionTrialSettings extends IStripeEntityOfSubscriptionTrialSettings {
    /** Defines how a subscription behaves when a free trial ends. */
    endBehavior?: SubscriptionTrialSettingsEndBehavior | undefined;
}

export abstract class StripeEntityOfSubscriptionTrialSettingsEndBehavior extends StripeEntity implements IStripeEntityOfSubscriptionTrialSettingsEndBehavior {

    constructor(data?: IStripeEntityOfSubscriptionTrialSettingsEndBehavior) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfSubscriptionTrialSettingsEndBehavior {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfSubscriptionTrialSettingsEndBehavior' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfSubscriptionTrialSettingsEndBehavior extends IStripeEntity {
}

export class SubscriptionTrialSettingsEndBehavior extends StripeEntityOfSubscriptionTrialSettingsEndBehavior implements ISubscriptionTrialSettingsEndBehavior {
    /** Indicates how the subscription should change when the trial ends if the user did not
provide a payment method.
One of: cancel, create_invoice, or pause. */
    missingPaymentMethod?: string | undefined;

    constructor(data?: ISubscriptionTrialSettingsEndBehavior) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.missingPaymentMethod = _data["missingPaymentMethod"];
        }
    }

    static override fromJS(data: any): SubscriptionTrialSettingsEndBehavior {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionTrialSettingsEndBehavior();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["missingPaymentMethod"] = this.missingPaymentMethod;
        super.toJSON(data);
        return data;
    }
}

export interface ISubscriptionTrialSettingsEndBehavior extends IStripeEntityOfSubscriptionTrialSettingsEndBehavior {
    /** Indicates how the subscription should change when the trial ends if the user did not
provide a payment method.
One of: cancel, create_invoice, or pause. */
    missingPaymentMethod?: string | undefined;
}

export abstract class StripeEntityOfCustomerInvoiceSettings extends StripeEntity implements IStripeEntityOfCustomerInvoiceSettings {

    constructor(data?: IStripeEntityOfCustomerInvoiceSettings) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfCustomerInvoiceSettings {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfCustomerInvoiceSettings' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfCustomerInvoiceSettings extends IStripeEntity {
}

export class CustomerInvoiceSettings extends StripeEntityOfCustomerInvoiceSettings implements ICustomerInvoiceSettings {
    /** Default custom fields to be displayed on invoices for this customer. */
    customFields?: CustomerInvoiceSettingsCustomField[] | undefined;
    /** (ID of the PaymentMethod)
ID of a payment method that's attached to the customer, to be used as the customer's
default payment method for subscriptions and invoices. */
    defaultPaymentMethodId?: string | undefined;
    /** (Expanded)
ID of a payment method that's attached to the customer, to be used as the customer's
default payment method for subscriptions and invoices.
            
For more information, see the expand documentation. */
    defaultPaymentMethod?: PaymentMethod | undefined;
    internalDefaultPaymentMethod?: ExpandableFieldOfPaymentMethod | undefined;
    /** Default footer to be displayed on invoices for this customer. */
    footer?: string | undefined;
    /** Default options for invoice PDF rendering for this customer. */
    renderingOptions?: CustomerInvoiceSettingsRenderingOptions | undefined;

    constructor(data?: ICustomerInvoiceSettings) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["customFields"])) {
                this.customFields = [] as any;
                for (let item of _data["customFields"])
                    this.customFields!.push(CustomerInvoiceSettingsCustomField.fromJS(item));
            }
            this.defaultPaymentMethodId = _data["defaultPaymentMethodId"];
            this.defaultPaymentMethod = _data["defaultPaymentMethod"] ? PaymentMethod.fromJS(_data["defaultPaymentMethod"]) : <any>undefined;
            this.internalDefaultPaymentMethod = _data["internalDefaultPaymentMethod"] ? ExpandableFieldOfPaymentMethod.fromJS(_data["internalDefaultPaymentMethod"]) : <any>undefined;
            this.footer = _data["footer"];
            this.renderingOptions = _data["renderingOptions"] ? CustomerInvoiceSettingsRenderingOptions.fromJS(_data["renderingOptions"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): CustomerInvoiceSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerInvoiceSettings();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.customFields)) {
            data["customFields"] = [];
            for (let item of this.customFields)
                data["customFields"].push(item.toJSON());
        }
        data["defaultPaymentMethodId"] = this.defaultPaymentMethodId;
        data["defaultPaymentMethod"] = this.defaultPaymentMethod ? this.defaultPaymentMethod.toJSON() : <any>undefined;
        data["internalDefaultPaymentMethod"] = this.internalDefaultPaymentMethod ? this.internalDefaultPaymentMethod.toJSON() : <any>undefined;
        data["footer"] = this.footer;
        data["renderingOptions"] = this.renderingOptions ? this.renderingOptions.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface ICustomerInvoiceSettings extends IStripeEntityOfCustomerInvoiceSettings {
    /** Default custom fields to be displayed on invoices for this customer. */
    customFields?: CustomerInvoiceSettingsCustomField[] | undefined;
    /** (ID of the PaymentMethod)
ID of a payment method that's attached to the customer, to be used as the customer's
default payment method for subscriptions and invoices. */
    defaultPaymentMethodId?: string | undefined;
    /** (Expanded)
ID of a payment method that's attached to the customer, to be used as the customer's
default payment method for subscriptions and invoices.
            
For more information, see the expand documentation. */
    defaultPaymentMethod?: PaymentMethod | undefined;
    internalDefaultPaymentMethod?: ExpandableFieldOfPaymentMethod | undefined;
    /** Default footer to be displayed on invoices for this customer. */
    footer?: string | undefined;
    /** Default options for invoice PDF rendering for this customer. */
    renderingOptions?: CustomerInvoiceSettingsRenderingOptions | undefined;
}

export abstract class StripeEntityOfCustomerInvoiceSettingsCustomField extends StripeEntity implements IStripeEntityOfCustomerInvoiceSettingsCustomField {

    constructor(data?: IStripeEntityOfCustomerInvoiceSettingsCustomField) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfCustomerInvoiceSettingsCustomField {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfCustomerInvoiceSettingsCustomField' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfCustomerInvoiceSettingsCustomField extends IStripeEntity {
}

export class CustomerInvoiceSettingsCustomField extends StripeEntityOfCustomerInvoiceSettingsCustomField implements ICustomerInvoiceSettingsCustomField {
    /** The name of the custom field. */
    name?: string | undefined;
    /** The value of the custom field. */
    value?: string | undefined;

    constructor(data?: ICustomerInvoiceSettingsCustomField) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static override fromJS(data: any): CustomerInvoiceSettingsCustomField {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerInvoiceSettingsCustomField();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        super.toJSON(data);
        return data;
    }
}

export interface ICustomerInvoiceSettingsCustomField extends IStripeEntityOfCustomerInvoiceSettingsCustomField {
    /** The name of the custom field. */
    name?: string | undefined;
    /** The value of the custom field. */
    value?: string | undefined;
}

export abstract class StripeEntityOfCustomerInvoiceSettingsRenderingOptions extends StripeEntity implements IStripeEntityOfCustomerInvoiceSettingsRenderingOptions {

    constructor(data?: IStripeEntityOfCustomerInvoiceSettingsRenderingOptions) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfCustomerInvoiceSettingsRenderingOptions {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfCustomerInvoiceSettingsRenderingOptions' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfCustomerInvoiceSettingsRenderingOptions extends IStripeEntity {
}

export class CustomerInvoiceSettingsRenderingOptions extends StripeEntityOfCustomerInvoiceSettingsRenderingOptions implements ICustomerInvoiceSettingsRenderingOptions {
    /** How line-item prices and amounts will be displayed with respect to tax on invoice PDFs. */
    amountTaxDisplay?: string | undefined;

    constructor(data?: ICustomerInvoiceSettingsRenderingOptions) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.amountTaxDisplay = _data["amountTaxDisplay"];
        }
    }

    static override fromJS(data: any): CustomerInvoiceSettingsRenderingOptions {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerInvoiceSettingsRenderingOptions();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amountTaxDisplay"] = this.amountTaxDisplay;
        super.toJSON(data);
        return data;
    }
}

export interface ICustomerInvoiceSettingsRenderingOptions extends IStripeEntityOfCustomerInvoiceSettingsRenderingOptions {
    /** How line-item prices and amounts will be displayed with respect to tax on invoice PDFs. */
    amountTaxDisplay?: string | undefined;
}

export abstract class StripeEntityOfStripeListOfIPaymentSource extends StripeEntity implements IStripeEntityOfStripeListOfIPaymentSource {

    constructor(data?: IStripeEntityOfStripeListOfIPaymentSource) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfStripeListOfIPaymentSource {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfStripeListOfIPaymentSource' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfStripeListOfIPaymentSource extends IStripeEntity {
}

export class StripeListOfIPaymentSource extends StripeEntityOfStripeListOfIPaymentSource implements IStripeListOfIPaymentSource {
    /** A string describing the object type returned. */
    object?: string | undefined;
    /** A list containing the actual response elements, paginated by any request parameters. */
    data?: IPaymentSource[] | undefined;
    /** Whether or not there are more elements available after this set. If false,
this set comprises the end of the list. */
    hasMore?: boolean;
    /** The URL for accessing this list. */
    url?: string | undefined;

    constructor(data?: IStripeListOfIPaymentSource) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.object = _data["object"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(IPaymentSource.fromJS(item));
            }
            this.hasMore = _data["hasMore"];
            this.url = _data["url"];
        }
    }

    static override fromJS(data: any): StripeListOfIPaymentSource {
        data = typeof data === 'object' ? data : {};
        let result = new StripeListOfIPaymentSource();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["object"] = this.object;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["hasMore"] = this.hasMore;
        data["url"] = this.url;
        super.toJSON(data);
        return data;
    }
}

export interface IStripeListOfIPaymentSource extends IStripeEntityOfStripeListOfIPaymentSource {
    /** A string describing the object type returned. */
    object?: string | undefined;
    /** A list containing the actual response elements, paginated by any request parameters. */
    data?: IPaymentSource[] | undefined;
    /** Whether or not there are more elements available after this set. If false,
this set comprises the end of the list. */
    hasMore?: boolean;
    /** The URL for accessing this list. */
    url?: string | undefined;
}

export abstract class StripeEntityOfStripeListOfSubscription extends StripeEntity implements IStripeEntityOfStripeListOfSubscription {

    constructor(data?: IStripeEntityOfStripeListOfSubscription) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfStripeListOfSubscription {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfStripeListOfSubscription' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfStripeListOfSubscription extends IStripeEntity {
}

export class StripeListOfSubscription extends StripeEntityOfStripeListOfSubscription implements IStripeListOfSubscription {
    /** A string describing the object type returned. */
    object?: string | undefined;
    /** A list containing the actual response elements, paginated by any request parameters. */
    data?: Subscription[] | undefined;
    /** Whether or not there are more elements available after this set. If false,
this set comprises the end of the list. */
    hasMore?: boolean;
    /** The URL for accessing this list. */
    url?: string | undefined;

    constructor(data?: IStripeListOfSubscription) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.object = _data["object"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(Subscription.fromJS(item));
            }
            this.hasMore = _data["hasMore"];
            this.url = _data["url"];
        }
    }

    static override fromJS(data: any): StripeListOfSubscription {
        data = typeof data === 'object' ? data : {};
        let result = new StripeListOfSubscription();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["object"] = this.object;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["hasMore"] = this.hasMore;
        data["url"] = this.url;
        super.toJSON(data);
        return data;
    }
}

export interface IStripeListOfSubscription extends IStripeEntityOfStripeListOfSubscription {
    /** A string describing the object type returned. */
    object?: string | undefined;
    /** A list containing the actual response elements, paginated by any request parameters. */
    data?: Subscription[] | undefined;
    /** Whether or not there are more elements available after this set. If false,
this set comprises the end of the list. */
    hasMore?: boolean;
    /** The URL for accessing this list. */
    url?: string | undefined;
}

export abstract class StripeEntityOfCustomerTax extends StripeEntity implements IStripeEntityOfCustomerTax {

    constructor(data?: IStripeEntityOfCustomerTax) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfCustomerTax {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfCustomerTax' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfCustomerTax extends IStripeEntity {
}

export class CustomerTax extends StripeEntityOfCustomerTax implements ICustomerTax {
    /** Surfaces if automatic tax computation is possible given the current customer location
information.
One of: failed, not_collecting, supported, or
unrecognized_location. */
    automaticTax?: string | undefined;
    /** A recent IP address of the customer used for tax reporting and tax location inference. */
    ipAddress?: string | undefined;
    /** The customer's location as identified by Stripe Tax. */
    location?: CustomerTaxLocation | undefined;

    constructor(data?: ICustomerTax) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.automaticTax = _data["automaticTax"];
            this.ipAddress = _data["ipAddress"];
            this.location = _data["location"] ? CustomerTaxLocation.fromJS(_data["location"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): CustomerTax {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerTax();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["automaticTax"] = this.automaticTax;
        data["ipAddress"] = this.ipAddress;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface ICustomerTax extends IStripeEntityOfCustomerTax {
    /** Surfaces if automatic tax computation is possible given the current customer location
information.
One of: failed, not_collecting, supported, or
unrecognized_location. */
    automaticTax?: string | undefined;
    /** A recent IP address of the customer used for tax reporting and tax location inference. */
    ipAddress?: string | undefined;
    /** The customer's location as identified by Stripe Tax. */
    location?: CustomerTaxLocation | undefined;
}

export abstract class StripeEntityOfCustomerTaxLocation extends StripeEntity implements IStripeEntityOfCustomerTaxLocation {

    constructor(data?: IStripeEntityOfCustomerTaxLocation) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfCustomerTaxLocation {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfCustomerTaxLocation' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfCustomerTaxLocation extends IStripeEntity {
}

export class CustomerTaxLocation extends StripeEntityOfCustomerTaxLocation implements ICustomerTaxLocation {
    /** The customer's country as identified by Stripe Tax. */
    country?: string | undefined;
    /** The data source used to infer the customer's location.
One of: billing_address, ip_address, payment_method, or
shipping_destination. */
    source?: string | undefined;
    /** The customer's state, county, province, or region as identified by Stripe Tax. */
    state?: string | undefined;

    constructor(data?: ICustomerTaxLocation) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.country = _data["country"];
            this.source = _data["source"];
            this.state = _data["state"];
        }
    }

    static override fromJS(data: any): CustomerTaxLocation {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerTaxLocation();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["country"] = this.country;
        data["source"] = this.source;
        data["state"] = this.state;
        super.toJSON(data);
        return data;
    }
}

export interface ICustomerTaxLocation extends IStripeEntityOfCustomerTaxLocation {
    /** The customer's country as identified by Stripe Tax. */
    country?: string | undefined;
    /** The data source used to infer the customer's location.
One of: billing_address, ip_address, payment_method, or
shipping_destination. */
    source?: string | undefined;
    /** The customer's state, county, province, or region as identified by Stripe Tax. */
    state?: string | undefined;
}

export abstract class StripeEntityOfStripeListOfTaxId extends StripeEntity implements IStripeEntityOfStripeListOfTaxId {

    constructor(data?: IStripeEntityOfStripeListOfTaxId) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StripeEntityOfStripeListOfTaxId {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'StripeEntityOfStripeListOfTaxId' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStripeEntityOfStripeListOfTaxId extends IStripeEntity {
}

export class StripeListOfTaxId extends StripeEntityOfStripeListOfTaxId implements IStripeListOfTaxId {
    /** A string describing the object type returned. */
    object?: string | undefined;
    /** A list containing the actual response elements, paginated by any request parameters. */
    data?: TaxId[] | undefined;
    /** Whether or not there are more elements available after this set. If false,
this set comprises the end of the list. */
    hasMore?: boolean;
    /** The URL for accessing this list. */
    url?: string | undefined;

    constructor(data?: IStripeListOfTaxId) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.object = _data["object"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(TaxId.fromJS(item));
            }
            this.hasMore = _data["hasMore"];
            this.url = _data["url"];
        }
    }

    static override fromJS(data: any): StripeListOfTaxId {
        data = typeof data === 'object' ? data : {};
        let result = new StripeListOfTaxId();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["object"] = this.object;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["hasMore"] = this.hasMore;
        data["url"] = this.url;
        super.toJSON(data);
        return data;
    }
}

export interface IStripeListOfTaxId extends IStripeEntityOfStripeListOfTaxId {
    /** A string describing the object type returned. */
    object?: string | undefined;
    /** A list containing the actual response elements, paginated by any request parameters. */
    data?: TaxId[] | undefined;
    /** Whether or not there are more elements available after this set. If false,
this set comprises the end of the list. */
    hasMore?: boolean;
    /** The URL for accessing this list. */
    url?: string | undefined;
}

export class CreateStripeCustomerCommand implements ICreateStripeCustomerCommand {
    customerId?: string;

    constructor(data?: ICreateStripeCustomerCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customerId = _data["customerId"];
        }
    }

    static fromJS(data: any): CreateStripeCustomerCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateStripeCustomerCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerId"] = this.customerId;
        return data;
    }
}

export interface ICreateStripeCustomerCommand {
    customerId?: string;
}

export class CreatePaymentIntentCommand implements ICreatePaymentIntentCommand {
    customer?: Customer2;
    id?: string;
    currency?: string;
    description?: string;
    orderId?: string;

    constructor(data?: ICreatePaymentIntentCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customer = _data["customer"] ? Customer2.fromJS(_data["customer"]) : <any>undefined;
            this.id = _data["id"];
            this.currency = _data["currency"];
            this.description = _data["description"];
            this.orderId = _data["orderId"];
        }
    }

    static fromJS(data: any): CreatePaymentIntentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePaymentIntentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["currency"] = this.currency;
        data["description"] = this.description;
        data["orderId"] = this.orderId;
        return data;
    }
}

export interface ICreatePaymentIntentCommand {
    customer?: Customer2;
    id?: string;
    currency?: string;
    description?: string;
    orderId?: string;
}

export class ConfirmPaymentIntentCommand implements IConfirmPaymentIntentCommand {
    id?: string;
    customerId?: string;

    constructor(data?: IConfirmPaymentIntentCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.customerId = _data["customerId"];
        }
    }

    static fromJS(data: any): ConfirmPaymentIntentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ConfirmPaymentIntentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["customerId"] = this.customerId;
        return data;
    }
}

export interface IConfirmPaymentIntentCommand {
    id?: string;
    customerId?: string;
}

export class CreateWarehouseCommand implements ICreateWarehouseCommand {
    name?: string;
    capacity?: number;

    constructor(data?: ICreateWarehouseCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.capacity = _data["capacity"];
        }
    }

    static fromJS(data: any): CreateWarehouseCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWarehouseCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["capacity"] = this.capacity;
        return data;
    }
}

export interface ICreateWarehouseCommand {
    name?: string;
    capacity?: number;
}

export class UpdateWarehouseCommand implements IUpdateWarehouseCommand {
    id?: string;
    name?: string;
    capacity?: number;

    constructor(data?: IUpdateWarehouseCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.capacity = _data["capacity"];
        }
    }

    static fromJS(data: any): UpdateWarehouseCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateWarehouseCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["capacity"] = this.capacity;
        return data;
    }
}

export interface IUpdateWarehouseCommand {
    id?: string;
    name?: string;
    capacity?: number;
}

export class DeleteWarehouseCommand implements IDeleteWarehouseCommand {
    id?: string;

    constructor(data?: IDeleteWarehouseCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DeleteWarehouseCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteWarehouseCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IDeleteWarehouseCommand {
    id?: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}